const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["assets/dagre-6UL2VRFP-BVRzo63V.js", "assets/graph-CkhT_M3u.js", "assets/_baseUniq-DFSO7zqk.js", "assets/layout-C6IJUjmO.js", "assets/_basePickBy-D5gCAhVI.js", "assets/clone-BN_u16k-.js", "assets/cose-bilkent-S5V4N54A-DxaxPR1Z.js", "assets/cytoscape.esm-DtBltrT8.js", "assets/c4Diagram-YG6GDRKO-CWLcVrDv.js", "assets/chunk-TZMSLE5B-kiF3X56X.js", "assets/flowDiagram-NV44I4VS-BnAOTmyK.js", "assets/chunk-FMBD7UC4-DFhYL7aT.js", "assets/chunk-55IACEB6-ref9vdea.js", "assets/chunk-QN33PNHL-BRshyCud.js", "assets/channel-PTe8EneF.js", "assets/erDiagram-Q2GNP2WA-Cr3vVunF.js", "assets/gitGraphDiagram-NY62KEGX-CC2lGZLA.js", "assets/chunk-4BX2VUAB-RWdkAmLn.js", "assets/chunk-QZHKN3VN-eS1dEnH2.js", "assets/treemap-KMMF4GRG-CLLY4Y6U.js", "assets/ganttDiagram-LVOFAZNH-B08ysZ5a.js", "assets/linear-DgTA2n3K.js", "assets/init-Gi6I4Gst.js", "assets/defaultLocale-C4B-KCzX.js", "assets/infoDiagram-F6ZHWCRC-DYFv4gnV.js", "assets/pieDiagram-ADFJNKIX-Cpt-Y17L.js", "assets/arc-CpLjpT3a.js", "assets/ordinal-BENe2yWM.js", "assets/quadrantDiagram-AYHSOK5B-CpEeCLo5.js", "assets/xychartDiagram-PRI3JC2R-Du79RmHN.js", "assets/requirementDiagram-UZGBJVZJ-Bj1N6rPu.js", "assets/sequenceDiagram-WL72ISMW-DuPk3aIv.js", "assets/classDiagram-2ON5EDUG-B4UOuWem.js", "assets/chunk-B4BG7PRW-DsODehaF.js", "assets/classDiagram-v2-WZHVMYZB-B4UOuWem.js", "assets/stateDiagram-FKZM4ZOC-Y3dVFcIw.js", "assets/chunk-DI55MBZ5-BJQZAyjh.js", "assets/stateDiagram-v2-4FDKWEC3-DQugY_wq.js", "assets/journeyDiagram-XKPGCS4Q-7IJs1njS.js", "assets/timeline-definition-IT6M3QCI-DnIJgjNQ.js", "assets/mindmap-definition-VGOIOE7T-u8frsvOj.js", "assets/kanban-definition-3W4ZIXB7-BQGRiOmD.js", "assets/sankeyDiagram-TZEHDZUN-D3KcfQuK.js", "assets/diagram-S2PKOQOG-By75yC75.js", "assets/diagram-QEK2KX5R-Q7ov5C6P.js", "assets/blockDiagram-VD42YOAC-7GPNweqI.js", "assets/architectureDiagram-VXUJARFQ-VtqpxFd5.js", "assets/diagram-PSM6KHXK-m8j4PP9B.js"]))) => i.map(i => d[i]);
function jZ(e, t) {
    for (var n = 0; n < t.length; n++) {
        const r = t[n];
        if (typeof r != "string" && !Array.isArray(r)) {
            for (const i in r)
                if (i !== "default" && !(i in e)) {
                    const o = Object.getOwnPropertyDescriptor(r, i);
                    o && Object.defineProperty(e, i, o.get ? o : {
                        enumerable: !0,
                        get: () => r[i]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        r(i);
    new MutationObserver(i => {
        for (const o of i)
            if (o.type === "childList")
                for (const a of o.addedNodes)
                    a.tagName === "LINK" && a.rel === "modulepreload" && r(a)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(i) {
        const o = {};
        return i.integrity && (o.integrity = i.integrity),
        i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin",
        o
    }
    function r(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const o = n(i);
        fetch(i.href, o)
    }
}
)();
function es(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var ww = {
    exports: {}
}
  , hp = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JO;
function BZ() {
    if (JO)
        return hp;
    JO = 1;
    var e = Symbol.for("react.transitional.element")
      , t = Symbol.for("react.fragment");
    function n(r, i, o) {
        var a = null;
        if (o !== void 0 && (a = "" + o),
        i.key !== void 0 && (a = "" + i.key),
        "key"in i) {
            o = {};
            for (var s in i)
                s !== "key" && (o[s] = i[s])
        } else
            o = i;
        return i = o.ref,
        {
            $$typeof: e,
            type: r,
            key: a,
            ref: i !== void 0 ? i : null,
            props: o
        }
    }
    return hp.Fragment = t,
    hp.jsx = n,
    hp.jsxs = n,
    hp
}
var eI;
function zZ() {
    return eI || (eI = 1,
    ww.exports = BZ()),
    ww.exports
}
var g = zZ()
  , kw = {
    exports: {}
}
  , pp = {}
  , Tw = {
    exports: {}
}
  , _w = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tI;
function FZ() {
    return tI || (tI = 1,
    (function(e) {
        function t(j, N) {
            var H = j.length;
            j.push(N);
            e: for (; 0 < H; ) {
                var Z = H - 1 >>> 1
                  , q = j[Z];
                if (0 < i(q, N))
                    j[Z] = N,
                    j[H] = q,
                    H = Z;
                else
                    break e
            }
        }
        function n(j) {
            return j.length === 0 ? null : j[0]
        }
        function r(j) {
            if (j.length === 0)
                return null;
            var N = j[0]
              , H = j.pop();
            if (H !== N) {
                j[0] = H;
                e: for (var Z = 0, q = j.length, V = q >>> 1; Z < V; ) {
                    var Y = 2 * (Z + 1) - 1
                      , W = j[Y]
                      , te = Y + 1
                      , K = j[te];
                    if (0 > i(W, H))
                        te < q && 0 > i(K, W) ? (j[Z] = K,
                        j[te] = H,
                        Z = te) : (j[Z] = W,
                        j[Y] = H,
                        Z = Y);
                    else if (te < q && 0 > i(K, H))
                        j[Z] = K,
                        j[te] = H,
                        Z = te;
                    else
                        break e
                }
            }
            return N
        }
        function i(j, N) {
            var H = j.sortIndex - N.sortIndex;
            return H !== 0 ? H : j.id - N.id
        }
        if (e.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var o = performance;
            e.unstable_now = function() {
                return o.now()
            }
        } else {
            var a = Date
              , s = a.now();
            e.unstable_now = function() {
                return a.now() - s
            }
        }
        var c = []
          , u = []
          , f = 1
          , h = null
          , m = 3
          , y = !1
          , b = !1
          , v = !1
          , S = !1
          , C = typeof setTimeout == "function" ? setTimeout : null
          , w = typeof clearTimeout == "function" ? clearTimeout : null
          , k = typeof setImmediate < "u" ? setImmediate : null;
        function T(j) {
            for (var N = n(u); N !== null; ) {
                if (N.callback === null)
                    r(u);
                else if (N.startTime <= j)
                    r(u),
                    N.sortIndex = N.expirationTime,
                    t(c, N);
                else
                    break;
                N = n(u)
            }
        }
        function E(j) {
            if (v = !1,
            T(j),
            !b)
                if (n(c) !== null)
                    b = !0,
                    P || (P = !0,
                    M());
                else {
                    var N = n(u);
                    N !== null && F(E, N.startTime - j)
                }
        }
        var P = !1
          , D = -1
          , $ = 5
          , z = -1;
        function O() {
            return S ? !0 : !(e.unstable_now() - z < $)
        }
        function I() {
            if (S = !1,
            P) {
                var j = e.unstable_now();
                z = j;
                var N = !0;
                try {
                    e: {
                        b = !1,
                        v && (v = !1,
                        w(D),
                        D = -1),
                        y = !0;
                        var H = m;
                        try {
                            t: {
                                for (T(j),
                                h = n(c); h !== null && !(h.expirationTime > j && O()); ) {
                                    var Z = h.callback;
                                    if (typeof Z == "function") {
                                        h.callback = null,
                                        m = h.priorityLevel;
                                        var q = Z(h.expirationTime <= j);
                                        if (j = e.unstable_now(),
                                        typeof q == "function") {
                                            h.callback = q,
                                            T(j),
                                            N = !0;
                                            break t
                                        }
                                        h === n(c) && r(c),
                                        T(j)
                                    } else
                                        r(c);
                                    h = n(c)
                                }
                                if (h !== null)
                                    N = !0;
                                else {
                                    var V = n(u);
                                    V !== null && F(E, V.startTime - j),
                                    N = !1
                                }
                            }
                            break e
                        } finally {
                            h = null,
                            m = H,
                            y = !1
                        }
                        N = void 0
                    }
                } finally {
                    N ? M() : P = !1
                }
            }
        }
        var M;
        if (typeof k == "function")
            M = function() {
                k(I)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var B = new MessageChannel
              , L = B.port2;
            B.port1.onmessage = I,
            M = function() {
                L.postMessage(null)
            }
        } else
            M = function() {
                C(I, 0)
            }
            ;
        function F(j, N) {
            D = C(function() {
                j(e.unstable_now())
            }, N)
        }
        e.unstable_IdlePriority = 5,
        e.unstable_ImmediatePriority = 1,
        e.unstable_LowPriority = 4,
        e.unstable_NormalPriority = 3,
        e.unstable_Profiling = null,
        e.unstable_UserBlockingPriority = 2,
        e.unstable_cancelCallback = function(j) {
            j.callback = null
        }
        ,
        e.unstable_forceFrameRate = function(j) {
            0 > j || 125 < j ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : $ = 0 < j ? Math.floor(1e3 / j) : 5
        }
        ,
        e.unstable_getCurrentPriorityLevel = function() {
            return m
        }
        ,
        e.unstable_next = function(j) {
            switch (m) {
            case 1:
            case 2:
            case 3:
                var N = 3;
                break;
            default:
                N = m
            }
            var H = m;
            m = N;
            try {
                return j()
            } finally {
                m = H
            }
        }
        ,
        e.unstable_requestPaint = function() {
            S = !0
        }
        ,
        e.unstable_runWithPriority = function(j, N) {
            switch (j) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                j = 3
            }
            var H = m;
            m = j;
            try {
                return N()
            } finally {
                m = H
            }
        }
        ,
        e.unstable_scheduleCallback = function(j, N, H) {
            var Z = e.unstable_now();
            switch (typeof H == "object" && H !== null ? (H = H.delay,
            H = typeof H == "number" && 0 < H ? Z + H : Z) : H = Z,
            j) {
            case 1:
                var q = -1;
                break;
            case 2:
                q = 250;
                break;
            case 5:
                q = 1073741823;
                break;
            case 4:
                q = 1e4;
                break;
            default:
                q = 5e3
            }
            return q = H + q,
            j = {
                id: f++,
                callback: N,
                priorityLevel: j,
                startTime: H,
                expirationTime: q,
                sortIndex: -1
            },
            H > Z ? (j.sortIndex = H,
            t(u, j),
            n(c) === null && j === n(u) && (v ? (w(D),
            D = -1) : v = !0,
            F(E, H - Z))) : (j.sortIndex = q,
            t(c, j),
            b || y || (b = !0,
            P || (P = !0,
            M()))),
            j
        }
        ,
        e.unstable_shouldYield = O,
        e.unstable_wrapCallback = function(j) {
            var N = m;
            return function() {
                var H = m;
                m = N;
                try {
                    return j.apply(this, arguments)
                } finally {
                    m = H
                }
            }
        }
    }
    )(_w)),
    _w
}
var nI;
function NZ() {
    return nI || (nI = 1,
    Tw.exports = FZ()),
    Tw.exports
}
var Ew = {
    exports: {}
}
  , Kt = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rI;
function UZ() {
    if (rI)
        return Kt;
    rI = 1;
    var e = Symbol.for("react.transitional.element")
      , t = Symbol.for("react.portal")
      , n = Symbol.for("react.fragment")
      , r = Symbol.for("react.strict_mode")
      , i = Symbol.for("react.profiler")
      , o = Symbol.for("react.consumer")
      , a = Symbol.for("react.context")
      , s = Symbol.for("react.forward_ref")
      , c = Symbol.for("react.suspense")
      , u = Symbol.for("react.memo")
      , f = Symbol.for("react.lazy")
      , h = Symbol.for("react.activity")
      , m = Symbol.iterator;
    function y(V) {
        return V === null || typeof V != "object" ? null : (V = m && V[m] || V["@@iterator"],
        typeof V == "function" ? V : null)
    }
    var b = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , v = Object.assign
      , S = {};
    function C(V, Y, W) {
        this.props = V,
        this.context = Y,
        this.refs = S,
        this.updater = W || b
    }
    C.prototype.isReactComponent = {},
    C.prototype.setState = function(V, Y) {
        if (typeof V != "object" && typeof V != "function" && V != null)
            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, V, Y, "setState")
    }
    ,
    C.prototype.forceUpdate = function(V) {
        this.updater.enqueueForceUpdate(this, V, "forceUpdate")
    }
    ;
    function w() {}
    w.prototype = C.prototype;
    function k(V, Y, W) {
        this.props = V,
        this.context = Y,
        this.refs = S,
        this.updater = W || b
    }
    var T = k.prototype = new w;
    T.constructor = k,
    v(T, C.prototype),
    T.isPureReactComponent = !0;
    var E = Array.isArray;
    function P() {}
    var D = {
        H: null,
        A: null,
        T: null,
        S: null
    }
      , $ = Object.prototype.hasOwnProperty;
    function z(V, Y, W) {
        var te = W.ref;
        return {
            $$typeof: e,
            type: V,
            key: Y,
            ref: te !== void 0 ? te : null,
            props: W
        }
    }
    function O(V, Y) {
        return z(V.type, Y, V.props)
    }
    function I(V) {
        return typeof V == "object" && V !== null && V.$$typeof === e
    }
    function M(V) {
        var Y = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + V.replace(/[=:]/g, function(W) {
            return Y[W]
        })
    }
    var B = /\/+/g;
    function L(V, Y) {
        return typeof V == "object" && V !== null && V.key != null ? M("" + V.key) : Y.toString(36)
    }
    function F(V) {
        switch (V.status) {
        case "fulfilled":
            return V.value;
        case "rejected":
            throw V.reason;
        default:
            switch (typeof V.status == "string" ? V.then(P, P) : (V.status = "pending",
            V.then(function(Y) {
                V.status === "pending" && (V.status = "fulfilled",
                V.value = Y)
            }, function(Y) {
                V.status === "pending" && (V.status = "rejected",
                V.reason = Y)
            })),
            V.status) {
            case "fulfilled":
                return V.value;
            case "rejected":
                throw V.reason
            }
        }
        throw V
    }
    function j(V, Y, W, te, K) {
        var ee = typeof V;
        (ee === "undefined" || ee === "boolean") && (V = null);
        var re = !1;
        if (V === null)
            re = !0;
        else
            switch (ee) {
            case "bigint":
            case "string":
            case "number":
                re = !0;
                break;
            case "object":
                switch (V.$$typeof) {
                case e:
                case t:
                    re = !0;
                    break;
                case f:
                    return re = V._init,
                    j(re(V._payload), Y, W, te, K)
                }
            }
        if (re)
            return K = K(V),
            re = te === "" ? "." + L(V, 0) : te,
            E(K) ? (W = "",
            re != null && (W = re.replace(B, "$&/") + "/"),
            j(K, Y, W, "", function(oe) {
                return oe
            })) : K != null && (I(K) && (K = O(K, W + (K.key == null || V && V.key === K.key ? "" : ("" + K.key).replace(B, "$&/") + "/") + re)),
            Y.push(K)),
            1;
        re = 0;
        var ie = te === "" ? "." : te + ":";
        if (E(V))
            for (var J = 0; J < V.length; J++)
                te = V[J],
                ee = ie + L(te, J),
                re += j(te, Y, W, ee, K);
        else if (J = y(V),
        typeof J == "function")
            for (V = J.call(V),
            J = 0; !(te = V.next()).done; )
                te = te.value,
                ee = ie + L(te, J++),
                re += j(te, Y, W, ee, K);
        else if (ee === "object") {
            if (typeof V.then == "function")
                return j(F(V), Y, W, te, K);
            throw Y = String(V),
            Error("Objects are not valid as a React child (found: " + (Y === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : Y) + "). If you meant to render a collection of children, use an array instead.")
        }
        return re
    }
    function N(V, Y, W) {
        if (V == null)
            return V;
        var te = []
          , K = 0;
        return j(V, te, "", "", function(ee) {
            return Y.call(W, ee, K++)
        }),
        te
    }
    function H(V) {
        if (V._status === -1) {
            var Y = V._result;
            Y = Y(),
            Y.then(function(W) {
                (V._status === 0 || V._status === -1) && (V._status = 1,
                V._result = W)
            }, function(W) {
                (V._status === 0 || V._status === -1) && (V._status = 2,
                V._result = W)
            }),
            V._status === -1 && (V._status = 0,
            V._result = Y)
        }
        if (V._status === 1)
            return V._result.default;
        throw V._result
    }
    var Z = typeof reportError == "function" ? reportError : function(V) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var Y = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof V == "object" && V !== null && typeof V.message == "string" ? String(V.message) : String(V),
                error: V
            });
            if (!window.dispatchEvent(Y))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", V);
            return
        }
        console.error(V)
    }
      , q = {
        map: N,
        forEach: function(V, Y, W) {
            N(V, function() {
                Y.apply(this, arguments)
            }, W)
        },
        count: function(V) {
            var Y = 0;
            return N(V, function() {
                Y++
            }),
            Y
        },
        toArray: function(V) {
            return N(V, function(Y) {
                return Y
            }) || []
        },
        only: function(V) {
            if (!I(V))
                throw Error("React.Children.only expected to receive a single React element child.");
            return V
        }
    };
    return Kt.Activity = h,
    Kt.Children = q,
    Kt.Component = C,
    Kt.Fragment = n,
    Kt.Profiler = i,
    Kt.PureComponent = k,
    Kt.StrictMode = r,
    Kt.Suspense = c,
    Kt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = D,
    Kt.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(V) {
            return D.H.useMemoCache(V)
        }
    },
    Kt.cache = function(V) {
        return function() {
            return V.apply(null, arguments)
        }
    }
    ,
    Kt.cacheSignal = function() {
        return null
    }
    ,
    Kt.cloneElement = function(V, Y, W) {
        if (V == null)
            throw Error("The argument must be a React element, but you passed " + V + ".");
        var te = v({}, V.props)
          , K = V.key;
        if (Y != null)
            for (ee in Y.key !== void 0 && (K = "" + Y.key),
            Y)
                !$.call(Y, ee) || ee === "key" || ee === "__self" || ee === "__source" || ee === "ref" && Y.ref === void 0 || (te[ee] = Y[ee]);
        var ee = arguments.length - 2;
        if (ee === 1)
            te.children = W;
        else if (1 < ee) {
            for (var re = Array(ee), ie = 0; ie < ee; ie++)
                re[ie] = arguments[ie + 2];
            te.children = re
        }
        return z(V.type, K, te)
    }
    ,
    Kt.createContext = function(V) {
        return V = {
            $$typeof: a,
            _currentValue: V,
            _currentValue2: V,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        },
        V.Provider = V,
        V.Consumer = {
            $$typeof: o,
            _context: V
        },
        V
    }
    ,
    Kt.createElement = function(V, Y, W) {
        var te, K = {}, ee = null;
        if (Y != null)
            for (te in Y.key !== void 0 && (ee = "" + Y.key),
            Y)
                $.call(Y, te) && te !== "key" && te !== "__self" && te !== "__source" && (K[te] = Y[te]);
        var re = arguments.length - 2;
        if (re === 1)
            K.children = W;
        else if (1 < re) {
            for (var ie = Array(re), J = 0; J < re; J++)
                ie[J] = arguments[J + 2];
            K.children = ie
        }
        if (V && V.defaultProps)
            for (te in re = V.defaultProps,
            re)
                K[te] === void 0 && (K[te] = re[te]);
        return z(V, ee, K)
    }
    ,
    Kt.createRef = function() {
        return {
            current: null
        }
    }
    ,
    Kt.forwardRef = function(V) {
        return {
            $$typeof: s,
            render: V
        }
    }
    ,
    Kt.isValidElement = I,
    Kt.lazy = function(V) {
        return {
            $$typeof: f,
            _payload: {
                _status: -1,
                _result: V
            },
            _init: H
        }
    }
    ,
    Kt.memo = function(V, Y) {
        return {
            $$typeof: u,
            type: V,
            compare: Y === void 0 ? null : Y
        }
    }
    ,
    Kt.startTransition = function(V) {
        var Y = D.T
          , W = {};
        D.T = W;
        try {
            var te = V()
              , K = D.S;
            K !== null && K(W, te),
            typeof te == "object" && te !== null && typeof te.then == "function" && te.then(P, Z)
        } catch (ee) {
            Z(ee)
        } finally {
            Y !== null && W.types !== null && (Y.types = W.types),
            D.T = Y
        }
    }
    ,
    Kt.unstable_useCacheRefresh = function() {
        return D.H.useCacheRefresh()
    }
    ,
    Kt.use = function(V) {
        return D.H.use(V)
    }
    ,
    Kt.useActionState = function(V, Y, W) {
        return D.H.useActionState(V, Y, W)
    }
    ,
    Kt.useCallback = function(V, Y) {
        return D.H.useCallback(V, Y)
    }
    ,
    Kt.useContext = function(V) {
        return D.H.useContext(V)
    }
    ,
    Kt.useDebugValue = function() {}
    ,
    Kt.useDeferredValue = function(V, Y) {
        return D.H.useDeferredValue(V, Y)
    }
    ,
    Kt.useEffect = function(V, Y) {
        return D.H.useEffect(V, Y)
    }
    ,
    Kt.useEffectEvent = function(V) {
        return D.H.useEffectEvent(V)
    }
    ,
    Kt.useId = function() {
        return D.H.useId()
    }
    ,
    Kt.useImperativeHandle = function(V, Y, W) {
        return D.H.useImperativeHandle(V, Y, W)
    }
    ,
    Kt.useInsertionEffect = function(V, Y) {
        return D.H.useInsertionEffect(V, Y)
    }
    ,
    Kt.useLayoutEffect = function(V, Y) {
        return D.H.useLayoutEffect(V, Y)
    }
    ,
    Kt.useMemo = function(V, Y) {
        return D.H.useMemo(V, Y)
    }
    ,
    Kt.useOptimistic = function(V, Y) {
        return D.H.useOptimistic(V, Y)
    }
    ,
    Kt.useReducer = function(V, Y, W) {
        return D.H.useReducer(V, Y, W)
    }
    ,
    Kt.useRef = function(V) {
        return D.H.useRef(V)
    }
    ,
    Kt.useState = function(V) {
        return D.H.useState(V)
    }
    ,
    Kt.useSyncExternalStore = function(V, Y, W) {
        return D.H.useSyncExternalStore(V, Y, W)
    }
    ,
    Kt.useTransition = function() {
        return D.H.useTransition()
    }
    ,
    Kt.version = "19.2.0",
    Kt
}
var iI;
function Tv() {
    return iI || (iI = 1,
    Ew.exports = UZ()),
    Ew.exports
}
var Aw = {
    exports: {}
}
  , Ci = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oI;
function VZ() {
    if (oI)
        return Ci;
    oI = 1;
    var e = Tv();
    function t(c) {
        var u = "https://react.dev/errors/" + c;
        if (1 < arguments.length) {
            u += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var f = 2; f < arguments.length; f++)
                u += "&args[]=" + encodeURIComponent(arguments[f])
        }
        return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function n() {}
    var r = {
        d: {
            f: n,
            r: function() {
                throw Error(t(522))
            },
            D: n,
            C: n,
            L: n,
            m: n,
            X: n,
            S: n,
            M: n
        },
        p: 0,
        findDOMNode: null
    }
      , i = Symbol.for("react.portal");
    function o(c, u, f) {
        var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: i,
            key: h == null ? null : "" + h,
            children: c,
            containerInfo: u,
            implementation: f
        }
    }
    var a = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function s(c, u) {
        if (c === "font")
            return "";
        if (typeof u == "string")
            return u === "use-credentials" ? u : ""
    }
    return Ci.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r,
    Ci.createPortal = function(c, u) {
        var f = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11)
            throw Error(t(299));
        return o(c, u, null, f)
    }
    ,
    Ci.flushSync = function(c) {
        var u = a.T
          , f = r.p;
        try {
            if (a.T = null,
            r.p = 2,
            c)
                return c()
        } finally {
            a.T = u,
            r.p = f,
            r.d.f()
        }
    }
    ,
    Ci.preconnect = function(c, u) {
        typeof c == "string" && (u ? (u = u.crossOrigin,
        u = typeof u == "string" ? u === "use-credentials" ? u : "" : void 0) : u = null,
        r.d.C(c, u))
    }
    ,
    Ci.prefetchDNS = function(c) {
        typeof c == "string" && r.d.D(c)
    }
    ,
    Ci.preinit = function(c, u) {
        if (typeof c == "string" && u && typeof u.as == "string") {
            var f = u.as
              , h = s(f, u.crossOrigin)
              , m = typeof u.integrity == "string" ? u.integrity : void 0
              , y = typeof u.fetchPriority == "string" ? u.fetchPriority : void 0;
            f === "style" ? r.d.S(c, typeof u.precedence == "string" ? u.precedence : void 0, {
                crossOrigin: h,
                integrity: m,
                fetchPriority: y
            }) : f === "script" && r.d.X(c, {
                crossOrigin: h,
                integrity: m,
                fetchPriority: y,
                nonce: typeof u.nonce == "string" ? u.nonce : void 0
            })
        }
    }
    ,
    Ci.preinitModule = function(c, u) {
        if (typeof c == "string")
            if (typeof u == "object" && u !== null) {
                if (u.as == null || u.as === "script") {
                    var f = s(u.as, u.crossOrigin);
                    r.d.M(c, {
                        crossOrigin: f,
                        integrity: typeof u.integrity == "string" ? u.integrity : void 0,
                        nonce: typeof u.nonce == "string" ? u.nonce : void 0
                    })
                }
            } else
                u == null && r.d.M(c)
    }
    ,
    Ci.preload = function(c, u) {
        if (typeof c == "string" && typeof u == "object" && u !== null && typeof u.as == "string") {
            var f = u.as
              , h = s(f, u.crossOrigin);
            r.d.L(c, f, {
                crossOrigin: h,
                integrity: typeof u.integrity == "string" ? u.integrity : void 0,
                nonce: typeof u.nonce == "string" ? u.nonce : void 0,
                type: typeof u.type == "string" ? u.type : void 0,
                fetchPriority: typeof u.fetchPriority == "string" ? u.fetchPriority : void 0,
                referrerPolicy: typeof u.referrerPolicy == "string" ? u.referrerPolicy : void 0,
                imageSrcSet: typeof u.imageSrcSet == "string" ? u.imageSrcSet : void 0,
                imageSizes: typeof u.imageSizes == "string" ? u.imageSizes : void 0,
                media: typeof u.media == "string" ? u.media : void 0
            })
        }
    }
    ,
    Ci.preloadModule = function(c, u) {
        if (typeof c == "string")
            if (u) {
                var f = s(u.as, u.crossOrigin);
                r.d.m(c, {
                    as: typeof u.as == "string" && u.as !== "script" ? u.as : void 0,
                    crossOrigin: f,
                    integrity: typeof u.integrity == "string" ? u.integrity : void 0
                })
            } else
                r.d.m(c)
    }
    ,
    Ci.requestFormReset = function(c) {
        r.d.r(c)
    }
    ,
    Ci.unstable_batchedUpdates = function(c, u) {
        return c(u)
    }
    ,
    Ci.useFormState = function(c, u, f) {
        return a.H.useFormState(c, u, f)
    }
    ,
    Ci.useFormStatus = function() {
        return a.H.useHostTransitionStatus()
    }
    ,
    Ci.version = "19.2.0",
    Ci
}
var aI;
function J5() {
    if (aI)
        return Aw.exports;
    aI = 1;
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
    }
    return e(),
    Aw.exports = VZ(),
    Aw.exports
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sI;
function HZ() {
    if (sI)
        return pp;
    sI = 1;
    var e = NZ()
      , t = Tv()
      , n = J5();
    function r(l) {
        var d = "https://react.dev/errors/" + l;
        if (1 < arguments.length) {
            d += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var p = 2; p < arguments.length; p++)
                d += "&args[]=" + encodeURIComponent(arguments[p])
        }
        return "Minified React error #" + l + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function i(l) {
        return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11)
    }
    function o(l) {
        var d = l
          , p = l;
        if (l.alternate)
            for (; d.return; )
                d = d.return;
        else {
            l = d;
            do
                d = l,
                (d.flags & 4098) !== 0 && (p = d.return),
                l = d.return;
            while (l)
        }
        return d.tag === 3 ? p : null
    }
    function a(l) {
        if (l.tag === 13) {
            var d = l.memoizedState;
            if (d === null && (l = l.alternate,
            l !== null && (d = l.memoizedState)),
            d !== null)
                return d.dehydrated
        }
        return null
    }
    function s(l) {
        if (l.tag === 31) {
            var d = l.memoizedState;
            if (d === null && (l = l.alternate,
            l !== null && (d = l.memoizedState)),
            d !== null)
                return d.dehydrated
        }
        return null
    }
    function c(l) {
        if (o(l) !== l)
            throw Error(r(188))
    }
    function u(l) {
        var d = l.alternate;
        if (!d) {
            if (d = o(l),
            d === null)
                throw Error(r(188));
            return d !== l ? null : l
        }
        for (var p = l, x = d; ; ) {
            var _ = p.return;
            if (_ === null)
                break;
            var R = _.alternate;
            if (R === null) {
                if (x = _.return,
                x !== null) {
                    p = x;
                    continue
                }
                break
            }
            if (_.child === R.child) {
                for (R = _.child; R; ) {
                    if (R === p)
                        return c(_),
                        l;
                    if (R === x)
                        return c(_),
                        d;
                    R = R.sibling
                }
                throw Error(r(188))
            }
            if (p.return !== x.return)
                p = _,
                x = R;
            else {
                for (var G = !1, Q = _.child; Q; ) {
                    if (Q === p) {
                        G = !0,
                        p = _,
                        x = R;
                        break
                    }
                    if (Q === x) {
                        G = !0,
                        x = _,
                        p = R;
                        break
                    }
                    Q = Q.sibling
                }
                if (!G) {
                    for (Q = R.child; Q; ) {
                        if (Q === p) {
                            G = !0,
                            p = R,
                            x = _;
                            break
                        }
                        if (Q === x) {
                            G = !0,
                            x = R,
                            p = _;
                            break
                        }
                        Q = Q.sibling
                    }
                    if (!G)
                        throw Error(r(189))
                }
            }
            if (p.alternate !== x)
                throw Error(r(190))
        }
        if (p.tag !== 3)
            throw Error(r(188));
        return p.stateNode.current === p ? l : d
    }
    function f(l) {
        var d = l.tag;
        if (d === 5 || d === 26 || d === 27 || d === 6)
            return l;
        for (l = l.child; l !== null; ) {
            if (d = f(l),
            d !== null)
                return d;
            l = l.sibling
        }
        return null
    }
    var h = Object.assign
      , m = Symbol.for("react.element")
      , y = Symbol.for("react.transitional.element")
      , b = Symbol.for("react.portal")
      , v = Symbol.for("react.fragment")
      , S = Symbol.for("react.strict_mode")
      , C = Symbol.for("react.profiler")
      , w = Symbol.for("react.consumer")
      , k = Symbol.for("react.context")
      , T = Symbol.for("react.forward_ref")
      , E = Symbol.for("react.suspense")
      , P = Symbol.for("react.suspense_list")
      , D = Symbol.for("react.memo")
      , $ = Symbol.for("react.lazy")
      , z = Symbol.for("react.activity")
      , O = Symbol.for("react.memo_cache_sentinel")
      , I = Symbol.iterator;
    function M(l) {
        return l === null || typeof l != "object" ? null : (l = I && l[I] || l["@@iterator"],
        typeof l == "function" ? l : null)
    }
    var B = Symbol.for("react.client.reference");
    function L(l) {
        if (l == null)
            return null;
        if (typeof l == "function")
            return l.$$typeof === B ? null : l.displayName || l.name || null;
        if (typeof l == "string")
            return l;
        switch (l) {
        case v:
            return "Fragment";
        case C:
            return "Profiler";
        case S:
            return "StrictMode";
        case E:
            return "Suspense";
        case P:
            return "SuspenseList";
        case z:
            return "Activity"
        }
        if (typeof l == "object")
            switch (l.$$typeof) {
            case b:
                return "Portal";
            case k:
                return l.displayName || "Context";
            case w:
                return (l._context.displayName || "Context") + ".Consumer";
            case T:
                var d = l.render;
                return l = l.displayName,
                l || (l = d.displayName || d.name || "",
                l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"),
                l;
            case D:
                return d = l.displayName || null,
                d !== null ? d : L(l.type) || "Memo";
            case $:
                d = l._payload,
                l = l._init;
                try {
                    return L(l(d))
                } catch {}
            }
        return null
    }
    var F = Array.isArray
      , j = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , N = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , H = {
        pending: !1,
        data: null,
        method: null,
        action: null
    }
      , Z = []
      , q = -1;
    function V(l) {
        return {
            current: l
        }
    }
    function Y(l) {
        0 > q || (l.current = Z[q],
        Z[q] = null,
        q--)
    }
    function W(l, d) {
        q++,
        Z[q] = l.current,
        l.current = d
    }
    var te = V(null)
      , K = V(null)
      , ee = V(null)
      , re = V(null);
    function ie(l, d) {
        switch (W(ee, d),
        W(K, l),
        W(te, null),
        d.nodeType) {
        case 9:
        case 11:
            l = (l = d.documentElement) && (l = l.namespaceURI) ? CO(l) : 0;
            break;
        default:
            if (l = d.tagName,
            d = d.namespaceURI)
                d = CO(d),
                l = wO(d, l);
            else
                switch (l) {
                case "svg":
                    l = 1;
                    break;
                case "math":
                    l = 2;
                    break;
                default:
                    l = 0
                }
        }
        Y(te),
        W(te, l)
    }
    function J() {
        Y(te),
        Y(K),
        Y(ee)
    }
    function oe(l) {
        l.memoizedState !== null && W(re, l);
        var d = te.current
          , p = wO(d, l.type);
        d !== p && (W(K, l),
        W(te, p))
    }
    function we(l) {
        K.current === l && (Y(te),
        Y(K)),
        re.current === l && (Y(re),
        cp._currentValue = H)
    }
    var xe, se;
    function de(l) {
        if (xe === void 0)
            try {
                throw Error()
            } catch (p) {
                var d = p.stack.trim().match(/\n( *(at )?)/);
                xe = d && d[1] || "",
                se = -1 < p.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < p.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
        return `
` + xe + l + se
    }
    var Se = !1;
    function Ce(l, d) {
        if (!l || Se)
            return "";
        Se = !0;
        var p = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            var x = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (d) {
                            var We = function() {
                                throw Error()
                            };
                            if (Object.defineProperty(We.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            typeof Reflect == "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(We, [])
                                } catch ($e) {
                                    var Pe = $e
                                }
                                Reflect.construct(l, [], We)
                            } else {
                                try {
                                    We.call()
                                } catch ($e) {
                                    Pe = $e
                                }
                                l.call(We.prototype)
                            }
                        } else {
                            try {
                                throw Error()
                            } catch ($e) {
                                Pe = $e
                            }
                            (We = l()) && typeof We.catch == "function" && We.catch(function() {})
                        }
                    } catch ($e) {
                        if ($e && Pe && typeof $e.stack == "string")
                            return [$e.stack, Pe.stack]
                    }
                    return [null, null]
                }
            };
            x.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var _ = Object.getOwnPropertyDescriptor(x.DetermineComponentFrameRoot, "name");
            _ && _.configurable && Object.defineProperty(x.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var R = x.DetermineComponentFrameRoot()
              , G = R[0]
              , Q = R[1];
            if (G && Q) {
                var ae = G.split(`
`)
                  , Ee = Q.split(`
`);
                for (_ = x = 0; x < ae.length && !ae[x].includes("DetermineComponentFrameRoot"); )
                    x++;
                for (; _ < Ee.length && !Ee[_].includes("DetermineComponentFrameRoot"); )
                    _++;
                if (x === ae.length || _ === Ee.length)
                    for (x = ae.length - 1,
                    _ = Ee.length - 1; 1 <= x && 0 <= _ && ae[x] !== Ee[_]; )
                        _--;
                for (; 1 <= x && 0 <= _; x--,
                _--)
                    if (ae[x] !== Ee[_]) {
                        if (x !== 1 || _ !== 1)
                            do
                                if (x--,
                                _--,
                                0 > _ || ae[x] !== Ee[_]) {
                                    var Ue = `
` + ae[x].replace(" at new ", " at ");
                                    return l.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", l.displayName)),
                                    Ue
                                }
                            while (1 <= x && 0 <= _);
                        break
                    }
            }
        } finally {
            Se = !1,
            Error.prepareStackTrace = p
        }
        return (p = l ? l.displayName || l.name : "") ? de(p) : ""
    }
    function Ye(l, d) {
        switch (l.tag) {
        case 26:
        case 27:
        case 5:
            return de(l.type);
        case 16:
            return de("Lazy");
        case 13:
            return l.child !== d && d !== null ? de("Suspense Fallback") : de("Suspense");
        case 19:
            return de("SuspenseList");
        case 0:
        case 15:
            return Ce(l.type, !1);
        case 11:
            return Ce(l.type.render, !1);
        case 1:
            return Ce(l.type, !0);
        case 31:
            return de("Activity");
        default:
            return ""
        }
    }
    function ye(l) {
        try {
            var d = ""
              , p = null;
            do
                d += Ye(l, p),
                p = l,
                l = l.return;
            while (l);
            return d
        } catch (x) {
            return `
Error generating stack: ` + x.message + `
` + x.stack
        }
    }
    var Ke = Object.prototype.hasOwnProperty
      , X = e.unstable_scheduleCallback
      , ce = e.unstable_cancelCallback
      , fe = e.unstable_shouldYield
      , Xe = e.unstable_requestPaint
      , Oe = e.unstable_now
      , Re = e.unstable_getCurrentPriorityLevel
      , le = e.unstable_ImmediatePriority
      , ke = e.unstable_UserBlockingPriority
      , He = e.unstable_NormalPriority
      , st = e.unstable_LowPriority
      , lt = e.unstable_IdlePriority
      , et = e.log
      , Ht = e.unstable_setDisableYieldValue
      , Ft = null
      , Pt = null;
    function nt(l) {
        if (typeof et == "function" && Ht(l),
        Pt && typeof Pt.setStrictMode == "function")
            try {
                Pt.setStrictMode(Ft, l)
            } catch {}
    }
    var ut = Math.clz32 ? Math.clz32 : Xt
      , Lt = Math.log
      , tn = Math.LN2;
    function Xt(l) {
        return l >>>= 0,
        l === 0 ? 32 : 31 - (Lt(l) / tn | 0) | 0
    }
    var Mn = 256
      , Pn = 262144
      , wn = 4194304;
    function Kn(l) {
        var d = l & 42;
        if (d !== 0)
            return d;
        switch (l & -l) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
            return 64;
        case 128:
            return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
            return l & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return l & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return l & 62914560;
        case 67108864:
            return 67108864;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 0;
        default:
            return l
        }
    }
    function vr(l, d, p) {
        var x = l.pendingLanes;
        if (x === 0)
            return 0;
        var _ = 0
          , R = l.suspendedLanes
          , G = l.pingedLanes;
        l = l.warmLanes;
        var Q = x & 134217727;
        return Q !== 0 ? (x = Q & ~R,
        x !== 0 ? _ = Kn(x) : (G &= Q,
        G !== 0 ? _ = Kn(G) : p || (p = Q & ~l,
        p !== 0 && (_ = Kn(p))))) : (Q = x & ~R,
        Q !== 0 ? _ = Kn(Q) : G !== 0 ? _ = Kn(G) : p || (p = x & ~l,
        p !== 0 && (_ = Kn(p)))),
        _ === 0 ? 0 : d !== 0 && d !== _ && (d & R) === 0 && (R = _ & -_,
        p = d & -d,
        R >= p || R === 32 && (p & 4194048) !== 0) ? d : _
    }
    function mr(l, d) {
        return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & d) === 0
    }
    function kn(l, d) {
        switch (l) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
            return d + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return d + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function At() {
        var l = wn;
        return wn <<= 1,
        (wn & 62914560) === 0 && (wn = 4194304),
        l
    }
    function nr(l) {
        for (var d = [], p = 0; 31 > p; p++)
            d.push(l);
        return d
    }
    function he(l, d) {
        l.pendingLanes |= d,
        d !== 268435456 && (l.suspendedLanes = 0,
        l.pingedLanes = 0,
        l.warmLanes = 0)
    }
    function Le(l, d, p, x, _, R) {
        var G = l.pendingLanes;
        l.pendingLanes = p,
        l.suspendedLanes = 0,
        l.pingedLanes = 0,
        l.warmLanes = 0,
        l.expiredLanes &= p,
        l.entangledLanes &= p,
        l.errorRecoveryDisabledLanes &= p,
        l.shellSuspendCounter = 0;
        var Q = l.entanglements
          , ae = l.expirationTimes
          , Ee = l.hiddenUpdates;
        for (p = G & ~p; 0 < p; ) {
            var Ue = 31 - ut(p)
              , We = 1 << Ue;
            Q[Ue] = 0,
            ae[Ue] = -1;
            var Pe = Ee[Ue];
            if (Pe !== null)
                for (Ee[Ue] = null,
                Ue = 0; Ue < Pe.length; Ue++) {
                    var $e = Pe[Ue];
                    $e !== null && ($e.lane &= -536870913)
                }
            p &= ~We
        }
        x !== 0 && it(l, x, 0),
        R !== 0 && _ === 0 && l.tag !== 0 && (l.suspendedLanes |= R & ~(G & ~d))
    }
    function it(l, d, p) {
        l.pendingLanes |= d,
        l.suspendedLanes &= ~d;
        var x = 31 - ut(d);
        l.entangledLanes |= d,
        l.entanglements[x] = l.entanglements[x] | 1073741824 | p & 261930
    }
    function Je(l, d) {
        var p = l.entangledLanes |= d;
        for (l = l.entanglements; p; ) {
            var x = 31 - ut(p)
              , _ = 1 << x;
            _ & d | l[x] & d && (l[x] |= d),
            p &= ~_
        }
    }
    function Jt(l, d) {
        var p = d & -d;
        return p = (p & 42) !== 0 ? 1 : qt(p),
        (p & (l.suspendedLanes | d)) !== 0 ? 0 : p
    }
    function qt(l) {
        switch (l) {
        case 2:
            l = 1;
            break;
        case 8:
            l = 4;
            break;
        case 32:
            l = 16;
            break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            l = 128;
            break;
        case 268435456:
            l = 134217728;
            break;
        default:
            l = 0
        }
        return l
    }
    function dn(l) {
        return l &= -l,
        2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
    }
    function Ir() {
        var l = N.p;
        return l !== 0 ? l : (l = window.event,
        l === void 0 ? 32 : WO(l.type))
    }
    function Ki(l, d) {
        var p = N.p;
        try {
            return N.p = l,
            d()
        } finally {
            N.p = p
        }
    }
    var Tr = Math.random().toString(36).slice(2)
      , ln = "__reactFiber$" + Tr
      , en = "__reactProps$" + Tr
      , si = "__reactContainer$" + Tr
      , is = "__reactEvents$" + Tr
      , os = "__reactListeners$" + Tr
      , zs = "__reactHandles$" + Tr
      , Fe = "__reactResources$" + Tr
      , me = "__reactMarker$" + Tr;
    function ne(l) {
        delete l[ln],
        delete l[en],
        delete l[is],
        delete l[os],
        delete l[zs]
    }
    function De(l) {
        var d = l[ln];
        if (d)
            return d;
        for (var p = l.parentNode; p; ) {
            if (d = p[si] || p[ln]) {
                if (p = d.alternate,
                d.child !== null || p !== null && p.child !== null)
                    for (l = PO(l); l !== null; ) {
                        if (p = l[ln])
                            return p;
                        l = PO(l)
                    }
                return d
            }
            l = p,
            p = l.parentNode
        }
        return null
    }
    function Ze(l) {
        if (l = l[ln] || l[si]) {
            var d = l.tag;
            if (d === 5 || d === 6 || d === 13 || d === 31 || d === 26 || d === 27 || d === 3)
                return l
        }
        return null
    }
    function Wt(l) {
        var d = l.tag;
        if (d === 5 || d === 26 || d === 27 || d === 6)
            return l.stateNode;
        throw Error(r(33))
    }
    function Zt(l) {
        var d = l[Fe];
        return d || (d = l[Fe] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
        }),
        d
    }
    function Nt(l) {
        l[me] = !0
    }
    var _r = new Set
      , Ii = {};
    function ui(l, d) {
        Mo(l, d),
        Mo(l + "Capture", d)
    }
    function Mo(l, d) {
        for (Ii[l] = d,
        l = 0; l < d.length; l++)
            _r.add(d[l])
    }
    var Bt = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
      , Xi = {}
      , Ji = {};
    function zc(l) {
        return Ke.call(Ji, l) ? !0 : Ke.call(Xi, l) ? !1 : Bt.test(l) ? Ji[l] = !0 : (Xi[l] = !0,
        !1)
    }
    function py(l, d, p) {
        if (zc(d))
            if (p === null)
                l.removeAttribute(d);
            else {
                switch (typeof p) {
                case "undefined":
                case "function":
                case "symbol":
                    l.removeAttribute(d);
                    return;
                case "boolean":
                    var x = d.toLowerCase().slice(0, 5);
                    if (x !== "data-" && x !== "aria-") {
                        l.removeAttribute(d);
                        return
                    }
                }
                l.setAttribute(d, "" + p)
            }
    }
    function my(l, d, p) {
        if (p === null)
            l.removeAttribute(d);
        else {
            switch (typeof p) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                l.removeAttribute(d);
                return
            }
            l.setAttribute(d, "" + p)
        }
    }
    function Fs(l, d, p, x) {
        if (x === null)
            l.removeAttribute(p);
        else {
            switch (typeof x) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                l.removeAttribute(p);
                return
            }
            l.setAttributeNS(d, p, "" + x)
        }
    }
    function Jo(l) {
        switch (typeof l) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return l;
        case "object":
            return l;
        default:
            return ""
        }
    }
    function pP(l) {
        var d = l.type;
        return (l = l.nodeName) && l.toLowerCase() === "input" && (d === "checkbox" || d === "radio")
    }
    function PG(l, d, p) {
        var x = Object.getOwnPropertyDescriptor(l.constructor.prototype, d);
        if (!l.hasOwnProperty(d) && typeof x < "u" && typeof x.get == "function" && typeof x.set == "function") {
            var _ = x.get
              , R = x.set;
            return Object.defineProperty(l, d, {
                configurable: !0,
                get: function() {
                    return _.call(this)
                },
                set: function(G) {
                    p = "" + G,
                    R.call(this, G)
                }
            }),
            Object.defineProperty(l, d, {
                enumerable: x.enumerable
            }),
            {
                getValue: function() {
                    return p
                },
                setValue: function(G) {
                    p = "" + G
                },
                stopTracking: function() {
                    l._valueTracker = null,
                    delete l[d]
                }
            }
        }
    }
    function gS(l) {
        if (!l._valueTracker) {
            var d = pP(l) ? "checked" : "value";
            l._valueTracker = PG(l, d, "" + l[d])
        }
    }
    function mP(l) {
        if (!l)
            return !1;
        var d = l._valueTracker;
        if (!d)
            return !0;
        var p = d.getValue()
          , x = "";
        return l && (x = pP(l) ? l.checked ? "true" : "false" : l.value),
        l = x,
        l !== p ? (d.setValue(l),
        !0) : !1
    }
    function gy(l) {
        if (l = l || (typeof document < "u" ? document : void 0),
        typeof l > "u")
            return null;
        try {
            return l.activeElement || l.body
        } catch {
            return l.body
        }
    }
    var RG = /[\n"\\]/g;
    function ea(l) {
        return l.replace(RG, function(d) {
            return "\\" + d.charCodeAt(0).toString(16) + " "
        })
    }
    function yS(l, d, p, x, _, R, G, Q) {
        l.name = "",
        G != null && typeof G != "function" && typeof G != "symbol" && typeof G != "boolean" ? l.type = G : l.removeAttribute("type"),
        d != null ? G === "number" ? (d === 0 && l.value === "" || l.value != d) && (l.value = "" + Jo(d)) : l.value !== "" + Jo(d) && (l.value = "" + Jo(d)) : G !== "submit" && G !== "reset" || l.removeAttribute("value"),
        d != null ? bS(l, G, Jo(d)) : p != null ? bS(l, G, Jo(p)) : x != null && l.removeAttribute("value"),
        _ == null && R != null && (l.defaultChecked = !!R),
        _ != null && (l.checked = _ && typeof _ != "function" && typeof _ != "symbol"),
        Q != null && typeof Q != "function" && typeof Q != "symbol" && typeof Q != "boolean" ? l.name = "" + Jo(Q) : l.removeAttribute("name")
    }
    function gP(l, d, p, x, _, R, G, Q) {
        if (R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" && (l.type = R),
        d != null || p != null) {
            if (!(R !== "submit" && R !== "reset" || d != null)) {
                gS(l);
                return
            }
            p = p != null ? "" + Jo(p) : "",
            d = d != null ? "" + Jo(d) : p,
            Q || d === l.value || (l.value = d),
            l.defaultValue = d
        }
        x = x ?? _,
        x = typeof x != "function" && typeof x != "symbol" && !!x,
        l.checked = Q ? l.checked : !!x,
        l.defaultChecked = !!x,
        G != null && typeof G != "function" && typeof G != "symbol" && typeof G != "boolean" && (l.name = G),
        gS(l)
    }
    function bS(l, d, p) {
        d === "number" && gy(l.ownerDocument) === l || l.defaultValue === "" + p || (l.defaultValue = "" + p)
    }
    function fd(l, d, p, x) {
        if (l = l.options,
        d) {
            d = {};
            for (var _ = 0; _ < p.length; _++)
                d["$" + p[_]] = !0;
            for (p = 0; p < l.length; p++)
                _ = d.hasOwnProperty("$" + l[p].value),
                l[p].selected !== _ && (l[p].selected = _),
                _ && x && (l[p].defaultSelected = !0)
        } else {
            for (p = "" + Jo(p),
            d = null,
            _ = 0; _ < l.length; _++) {
                if (l[_].value === p) {
                    l[_].selected = !0,
                    x && (l[_].defaultSelected = !0);
                    return
                }
                d !== null || l[_].disabled || (d = l[_])
            }
            d !== null && (d.selected = !0)
        }
    }
    function yP(l, d, p) {
        if (d != null && (d = "" + Jo(d),
        d !== l.value && (l.value = d),
        p == null)) {
            l.defaultValue !== d && (l.defaultValue = d);
            return
        }
        l.defaultValue = p != null ? "" + Jo(p) : ""
    }
    function bP(l, d, p, x) {
        if (d == null) {
            if (x != null) {
                if (p != null)
                    throw Error(r(92));
                if (F(x)) {
                    if (1 < x.length)
                        throw Error(r(93));
                    x = x[0]
                }
                p = x
            }
            p == null && (p = ""),
            d = p
        }
        p = Jo(d),
        l.defaultValue = p,
        x = l.textContent,
        x === p && x !== "" && x !== null && (l.value = x),
        gS(l)
    }
    function hd(l, d) {
        if (d) {
            var p = l.firstChild;
            if (p && p === l.lastChild && p.nodeType === 3) {
                p.nodeValue = d;
                return
            }
        }
        l.textContent = d
    }
    var DG = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function xP(l, d, p) {
        var x = d.indexOf("--") === 0;
        p == null || typeof p == "boolean" || p === "" ? x ? l.setProperty(d, "") : d === "float" ? l.cssFloat = "" : l[d] = "" : x ? l.setProperty(d, p) : typeof p != "number" || p === 0 || DG.has(d) ? d === "float" ? l.cssFloat = p : l[d] = ("" + p).trim() : l[d] = p + "px"
    }
    function vP(l, d, p) {
        if (d != null && typeof d != "object")
            throw Error(r(62));
        if (l = l.style,
        p != null) {
            for (var x in p)
                !p.hasOwnProperty(x) || d != null && d.hasOwnProperty(x) || (x.indexOf("--") === 0 ? l.setProperty(x, "") : x === "float" ? l.cssFloat = "" : l[x] = "");
            for (var _ in d)
                x = d[_],
                d.hasOwnProperty(_) && p[_] !== x && xP(l, _, x)
        } else
            for (var R in d)
                d.hasOwnProperty(R) && xP(l, R, d[R])
    }
    function xS(l) {
        if (l.indexOf("-") === -1)
            return !1;
        switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var OG = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
      , IG = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function yy(l) {
        return IG.test("" + l) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : l
    }
    function Ns() {}
    var vS = null;
    function SS(l) {
        return l = l.target || l.srcElement || window,
        l.correspondingUseElement && (l = l.correspondingUseElement),
        l.nodeType === 3 ? l.parentNode : l
    }
    var pd = null
      , md = null;
    function SP(l) {
        var d = Ze(l);
        if (d && (l = d.stateNode)) {
            var p = l[en] || null;
            e: switch (l = d.stateNode,
            d.type) {
            case "input":
                if (yS(l, p.value, p.defaultValue, p.defaultValue, p.checked, p.defaultChecked, p.type, p.name),
                d = p.name,
                p.type === "radio" && d != null) {
                    for (p = l; p.parentNode; )
                        p = p.parentNode;
                    for (p = p.querySelectorAll('input[name="' + ea("" + d) + '"][type="radio"]'),
                    d = 0; d < p.length; d++) {
                        var x = p[d];
                        if (x !== l && x.form === l.form) {
                            var _ = x[en] || null;
                            if (!_)
                                throw Error(r(90));
                            yS(x, _.value, _.defaultValue, _.defaultValue, _.checked, _.defaultChecked, _.type, _.name)
                        }
                    }
                    for (d = 0; d < p.length; d++)
                        x = p[d],
                        x.form === l.form && mP(x)
                }
                break e;
            case "textarea":
                yP(l, p.value, p.defaultValue);
                break e;
            case "select":
                d = p.value,
                d != null && fd(l, !!p.multiple, d, !1)
            }
        }
    }
    var CS = !1;
    function CP(l, d, p) {
        if (CS)
            return l(d, p);
        CS = !0;
        try {
            var x = l(d);
            return x
        } finally {
            if (CS = !1,
            (pd !== null || md !== null) && (ib(),
            pd && (d = pd,
            l = md,
            md = pd = null,
            SP(d),
            l)))
                for (d = 0; d < l.length; d++)
                    SP(l[d])
        }
    }
    function _h(l, d) {
        var p = l.stateNode;
        if (p === null)
            return null;
        var x = p[en] || null;
        if (x === null)
            return null;
        p = x[d];
        e: switch (d) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (x = !x.disabled) || (l = l.type,
            x = !(l === "button" || l === "input" || l === "select" || l === "textarea")),
            l = !x;
            break e;
        default:
            l = !1
        }
        if (l)
            return null;
        if (p && typeof p != "function")
            throw Error(r(231, d, typeof p));
        return p
    }
    var Us = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , wS = !1;
    if (Us)
        try {
            var Eh = {};
            Object.defineProperty(Eh, "passive", {
                get: function() {
                    wS = !0
                }
            }),
            window.addEventListener("test", Eh, Eh),
            window.removeEventListener("test", Eh, Eh)
        } catch {
            wS = !1
        }
    var Dl = null
      , kS = null
      , by = null;
    function wP() {
        if (by)
            return by;
        var l, d = kS, p = d.length, x, _ = "value"in Dl ? Dl.value : Dl.textContent, R = _.length;
        for (l = 0; l < p && d[l] === _[l]; l++)
            ;
        var G = p - l;
        for (x = 1; x <= G && d[p - x] === _[R - x]; x++)
            ;
        return by = _.slice(l, 1 < x ? 1 - x : void 0)
    }
    function xy(l) {
        var d = l.keyCode;
        return "charCode"in l ? (l = l.charCode,
        l === 0 && d === 13 && (l = 13)) : l = d,
        l === 10 && (l = 13),
        32 <= l || l === 13 ? l : 0
    }
    function vy() {
        return !0
    }
    function kP() {
        return !1
    }
    function eo(l) {
        function d(p, x, _, R, G) {
            this._reactName = p,
            this._targetInst = _,
            this.type = x,
            this.nativeEvent = R,
            this.target = G,
            this.currentTarget = null;
            for (var Q in l)
                l.hasOwnProperty(Q) && (p = l[Q],
                this[Q] = p ? p(R) : R[Q]);
            return this.isDefaultPrevented = (R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1) ? vy : kP,
            this.isPropagationStopped = kP,
            this
        }
        return h(d.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var p = this.nativeEvent;
                p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1),
                this.isDefaultPrevented = vy)
            },
            stopPropagation: function() {
                var p = this.nativeEvent;
                p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0),
                this.isPropagationStopped = vy)
            },
            persist: function() {},
            isPersistent: vy
        }),
        d
    }
    var Fc = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(l) {
            return l.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, Sy = eo(Fc), Ah = h({}, Fc, {
        view: 0,
        detail: 0
    }), $G = eo(Ah), TS, _S, Mh, Cy = h({}, Ah, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: AS,
        button: 0,
        buttons: 0,
        relatedTarget: function(l) {
            return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget
        },
        movementX: function(l) {
            return "movementX"in l ? l.movementX : (l !== Mh && (Mh && l.type === "mousemove" ? (TS = l.screenX - Mh.screenX,
            _S = l.screenY - Mh.screenY) : _S = TS = 0,
            Mh = l),
            TS)
        },
        movementY: function(l) {
            return "movementY"in l ? l.movementY : _S
        }
    }), TP = eo(Cy), LG = h({}, Cy, {
        dataTransfer: 0
    }), jG = eo(LG), BG = h({}, Ah, {
        relatedTarget: 0
    }), ES = eo(BG), zG = h({}, Fc, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), FG = eo(zG), NG = h({}, Fc, {
        clipboardData: function(l) {
            return "clipboardData"in l ? l.clipboardData : window.clipboardData
        }
    }), UG = eo(NG), VG = h({}, Fc, {
        data: 0
    }), _P = eo(VG), HG = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, qG = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, WG = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function GG(l) {
        var d = this.nativeEvent;
        return d.getModifierState ? d.getModifierState(l) : (l = WG[l]) ? !!d[l] : !1
    }
    function AS() {
        return GG
    }
    var YG = h({}, Ah, {
        key: function(l) {
            if (l.key) {
                var d = HG[l.key] || l.key;
                if (d !== "Unidentified")
                    return d
            }
            return l.type === "keypress" ? (l = xy(l),
            l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? qG[l.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: AS,
        charCode: function(l) {
            return l.type === "keypress" ? xy(l) : 0
        },
        keyCode: function(l) {
            return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0
        },
        which: function(l) {
            return l.type === "keypress" ? xy(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0
        }
    })
      , ZG = eo(YG)
      , QG = h({}, Cy, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , EP = eo(QG)
      , KG = h({}, Ah, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: AS
    })
      , XG = eo(KG)
      , JG = h({}, Fc, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , eY = eo(JG)
      , tY = h({}, Cy, {
        deltaX: function(l) {
            return "deltaX"in l ? l.deltaX : "wheelDeltaX"in l ? -l.wheelDeltaX : 0
        },
        deltaY: function(l) {
            return "deltaY"in l ? l.deltaY : "wheelDeltaY"in l ? -l.wheelDeltaY : "wheelDelta"in l ? -l.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , nY = eo(tY)
      , rY = h({}, Fc, {
        newState: 0,
        oldState: 0
    })
      , iY = eo(rY)
      , oY = [9, 13, 27, 32]
      , MS = Us && "CompositionEvent"in window
      , Ph = null;
    Us && "documentMode"in document && (Ph = document.documentMode);
    var aY = Us && "TextEvent"in window && !Ph
      , AP = Us && (!MS || Ph && 8 < Ph && 11 >= Ph)
      , MP = " "
      , PP = !1;
    function RP(l, d) {
        switch (l) {
        case "keyup":
            return oY.indexOf(d.keyCode) !== -1;
        case "keydown":
            return d.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function DP(l) {
        return l = l.detail,
        typeof l == "object" && "data"in l ? l.data : null
    }
    var gd = !1;
    function sY(l, d) {
        switch (l) {
        case "compositionend":
            return DP(d);
        case "keypress":
            return d.which !== 32 ? null : (PP = !0,
            MP);
        case "textInput":
            return l = d.data,
            l === MP && PP ? null : l;
        default:
            return null
        }
    }
    function lY(l, d) {
        if (gd)
            return l === "compositionend" || !MS && RP(l, d) ? (l = wP(),
            by = kS = Dl = null,
            gd = !1,
            l) : null;
        switch (l) {
        case "paste":
            return null;
        case "keypress":
            if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) {
                if (d.char && 1 < d.char.length)
                    return d.char;
                if (d.which)
                    return String.fromCharCode(d.which)
            }
            return null;
        case "compositionend":
            return AP && d.locale !== "ko" ? null : d.data;
        default:
            return null
        }
    }
    var cY = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function OP(l) {
        var d = l && l.nodeName && l.nodeName.toLowerCase();
        return d === "input" ? !!cY[l.type] : d === "textarea"
    }
    function IP(l, d, p, x) {
        pd ? md ? md.push(x) : md = [x] : pd = x,
        d = db(d, "onChange"),
        0 < d.length && (p = new Sy("onChange","change",null,p,x),
        l.push({
            event: p,
            listeners: d
        }))
    }
    var Rh = null
      , Dh = null;
    function uY(l) {
        gO(l, 0)
    }
    function wy(l) {
        var d = Wt(l);
        if (mP(d))
            return l
    }
    function $P(l, d) {
        if (l === "change")
            return d
    }
    var LP = !1;
    if (Us) {
        var PS;
        if (Us) {
            var RS = "oninput"in document;
            if (!RS) {
                var jP = document.createElement("div");
                jP.setAttribute("oninput", "return;"),
                RS = typeof jP.oninput == "function"
            }
            PS = RS
        } else
            PS = !1;
        LP = PS && (!document.documentMode || 9 < document.documentMode)
    }
    function BP() {
        Rh && (Rh.detachEvent("onpropertychange", zP),
        Dh = Rh = null)
    }
    function zP(l) {
        if (l.propertyName === "value" && wy(Dh)) {
            var d = [];
            IP(d, Dh, l, SS(l)),
            CP(uY, d)
        }
    }
    function dY(l, d, p) {
        l === "focusin" ? (BP(),
        Rh = d,
        Dh = p,
        Rh.attachEvent("onpropertychange", zP)) : l === "focusout" && BP()
    }
    function fY(l) {
        if (l === "selectionchange" || l === "keyup" || l === "keydown")
            return wy(Dh)
    }
    function hY(l, d) {
        if (l === "click")
            return wy(d)
    }
    function pY(l, d) {
        if (l === "input" || l === "change")
            return wy(d)
    }
    function mY(l, d) {
        return l === d && (l !== 0 || 1 / l === 1 / d) || l !== l && d !== d
    }
    var Po = typeof Object.is == "function" ? Object.is : mY;
    function Oh(l, d) {
        if (Po(l, d))
            return !0;
        if (typeof l != "object" || l === null || typeof d != "object" || d === null)
            return !1;
        var p = Object.keys(l)
          , x = Object.keys(d);
        if (p.length !== x.length)
            return !1;
        for (x = 0; x < p.length; x++) {
            var _ = p[x];
            if (!Ke.call(d, _) || !Po(l[_], d[_]))
                return !1
        }
        return !0
    }
    function FP(l) {
        for (; l && l.firstChild; )
            l = l.firstChild;
        return l
    }
    function NP(l, d) {
        var p = FP(l);
        l = 0;
        for (var x; p; ) {
            if (p.nodeType === 3) {
                if (x = l + p.textContent.length,
                l <= d && x >= d)
                    return {
                        node: p,
                        offset: d - l
                    };
                l = x
            }
            e: {
                for (; p; ) {
                    if (p.nextSibling) {
                        p = p.nextSibling;
                        break e
                    }
                    p = p.parentNode
                }
                p = void 0
            }
            p = FP(p)
        }
    }
    function UP(l, d) {
        return l && d ? l === d ? !0 : l && l.nodeType === 3 ? !1 : d && d.nodeType === 3 ? UP(l, d.parentNode) : "contains"in l ? l.contains(d) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(d) & 16) : !1 : !1
    }
    function VP(l) {
        l = l != null && l.ownerDocument != null && l.ownerDocument.defaultView != null ? l.ownerDocument.defaultView : window;
        for (var d = gy(l.document); d instanceof l.HTMLIFrameElement; ) {
            try {
                var p = typeof d.contentWindow.location.href == "string"
            } catch {
                p = !1
            }
            if (p)
                l = d.contentWindow;
            else
                break;
            d = gy(l.document)
        }
        return d
    }
    function DS(l) {
        var d = l && l.nodeName && l.nodeName.toLowerCase();
        return d && (d === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || d === "textarea" || l.contentEditable === "true")
    }
    var gY = Us && "documentMode"in document && 11 >= document.documentMode
      , yd = null
      , OS = null
      , Ih = null
      , IS = !1;
    function HP(l, d, p) {
        var x = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
        IS || yd == null || yd !== gy(x) || (x = yd,
        "selectionStart"in x && DS(x) ? x = {
            start: x.selectionStart,
            end: x.selectionEnd
        } : (x = (x.ownerDocument && x.ownerDocument.defaultView || window).getSelection(),
        x = {
            anchorNode: x.anchorNode,
            anchorOffset: x.anchorOffset,
            focusNode: x.focusNode,
            focusOffset: x.focusOffset
        }),
        Ih && Oh(Ih, x) || (Ih = x,
        x = db(OS, "onSelect"),
        0 < x.length && (d = new Sy("onSelect","select",null,d,p),
        l.push({
            event: d,
            listeners: x
        }),
        d.target = yd)))
    }
    function Nc(l, d) {
        var p = {};
        return p[l.toLowerCase()] = d.toLowerCase(),
        p["Webkit" + l] = "webkit" + d,
        p["Moz" + l] = "moz" + d,
        p
    }
    var bd = {
        animationend: Nc("Animation", "AnimationEnd"),
        animationiteration: Nc("Animation", "AnimationIteration"),
        animationstart: Nc("Animation", "AnimationStart"),
        transitionrun: Nc("Transition", "TransitionRun"),
        transitionstart: Nc("Transition", "TransitionStart"),
        transitioncancel: Nc("Transition", "TransitionCancel"),
        transitionend: Nc("Transition", "TransitionEnd")
    }
      , $S = {}
      , qP = {};
    Us && (qP = document.createElement("div").style,
    "AnimationEvent"in window || (delete bd.animationend.animation,
    delete bd.animationiteration.animation,
    delete bd.animationstart.animation),
    "TransitionEvent"in window || delete bd.transitionend.transition);
    function Uc(l) {
        if ($S[l])
            return $S[l];
        if (!bd[l])
            return l;
        var d = bd[l], p;
        for (p in d)
            if (d.hasOwnProperty(p) && p in qP)
                return $S[l] = d[p];
        return l
    }
    var WP = Uc("animationend")
      , GP = Uc("animationiteration")
      , YP = Uc("animationstart")
      , yY = Uc("transitionrun")
      , bY = Uc("transitionstart")
      , xY = Uc("transitioncancel")
      , ZP = Uc("transitionend")
      , QP = new Map
      , LS = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    LS.push("scrollEnd");
    function Pa(l, d) {
        QP.set(l, d),
        ui(d, [l])
    }
    var ky = typeof reportError == "function" ? reportError : function(l) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var d = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
                error: l
            });
            if (!window.dispatchEvent(d))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", l);
            return
        }
        console.error(l)
    }
      , ta = []
      , xd = 0
      , jS = 0;
    function Ty() {
        for (var l = xd, d = jS = xd = 0; d < l; ) {
            var p = ta[d];
            ta[d++] = null;
            var x = ta[d];
            ta[d++] = null;
            var _ = ta[d];
            ta[d++] = null;
            var R = ta[d];
            if (ta[d++] = null,
            x !== null && _ !== null) {
                var G = x.pending;
                G === null ? _.next = _ : (_.next = G.next,
                G.next = _),
                x.pending = _
            }
            R !== 0 && KP(p, _, R)
        }
    }
    function _y(l, d, p, x) {
        ta[xd++] = l,
        ta[xd++] = d,
        ta[xd++] = p,
        ta[xd++] = x,
        jS |= x,
        l.lanes |= x,
        l = l.alternate,
        l !== null && (l.lanes |= x)
    }
    function BS(l, d, p, x) {
        return _y(l, d, p, x),
        Ey(l)
    }
    function Vc(l, d) {
        return _y(l, null, null, d),
        Ey(l)
    }
    function KP(l, d, p) {
        l.lanes |= p;
        var x = l.alternate;
        x !== null && (x.lanes |= p);
        for (var _ = !1, R = l.return; R !== null; )
            R.childLanes |= p,
            x = R.alternate,
            x !== null && (x.childLanes |= p),
            R.tag === 22 && (l = R.stateNode,
            l === null || l._visibility & 1 || (_ = !0)),
            l = R,
            R = R.return;
        return l.tag === 3 ? (R = l.stateNode,
        _ && d !== null && (_ = 31 - ut(p),
        l = R.hiddenUpdates,
        x = l[_],
        x === null ? l[_] = [d] : x.push(d),
        d.lane = p | 536870912),
        R) : null
    }
    function Ey(l) {
        if (50 < np)
            throw np = 0,
            GC = null,
            Error(r(185));
        for (var d = l.return; d !== null; )
            l = d,
            d = l.return;
        return l.tag === 3 ? l.stateNode : null
    }
    var vd = {};
    function vY(l, d, p, x) {
        this.tag = l,
        this.key = p,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = d,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = x,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Ro(l, d, p, x) {
        return new vY(l,d,p,x)
    }
    function zS(l) {
        return l = l.prototype,
        !(!l || !l.isReactComponent)
    }
    function Vs(l, d) {
        var p = l.alternate;
        return p === null ? (p = Ro(l.tag, d, l.key, l.mode),
        p.elementType = l.elementType,
        p.type = l.type,
        p.stateNode = l.stateNode,
        p.alternate = l,
        l.alternate = p) : (p.pendingProps = d,
        p.type = l.type,
        p.flags = 0,
        p.subtreeFlags = 0,
        p.deletions = null),
        p.flags = l.flags & 65011712,
        p.childLanes = l.childLanes,
        p.lanes = l.lanes,
        p.child = l.child,
        p.memoizedProps = l.memoizedProps,
        p.memoizedState = l.memoizedState,
        p.updateQueue = l.updateQueue,
        d = l.dependencies,
        p.dependencies = d === null ? null : {
            lanes: d.lanes,
            firstContext: d.firstContext
        },
        p.sibling = l.sibling,
        p.index = l.index,
        p.ref = l.ref,
        p.refCleanup = l.refCleanup,
        p
    }
    function XP(l, d) {
        l.flags &= 65011714;
        var p = l.alternate;
        return p === null ? (l.childLanes = 0,
        l.lanes = d,
        l.child = null,
        l.subtreeFlags = 0,
        l.memoizedProps = null,
        l.memoizedState = null,
        l.updateQueue = null,
        l.dependencies = null,
        l.stateNode = null) : (l.childLanes = p.childLanes,
        l.lanes = p.lanes,
        l.child = p.child,
        l.subtreeFlags = 0,
        l.deletions = null,
        l.memoizedProps = p.memoizedProps,
        l.memoizedState = p.memoizedState,
        l.updateQueue = p.updateQueue,
        l.type = p.type,
        d = p.dependencies,
        l.dependencies = d === null ? null : {
            lanes: d.lanes,
            firstContext: d.firstContext
        }),
        l
    }
    function Ay(l, d, p, x, _, R) {
        var G = 0;
        if (x = l,
        typeof l == "function")
            zS(l) && (G = 1);
        else if (typeof l == "string")
            G = TZ(l, p, te.current) ? 26 : l === "html" || l === "head" || l === "body" ? 27 : 5;
        else
            e: switch (l) {
            case z:
                return l = Ro(31, p, d, _),
                l.elementType = z,
                l.lanes = R,
                l;
            case v:
                return Hc(p.children, _, R, d);
            case S:
                G = 8,
                _ |= 24;
                break;
            case C:
                return l = Ro(12, p, d, _ | 2),
                l.elementType = C,
                l.lanes = R,
                l;
            case E:
                return l = Ro(13, p, d, _),
                l.elementType = E,
                l.lanes = R,
                l;
            case P:
                return l = Ro(19, p, d, _),
                l.elementType = P,
                l.lanes = R,
                l;
            default:
                if (typeof l == "object" && l !== null)
                    switch (l.$$typeof) {
                    case k:
                        G = 10;
                        break e;
                    case w:
                        G = 9;
                        break e;
                    case T:
                        G = 11;
                        break e;
                    case D:
                        G = 14;
                        break e;
                    case $:
                        G = 16,
                        x = null;
                        break e
                    }
                G = 29,
                p = Error(r(130, l === null ? "null" : typeof l, "")),
                x = null
            }
        return d = Ro(G, p, d, _),
        d.elementType = l,
        d.type = x,
        d.lanes = R,
        d
    }
    function Hc(l, d, p, x) {
        return l = Ro(7, l, x, d),
        l.lanes = p,
        l
    }
    function FS(l, d, p) {
        return l = Ro(6, l, null, d),
        l.lanes = p,
        l
    }
    function JP(l) {
        var d = Ro(18, null, null, 0);
        return d.stateNode = l,
        d
    }
    function NS(l, d, p) {
        return d = Ro(4, l.children !== null ? l.children : [], l.key, d),
        d.lanes = p,
        d.stateNode = {
            containerInfo: l.containerInfo,
            pendingChildren: null,
            implementation: l.implementation
        },
        d
    }
    var eR = new WeakMap;
    function na(l, d) {
        if (typeof l == "object" && l !== null) {
            var p = eR.get(l);
            return p !== void 0 ? p : (d = {
                value: l,
                source: d,
                stack: ye(d)
            },
            eR.set(l, d),
            d)
        }
        return {
            value: l,
            source: d,
            stack: ye(d)
        }
    }
    var Sd = []
      , Cd = 0
      , My = null
      , $h = 0
      , ra = []
      , ia = 0
      , Ol = null
      , as = 1
      , ss = "";
    function Hs(l, d) {
        Sd[Cd++] = $h,
        Sd[Cd++] = My,
        My = l,
        $h = d
    }
    function tR(l, d, p) {
        ra[ia++] = as,
        ra[ia++] = ss,
        ra[ia++] = Ol,
        Ol = l;
        var x = as;
        l = ss;
        var _ = 32 - ut(x) - 1;
        x &= ~(1 << _),
        p += 1;
        var R = 32 - ut(d) + _;
        if (30 < R) {
            var G = _ - _ % 5;
            R = (x & (1 << G) - 1).toString(32),
            x >>= G,
            _ -= G,
            as = 1 << 32 - ut(d) + _ | p << _ | x,
            ss = R + l
        } else
            as = 1 << R | p << _ | x,
            ss = l
    }
    function US(l) {
        l.return !== null && (Hs(l, 1),
        tR(l, 1, 0))
    }
    function VS(l) {
        for (; l === My; )
            My = Sd[--Cd],
            Sd[Cd] = null,
            $h = Sd[--Cd],
            Sd[Cd] = null;
        for (; l === Ol; )
            Ol = ra[--ia],
            ra[ia] = null,
            ss = ra[--ia],
            ra[ia] = null,
            as = ra[--ia],
            ra[ia] = null
    }
    function nR(l, d) {
        ra[ia++] = as,
        ra[ia++] = ss,
        ra[ia++] = Ol,
        as = d.id,
        ss = d.overflow,
        Ol = l
    }
    var di = null
      , lr = null
      , Tn = !1
      , Il = null
      , oa = !1
      , HS = Error(r(519));
    function $l(l) {
        var d = Error(r(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", ""));
        throw Lh(na(d, l)),
        HS
    }
    function rR(l) {
        var d = l.stateNode
          , p = l.type
          , x = l.memoizedProps;
        switch (d[ln] = l,
        d[en] = x,
        p) {
        case "dialog":
            hn("cancel", d),
            hn("close", d);
            break;
        case "iframe":
        case "object":
        case "embed":
            hn("load", d);
            break;
        case "video":
        case "audio":
            for (p = 0; p < ip.length; p++)
                hn(ip[p], d);
            break;
        case "source":
            hn("error", d);
            break;
        case "img":
        case "image":
        case "link":
            hn("error", d),
            hn("load", d);
            break;
        case "details":
            hn("toggle", d);
            break;
        case "input":
            hn("invalid", d),
            gP(d, x.value, x.defaultValue, x.checked, x.defaultChecked, x.type, x.name, !0);
            break;
        case "select":
            hn("invalid", d);
            break;
        case "textarea":
            hn("invalid", d),
            bP(d, x.value, x.defaultValue, x.children)
        }
        p = x.children,
        typeof p != "string" && typeof p != "number" && typeof p != "bigint" || d.textContent === "" + p || x.suppressHydrationWarning === !0 || vO(d.textContent, p) ? (x.popover != null && (hn("beforetoggle", d),
        hn("toggle", d)),
        x.onScroll != null && hn("scroll", d),
        x.onScrollEnd != null && hn("scrollend", d),
        x.onClick != null && (d.onclick = Ns),
        d = !0) : d = !1,
        d || $l(l, !0)
    }
    function iR(l) {
        for (di = l.return; di; )
            switch (di.tag) {
            case 5:
            case 31:
            case 13:
                oa = !1;
                return;
            case 27:
            case 3:
                oa = !0;
                return;
            default:
                di = di.return
            }
    }
    function wd(l) {
        if (l !== di)
            return !1;
        if (!Tn)
            return iR(l),
            Tn = !0,
            !1;
        var d = l.tag, p;
        if ((p = d !== 3 && d !== 27) && ((p = d === 5) && (p = l.type,
        p = !(p !== "form" && p !== "button") || lw(l.type, l.memoizedProps)),
        p = !p),
        p && lr && $l(l),
        iR(l),
        d === 13) {
            if (l = l.memoizedState,
            l = l !== null ? l.dehydrated : null,
            !l)
                throw Error(r(317));
            lr = MO(l)
        } else if (d === 31) {
            if (l = l.memoizedState,
            l = l !== null ? l.dehydrated : null,
            !l)
                throw Error(r(317));
            lr = MO(l)
        } else
            d === 27 ? (d = lr,
            Zl(l.type) ? (l = hw,
            hw = null,
            lr = l) : lr = d) : lr = di ? sa(l.stateNode.nextSibling) : null;
        return !0
    }
    function qc() {
        lr = di = null,
        Tn = !1
    }
    function qS() {
        var l = Il;
        return l !== null && (io === null ? io = l : io.push.apply(io, l),
        Il = null),
        l
    }
    function Lh(l) {
        Il === null ? Il = [l] : Il.push(l)
    }
    var WS = V(null)
      , Wc = null
      , qs = null;
    function Ll(l, d, p) {
        W(WS, d._currentValue),
        d._currentValue = p
    }
    function Ws(l) {
        l._currentValue = WS.current,
        Y(WS)
    }
    function GS(l, d, p) {
        for (; l !== null; ) {
            var x = l.alternate;
            if ((l.childLanes & d) !== d ? (l.childLanes |= d,
            x !== null && (x.childLanes |= d)) : x !== null && (x.childLanes & d) !== d && (x.childLanes |= d),
            l === p)
                break;
            l = l.return
        }
    }
    function YS(l, d, p, x) {
        var _ = l.child;
        for (_ !== null && (_.return = l); _ !== null; ) {
            var R = _.dependencies;
            if (R !== null) {
                var G = _.child;
                R = R.firstContext;
                e: for (; R !== null; ) {
                    var Q = R;
                    R = _;
                    for (var ae = 0; ae < d.length; ae++)
                        if (Q.context === d[ae]) {
                            R.lanes |= p,
                            Q = R.alternate,
                            Q !== null && (Q.lanes |= p),
                            GS(R.return, p, l),
                            x || (G = null);
                            break e
                        }
                    R = Q.next
                }
            } else if (_.tag === 18) {
                if (G = _.return,
                G === null)
                    throw Error(r(341));
                G.lanes |= p,
                R = G.alternate,
                R !== null && (R.lanes |= p),
                GS(G, p, l),
                G = null
            } else
                G = _.child;
            if (G !== null)
                G.return = _;
            else
                for (G = _; G !== null; ) {
                    if (G === l) {
                        G = null;
                        break
                    }
                    if (_ = G.sibling,
                    _ !== null) {
                        _.return = G.return,
                        G = _;
                        break
                    }
                    G = G.return
                }
            _ = G
        }
    }
    function kd(l, d, p, x) {
        l = null;
        for (var _ = d, R = !1; _ !== null; ) {
            if (!R) {
                if ((_.flags & 524288) !== 0)
                    R = !0;
                else if ((_.flags & 262144) !== 0)
                    break
            }
            if (_.tag === 10) {
                var G = _.alternate;
                if (G === null)
                    throw Error(r(387));
                if (G = G.memoizedProps,
                G !== null) {
                    var Q = _.type;
                    Po(_.pendingProps.value, G.value) || (l !== null ? l.push(Q) : l = [Q])
                }
            } else if (_ === re.current) {
                if (G = _.alternate,
                G === null)
                    throw Error(r(387));
                G.memoizedState.memoizedState !== _.memoizedState.memoizedState && (l !== null ? l.push(cp) : l = [cp])
            }
            _ = _.return
        }
        l !== null && YS(d, l, p, x),
        d.flags |= 262144
    }
    function Py(l) {
        for (l = l.firstContext; l !== null; ) {
            if (!Po(l.context._currentValue, l.memoizedValue))
                return !0;
            l = l.next
        }
        return !1
    }
    function Gc(l) {
        Wc = l,
        qs = null,
        l = l.dependencies,
        l !== null && (l.firstContext = null)
    }
    function fi(l) {
        return oR(Wc, l)
    }
    function Ry(l, d) {
        return Wc === null && Gc(l),
        oR(l, d)
    }
    function oR(l, d) {
        var p = d._currentValue;
        if (d = {
            context: d,
            memoizedValue: p,
            next: null
        },
        qs === null) {
            if (l === null)
                throw Error(r(308));
            qs = d,
            l.dependencies = {
                lanes: 0,
                firstContext: d
            },
            l.flags |= 524288
        } else
            qs = qs.next = d;
        return p
    }
    var SY = typeof AbortController < "u" ? AbortController : function() {
        var l = []
          , d = this.signal = {
            aborted: !1,
            addEventListener: function(p, x) {
                l.push(x)
            }
        };
        this.abort = function() {
            d.aborted = !0,
            l.forEach(function(p) {
                return p()
            })
        }
    }
      , CY = e.unstable_scheduleCallback
      , wY = e.unstable_NormalPriority
      , Ur = {
        $$typeof: k,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
    };
    function ZS() {
        return {
            controller: new SY,
            data: new Map,
            refCount: 0
        }
    }
    function jh(l) {
        l.refCount--,
        l.refCount === 0 && CY(wY, function() {
            l.controller.abort()
        })
    }
    var Bh = null
      , QS = 0
      , Td = 0
      , _d = null;
    function kY(l, d) {
        if (Bh === null) {
            var p = Bh = [];
            QS = 0,
            Td = JC(),
            _d = {
                status: "pending",
                value: void 0,
                then: function(x) {
                    p.push(x)
                }
            }
        }
        return QS++,
        d.then(aR, aR),
        d
    }
    function aR() {
        if (--QS === 0 && Bh !== null) {
            _d !== null && (_d.status = "fulfilled");
            var l = Bh;
            Bh = null,
            Td = 0,
            _d = null;
            for (var d = 0; d < l.length; d++)
                (0,
                l[d])()
        }
    }
    function TY(l, d) {
        var p = []
          , x = {
            status: "pending",
            value: null,
            reason: null,
            then: function(_) {
                p.push(_)
            }
        };
        return l.then(function() {
            x.status = "fulfilled",
            x.value = d;
            for (var _ = 0; _ < p.length; _++)
                (0,
                p[_])(d)
        }, function(_) {
            for (x.status = "rejected",
            x.reason = _,
            _ = 0; _ < p.length; _++)
                (0,
                p[_])(void 0)
        }),
        x
    }
    var sR = j.S;
    j.S = function(l, d) {
        HD = Oe(),
        typeof d == "object" && d !== null && typeof d.then == "function" && kY(l, d),
        sR !== null && sR(l, d)
    }
    ;
    var Yc = V(null);
    function KS() {
        var l = Yc.current;
        return l !== null ? l : rr.pooledCache
    }
    function Dy(l, d) {
        d === null ? W(Yc, Yc.current) : W(Yc, d.pool)
    }
    function lR() {
        var l = KS();
        return l === null ? null : {
            parent: Ur._currentValue,
            pool: l
        }
    }
    var Ed = Error(r(460))
      , XS = Error(r(474))
      , Oy = Error(r(542))
      , Iy = {
        then: function() {}
    };
    function cR(l) {
        return l = l.status,
        l === "fulfilled" || l === "rejected"
    }
    function uR(l, d, p) {
        switch (p = l[p],
        p === void 0 ? l.push(d) : p !== d && (d.then(Ns, Ns),
        d = p),
        d.status) {
        case "fulfilled":
            return d.value;
        case "rejected":
            throw l = d.reason,
            fR(l),
            l;
        default:
            if (typeof d.status == "string")
                d.then(Ns, Ns);
            else {
                if (l = rr,
                l !== null && 100 < l.shellSuspendCounter)
                    throw Error(r(482));
                l = d,
                l.status = "pending",
                l.then(function(x) {
                    if (d.status === "pending") {
                        var _ = d;
                        _.status = "fulfilled",
                        _.value = x
                    }
                }, function(x) {
                    if (d.status === "pending") {
                        var _ = d;
                        _.status = "rejected",
                        _.reason = x
                    }
                })
            }
            switch (d.status) {
            case "fulfilled":
                return d.value;
            case "rejected":
                throw l = d.reason,
                fR(l),
                l
            }
            throw Qc = d,
            Ed
        }
    }
    function Zc(l) {
        try {
            var d = l._init;
            return d(l._payload)
        } catch (p) {
            throw p !== null && typeof p == "object" && typeof p.then == "function" ? (Qc = p,
            Ed) : p
        }
    }
    var Qc = null;
    function dR() {
        if (Qc === null)
            throw Error(r(459));
        var l = Qc;
        return Qc = null,
        l
    }
    function fR(l) {
        if (l === Ed || l === Oy)
            throw Error(r(483))
    }
    var Ad = null
      , zh = 0;
    function $y(l) {
        var d = zh;
        return zh += 1,
        Ad === null && (Ad = []),
        uR(Ad, l, d)
    }
    function Fh(l, d) {
        d = d.props.ref,
        l.ref = d !== void 0 ? d : null
    }
    function Ly(l, d) {
        throw d.$$typeof === m ? Error(r(525)) : (l = Object.prototype.toString.call(d),
        Error(r(31, l === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : l)))
    }
    function hR(l) {
        function d(be, pe) {
            if (l) {
                var _e = be.deletions;
                _e === null ? (be.deletions = [pe],
                be.flags |= 16) : _e.push(pe)
            }
        }
        function p(be, pe) {
            if (!l)
                return null;
            for (; pe !== null; )
                d(be, pe),
                pe = pe.sibling;
            return null
        }
        function x(be) {
            for (var pe = new Map; be !== null; )
                be.key !== null ? pe.set(be.key, be) : pe.set(be.index, be),
                be = be.sibling;
            return pe
        }
        function _(be, pe) {
            return be = Vs(be, pe),
            be.index = 0,
            be.sibling = null,
            be
        }
        function R(be, pe, _e) {
            return be.index = _e,
            l ? (_e = be.alternate,
            _e !== null ? (_e = _e.index,
            _e < pe ? (be.flags |= 67108866,
            pe) : _e) : (be.flags |= 67108866,
            pe)) : (be.flags |= 1048576,
            pe)
        }
        function G(be) {
            return l && be.alternate === null && (be.flags |= 67108866),
            be
        }
        function Q(be, pe, _e, qe) {
            return pe === null || pe.tag !== 6 ? (pe = FS(_e, be.mode, qe),
            pe.return = be,
            pe) : (pe = _(pe, _e),
            pe.return = be,
            pe)
        }
        function ae(be, pe, _e, qe) {
            var Dt = _e.type;
            return Dt === v ? Ue(be, pe, _e.props.children, qe, _e.key) : pe !== null && (pe.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === $ && Zc(Dt) === pe.type) ? (pe = _(pe, _e.props),
            Fh(pe, _e),
            pe.return = be,
            pe) : (pe = Ay(_e.type, _e.key, _e.props, null, be.mode, qe),
            Fh(pe, _e),
            pe.return = be,
            pe)
        }
        function Ee(be, pe, _e, qe) {
            return pe === null || pe.tag !== 4 || pe.stateNode.containerInfo !== _e.containerInfo || pe.stateNode.implementation !== _e.implementation ? (pe = NS(_e, be.mode, qe),
            pe.return = be,
            pe) : (pe = _(pe, _e.children || []),
            pe.return = be,
            pe)
        }
        function Ue(be, pe, _e, qe, Dt) {
            return pe === null || pe.tag !== 7 ? (pe = Hc(_e, be.mode, qe, Dt),
            pe.return = be,
            pe) : (pe = _(pe, _e),
            pe.return = be,
            pe)
        }
        function We(be, pe, _e) {
            if (typeof pe == "string" && pe !== "" || typeof pe == "number" || typeof pe == "bigint")
                return pe = FS("" + pe, be.mode, _e),
                pe.return = be,
                pe;
            if (typeof pe == "object" && pe !== null) {
                switch (pe.$$typeof) {
                case y:
                    return _e = Ay(pe.type, pe.key, pe.props, null, be.mode, _e),
                    Fh(_e, pe),
                    _e.return = be,
                    _e;
                case b:
                    return pe = NS(pe, be.mode, _e),
                    pe.return = be,
                    pe;
                case $:
                    return pe = Zc(pe),
                    We(be, pe, _e)
                }
                if (F(pe) || M(pe))
                    return pe = Hc(pe, be.mode, _e, null),
                    pe.return = be,
                    pe;
                if (typeof pe.then == "function")
                    return We(be, $y(pe), _e);
                if (pe.$$typeof === k)
                    return We(be, Ry(be, pe), _e);
                Ly(be, pe)
            }
            return null
        }
        function Pe(be, pe, _e, qe) {
            var Dt = pe !== null ? pe.key : null;
            if (typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint")
                return Dt !== null ? null : Q(be, pe, "" + _e, qe);
            if (typeof _e == "object" && _e !== null) {
                switch (_e.$$typeof) {
                case y:
                    return _e.key === Dt ? ae(be, pe, _e, qe) : null;
                case b:
                    return _e.key === Dt ? Ee(be, pe, _e, qe) : null;
                case $:
                    return _e = Zc(_e),
                    Pe(be, pe, _e, qe)
                }
                if (F(_e) || M(_e))
                    return Dt !== null ? null : Ue(be, pe, _e, qe, null);
                if (typeof _e.then == "function")
                    return Pe(be, pe, $y(_e), qe);
                if (_e.$$typeof === k)
                    return Pe(be, pe, Ry(be, _e), qe);
                Ly(be, _e)
            }
            return null
        }
        function $e(be, pe, _e, qe, Dt) {
            if (typeof qe == "string" && qe !== "" || typeof qe == "number" || typeof qe == "bigint")
                return be = be.get(_e) || null,
                Q(pe, be, "" + qe, Dt);
            if (typeof qe == "object" && qe !== null) {
                switch (qe.$$typeof) {
                case y:
                    return be = be.get(qe.key === null ? _e : qe.key) || null,
                    ae(pe, be, qe, Dt);
                case b:
                    return be = be.get(qe.key === null ? _e : qe.key) || null,
                    Ee(pe, be, qe, Dt);
                case $:
                    return qe = Zc(qe),
                    $e(be, pe, _e, qe, Dt)
                }
                if (F(qe) || M(qe))
                    return be = be.get(_e) || null,
                    Ue(pe, be, qe, Dt, null);
                if (typeof qe.then == "function")
                    return $e(be, pe, _e, $y(qe), Dt);
                if (qe.$$typeof === k)
                    return $e(be, pe, _e, Ry(pe, qe), Dt);
                Ly(pe, qe)
            }
            return null
        }
        function vt(be, pe, _e, qe) {
            for (var Dt = null, Rn = null, Et = pe, on = pe = 0, Sn = null; Et !== null && on < _e.length; on++) {
                Et.index > on ? (Sn = Et,
                Et = null) : Sn = Et.sibling;
                var Dn = Pe(be, Et, _e[on], qe);
                if (Dn === null) {
                    Et === null && (Et = Sn);
                    break
                }
                l && Et && Dn.alternate === null && d(be, Et),
                pe = R(Dn, pe, on),
                Rn === null ? Dt = Dn : Rn.sibling = Dn,
                Rn = Dn,
                Et = Sn
            }
            if (on === _e.length)
                return p(be, Et),
                Tn && Hs(be, on),
                Dt;
            if (Et === null) {
                for (; on < _e.length; on++)
                    Et = We(be, _e[on], qe),
                    Et !== null && (pe = R(Et, pe, on),
                    Rn === null ? Dt = Et : Rn.sibling = Et,
                    Rn = Et);
                return Tn && Hs(be, on),
                Dt
            }
            for (Et = x(Et); on < _e.length; on++)
                Sn = $e(Et, be, on, _e[on], qe),
                Sn !== null && (l && Sn.alternate !== null && Et.delete(Sn.key === null ? on : Sn.key),
                pe = R(Sn, pe, on),
                Rn === null ? Dt = Sn : Rn.sibling = Sn,
                Rn = Sn);
            return l && Et.forEach(function(ec) {
                return d(be, ec)
            }),
            Tn && Hs(be, on),
            Dt
        }
        function Ut(be, pe, _e, qe) {
            if (_e == null)
                throw Error(r(151));
            for (var Dt = null, Rn = null, Et = pe, on = pe = 0, Sn = null, Dn = _e.next(); Et !== null && !Dn.done; on++,
            Dn = _e.next()) {
                Et.index > on ? (Sn = Et,
                Et = null) : Sn = Et.sibling;
                var ec = Pe(be, Et, Dn.value, qe);
                if (ec === null) {
                    Et === null && (Et = Sn);
                    break
                }
                l && Et && ec.alternate === null && d(be, Et),
                pe = R(ec, pe, on),
                Rn === null ? Dt = ec : Rn.sibling = ec,
                Rn = ec,
                Et = Sn
            }
            if (Dn.done)
                return p(be, Et),
                Tn && Hs(be, on),
                Dt;
            if (Et === null) {
                for (; !Dn.done; on++,
                Dn = _e.next())
                    Dn = We(be, Dn.value, qe),
                    Dn !== null && (pe = R(Dn, pe, on),
                    Rn === null ? Dt = Dn : Rn.sibling = Dn,
                    Rn = Dn);
                return Tn && Hs(be, on),
                Dt
            }
            for (Et = x(Et); !Dn.done; on++,
            Dn = _e.next())
                Dn = $e(Et, be, on, Dn.value, qe),
                Dn !== null && (l && Dn.alternate !== null && Et.delete(Dn.key === null ? on : Dn.key),
                pe = R(Dn, pe, on),
                Rn === null ? Dt = Dn : Rn.sibling = Dn,
                Rn = Dn);
            return l && Et.forEach(function(LZ) {
                return d(be, LZ)
            }),
            Tn && Hs(be, on),
            Dt
        }
        function er(be, pe, _e, qe) {
            if (typeof _e == "object" && _e !== null && _e.type === v && _e.key === null && (_e = _e.props.children),
            typeof _e == "object" && _e !== null) {
                switch (_e.$$typeof) {
                case y:
                    e: {
                        for (var Dt = _e.key; pe !== null; ) {
                            if (pe.key === Dt) {
                                if (Dt = _e.type,
                                Dt === v) {
                                    if (pe.tag === 7) {
                                        p(be, pe.sibling),
                                        qe = _(pe, _e.props.children),
                                        qe.return = be,
                                        be = qe;
                                        break e
                                    }
                                } else if (pe.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === $ && Zc(Dt) === pe.type) {
                                    p(be, pe.sibling),
                                    qe = _(pe, _e.props),
                                    Fh(qe, _e),
                                    qe.return = be,
                                    be = qe;
                                    break e
                                }
                                p(be, pe);
                                break
                            } else
                                d(be, pe);
                            pe = pe.sibling
                        }
                        _e.type === v ? (qe = Hc(_e.props.children, be.mode, qe, _e.key),
                        qe.return = be,
                        be = qe) : (qe = Ay(_e.type, _e.key, _e.props, null, be.mode, qe),
                        Fh(qe, _e),
                        qe.return = be,
                        be = qe)
                    }
                    return G(be);
                case b:
                    e: {
                        for (Dt = _e.key; pe !== null; ) {
                            if (pe.key === Dt)
                                if (pe.tag === 4 && pe.stateNode.containerInfo === _e.containerInfo && pe.stateNode.implementation === _e.implementation) {
                                    p(be, pe.sibling),
                                    qe = _(pe, _e.children || []),
                                    qe.return = be,
                                    be = qe;
                                    break e
                                } else {
                                    p(be, pe);
                                    break
                                }
                            else
                                d(be, pe);
                            pe = pe.sibling
                        }
                        qe = NS(_e, be.mode, qe),
                        qe.return = be,
                        be = qe
                    }
                    return G(be);
                case $:
                    return _e = Zc(_e),
                    er(be, pe, _e, qe)
                }
                if (F(_e))
                    return vt(be, pe, _e, qe);
                if (M(_e)) {
                    if (Dt = M(_e),
                    typeof Dt != "function")
                        throw Error(r(150));
                    return _e = Dt.call(_e),
                    Ut(be, pe, _e, qe)
                }
                if (typeof _e.then == "function")
                    return er(be, pe, $y(_e), qe);
                if (_e.$$typeof === k)
                    return er(be, pe, Ry(be, _e), qe);
                Ly(be, _e)
            }
            return typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint" ? (_e = "" + _e,
            pe !== null && pe.tag === 6 ? (p(be, pe.sibling),
            qe = _(pe, _e),
            qe.return = be,
            be = qe) : (p(be, pe),
            qe = FS(_e, be.mode, qe),
            qe.return = be,
            be = qe),
            G(be)) : p(be, pe)
        }
        return function(be, pe, _e, qe) {
            try {
                zh = 0;
                var Dt = er(be, pe, _e, qe);
                return Ad = null,
                Dt
            } catch (Et) {
                if (Et === Ed || Et === Oy)
                    throw Et;
                var Rn = Ro(29, Et, null, be.mode);
                return Rn.lanes = qe,
                Rn.return = be,
                Rn
            } finally {}
        }
    }
    var Kc = hR(!0)
      , pR = hR(!1)
      , jl = !1;
    function JS(l) {
        l.updateQueue = {
            baseState: l.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        }
    }
    function eC(l, d) {
        l = l.updateQueue,
        d.updateQueue === l && (d.updateQueue = {
            baseState: l.baseState,
            firstBaseUpdate: l.firstBaseUpdate,
            lastBaseUpdate: l.lastBaseUpdate,
            shared: l.shared,
            callbacks: null
        })
    }
    function Bl(l) {
        return {
            lane: l,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function zl(l, d, p) {
        var x = l.updateQueue;
        if (x === null)
            return null;
        if (x = x.shared,
        (Ln & 2) !== 0) {
            var _ = x.pending;
            return _ === null ? d.next = d : (d.next = _.next,
            _.next = d),
            x.pending = d,
            d = Ey(l),
            KP(l, null, p),
            d
        }
        return _y(l, x, d, p),
        Ey(l)
    }
    function Nh(l, d, p) {
        if (d = d.updateQueue,
        d !== null && (d = d.shared,
        (p & 4194048) !== 0)) {
            var x = d.lanes;
            x &= l.pendingLanes,
            p |= x,
            d.lanes = p,
            Je(l, p)
        }
    }
    function tC(l, d) {
        var p = l.updateQueue
          , x = l.alternate;
        if (x !== null && (x = x.updateQueue,
        p === x)) {
            var _ = null
              , R = null;
            if (p = p.firstBaseUpdate,
            p !== null) {
                do {
                    var G = {
                        lane: p.lane,
                        tag: p.tag,
                        payload: p.payload,
                        callback: null,
                        next: null
                    };
                    R === null ? _ = R = G : R = R.next = G,
                    p = p.next
                } while (p !== null);
                R === null ? _ = R = d : R = R.next = d
            } else
                _ = R = d;
            p = {
                baseState: x.baseState,
                firstBaseUpdate: _,
                lastBaseUpdate: R,
                shared: x.shared,
                callbacks: x.callbacks
            },
            l.updateQueue = p;
            return
        }
        l = p.lastBaseUpdate,
        l === null ? p.firstBaseUpdate = d : l.next = d,
        p.lastBaseUpdate = d
    }
    var nC = !1;
    function Uh() {
        if (nC) {
            var l = _d;
            if (l !== null)
                throw l
        }
    }
    function Vh(l, d, p, x) {
        nC = !1;
        var _ = l.updateQueue;
        jl = !1;
        var R = _.firstBaseUpdate
          , G = _.lastBaseUpdate
          , Q = _.shared.pending;
        if (Q !== null) {
            _.shared.pending = null;
            var ae = Q
              , Ee = ae.next;
            ae.next = null,
            G === null ? R = Ee : G.next = Ee,
            G = ae;
            var Ue = l.alternate;
            Ue !== null && (Ue = Ue.updateQueue,
            Q = Ue.lastBaseUpdate,
            Q !== G && (Q === null ? Ue.firstBaseUpdate = Ee : Q.next = Ee,
            Ue.lastBaseUpdate = ae))
        }
        if (R !== null) {
            var We = _.baseState;
            G = 0,
            Ue = Ee = ae = null,
            Q = R;
            do {
                var Pe = Q.lane & -536870913
                  , $e = Pe !== Q.lane;
                if ($e ? (vn & Pe) === Pe : (x & Pe) === Pe) {
                    Pe !== 0 && Pe === Td && (nC = !0),
                    Ue !== null && (Ue = Ue.next = {
                        lane: 0,
                        tag: Q.tag,
                        payload: Q.payload,
                        callback: null,
                        next: null
                    });
                    e: {
                        var vt = l
                          , Ut = Q;
                        Pe = d;
                        var er = p;
                        switch (Ut.tag) {
                        case 1:
                            if (vt = Ut.payload,
                            typeof vt == "function") {
                                We = vt.call(er, We, Pe);
                                break e
                            }
                            We = vt;
                            break e;
                        case 3:
                            vt.flags = vt.flags & -65537 | 128;
                        case 0:
                            if (vt = Ut.payload,
                            Pe = typeof vt == "function" ? vt.call(er, We, Pe) : vt,
                            Pe == null)
                                break e;
                            We = h({}, We, Pe);
                            break e;
                        case 2:
                            jl = !0
                        }
                    }
                    Pe = Q.callback,
                    Pe !== null && (l.flags |= 64,
                    $e && (l.flags |= 8192),
                    $e = _.callbacks,
                    $e === null ? _.callbacks = [Pe] : $e.push(Pe))
                } else
                    $e = {
                        lane: Pe,
                        tag: Q.tag,
                        payload: Q.payload,
                        callback: Q.callback,
                        next: null
                    },
                    Ue === null ? (Ee = Ue = $e,
                    ae = We) : Ue = Ue.next = $e,
                    G |= Pe;
                if (Q = Q.next,
                Q === null) {
                    if (Q = _.shared.pending,
                    Q === null)
                        break;
                    $e = Q,
                    Q = $e.next,
                    $e.next = null,
                    _.lastBaseUpdate = $e,
                    _.shared.pending = null
                }
            } while (!0);
            Ue === null && (ae = We),
            _.baseState = ae,
            _.firstBaseUpdate = Ee,
            _.lastBaseUpdate = Ue,
            R === null && (_.shared.lanes = 0),
            Hl |= G,
            l.lanes = G,
            l.memoizedState = We
        }
    }
    function mR(l, d) {
        if (typeof l != "function")
            throw Error(r(191, l));
        l.call(d)
    }
    function gR(l, d) {
        var p = l.callbacks;
        if (p !== null)
            for (l.callbacks = null,
            l = 0; l < p.length; l++)
                mR(p[l], d)
    }
    var Md = V(null)
      , jy = V(0);
    function yR(l, d) {
        l = tl,
        W(jy, l),
        W(Md, d),
        tl = l | d.baseLanes
    }
    function rC() {
        W(jy, tl),
        W(Md, Md.current)
    }
    function iC() {
        tl = jy.current,
        Y(Md),
        Y(jy)
    }
    var Do = V(null)
      , aa = null;
    function Fl(l) {
        var d = l.alternate;
        W($r, $r.current & 1),
        W(Do, l),
        aa === null && (d === null || Md.current !== null || d.memoizedState !== null) && (aa = l)
    }
    function oC(l) {
        W($r, $r.current),
        W(Do, l),
        aa === null && (aa = l)
    }
    function bR(l) {
        l.tag === 22 ? (W($r, $r.current),
        W(Do, l),
        aa === null && (aa = l)) : Nl()
    }
    function Nl() {
        W($r, $r.current),
        W(Do, Do.current)
    }
    function Oo(l) {
        Y(Do),
        aa === l && (aa = null),
        Y($r)
    }
    var $r = V(0);
    function By(l) {
        for (var d = l; d !== null; ) {
            if (d.tag === 13) {
                var p = d.memoizedState;
                if (p !== null && (p = p.dehydrated,
                p === null || dw(p) || fw(p)))
                    return d
            } else if (d.tag === 19 && (d.memoizedProps.revealOrder === "forwards" || d.memoizedProps.revealOrder === "backwards" || d.memoizedProps.revealOrder === "unstable_legacy-backwards" || d.memoizedProps.revealOrder === "together")) {
                if ((d.flags & 128) !== 0)
                    return d
            } else if (d.child !== null) {
                d.child.return = d,
                d = d.child;
                continue
            }
            if (d === l)
                break;
            for (; d.sibling === null; ) {
                if (d.return === null || d.return === l)
                    return null;
                d = d.return
            }
            d.sibling.return = d.return,
            d = d.sibling
        }
        return null
    }
    var Gs = 0
      , nn = null
      , Xn = null
      , Vr = null
      , zy = !1
      , Pd = !1
      , Xc = !1
      , Fy = 0
      , Hh = 0
      , Rd = null
      , _Y = 0;
    function Er() {
        throw Error(r(321))
    }
    function aC(l, d) {
        if (d === null)
            return !1;
        for (var p = 0; p < d.length && p < l.length; p++)
            if (!Po(l[p], d[p]))
                return !1;
        return !0
    }
    function sC(l, d, p, x, _, R) {
        return Gs = R,
        nn = d,
        d.memoizedState = null,
        d.updateQueue = null,
        d.lanes = 0,
        j.H = l === null || l.memoizedState === null ? tD : CC,
        Xc = !1,
        R = p(x, _),
        Xc = !1,
        Pd && (R = vR(d, p, x, _)),
        xR(l),
        R
    }
    function xR(l) {
        j.H = Gh;
        var d = Xn !== null && Xn.next !== null;
        if (Gs = 0,
        Vr = Xn = nn = null,
        zy = !1,
        Hh = 0,
        Rd = null,
        d)
            throw Error(r(300));
        l === null || Hr || (l = l.dependencies,
        l !== null && Py(l) && (Hr = !0))
    }
    function vR(l, d, p, x) {
        nn = l;
        var _ = 0;
        do {
            if (Pd && (Rd = null),
            Hh = 0,
            Pd = !1,
            25 <= _)
                throw Error(r(301));
            if (_ += 1,
            Vr = Xn = null,
            l.updateQueue != null) {
                var R = l.updateQueue;
                R.lastEffect = null,
                R.events = null,
                R.stores = null,
                R.memoCache != null && (R.memoCache.index = 0)
            }
            j.H = nD,
            R = d(p, x)
        } while (Pd);
        return R
    }
    function EY() {
        var l = j.H
          , d = l.useState()[0];
        return d = typeof d.then == "function" ? qh(d) : d,
        l = l.useState()[0],
        (Xn !== null ? Xn.memoizedState : null) !== l && (nn.flags |= 1024),
        d
    }
    function lC() {
        var l = Fy !== 0;
        return Fy = 0,
        l
    }
    function cC(l, d, p) {
        d.updateQueue = l.updateQueue,
        d.flags &= -2053,
        l.lanes &= ~p
    }
    function uC(l) {
        if (zy) {
            for (l = l.memoizedState; l !== null; ) {
                var d = l.queue;
                d !== null && (d.pending = null),
                l = l.next
            }
            zy = !1
        }
        Gs = 0,
        Vr = Xn = nn = null,
        Pd = !1,
        Hh = Fy = 0,
        Rd = null
    }
    function $i() {
        var l = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Vr === null ? nn.memoizedState = Vr = l : Vr = Vr.next = l,
        Vr
    }
    function Lr() {
        if (Xn === null) {
            var l = nn.alternate;
            l = l !== null ? l.memoizedState : null
        } else
            l = Xn.next;
        var d = Vr === null ? nn.memoizedState : Vr.next;
        if (d !== null)
            Vr = d,
            Xn = l;
        else {
            if (l === null)
                throw nn.alternate === null ? Error(r(467)) : Error(r(310));
            Xn = l,
            l = {
                memoizedState: Xn.memoizedState,
                baseState: Xn.baseState,
                baseQueue: Xn.baseQueue,
                queue: Xn.queue,
                next: null
            },
            Vr === null ? nn.memoizedState = Vr = l : Vr = Vr.next = l
        }
        return Vr
    }
    function Ny() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        }
    }
    function qh(l) {
        var d = Hh;
        return Hh += 1,
        Rd === null && (Rd = []),
        l = uR(Rd, l, d),
        d = nn,
        (Vr === null ? d.memoizedState : Vr.next) === null && (d = d.alternate,
        j.H = d === null || d.memoizedState === null ? tD : CC),
        l
    }
    function Uy(l) {
        if (l !== null && typeof l == "object") {
            if (typeof l.then == "function")
                return qh(l);
            if (l.$$typeof === k)
                return fi(l)
        }
        throw Error(r(438, String(l)))
    }
    function dC(l) {
        var d = null
          , p = nn.updateQueue;
        if (p !== null && (d = p.memoCache),
        d == null) {
            var x = nn.alternate;
            x !== null && (x = x.updateQueue,
            x !== null && (x = x.memoCache,
            x != null && (d = {
                data: x.data.map(function(_) {
                    return _.slice()
                }),
                index: 0
            })))
        }
        if (d == null && (d = {
            data: [],
            index: 0
        }),
        p === null && (p = Ny(),
        nn.updateQueue = p),
        p.memoCache = d,
        p = d.data[d.index],
        p === void 0)
            for (p = d.data[d.index] = Array(l),
            x = 0; x < l; x++)
                p[x] = O;
        return d.index++,
        p
    }
    function Ys(l, d) {
        return typeof d == "function" ? d(l) : d
    }
    function Vy(l) {
        var d = Lr();
        return fC(d, Xn, l)
    }
    function fC(l, d, p) {
        var x = l.queue;
        if (x === null)
            throw Error(r(311));
        x.lastRenderedReducer = p;
        var _ = l.baseQueue
          , R = x.pending;
        if (R !== null) {
            if (_ !== null) {
                var G = _.next;
                _.next = R.next,
                R.next = G
            }
            d.baseQueue = _ = R,
            x.pending = null
        }
        if (R = l.baseState,
        _ === null)
            l.memoizedState = R;
        else {
            d = _.next;
            var Q = G = null
              , ae = null
              , Ee = d
              , Ue = !1;
            do {
                var We = Ee.lane & -536870913;
                if (We !== Ee.lane ? (vn & We) === We : (Gs & We) === We) {
                    var Pe = Ee.revertLane;
                    if (Pe === 0)
                        ae !== null && (ae = ae.next = {
                            lane: 0,
                            revertLane: 0,
                            gesture: null,
                            action: Ee.action,
                            hasEagerState: Ee.hasEagerState,
                            eagerState: Ee.eagerState,
                            next: null
                        }),
                        We === Td && (Ue = !0);
                    else if ((Gs & Pe) === Pe) {
                        Ee = Ee.next,
                        Pe === Td && (Ue = !0);
                        continue
                    } else
                        We = {
                            lane: 0,
                            revertLane: Ee.revertLane,
                            gesture: null,
                            action: Ee.action,
                            hasEagerState: Ee.hasEagerState,
                            eagerState: Ee.eagerState,
                            next: null
                        },
                        ae === null ? (Q = ae = We,
                        G = R) : ae = ae.next = We,
                        nn.lanes |= Pe,
                        Hl |= Pe;
                    We = Ee.action,
                    Xc && p(R, We),
                    R = Ee.hasEagerState ? Ee.eagerState : p(R, We)
                } else
                    Pe = {
                        lane: We,
                        revertLane: Ee.revertLane,
                        gesture: Ee.gesture,
                        action: Ee.action,
                        hasEagerState: Ee.hasEagerState,
                        eagerState: Ee.eagerState,
                        next: null
                    },
                    ae === null ? (Q = ae = Pe,
                    G = R) : ae = ae.next = Pe,
                    nn.lanes |= We,
                    Hl |= We;
                Ee = Ee.next
            } while (Ee !== null && Ee !== d);
            if (ae === null ? G = R : ae.next = Q,
            !Po(R, l.memoizedState) && (Hr = !0,
            Ue && (p = _d,
            p !== null)))
                throw p;
            l.memoizedState = R,
            l.baseState = G,
            l.baseQueue = ae,
            x.lastRenderedState = R
        }
        return _ === null && (x.lanes = 0),
        [l.memoizedState, x.dispatch]
    }
    function hC(l) {
        var d = Lr()
          , p = d.queue;
        if (p === null)
            throw Error(r(311));
        p.lastRenderedReducer = l;
        var x = p.dispatch
          , _ = p.pending
          , R = d.memoizedState;
        if (_ !== null) {
            p.pending = null;
            var G = _ = _.next;
            do
                R = l(R, G.action),
                G = G.next;
            while (G !== _);
            Po(R, d.memoizedState) || (Hr = !0),
            d.memoizedState = R,
            d.baseQueue === null && (d.baseState = R),
            p.lastRenderedState = R
        }
        return [R, x]
    }
    function SR(l, d, p) {
        var x = nn
          , _ = Lr()
          , R = Tn;
        if (R) {
            if (p === void 0)
                throw Error(r(407));
            p = p()
        } else
            p = d();
        var G = !Po((Xn || _).memoizedState, p);
        if (G && (_.memoizedState = p,
        Hr = !0),
        _ = _.queue,
        gC(kR.bind(null, x, _, l), [l]),
        _.getSnapshot !== d || G || Vr !== null && Vr.memoizedState.tag & 1) {
            if (x.flags |= 2048,
            Dd(9, {
                destroy: void 0
            }, wR.bind(null, x, _, p, d), null),
            rr === null)
                throw Error(r(349));
            R || (Gs & 127) !== 0 || CR(x, d, p)
        }
        return p
    }
    function CR(l, d, p) {
        l.flags |= 16384,
        l = {
            getSnapshot: d,
            value: p
        },
        d = nn.updateQueue,
        d === null ? (d = Ny(),
        nn.updateQueue = d,
        d.stores = [l]) : (p = d.stores,
        p === null ? d.stores = [l] : p.push(l))
    }
    function wR(l, d, p, x) {
        d.value = p,
        d.getSnapshot = x,
        TR(d) && _R(l)
    }
    function kR(l, d, p) {
        return p(function() {
            TR(d) && _R(l)
        })
    }
    function TR(l) {
        var d = l.getSnapshot;
        l = l.value;
        try {
            var p = d();
            return !Po(l, p)
        } catch {
            return !0
        }
    }
    function _R(l) {
        var d = Vc(l, 2);
        d !== null && oo(d, l, 2)
    }
    function pC(l) {
        var d = $i();
        if (typeof l == "function") {
            var p = l;
            if (l = p(),
            Xc) {
                nt(!0);
                try {
                    p()
                } finally {
                    nt(!1)
                }
            }
        }
        return d.memoizedState = d.baseState = l,
        d.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ys,
            lastRenderedState: l
        },
        d
    }
    function ER(l, d, p, x) {
        return l.baseState = p,
        fC(l, Xn, typeof x == "function" ? x : Ys)
    }
    function AY(l, d, p, x, _) {
        if (Wy(l))
            throw Error(r(485));
        if (l = d.action,
        l !== null) {
            var R = {
                payload: _,
                action: l,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(G) {
                    R.listeners.push(G)
                }
            };
            j.T !== null ? p(!0) : R.isTransition = !1,
            x(R),
            p = d.pending,
            p === null ? (R.next = d.pending = R,
            AR(d, R)) : (R.next = p.next,
            d.pending = p.next = R)
        }
    }
    function AR(l, d) {
        var p = d.action
          , x = d.payload
          , _ = l.state;
        if (d.isTransition) {
            var R = j.T
              , G = {};
            j.T = G;
            try {
                var Q = p(_, x)
                  , ae = j.S;
                ae !== null && ae(G, Q),
                MR(l, d, Q)
            } catch (Ee) {
                mC(l, d, Ee)
            } finally {
                R !== null && G.types !== null && (R.types = G.types),
                j.T = R
            }
        } else
            try {
                R = p(_, x),
                MR(l, d, R)
            } catch (Ee) {
                mC(l, d, Ee)
            }
    }
    function MR(l, d, p) {
        p !== null && typeof p == "object" && typeof p.then == "function" ? p.then(function(x) {
            PR(l, d, x)
        }, function(x) {
            return mC(l, d, x)
        }) : PR(l, d, p)
    }
    function PR(l, d, p) {
        d.status = "fulfilled",
        d.value = p,
        RR(d),
        l.state = p,
        d = l.pending,
        d !== null && (p = d.next,
        p === d ? l.pending = null : (p = p.next,
        d.next = p,
        AR(l, p)))
    }
    function mC(l, d, p) {
        var x = l.pending;
        if (l.pending = null,
        x !== null) {
            x = x.next;
            do
                d.status = "rejected",
                d.reason = p,
                RR(d),
                d = d.next;
            while (d !== x)
        }
        l.action = null
    }
    function RR(l) {
        l = l.listeners;
        for (var d = 0; d < l.length; d++)
            (0,
            l[d])()
    }
    function DR(l, d) {
        return d
    }
    function OR(l, d) {
        if (Tn) {
            var p = rr.formState;
            if (p !== null) {
                e: {
                    var x = nn;
                    if (Tn) {
                        if (lr) {
                            t: {
                                for (var _ = lr, R = oa; _.nodeType !== 8; ) {
                                    if (!R) {
                                        _ = null;
                                        break t
                                    }
                                    if (_ = sa(_.nextSibling),
                                    _ === null) {
                                        _ = null;
                                        break t
                                    }
                                }
                                R = _.data,
                                _ = R === "F!" || R === "F" ? _ : null
                            }
                            if (_) {
                                lr = sa(_.nextSibling),
                                x = _.data === "F!";
                                break e
                            }
                        }
                        $l(x)
                    }
                    x = !1
                }
                x && (d = p[0])
            }
        }
        return p = $i(),
        p.memoizedState = p.baseState = d,
        x = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: DR,
            lastRenderedState: d
        },
        p.queue = x,
        p = XR.bind(null, nn, x),
        x.dispatch = p,
        x = pC(!1),
        R = SC.bind(null, nn, !1, x.queue),
        x = $i(),
        _ = {
            state: d,
            dispatch: null,
            action: l,
            pending: null
        },
        x.queue = _,
        p = AY.bind(null, nn, _, R, p),
        _.dispatch = p,
        x.memoizedState = l,
        [d, p, !1]
    }
    function IR(l) {
        var d = Lr();
        return $R(d, Xn, l)
    }
    function $R(l, d, p) {
        if (d = fC(l, d, DR)[0],
        l = Vy(Ys)[0],
        typeof d == "object" && d !== null && typeof d.then == "function")
            try {
                var x = qh(d)
            } catch (G) {
                throw G === Ed ? Oy : G
            }
        else
            x = d;
        d = Lr();
        var _ = d.queue
          , R = _.dispatch;
        return p !== d.memoizedState && (nn.flags |= 2048,
        Dd(9, {
            destroy: void 0
        }, MY.bind(null, _, p), null)),
        [x, R, l]
    }
    function MY(l, d) {
        l.action = d
    }
    function LR(l) {
        var d = Lr()
          , p = Xn;
        if (p !== null)
            return $R(d, p, l);
        Lr(),
        d = d.memoizedState,
        p = Lr();
        var x = p.queue.dispatch;
        return p.memoizedState = l,
        [d, x, !1]
    }
    function Dd(l, d, p, x) {
        return l = {
            tag: l,
            create: p,
            deps: x,
            inst: d,
            next: null
        },
        d = nn.updateQueue,
        d === null && (d = Ny(),
        nn.updateQueue = d),
        p = d.lastEffect,
        p === null ? d.lastEffect = l.next = l : (x = p.next,
        p.next = l,
        l.next = x,
        d.lastEffect = l),
        l
    }
    function jR() {
        return Lr().memoizedState
    }
    function Hy(l, d, p, x) {
        var _ = $i();
        nn.flags |= l,
        _.memoizedState = Dd(1 | d, {
            destroy: void 0
        }, p, x === void 0 ? null : x)
    }
    function qy(l, d, p, x) {
        var _ = Lr();
        x = x === void 0 ? null : x;
        var R = _.memoizedState.inst;
        Xn !== null && x !== null && aC(x, Xn.memoizedState.deps) ? _.memoizedState = Dd(d, R, p, x) : (nn.flags |= l,
        _.memoizedState = Dd(1 | d, R, p, x))
    }
    function BR(l, d) {
        Hy(8390656, 8, l, d)
    }
    function gC(l, d) {
        qy(2048, 8, l, d)
    }
    function PY(l) {
        nn.flags |= 4;
        var d = nn.updateQueue;
        if (d === null)
            d = Ny(),
            nn.updateQueue = d,
            d.events = [l];
        else {
            var p = d.events;
            p === null ? d.events = [l] : p.push(l)
        }
    }
    function zR(l) {
        var d = Lr().memoizedState;
        return PY({
            ref: d,
            nextImpl: l
        }),
        function() {
            if ((Ln & 2) !== 0)
                throw Error(r(440));
            return d.impl.apply(void 0, arguments)
        }
    }
    function FR(l, d) {
        return qy(4, 2, l, d)
    }
    function NR(l, d) {
        return qy(4, 4, l, d)
    }
    function UR(l, d) {
        if (typeof d == "function") {
            l = l();
            var p = d(l);
            return function() {
                typeof p == "function" ? p() : d(null)
            }
        }
        if (d != null)
            return l = l(),
            d.current = l,
            function() {
                d.current = null
            }
    }
    function VR(l, d, p) {
        p = p != null ? p.concat([l]) : null,
        qy(4, 4, UR.bind(null, d, l), p)
    }
    function yC() {}
    function HR(l, d) {
        var p = Lr();
        d = d === void 0 ? null : d;
        var x = p.memoizedState;
        return d !== null && aC(d, x[1]) ? x[0] : (p.memoizedState = [l, d],
        l)
    }
    function qR(l, d) {
        var p = Lr();
        d = d === void 0 ? null : d;
        var x = p.memoizedState;
        if (d !== null && aC(d, x[1]))
            return x[0];
        if (x = l(),
        Xc) {
            nt(!0);
            try {
                l()
            } finally {
                nt(!1)
            }
        }
        return p.memoizedState = [x, d],
        x
    }
    function bC(l, d, p) {
        return p === void 0 || (Gs & 1073741824) !== 0 && (vn & 261930) === 0 ? l.memoizedState = d : (l.memoizedState = p,
        l = WD(),
        nn.lanes |= l,
        Hl |= l,
        p)
    }
    function WR(l, d, p, x) {
        return Po(p, d) ? p : Md.current !== null ? (l = bC(l, p, x),
        Po(l, d) || (Hr = !0),
        l) : (Gs & 42) === 0 || (Gs & 1073741824) !== 0 && (vn & 261930) === 0 ? (Hr = !0,
        l.memoizedState = p) : (l = WD(),
        nn.lanes |= l,
        Hl |= l,
        d)
    }
    function GR(l, d, p, x, _) {
        var R = N.p;
        N.p = R !== 0 && 8 > R ? R : 8;
        var G = j.T
          , Q = {};
        j.T = Q,
        SC(l, !1, d, p);
        try {
            var ae = _()
              , Ee = j.S;
            if (Ee !== null && Ee(Q, ae),
            ae !== null && typeof ae == "object" && typeof ae.then == "function") {
                var Ue = TY(ae, x);
                Wh(l, d, Ue, Lo(l))
            } else
                Wh(l, d, x, Lo(l))
        } catch (We) {
            Wh(l, d, {
                then: function() {},
                status: "rejected",
                reason: We
            }, Lo())
        } finally {
            N.p = R,
            G !== null && Q.types !== null && (G.types = Q.types),
            j.T = G
        }
    }
    function RY() {}
    function xC(l, d, p, x) {
        if (l.tag !== 5)
            throw Error(r(476));
        var _ = YR(l).queue;
        GR(l, _, d, H, p === null ? RY : function() {
            return ZR(l),
            p(x)
        }
        )
    }
    function YR(l) {
        var d = l.memoizedState;
        if (d !== null)
            return d;
        d = {
            memoizedState: H,
            baseState: H,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ys,
                lastRenderedState: H
            },
            next: null
        };
        var p = {};
        return d.next = {
            memoizedState: p,
            baseState: p,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Ys,
                lastRenderedState: p
            },
            next: null
        },
        l.memoizedState = d,
        l = l.alternate,
        l !== null && (l.memoizedState = d),
        d
    }
    function ZR(l) {
        var d = YR(l);
        d.next === null && (d = l.alternate.memoizedState),
        Wh(l, d.next.queue, {}, Lo())
    }
    function vC() {
        return fi(cp)
    }
    function QR() {
        return Lr().memoizedState
    }
    function KR() {
        return Lr().memoizedState
    }
    function DY(l) {
        for (var d = l.return; d !== null; ) {
            switch (d.tag) {
            case 24:
            case 3:
                var p = Lo();
                l = Bl(p);
                var x = zl(d, l, p);
                x !== null && (oo(x, d, p),
                Nh(x, d, p)),
                d = {
                    cache: ZS()
                },
                l.payload = d;
                return
            }
            d = d.return
        }
    }
    function OY(l, d, p) {
        var x = Lo();
        p = {
            lane: x,
            revertLane: 0,
            gesture: null,
            action: p,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Wy(l) ? JR(d, p) : (p = BS(l, d, p, x),
        p !== null && (oo(p, l, x),
        eD(p, d, x)))
    }
    function XR(l, d, p) {
        var x = Lo();
        Wh(l, d, p, x)
    }
    function Wh(l, d, p, x) {
        var _ = {
            lane: x,
            revertLane: 0,
            gesture: null,
            action: p,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Wy(l))
            JR(d, _);
        else {
            var R = l.alternate;
            if (l.lanes === 0 && (R === null || R.lanes === 0) && (R = d.lastRenderedReducer,
            R !== null))
                try {
                    var G = d.lastRenderedState
                      , Q = R(G, p);
                    if (_.hasEagerState = !0,
                    _.eagerState = Q,
                    Po(Q, G))
                        return _y(l, d, _, 0),
                        rr === null && Ty(),
                        !1
                } catch {} finally {}
            if (p = BS(l, d, _, x),
            p !== null)
                return oo(p, l, x),
                eD(p, d, x),
                !0
        }
        return !1
    }
    function SC(l, d, p, x) {
        if (x = {
            lane: 2,
            revertLane: JC(),
            gesture: null,
            action: x,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Wy(l)) {
            if (d)
                throw Error(r(479))
        } else
            d = BS(l, p, x, 2),
            d !== null && oo(d, l, 2)
    }
    function Wy(l) {
        var d = l.alternate;
        return l === nn || d !== null && d === nn
    }
    function JR(l, d) {
        Pd = zy = !0;
        var p = l.pending;
        p === null ? d.next = d : (d.next = p.next,
        p.next = d),
        l.pending = d
    }
    function eD(l, d, p) {
        if ((p & 4194048) !== 0) {
            var x = d.lanes;
            x &= l.pendingLanes,
            p |= x,
            d.lanes = p,
            Je(l, p)
        }
    }
    var Gh = {
        readContext: fi,
        use: Uy,
        useCallback: Er,
        useContext: Er,
        useEffect: Er,
        useImperativeHandle: Er,
        useLayoutEffect: Er,
        useInsertionEffect: Er,
        useMemo: Er,
        useReducer: Er,
        useRef: Er,
        useState: Er,
        useDebugValue: Er,
        useDeferredValue: Er,
        useTransition: Er,
        useSyncExternalStore: Er,
        useId: Er,
        useHostTransitionStatus: Er,
        useFormState: Er,
        useActionState: Er,
        useOptimistic: Er,
        useMemoCache: Er,
        useCacheRefresh: Er
    };
    Gh.useEffectEvent = Er;
    var tD = {
        readContext: fi,
        use: Uy,
        useCallback: function(l, d) {
            return $i().memoizedState = [l, d === void 0 ? null : d],
            l
        },
        useContext: fi,
        useEffect: BR,
        useImperativeHandle: function(l, d, p) {
            p = p != null ? p.concat([l]) : null,
            Hy(4194308, 4, UR.bind(null, d, l), p)
        },
        useLayoutEffect: function(l, d) {
            return Hy(4194308, 4, l, d)
        },
        useInsertionEffect: function(l, d) {
            Hy(4, 2, l, d)
        },
        useMemo: function(l, d) {
            var p = $i();
            d = d === void 0 ? null : d;
            var x = l();
            if (Xc) {
                nt(!0);
                try {
                    l()
                } finally {
                    nt(!1)
                }
            }
            return p.memoizedState = [x, d],
            x
        },
        useReducer: function(l, d, p) {
            var x = $i();
            if (p !== void 0) {
                var _ = p(d);
                if (Xc) {
                    nt(!0);
                    try {
                        p(d)
                    } finally {
                        nt(!1)
                    }
                }
            } else
                _ = d;
            return x.memoizedState = x.baseState = _,
            l = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: l,
                lastRenderedState: _
            },
            x.queue = l,
            l = l.dispatch = OY.bind(null, nn, l),
            [x.memoizedState, l]
        },
        useRef: function(l) {
            var d = $i();
            return l = {
                current: l
            },
            d.memoizedState = l
        },
        useState: function(l) {
            l = pC(l);
            var d = l.queue
              , p = XR.bind(null, nn, d);
            return d.dispatch = p,
            [l.memoizedState, p]
        },
        useDebugValue: yC,
        useDeferredValue: function(l, d) {
            var p = $i();
            return bC(p, l, d)
        },
        useTransition: function() {
            var l = pC(!1);
            return l = GR.bind(null, nn, l.queue, !0, !1),
            $i().memoizedState = l,
            [!1, l]
        },
        useSyncExternalStore: function(l, d, p) {
            var x = nn
              , _ = $i();
            if (Tn) {
                if (p === void 0)
                    throw Error(r(407));
                p = p()
            } else {
                if (p = d(),
                rr === null)
                    throw Error(r(349));
                (vn & 127) !== 0 || CR(x, d, p)
            }
            _.memoizedState = p;
            var R = {
                value: p,
                getSnapshot: d
            };
            return _.queue = R,
            BR(kR.bind(null, x, R, l), [l]),
            x.flags |= 2048,
            Dd(9, {
                destroy: void 0
            }, wR.bind(null, x, R, p, d), null),
            p
        },
        useId: function() {
            var l = $i()
              , d = rr.identifierPrefix;
            if (Tn) {
                var p = ss
                  , x = as;
                p = (x & ~(1 << 32 - ut(x) - 1)).toString(32) + p,
                d = "_" + d + "R_" + p,
                p = Fy++,
                0 < p && (d += "H" + p.toString(32)),
                d += "_"
            } else
                p = _Y++,
                d = "_" + d + "r_" + p.toString(32) + "_";
            return l.memoizedState = d
        },
        useHostTransitionStatus: vC,
        useFormState: OR,
        useActionState: OR,
        useOptimistic: function(l) {
            var d = $i();
            d.memoizedState = d.baseState = l;
            var p = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            return d.queue = p,
            d = SC.bind(null, nn, !0, p),
            p.dispatch = d,
            [l, d]
        },
        useMemoCache: dC,
        useCacheRefresh: function() {
            return $i().memoizedState = DY.bind(null, nn)
        },
        useEffectEvent: function(l) {
            var d = $i()
              , p = {
                impl: l
            };
            return d.memoizedState = p,
            function() {
                if ((Ln & 2) !== 0)
                    throw Error(r(440));
                return p.impl.apply(void 0, arguments)
            }
        }
    }
      , CC = {
        readContext: fi,
        use: Uy,
        useCallback: HR,
        useContext: fi,
        useEffect: gC,
        useImperativeHandle: VR,
        useInsertionEffect: FR,
        useLayoutEffect: NR,
        useMemo: qR,
        useReducer: Vy,
        useRef: jR,
        useState: function() {
            return Vy(Ys)
        },
        useDebugValue: yC,
        useDeferredValue: function(l, d) {
            var p = Lr();
            return WR(p, Xn.memoizedState, l, d)
        },
        useTransition: function() {
            var l = Vy(Ys)[0]
              , d = Lr().memoizedState;
            return [typeof l == "boolean" ? l : qh(l), d]
        },
        useSyncExternalStore: SR,
        useId: QR,
        useHostTransitionStatus: vC,
        useFormState: IR,
        useActionState: IR,
        useOptimistic: function(l, d) {
            var p = Lr();
            return ER(p, Xn, l, d)
        },
        useMemoCache: dC,
        useCacheRefresh: KR
    };
    CC.useEffectEvent = zR;
    var nD = {
        readContext: fi,
        use: Uy,
        useCallback: HR,
        useContext: fi,
        useEffect: gC,
        useImperativeHandle: VR,
        useInsertionEffect: FR,
        useLayoutEffect: NR,
        useMemo: qR,
        useReducer: hC,
        useRef: jR,
        useState: function() {
            return hC(Ys)
        },
        useDebugValue: yC,
        useDeferredValue: function(l, d) {
            var p = Lr();
            return Xn === null ? bC(p, l, d) : WR(p, Xn.memoizedState, l, d)
        },
        useTransition: function() {
            var l = hC(Ys)[0]
              , d = Lr().memoizedState;
            return [typeof l == "boolean" ? l : qh(l), d]
        },
        useSyncExternalStore: SR,
        useId: QR,
        useHostTransitionStatus: vC,
        useFormState: LR,
        useActionState: LR,
        useOptimistic: function(l, d) {
            var p = Lr();
            return Xn !== null ? ER(p, Xn, l, d) : (p.baseState = l,
            [l, p.queue.dispatch])
        },
        useMemoCache: dC,
        useCacheRefresh: KR
    };
    nD.useEffectEvent = zR;
    function wC(l, d, p, x) {
        d = l.memoizedState,
        p = p(x, d),
        p = p == null ? d : h({}, d, p),
        l.memoizedState = p,
        l.lanes === 0 && (l.updateQueue.baseState = p)
    }
    var kC = {
        enqueueSetState: function(l, d, p) {
            l = l._reactInternals;
            var x = Lo()
              , _ = Bl(x);
            _.payload = d,
            p != null && (_.callback = p),
            d = zl(l, _, x),
            d !== null && (oo(d, l, x),
            Nh(d, l, x))
        },
        enqueueReplaceState: function(l, d, p) {
            l = l._reactInternals;
            var x = Lo()
              , _ = Bl(x);
            _.tag = 1,
            _.payload = d,
            p != null && (_.callback = p),
            d = zl(l, _, x),
            d !== null && (oo(d, l, x),
            Nh(d, l, x))
        },
        enqueueForceUpdate: function(l, d) {
            l = l._reactInternals;
            var p = Lo()
              , x = Bl(p);
            x.tag = 2,
            d != null && (x.callback = d),
            d = zl(l, x, p),
            d !== null && (oo(d, l, p),
            Nh(d, l, p))
        }
    };
    function rD(l, d, p, x, _, R, G) {
        return l = l.stateNode,
        typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(x, R, G) : d.prototype && d.prototype.isPureReactComponent ? !Oh(p, x) || !Oh(_, R) : !0
    }
    function iD(l, d, p, x) {
        l = d.state,
        typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(p, x),
        typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(p, x),
        d.state !== l && kC.enqueueReplaceState(d, d.state, null)
    }
    function Jc(l, d) {
        var p = d;
        if ("ref"in d) {
            p = {};
            for (var x in d)
                x !== "ref" && (p[x] = d[x])
        }
        if (l = l.defaultProps) {
            p === d && (p = h({}, p));
            for (var _ in l)
                p[_] === void 0 && (p[_] = l[_])
        }
        return p
    }
    function oD(l) {
        ky(l)
    }
    function aD(l) {
        console.error(l)
    }
    function sD(l) {
        ky(l)
    }
    function Gy(l, d) {
        try {
            var p = l.onUncaughtError;
            p(d.value, {
                componentStack: d.stack
            })
        } catch (x) {
            setTimeout(function() {
                throw x
            })
        }
    }
    function lD(l, d, p) {
        try {
            var x = l.onCaughtError;
            x(p.value, {
                componentStack: p.stack,
                errorBoundary: d.tag === 1 ? d.stateNode : null
            })
        } catch (_) {
            setTimeout(function() {
                throw _
            })
        }
    }
    function TC(l, d, p) {
        return p = Bl(p),
        p.tag = 3,
        p.payload = {
            element: null
        },
        p.callback = function() {
            Gy(l, d)
        }
        ,
        p
    }
    function cD(l) {
        return l = Bl(l),
        l.tag = 3,
        l
    }
    function uD(l, d, p, x) {
        var _ = p.type.getDerivedStateFromError;
        if (typeof _ == "function") {
            var R = x.value;
            l.payload = function() {
                return _(R)
            }
            ,
            l.callback = function() {
                lD(d, p, x)
            }
        }
        var G = p.stateNode;
        G !== null && typeof G.componentDidCatch == "function" && (l.callback = function() {
            lD(d, p, x),
            typeof _ != "function" && (ql === null ? ql = new Set([this]) : ql.add(this));
            var Q = x.stack;
            this.componentDidCatch(x.value, {
                componentStack: Q !== null ? Q : ""
            })
        }
        )
    }
    function IY(l, d, p, x, _) {
        if (p.flags |= 32768,
        x !== null && typeof x == "object" && typeof x.then == "function") {
            if (d = p.alternate,
            d !== null && kd(d, p, _, !0),
            p = Do.current,
            p !== null) {
                switch (p.tag) {
                case 31:
                case 13:
                    return aa === null ? ob() : p.alternate === null && Ar === 0 && (Ar = 3),
                    p.flags &= -257,
                    p.flags |= 65536,
                    p.lanes = _,
                    x === Iy ? p.flags |= 16384 : (d = p.updateQueue,
                    d === null ? p.updateQueue = new Set([x]) : d.add(x),
                    QC(l, x, _)),
                    !1;
                case 22:
                    return p.flags |= 65536,
                    x === Iy ? p.flags |= 16384 : (d = p.updateQueue,
                    d === null ? (d = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([x])
                    },
                    p.updateQueue = d) : (p = d.retryQueue,
                    p === null ? d.retryQueue = new Set([x]) : p.add(x)),
                    QC(l, x, _)),
                    !1
                }
                throw Error(r(435, p.tag))
            }
            return QC(l, x, _),
            ob(),
            !1
        }
        if (Tn)
            return d = Do.current,
            d !== null ? ((d.flags & 65536) === 0 && (d.flags |= 256),
            d.flags |= 65536,
            d.lanes = _,
            x !== HS && (l = Error(r(422), {
                cause: x
            }),
            Lh(na(l, p)))) : (x !== HS && (d = Error(r(423), {
                cause: x
            }),
            Lh(na(d, p))),
            l = l.current.alternate,
            l.flags |= 65536,
            _ &= -_,
            l.lanes |= _,
            x = na(x, p),
            _ = TC(l.stateNode, x, _),
            tC(l, _),
            Ar !== 4 && (Ar = 2)),
            !1;
        var R = Error(r(520), {
            cause: x
        });
        if (R = na(R, p),
        tp === null ? tp = [R] : tp.push(R),
        Ar !== 4 && (Ar = 2),
        d === null)
            return !0;
        x = na(x, p),
        p = d;
        do {
            switch (p.tag) {
            case 3:
                return p.flags |= 65536,
                l = _ & -_,
                p.lanes |= l,
                l = TC(p.stateNode, x, l),
                tC(p, l),
                !1;
            case 1:
                if (d = p.type,
                R = p.stateNode,
                (p.flags & 128) === 0 && (typeof d.getDerivedStateFromError == "function" || R !== null && typeof R.componentDidCatch == "function" && (ql === null || !ql.has(R))))
                    return p.flags |= 65536,
                    _ &= -_,
                    p.lanes |= _,
                    _ = cD(_),
                    uD(_, l, p, x),
                    tC(p, _),
                    !1
            }
            p = p.return
        } while (p !== null);
        return !1
    }
    var _C = Error(r(461))
      , Hr = !1;
    function hi(l, d, p, x) {
        d.child = l === null ? pR(d, null, p, x) : Kc(d, l.child, p, x)
    }
    function dD(l, d, p, x, _) {
        p = p.render;
        var R = d.ref;
        if ("ref"in x) {
            var G = {};
            for (var Q in x)
                Q !== "ref" && (G[Q] = x[Q])
        } else
            G = x;
        return Gc(d),
        x = sC(l, d, p, G, R, _),
        Q = lC(),
        l !== null && !Hr ? (cC(l, d, _),
        Zs(l, d, _)) : (Tn && Q && US(d),
        d.flags |= 1,
        hi(l, d, x, _),
        d.child)
    }
    function fD(l, d, p, x, _) {
        if (l === null) {
            var R = p.type;
            return typeof R == "function" && !zS(R) && R.defaultProps === void 0 && p.compare === null ? (d.tag = 15,
            d.type = R,
            hD(l, d, R, x, _)) : (l = Ay(p.type, null, x, d, d.mode, _),
            l.ref = d.ref,
            l.return = d,
            d.child = l)
        }
        if (R = l.child,
        !IC(l, _)) {
            var G = R.memoizedProps;
            if (p = p.compare,
            p = p !== null ? p : Oh,
            p(G, x) && l.ref === d.ref)
                return Zs(l, d, _)
        }
        return d.flags |= 1,
        l = Vs(R, x),
        l.ref = d.ref,
        l.return = d,
        d.child = l
    }
    function hD(l, d, p, x, _) {
        if (l !== null) {
            var R = l.memoizedProps;
            if (Oh(R, x) && l.ref === d.ref)
                if (Hr = !1,
                d.pendingProps = x = R,
                IC(l, _))
                    (l.flags & 131072) !== 0 && (Hr = !0);
                else
                    return d.lanes = l.lanes,
                    Zs(l, d, _)
        }
        return EC(l, d, p, x, _)
    }
    function pD(l, d, p, x) {
        var _ = x.children
          , R = l !== null ? l.memoizedState : null;
        if (l === null && d.stateNode === null && (d.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        }),
        x.mode === "hidden") {
            if ((d.flags & 128) !== 0) {
                if (R = R !== null ? R.baseLanes | p : p,
                l !== null) {
                    for (x = d.child = l.child,
                    _ = 0; x !== null; )
                        _ = _ | x.lanes | x.childLanes,
                        x = x.sibling;
                    x = _ & ~R
                } else
                    x = 0,
                    d.child = null;
                return mD(l, d, R, p, x)
            }
            if ((p & 536870912) !== 0)
                d.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                l !== null && Dy(d, R !== null ? R.cachePool : null),
                R !== null ? yR(d, R) : rC(),
                bR(d);
            else
                return x = d.lanes = 536870912,
                mD(l, d, R !== null ? R.baseLanes | p : p, p, x)
        } else
            R !== null ? (Dy(d, R.cachePool),
            yR(d, R),
            Nl(),
            d.memoizedState = null) : (l !== null && Dy(d, null),
            rC(),
            Nl());
        return hi(l, d, _, p),
        d.child
    }
    function Yh(l, d) {
        return l !== null && l.tag === 22 || d.stateNode !== null || (d.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        }),
        d.sibling
    }
    function mD(l, d, p, x, _) {
        var R = KS();
        return R = R === null ? null : {
            parent: Ur._currentValue,
            pool: R
        },
        d.memoizedState = {
            baseLanes: p,
            cachePool: R
        },
        l !== null && Dy(d, null),
        rC(),
        bR(d),
        l !== null && kd(l, d, x, !0),
        d.childLanes = _,
        null
    }
    function Yy(l, d) {
        return d = Qy({
            mode: d.mode,
            children: d.children
        }, l.mode),
        d.ref = l.ref,
        l.child = d,
        d.return = l,
        d
    }
    function gD(l, d, p) {
        return Kc(d, l.child, null, p),
        l = Yy(d, d.pendingProps),
        l.flags |= 2,
        Oo(d),
        d.memoizedState = null,
        l
    }
    function $Y(l, d, p) {
        var x = d.pendingProps
          , _ = (d.flags & 128) !== 0;
        if (d.flags &= -129,
        l === null) {
            if (Tn) {
                if (x.mode === "hidden")
                    return l = Yy(d, x),
                    d.lanes = 536870912,
                    Yh(null, l);
                if (oC(d),
                (l = lr) ? (l = AO(l, oa),
                l = l !== null && l.data === "&" ? l : null,
                l !== null && (d.memoizedState = {
                    dehydrated: l,
                    treeContext: Ol !== null ? {
                        id: as,
                        overflow: ss
                    } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                },
                p = JP(l),
                p.return = d,
                d.child = p,
                di = d,
                lr = null)) : l = null,
                l === null)
                    throw $l(d);
                return d.lanes = 536870912,
                null
            }
            return Yy(d, x)
        }
        var R = l.memoizedState;
        if (R !== null) {
            var G = R.dehydrated;
            if (oC(d),
            _)
                if (d.flags & 256)
                    d.flags &= -257,
                    d = gD(l, d, p);
                else if (d.memoizedState !== null)
                    d.child = l.child,
                    d.flags |= 128,
                    d = null;
                else
                    throw Error(r(558));
            else if (Hr || kd(l, d, p, !1),
            _ = (p & l.childLanes) !== 0,
            Hr || _) {
                if (x = rr,
                x !== null && (G = Jt(x, p),
                G !== 0 && G !== R.retryLane))
                    throw R.retryLane = G,
                    Vc(l, G),
                    oo(x, l, G),
                    _C;
                ob(),
                d = gD(l, d, p)
            } else
                l = R.treeContext,
                lr = sa(G.nextSibling),
                di = d,
                Tn = !0,
                Il = null,
                oa = !1,
                l !== null && nR(d, l),
                d = Yy(d, x),
                d.flags |= 4096;
            return d
        }
        return l = Vs(l.child, {
            mode: x.mode,
            children: x.children
        }),
        l.ref = d.ref,
        d.child = l,
        l.return = d,
        l
    }
    function Zy(l, d) {
        var p = d.ref;
        if (p === null)
            l !== null && l.ref !== null && (d.flags |= 4194816);
        else {
            if (typeof p != "function" && typeof p != "object")
                throw Error(r(284));
            (l === null || l.ref !== p) && (d.flags |= 4194816)
        }
    }
    function EC(l, d, p, x, _) {
        return Gc(d),
        p = sC(l, d, p, x, void 0, _),
        x = lC(),
        l !== null && !Hr ? (cC(l, d, _),
        Zs(l, d, _)) : (Tn && x && US(d),
        d.flags |= 1,
        hi(l, d, p, _),
        d.child)
    }
    function yD(l, d, p, x, _, R) {
        return Gc(d),
        d.updateQueue = null,
        p = vR(d, x, p, _),
        xR(l),
        x = lC(),
        l !== null && !Hr ? (cC(l, d, R),
        Zs(l, d, R)) : (Tn && x && US(d),
        d.flags |= 1,
        hi(l, d, p, R),
        d.child)
    }
    function bD(l, d, p, x, _) {
        if (Gc(d),
        d.stateNode === null) {
            var R = vd
              , G = p.contextType;
            typeof G == "object" && G !== null && (R = fi(G)),
            R = new p(x,R),
            d.memoizedState = R.state !== null && R.state !== void 0 ? R.state : null,
            R.updater = kC,
            d.stateNode = R,
            R._reactInternals = d,
            R = d.stateNode,
            R.props = x,
            R.state = d.memoizedState,
            R.refs = {},
            JS(d),
            G = p.contextType,
            R.context = typeof G == "object" && G !== null ? fi(G) : vd,
            R.state = d.memoizedState,
            G = p.getDerivedStateFromProps,
            typeof G == "function" && (wC(d, p, G, x),
            R.state = d.memoizedState),
            typeof p.getDerivedStateFromProps == "function" || typeof R.getSnapshotBeforeUpdate == "function" || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (G = R.state,
            typeof R.componentWillMount == "function" && R.componentWillMount(),
            typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount(),
            G !== R.state && kC.enqueueReplaceState(R, R.state, null),
            Vh(d, x, R, _),
            Uh(),
            R.state = d.memoizedState),
            typeof R.componentDidMount == "function" && (d.flags |= 4194308),
            x = !0
        } else if (l === null) {
            R = d.stateNode;
            var Q = d.memoizedProps
              , ae = Jc(p, Q);
            R.props = ae;
            var Ee = R.context
              , Ue = p.contextType;
            G = vd,
            typeof Ue == "object" && Ue !== null && (G = fi(Ue));
            var We = p.getDerivedStateFromProps;
            Ue = typeof We == "function" || typeof R.getSnapshotBeforeUpdate == "function",
            Q = d.pendingProps !== Q,
            Ue || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (Q || Ee !== G) && iD(d, R, x, G),
            jl = !1;
            var Pe = d.memoizedState;
            R.state = Pe,
            Vh(d, x, R, _),
            Uh(),
            Ee = d.memoizedState,
            Q || Pe !== Ee || jl ? (typeof We == "function" && (wC(d, p, We, x),
            Ee = d.memoizedState),
            (ae = jl || rD(d, p, ae, x, Pe, Ee, G)) ? (Ue || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (typeof R.componentWillMount == "function" && R.componentWillMount(),
            typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()),
            typeof R.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof R.componentDidMount == "function" && (d.flags |= 4194308),
            d.memoizedProps = x,
            d.memoizedState = Ee),
            R.props = x,
            R.state = Ee,
            R.context = G,
            x = ae) : (typeof R.componentDidMount == "function" && (d.flags |= 4194308),
            x = !1)
        } else {
            R = d.stateNode,
            eC(l, d),
            G = d.memoizedProps,
            Ue = Jc(p, G),
            R.props = Ue,
            We = d.pendingProps,
            Pe = R.context,
            Ee = p.contextType,
            ae = vd,
            typeof Ee == "object" && Ee !== null && (ae = fi(Ee)),
            Q = p.getDerivedStateFromProps,
            (Ee = typeof Q == "function" || typeof R.getSnapshotBeforeUpdate == "function") || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (G !== We || Pe !== ae) && iD(d, R, x, ae),
            jl = !1,
            Pe = d.memoizedState,
            R.state = Pe,
            Vh(d, x, R, _),
            Uh();
            var $e = d.memoizedState;
            G !== We || Pe !== $e || jl || l !== null && l.dependencies !== null && Py(l.dependencies) ? (typeof Q == "function" && (wC(d, p, Q, x),
            $e = d.memoizedState),
            (Ue = jl || rD(d, p, Ue, x, Pe, $e, ae) || l !== null && l.dependencies !== null && Py(l.dependencies)) ? (Ee || typeof R.UNSAFE_componentWillUpdate != "function" && typeof R.componentWillUpdate != "function" || (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(x, $e, ae),
            typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(x, $e, ae)),
            typeof R.componentDidUpdate == "function" && (d.flags |= 4),
            typeof R.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof R.componentDidUpdate != "function" || G === l.memoizedProps && Pe === l.memoizedState || (d.flags |= 4),
            typeof R.getSnapshotBeforeUpdate != "function" || G === l.memoizedProps && Pe === l.memoizedState || (d.flags |= 1024),
            d.memoizedProps = x,
            d.memoizedState = $e),
            R.props = x,
            R.state = $e,
            R.context = ae,
            x = Ue) : (typeof R.componentDidUpdate != "function" || G === l.memoizedProps && Pe === l.memoizedState || (d.flags |= 4),
            typeof R.getSnapshotBeforeUpdate != "function" || G === l.memoizedProps && Pe === l.memoizedState || (d.flags |= 1024),
            x = !1)
        }
        return R = x,
        Zy(l, d),
        x = (d.flags & 128) !== 0,
        R || x ? (R = d.stateNode,
        p = x && typeof p.getDerivedStateFromError != "function" ? null : R.render(),
        d.flags |= 1,
        l !== null && x ? (d.child = Kc(d, l.child, null, _),
        d.child = Kc(d, null, p, _)) : hi(l, d, p, _),
        d.memoizedState = R.state,
        l = d.child) : l = Zs(l, d, _),
        l
    }
    function xD(l, d, p, x) {
        return qc(),
        d.flags |= 256,
        hi(l, d, p, x),
        d.child
    }
    var AC = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
    };
    function MC(l) {
        return {
            baseLanes: l,
            cachePool: lR()
        }
    }
    function PC(l, d, p) {
        return l = l !== null ? l.childLanes & ~p : 0,
        d && (l |= $o),
        l
    }
    function vD(l, d, p) {
        var x = d.pendingProps, _ = !1, R = (d.flags & 128) !== 0, G;
        if ((G = R) || (G = l !== null && l.memoizedState === null ? !1 : ($r.current & 2) !== 0),
        G && (_ = !0,
        d.flags &= -129),
        G = (d.flags & 32) !== 0,
        d.flags &= -33,
        l === null) {
            if (Tn) {
                if (_ ? Fl(d) : Nl(),
                (l = lr) ? (l = AO(l, oa),
                l = l !== null && l.data !== "&" ? l : null,
                l !== null && (d.memoizedState = {
                    dehydrated: l,
                    treeContext: Ol !== null ? {
                        id: as,
                        overflow: ss
                    } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                },
                p = JP(l),
                p.return = d,
                d.child = p,
                di = d,
                lr = null)) : l = null,
                l === null)
                    throw $l(d);
                return fw(l) ? d.lanes = 32 : d.lanes = 536870912,
                null
            }
            var Q = x.children;
            return x = x.fallback,
            _ ? (Nl(),
            _ = d.mode,
            Q = Qy({
                mode: "hidden",
                children: Q
            }, _),
            x = Hc(x, _, p, null),
            Q.return = d,
            x.return = d,
            Q.sibling = x,
            d.child = Q,
            x = d.child,
            x.memoizedState = MC(p),
            x.childLanes = PC(l, G, p),
            d.memoizedState = AC,
            Yh(null, x)) : (Fl(d),
            RC(d, Q))
        }
        var ae = l.memoizedState;
        if (ae !== null && (Q = ae.dehydrated,
        Q !== null)) {
            if (R)
                d.flags & 256 ? (Fl(d),
                d.flags &= -257,
                d = DC(l, d, p)) : d.memoizedState !== null ? (Nl(),
                d.child = l.child,
                d.flags |= 128,
                d = null) : (Nl(),
                Q = x.fallback,
                _ = d.mode,
                x = Qy({
                    mode: "visible",
                    children: x.children
                }, _),
                Q = Hc(Q, _, p, null),
                Q.flags |= 2,
                x.return = d,
                Q.return = d,
                x.sibling = Q,
                d.child = x,
                Kc(d, l.child, null, p),
                x = d.child,
                x.memoizedState = MC(p),
                x.childLanes = PC(l, G, p),
                d.memoizedState = AC,
                d = Yh(null, x));
            else if (Fl(d),
            fw(Q)) {
                if (G = Q.nextSibling && Q.nextSibling.dataset,
                G)
                    var Ee = G.dgst;
                G = Ee,
                x = Error(r(419)),
                x.stack = "",
                x.digest = G,
                Lh({
                    value: x,
                    source: null,
                    stack: null
                }),
                d = DC(l, d, p)
            } else if (Hr || kd(l, d, p, !1),
            G = (p & l.childLanes) !== 0,
            Hr || G) {
                if (G = rr,
                G !== null && (x = Jt(G, p),
                x !== 0 && x !== ae.retryLane))
                    throw ae.retryLane = x,
                    Vc(l, x),
                    oo(G, l, x),
                    _C;
                dw(Q) || ob(),
                d = DC(l, d, p)
            } else
                dw(Q) ? (d.flags |= 192,
                d.child = l.child,
                d = null) : (l = ae.treeContext,
                lr = sa(Q.nextSibling),
                di = d,
                Tn = !0,
                Il = null,
                oa = !1,
                l !== null && nR(d, l),
                d = RC(d, x.children),
                d.flags |= 4096);
            return d
        }
        return _ ? (Nl(),
        Q = x.fallback,
        _ = d.mode,
        ae = l.child,
        Ee = ae.sibling,
        x = Vs(ae, {
            mode: "hidden",
            children: x.children
        }),
        x.subtreeFlags = ae.subtreeFlags & 65011712,
        Ee !== null ? Q = Vs(Ee, Q) : (Q = Hc(Q, _, p, null),
        Q.flags |= 2),
        Q.return = d,
        x.return = d,
        x.sibling = Q,
        d.child = x,
        Yh(null, x),
        x = d.child,
        Q = l.child.memoizedState,
        Q === null ? Q = MC(p) : (_ = Q.cachePool,
        _ !== null ? (ae = Ur._currentValue,
        _ = _.parent !== ae ? {
            parent: ae,
            pool: ae
        } : _) : _ = lR(),
        Q = {
            baseLanes: Q.baseLanes | p,
            cachePool: _
        }),
        x.memoizedState = Q,
        x.childLanes = PC(l, G, p),
        d.memoizedState = AC,
        Yh(l.child, x)) : (Fl(d),
        p = l.child,
        l = p.sibling,
        p = Vs(p, {
            mode: "visible",
            children: x.children
        }),
        p.return = d,
        p.sibling = null,
        l !== null && (G = d.deletions,
        G === null ? (d.deletions = [l],
        d.flags |= 16) : G.push(l)),
        d.child = p,
        d.memoizedState = null,
        p)
    }
    function RC(l, d) {
        return d = Qy({
            mode: "visible",
            children: d
        }, l.mode),
        d.return = l,
        l.child = d
    }
    function Qy(l, d) {
        return l = Ro(22, l, null, d),
        l.lanes = 0,
        l
    }
    function DC(l, d, p) {
        return Kc(d, l.child, null, p),
        l = RC(d, d.pendingProps.children),
        l.flags |= 2,
        d.memoizedState = null,
        l
    }
    function SD(l, d, p) {
        l.lanes |= d;
        var x = l.alternate;
        x !== null && (x.lanes |= d),
        GS(l.return, d, p)
    }
    function OC(l, d, p, x, _, R) {
        var G = l.memoizedState;
        G === null ? l.memoizedState = {
            isBackwards: d,
            rendering: null,
            renderingStartTime: 0,
            last: x,
            tail: p,
            tailMode: _,
            treeForkCount: R
        } : (G.isBackwards = d,
        G.rendering = null,
        G.renderingStartTime = 0,
        G.last = x,
        G.tail = p,
        G.tailMode = _,
        G.treeForkCount = R)
    }
    function CD(l, d, p) {
        var x = d.pendingProps
          , _ = x.revealOrder
          , R = x.tail;
        x = x.children;
        var G = $r.current
          , Q = (G & 2) !== 0;
        if (Q ? (G = G & 1 | 2,
        d.flags |= 128) : G &= 1,
        W($r, G),
        hi(l, d, x, p),
        x = Tn ? $h : 0,
        !Q && l !== null && (l.flags & 128) !== 0)
            e: for (l = d.child; l !== null; ) {
                if (l.tag === 13)
                    l.memoizedState !== null && SD(l, p, d);
                else if (l.tag === 19)
                    SD(l, p, d);
                else if (l.child !== null) {
                    l.child.return = l,
                    l = l.child;
                    continue
                }
                if (l === d)
                    break e;
                for (; l.sibling === null; ) {
                    if (l.return === null || l.return === d)
                        break e;
                    l = l.return
                }
                l.sibling.return = l.return,
                l = l.sibling
            }
        switch (_) {
        case "forwards":
            for (p = d.child,
            _ = null; p !== null; )
                l = p.alternate,
                l !== null && By(l) === null && (_ = p),
                p = p.sibling;
            p = _,
            p === null ? (_ = d.child,
            d.child = null) : (_ = p.sibling,
            p.sibling = null),
            OC(d, !1, _, p, R, x);
            break;
        case "backwards":
        case "unstable_legacy-backwards":
            for (p = null,
            _ = d.child,
            d.child = null; _ !== null; ) {
                if (l = _.alternate,
                l !== null && By(l) === null) {
                    d.child = _;
                    break
                }
                l = _.sibling,
                _.sibling = p,
                p = _,
                _ = l
            }
            OC(d, !0, p, null, R, x);
            break;
        case "together":
            OC(d, !1, null, null, void 0, x);
            break;
        default:
            d.memoizedState = null
        }
        return d.child
    }
    function Zs(l, d, p) {
        if (l !== null && (d.dependencies = l.dependencies),
        Hl |= d.lanes,
        (p & d.childLanes) === 0)
            if (l !== null) {
                if (kd(l, d, p, !1),
                (p & d.childLanes) === 0)
                    return null
            } else
                return null;
        if (l !== null && d.child !== l.child)
            throw Error(r(153));
        if (d.child !== null) {
            for (l = d.child,
            p = Vs(l, l.pendingProps),
            d.child = p,
            p.return = d; l.sibling !== null; )
                l = l.sibling,
                p = p.sibling = Vs(l, l.pendingProps),
                p.return = d;
            p.sibling = null
        }
        return d.child
    }
    function IC(l, d) {
        return (l.lanes & d) !== 0 ? !0 : (l = l.dependencies,
        !!(l !== null && Py(l)))
    }
    function LY(l, d, p) {
        switch (d.tag) {
        case 3:
            ie(d, d.stateNode.containerInfo),
            Ll(d, Ur, l.memoizedState.cache),
            qc();
            break;
        case 27:
        case 5:
            oe(d);
            break;
        case 4:
            ie(d, d.stateNode.containerInfo);
            break;
        case 10:
            Ll(d, d.type, d.memoizedProps.value);
            break;
        case 31:
            if (d.memoizedState !== null)
                return d.flags |= 128,
                oC(d),
                null;
            break;
        case 13:
            var x = d.memoizedState;
            if (x !== null)
                return x.dehydrated !== null ? (Fl(d),
                d.flags |= 128,
                null) : (p & d.child.childLanes) !== 0 ? vD(l, d, p) : (Fl(d),
                l = Zs(l, d, p),
                l !== null ? l.sibling : null);
            Fl(d);
            break;
        case 19:
            var _ = (l.flags & 128) !== 0;
            if (x = (p & d.childLanes) !== 0,
            x || (kd(l, d, p, !1),
            x = (p & d.childLanes) !== 0),
            _) {
                if (x)
                    return CD(l, d, p);
                d.flags |= 128
            }
            if (_ = d.memoizedState,
            _ !== null && (_.rendering = null,
            _.tail = null,
            _.lastEffect = null),
            W($r, $r.current),
            x)
                break;
            return null;
        case 22:
            return d.lanes = 0,
            pD(l, d, p, d.pendingProps);
        case 24:
            Ll(d, Ur, l.memoizedState.cache)
        }
        return Zs(l, d, p)
    }
    function wD(l, d, p) {
        if (l !== null)
            if (l.memoizedProps !== d.pendingProps)
                Hr = !0;
            else {
                if (!IC(l, p) && (d.flags & 128) === 0)
                    return Hr = !1,
                    LY(l, d, p);
                Hr = (l.flags & 131072) !== 0
            }
        else
            Hr = !1,
            Tn && (d.flags & 1048576) !== 0 && tR(d, $h, d.index);
        switch (d.lanes = 0,
        d.tag) {
        case 16:
            e: {
                var x = d.pendingProps;
                if (l = Zc(d.elementType),
                d.type = l,
                typeof l == "function")
                    zS(l) ? (x = Jc(l, x),
                    d.tag = 1,
                    d = bD(null, d, l, x, p)) : (d.tag = 0,
                    d = EC(null, d, l, x, p));
                else {
                    if (l != null) {
                        var _ = l.$$typeof;
                        if (_ === T) {
                            d.tag = 11,
                            d = dD(null, d, l, x, p);
                            break e
                        } else if (_ === D) {
                            d.tag = 14,
                            d = fD(null, d, l, x, p);
                            break e
                        }
                    }
                    throw d = L(l) || l,
                    Error(r(306, d, ""))
                }
            }
            return d;
        case 0:
            return EC(l, d, d.type, d.pendingProps, p);
        case 1:
            return x = d.type,
            _ = Jc(x, d.pendingProps),
            bD(l, d, x, _, p);
        case 3:
            e: {
                if (ie(d, d.stateNode.containerInfo),
                l === null)
                    throw Error(r(387));
                x = d.pendingProps;
                var R = d.memoizedState;
                _ = R.element,
                eC(l, d),
                Vh(d, x, null, p);
                var G = d.memoizedState;
                if (x = G.cache,
                Ll(d, Ur, x),
                x !== R.cache && YS(d, [Ur], p, !0),
                Uh(),
                x = G.element,
                R.isDehydrated)
                    if (R = {
                        element: x,
                        isDehydrated: !1,
                        cache: G.cache
                    },
                    d.updateQueue.baseState = R,
                    d.memoizedState = R,
                    d.flags & 256) {
                        d = xD(l, d, x, p);
                        break e
                    } else if (x !== _) {
                        _ = na(Error(r(424)), d),
                        Lh(_),
                        d = xD(l, d, x, p);
                        break e
                    } else {
                        switch (l = d.stateNode.containerInfo,
                        l.nodeType) {
                        case 9:
                            l = l.body;
                            break;
                        default:
                            l = l.nodeName === "HTML" ? l.ownerDocument.body : l
                        }
                        for (lr = sa(l.firstChild),
                        di = d,
                        Tn = !0,
                        Il = null,
                        oa = !0,
                        p = pR(d, null, x, p),
                        d.child = p; p; )
                            p.flags = p.flags & -3 | 4096,
                            p = p.sibling
                    }
                else {
                    if (qc(),
                    x === _) {
                        d = Zs(l, d, p);
                        break e
                    }
                    hi(l, d, x, p)
                }
                d = d.child
            }
            return d;
        case 26:
            return Zy(l, d),
            l === null ? (p = IO(d.type, null, d.pendingProps, null)) ? d.memoizedState = p : Tn || (p = d.type,
            l = d.pendingProps,
            x = fb(ee.current).createElement(p),
            x[ln] = d,
            x[en] = l,
            pi(x, p, l),
            Nt(x),
            d.stateNode = x) : d.memoizedState = IO(d.type, l.memoizedProps, d.pendingProps, l.memoizedState),
            null;
        case 27:
            return oe(d),
            l === null && Tn && (x = d.stateNode = RO(d.type, d.pendingProps, ee.current),
            di = d,
            oa = !0,
            _ = lr,
            Zl(d.type) ? (hw = _,
            lr = sa(x.firstChild)) : lr = _),
            hi(l, d, d.pendingProps.children, p),
            Zy(l, d),
            l === null && (d.flags |= 4194304),
            d.child;
        case 5:
            return l === null && Tn && ((_ = x = lr) && (x = fZ(x, d.type, d.pendingProps, oa),
            x !== null ? (d.stateNode = x,
            di = d,
            lr = sa(x.firstChild),
            oa = !1,
            _ = !0) : _ = !1),
            _ || $l(d)),
            oe(d),
            _ = d.type,
            R = d.pendingProps,
            G = l !== null ? l.memoizedProps : null,
            x = R.children,
            lw(_, R) ? x = null : G !== null && lw(_, G) && (d.flags |= 32),
            d.memoizedState !== null && (_ = sC(l, d, EY, null, null, p),
            cp._currentValue = _),
            Zy(l, d),
            hi(l, d, x, p),
            d.child;
        case 6:
            return l === null && Tn && ((l = p = lr) && (p = hZ(p, d.pendingProps, oa),
            p !== null ? (d.stateNode = p,
            di = d,
            lr = null,
            l = !0) : l = !1),
            l || $l(d)),
            null;
        case 13:
            return vD(l, d, p);
        case 4:
            return ie(d, d.stateNode.containerInfo),
            x = d.pendingProps,
            l === null ? d.child = Kc(d, null, x, p) : hi(l, d, x, p),
            d.child;
        case 11:
            return dD(l, d, d.type, d.pendingProps, p);
        case 7:
            return hi(l, d, d.pendingProps, p),
            d.child;
        case 8:
            return hi(l, d, d.pendingProps.children, p),
            d.child;
        case 12:
            return hi(l, d, d.pendingProps.children, p),
            d.child;
        case 10:
            return x = d.pendingProps,
            Ll(d, d.type, x.value),
            hi(l, d, x.children, p),
            d.child;
        case 9:
            return _ = d.type._context,
            x = d.pendingProps.children,
            Gc(d),
            _ = fi(_),
            x = x(_),
            d.flags |= 1,
            hi(l, d, x, p),
            d.child;
        case 14:
            return fD(l, d, d.type, d.pendingProps, p);
        case 15:
            return hD(l, d, d.type, d.pendingProps, p);
        case 19:
            return CD(l, d, p);
        case 31:
            return $Y(l, d, p);
        case 22:
            return pD(l, d, p, d.pendingProps);
        case 24:
            return Gc(d),
            x = fi(Ur),
            l === null ? (_ = KS(),
            _ === null && (_ = rr,
            R = ZS(),
            _.pooledCache = R,
            R.refCount++,
            R !== null && (_.pooledCacheLanes |= p),
            _ = R),
            d.memoizedState = {
                parent: x,
                cache: _
            },
            JS(d),
            Ll(d, Ur, _)) : ((l.lanes & p) !== 0 && (eC(l, d),
            Vh(d, null, null, p),
            Uh()),
            _ = l.memoizedState,
            R = d.memoizedState,
            _.parent !== x ? (_ = {
                parent: x,
                cache: x
            },
            d.memoizedState = _,
            d.lanes === 0 && (d.memoizedState = d.updateQueue.baseState = _),
            Ll(d, Ur, x)) : (x = R.cache,
            Ll(d, Ur, x),
            x !== _.cache && YS(d, [Ur], p, !0))),
            hi(l, d, d.pendingProps.children, p),
            d.child;
        case 29:
            throw d.pendingProps
        }
        throw Error(r(156, d.tag))
    }
    function Qs(l) {
        l.flags |= 4
    }
    function $C(l, d, p, x, _) {
        if ((d = (l.mode & 32) !== 0) && (d = !1),
        d) {
            if (l.flags |= 16777216,
            (_ & 335544128) === _)
                if (l.stateNode.complete)
                    l.flags |= 8192;
                else if (QD())
                    l.flags |= 8192;
                else
                    throw Qc = Iy,
                    XS
        } else
            l.flags &= -16777217
    }
    function kD(l, d) {
        if (d.type !== "stylesheet" || (d.state.loading & 4) !== 0)
            l.flags &= -16777217;
        else if (l.flags |= 16777216,
        !zO(d))
            if (QD())
                l.flags |= 8192;
            else
                throw Qc = Iy,
                XS
    }
    function Ky(l, d) {
        d !== null && (l.flags |= 4),
        l.flags & 16384 && (d = l.tag !== 22 ? At() : 536870912,
        l.lanes |= d,
        Ld |= d)
    }
    function Zh(l, d) {
        if (!Tn)
            switch (l.tailMode) {
            case "hidden":
                d = l.tail;
                for (var p = null; d !== null; )
                    d.alternate !== null && (p = d),
                    d = d.sibling;
                p === null ? l.tail = null : p.sibling = null;
                break;
            case "collapsed":
                p = l.tail;
                for (var x = null; p !== null; )
                    p.alternate !== null && (x = p),
                    p = p.sibling;
                x === null ? d || l.tail === null ? l.tail = null : l.tail.sibling = null : x.sibling = null
            }
    }
    function cr(l) {
        var d = l.alternate !== null && l.alternate.child === l.child
          , p = 0
          , x = 0;
        if (d)
            for (var _ = l.child; _ !== null; )
                p |= _.lanes | _.childLanes,
                x |= _.subtreeFlags & 65011712,
                x |= _.flags & 65011712,
                _.return = l,
                _ = _.sibling;
        else
            for (_ = l.child; _ !== null; )
                p |= _.lanes | _.childLanes,
                x |= _.subtreeFlags,
                x |= _.flags,
                _.return = l,
                _ = _.sibling;
        return l.subtreeFlags |= x,
        l.childLanes = p,
        d
    }
    function jY(l, d, p) {
        var x = d.pendingProps;
        switch (VS(d),
        d.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return cr(d),
            null;
        case 1:
            return cr(d),
            null;
        case 3:
            return p = d.stateNode,
            x = null,
            l !== null && (x = l.memoizedState.cache),
            d.memoizedState.cache !== x && (d.flags |= 2048),
            Ws(Ur),
            J(),
            p.pendingContext && (p.context = p.pendingContext,
            p.pendingContext = null),
            (l === null || l.child === null) && (wd(d) ? Qs(d) : l === null || l.memoizedState.isDehydrated && (d.flags & 256) === 0 || (d.flags |= 1024,
            qS())),
            cr(d),
            null;
        case 26:
            var _ = d.type
              , R = d.memoizedState;
            return l === null ? (Qs(d),
            R !== null ? (cr(d),
            kD(d, R)) : (cr(d),
            $C(d, _, null, x, p))) : R ? R !== l.memoizedState ? (Qs(d),
            cr(d),
            kD(d, R)) : (cr(d),
            d.flags &= -16777217) : (l = l.memoizedProps,
            l !== x && Qs(d),
            cr(d),
            $C(d, _, l, x, p)),
            null;
        case 27:
            if (we(d),
            p = ee.current,
            _ = d.type,
            l !== null && d.stateNode != null)
                l.memoizedProps !== x && Qs(d);
            else {
                if (!x) {
                    if (d.stateNode === null)
                        throw Error(r(166));
                    return cr(d),
                    null
                }
                l = te.current,
                wd(d) ? rR(d) : (l = RO(_, x, p),
                d.stateNode = l,
                Qs(d))
            }
            return cr(d),
            null;
        case 5:
            if (we(d),
            _ = d.type,
            l !== null && d.stateNode != null)
                l.memoizedProps !== x && Qs(d);
            else {
                if (!x) {
                    if (d.stateNode === null)
                        throw Error(r(166));
                    return cr(d),
                    null
                }
                if (R = te.current,
                wd(d))
                    rR(d);
                else {
                    var G = fb(ee.current);
                    switch (R) {
                    case 1:
                        R = G.createElementNS("http://www.w3.org/2000/svg", _);
                        break;
                    case 2:
                        R = G.createElementNS("http://www.w3.org/1998/Math/MathML", _);
                        break;
                    default:
                        switch (_) {
                        case "svg":
                            R = G.createElementNS("http://www.w3.org/2000/svg", _);
                            break;
                        case "math":
                            R = G.createElementNS("http://www.w3.org/1998/Math/MathML", _);
                            break;
                        case "script":
                            R = G.createElement("div"),
                            R.innerHTML = "<script><\/script>",
                            R = R.removeChild(R.firstChild);
                            break;
                        case "select":
                            R = typeof x.is == "string" ? G.createElement("select", {
                                is: x.is
                            }) : G.createElement("select"),
                            x.multiple ? R.multiple = !0 : x.size && (R.size = x.size);
                            break;
                        default:
                            R = typeof x.is == "string" ? G.createElement(_, {
                                is: x.is
                            }) : G.createElement(_)
                        }
                    }
                    R[ln] = d,
                    R[en] = x;
                    e: for (G = d.child; G !== null; ) {
                        if (G.tag === 5 || G.tag === 6)
                            R.appendChild(G.stateNode);
                        else if (G.tag !== 4 && G.tag !== 27 && G.child !== null) {
                            G.child.return = G,
                            G = G.child;
                            continue
                        }
                        if (G === d)
                            break e;
                        for (; G.sibling === null; ) {
                            if (G.return === null || G.return === d)
                                break e;
                            G = G.return
                        }
                        G.sibling.return = G.return,
                        G = G.sibling
                    }
                    d.stateNode = R;
                    e: switch (pi(R, _, x),
                    _) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        x = !!x.autoFocus;
                        break e;
                    case "img":
                        x = !0;
                        break e;
                    default:
                        x = !1
                    }
                    x && Qs(d)
                }
            }
            return cr(d),
            $C(d, d.type, l === null ? null : l.memoizedProps, d.pendingProps, p),
            null;
        case 6:
            if (l && d.stateNode != null)
                l.memoizedProps !== x && Qs(d);
            else {
                if (typeof x != "string" && d.stateNode === null)
                    throw Error(r(166));
                if (l = ee.current,
                wd(d)) {
                    if (l = d.stateNode,
                    p = d.memoizedProps,
                    x = null,
                    _ = di,
                    _ !== null)
                        switch (_.tag) {
                        case 27:
                        case 5:
                            x = _.memoizedProps
                        }
                    l[ln] = d,
                    l = !!(l.nodeValue === p || x !== null && x.suppressHydrationWarning === !0 || vO(l.nodeValue, p)),
                    l || $l(d, !0)
                } else
                    l = fb(l).createTextNode(x),
                    l[ln] = d,
                    d.stateNode = l
            }
            return cr(d),
            null;
        case 31:
            if (p = d.memoizedState,
            l === null || l.memoizedState !== null) {
                if (x = wd(d),
                p !== null) {
                    if (l === null) {
                        if (!x)
                            throw Error(r(318));
                        if (l = d.memoizedState,
                        l = l !== null ? l.dehydrated : null,
                        !l)
                            throw Error(r(557));
                        l[ln] = d
                    } else
                        qc(),
                        (d.flags & 128) === 0 && (d.memoizedState = null),
                        d.flags |= 4;
                    cr(d),
                    l = !1
                } else
                    p = qS(),
                    l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = p),
                    l = !0;
                if (!l)
                    return d.flags & 256 ? (Oo(d),
                    d) : (Oo(d),
                    null);
                if ((d.flags & 128) !== 0)
                    throw Error(r(558))
            }
            return cr(d),
            null;
        case 13:
            if (x = d.memoizedState,
            l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
                if (_ = wd(d),
                x !== null && x.dehydrated !== null) {
                    if (l === null) {
                        if (!_)
                            throw Error(r(318));
                        if (_ = d.memoizedState,
                        _ = _ !== null ? _.dehydrated : null,
                        !_)
                            throw Error(r(317));
                        _[ln] = d
                    } else
                        qc(),
                        (d.flags & 128) === 0 && (d.memoizedState = null),
                        d.flags |= 4;
                    cr(d),
                    _ = !1
                } else
                    _ = qS(),
                    l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = _),
                    _ = !0;
                if (!_)
                    return d.flags & 256 ? (Oo(d),
                    d) : (Oo(d),
                    null)
            }
            return Oo(d),
            (d.flags & 128) !== 0 ? (d.lanes = p,
            d) : (p = x !== null,
            l = l !== null && l.memoizedState !== null,
            p && (x = d.child,
            _ = null,
            x.alternate !== null && x.alternate.memoizedState !== null && x.alternate.memoizedState.cachePool !== null && (_ = x.alternate.memoizedState.cachePool.pool),
            R = null,
            x.memoizedState !== null && x.memoizedState.cachePool !== null && (R = x.memoizedState.cachePool.pool),
            R !== _ && (x.flags |= 2048)),
            p !== l && p && (d.child.flags |= 8192),
            Ky(d, d.updateQueue),
            cr(d),
            null);
        case 4:
            return J(),
            l === null && rw(d.stateNode.containerInfo),
            cr(d),
            null;
        case 10:
            return Ws(d.type),
            cr(d),
            null;
        case 19:
            if (Y($r),
            x = d.memoizedState,
            x === null)
                return cr(d),
                null;
            if (_ = (d.flags & 128) !== 0,
            R = x.rendering,
            R === null)
                if (_)
                    Zh(x, !1);
                else {
                    if (Ar !== 0 || l !== null && (l.flags & 128) !== 0)
                        for (l = d.child; l !== null; ) {
                            if (R = By(l),
                            R !== null) {
                                for (d.flags |= 128,
                                Zh(x, !1),
                                l = R.updateQueue,
                                d.updateQueue = l,
                                Ky(d, l),
                                d.subtreeFlags = 0,
                                l = p,
                                p = d.child; p !== null; )
                                    XP(p, l),
                                    p = p.sibling;
                                return W($r, $r.current & 1 | 2),
                                Tn && Hs(d, x.treeForkCount),
                                d.child
                            }
                            l = l.sibling
                        }
                    x.tail !== null && Oe() > nb && (d.flags |= 128,
                    _ = !0,
                    Zh(x, !1),
                    d.lanes = 4194304)
                }
            else {
                if (!_)
                    if (l = By(R),
                    l !== null) {
                        if (d.flags |= 128,
                        _ = !0,
                        l = l.updateQueue,
                        d.updateQueue = l,
                        Ky(d, l),
                        Zh(x, !0),
                        x.tail === null && x.tailMode === "hidden" && !R.alternate && !Tn)
                            return cr(d),
                            null
                    } else
                        2 * Oe() - x.renderingStartTime > nb && p !== 536870912 && (d.flags |= 128,
                        _ = !0,
                        Zh(x, !1),
                        d.lanes = 4194304);
                x.isBackwards ? (R.sibling = d.child,
                d.child = R) : (l = x.last,
                l !== null ? l.sibling = R : d.child = R,
                x.last = R)
            }
            return x.tail !== null ? (l = x.tail,
            x.rendering = l,
            x.tail = l.sibling,
            x.renderingStartTime = Oe(),
            l.sibling = null,
            p = $r.current,
            W($r, _ ? p & 1 | 2 : p & 1),
            Tn && Hs(d, x.treeForkCount),
            l) : (cr(d),
            null);
        case 22:
        case 23:
            return Oo(d),
            iC(),
            x = d.memoizedState !== null,
            l !== null ? l.memoizedState !== null !== x && (d.flags |= 8192) : x && (d.flags |= 8192),
            x ? (p & 536870912) !== 0 && (d.flags & 128) === 0 && (cr(d),
            d.subtreeFlags & 6 && (d.flags |= 8192)) : cr(d),
            p = d.updateQueue,
            p !== null && Ky(d, p.retryQueue),
            p = null,
            l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (p = l.memoizedState.cachePool.pool),
            x = null,
            d.memoizedState !== null && d.memoizedState.cachePool !== null && (x = d.memoizedState.cachePool.pool),
            x !== p && (d.flags |= 2048),
            l !== null && Y(Yc),
            null;
        case 24:
            return p = null,
            l !== null && (p = l.memoizedState.cache),
            d.memoizedState.cache !== p && (d.flags |= 2048),
            Ws(Ur),
            cr(d),
            null;
        case 25:
            return null;
        case 30:
            return null
        }
        throw Error(r(156, d.tag))
    }
    function BY(l, d) {
        switch (VS(d),
        d.tag) {
        case 1:
            return l = d.flags,
            l & 65536 ? (d.flags = l & -65537 | 128,
            d) : null;
        case 3:
            return Ws(Ur),
            J(),
            l = d.flags,
            (l & 65536) !== 0 && (l & 128) === 0 ? (d.flags = l & -65537 | 128,
            d) : null;
        case 26:
        case 27:
        case 5:
            return we(d),
            null;
        case 31:
            if (d.memoizedState !== null) {
                if (Oo(d),
                d.alternate === null)
                    throw Error(r(340));
                qc()
            }
            return l = d.flags,
            l & 65536 ? (d.flags = l & -65537 | 128,
            d) : null;
        case 13:
            if (Oo(d),
            l = d.memoizedState,
            l !== null && l.dehydrated !== null) {
                if (d.alternate === null)
                    throw Error(r(340));
                qc()
            }
            return l = d.flags,
            l & 65536 ? (d.flags = l & -65537 | 128,
            d) : null;
        case 19:
            return Y($r),
            null;
        case 4:
            return J(),
            null;
        case 10:
            return Ws(d.type),
            null;
        case 22:
        case 23:
            return Oo(d),
            iC(),
            l !== null && Y(Yc),
            l = d.flags,
            l & 65536 ? (d.flags = l & -65537 | 128,
            d) : null;
        case 24:
            return Ws(Ur),
            null;
        case 25:
            return null;
        default:
            return null
        }
    }
    function TD(l, d) {
        switch (VS(d),
        d.tag) {
        case 3:
            Ws(Ur),
            J();
            break;
        case 26:
        case 27:
        case 5:
            we(d);
            break;
        case 4:
            J();
            break;
        case 31:
            d.memoizedState !== null && Oo(d);
            break;
        case 13:
            Oo(d);
            break;
        case 19:
            Y($r);
            break;
        case 10:
            Ws(d.type);
            break;
        case 22:
        case 23:
            Oo(d),
            iC(),
            l !== null && Y(Yc);
            break;
        case 24:
            Ws(Ur)
        }
    }
    function Qh(l, d) {
        try {
            var p = d.updateQueue
              , x = p !== null ? p.lastEffect : null;
            if (x !== null) {
                var _ = x.next;
                p = _;
                do {
                    if ((p.tag & l) === l) {
                        x = void 0;
                        var R = p.create
                          , G = p.inst;
                        x = R(),
                        G.destroy = x
                    }
                    p = p.next
                } while (p !== _)
            }
        } catch (Q) {
            Gn(d, d.return, Q)
        }
    }
    function Ul(l, d, p) {
        try {
            var x = d.updateQueue
              , _ = x !== null ? x.lastEffect : null;
            if (_ !== null) {
                var R = _.next;
                x = R;
                do {
                    if ((x.tag & l) === l) {
                        var G = x.inst
                          , Q = G.destroy;
                        if (Q !== void 0) {
                            G.destroy = void 0,
                            _ = d;
                            var ae = p
                              , Ee = Q;
                            try {
                                Ee()
                            } catch (Ue) {
                                Gn(_, ae, Ue)
                            }
                        }
                    }
                    x = x.next
                } while (x !== R)
            }
        } catch (Ue) {
            Gn(d, d.return, Ue)
        }
    }
    function _D(l) {
        var d = l.updateQueue;
        if (d !== null) {
            var p = l.stateNode;
            try {
                gR(d, p)
            } catch (x) {
                Gn(l, l.return, x)
            }
        }
    }
    function ED(l, d, p) {
        p.props = Jc(l.type, l.memoizedProps),
        p.state = l.memoizedState;
        try {
            p.componentWillUnmount()
        } catch (x) {
            Gn(l, d, x)
        }
    }
    function Kh(l, d) {
        try {
            var p = l.ref;
            if (p !== null) {
                switch (l.tag) {
                case 26:
                case 27:
                case 5:
                    var x = l.stateNode;
                    break;
                case 30:
                    x = l.stateNode;
                    break;
                default:
                    x = l.stateNode
                }
                typeof p == "function" ? l.refCleanup = p(x) : p.current = x
            }
        } catch (_) {
            Gn(l, d, _)
        }
    }
    function ls(l, d) {
        var p = l.ref
          , x = l.refCleanup;
        if (p !== null)
            if (typeof x == "function")
                try {
                    x()
                } catch (_) {
                    Gn(l, d, _)
                } finally {
                    l.refCleanup = null,
                    l = l.alternate,
                    l != null && (l.refCleanup = null)
                }
            else if (typeof p == "function")
                try {
                    p(null)
                } catch (_) {
                    Gn(l, d, _)
                }
            else
                p.current = null
    }
    function AD(l) {
        var d = l.type
          , p = l.memoizedProps
          , x = l.stateNode;
        try {
            e: switch (d) {
            case "button":
            case "input":
            case "select":
            case "textarea":
                p.autoFocus && x.focus();
                break e;
            case "img":
                p.src ? x.src = p.src : p.srcSet && (x.srcset = p.srcSet)
            }
        } catch (_) {
            Gn(l, l.return, _)
        }
    }
    function LC(l, d, p) {
        try {
            var x = l.stateNode;
            aZ(x, l.type, p, d),
            x[en] = d
        } catch (_) {
            Gn(l, l.return, _)
        }
    }
    function MD(l) {
        return l.tag === 5 || l.tag === 3 || l.tag === 26 || l.tag === 27 && Zl(l.type) || l.tag === 4
    }
    function jC(l) {
        e: for (; ; ) {
            for (; l.sibling === null; ) {
                if (l.return === null || MD(l.return))
                    return null;
                l = l.return
            }
            for (l.sibling.return = l.return,
            l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
                if (l.tag === 27 && Zl(l.type) || l.flags & 2 || l.child === null || l.tag === 4)
                    continue e;
                l.child.return = l,
                l = l.child
            }
            if (!(l.flags & 2))
                return l.stateNode
        }
    }
    function BC(l, d, p) {
        var x = l.tag;
        if (x === 5 || x === 6)
            l = l.stateNode,
            d ? (p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p).insertBefore(l, d) : (d = p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p,
            d.appendChild(l),
            p = p._reactRootContainer,
            p != null || d.onclick !== null || (d.onclick = Ns));
        else if (x !== 4 && (x === 27 && Zl(l.type) && (p = l.stateNode,
        d = null),
        l = l.child,
        l !== null))
            for (BC(l, d, p),
            l = l.sibling; l !== null; )
                BC(l, d, p),
                l = l.sibling
    }
    function Xy(l, d, p) {
        var x = l.tag;
        if (x === 5 || x === 6)
            l = l.stateNode,
            d ? p.insertBefore(l, d) : p.appendChild(l);
        else if (x !== 4 && (x === 27 && Zl(l.type) && (p = l.stateNode),
        l = l.child,
        l !== null))
            for (Xy(l, d, p),
            l = l.sibling; l !== null; )
                Xy(l, d, p),
                l = l.sibling
    }
    function PD(l) {
        var d = l.stateNode
          , p = l.memoizedProps;
        try {
            for (var x = l.type, _ = d.attributes; _.length; )
                d.removeAttributeNode(_[0]);
            pi(d, x, p),
            d[ln] = l,
            d[en] = p
        } catch (R) {
            Gn(l, l.return, R)
        }
    }
    var Ks = !1
      , qr = !1
      , zC = !1
      , RD = typeof WeakSet == "function" ? WeakSet : Set
      , li = null;
    function zY(l, d) {
        if (l = l.containerInfo,
        aw = xb,
        l = VP(l),
        DS(l)) {
            if ("selectionStart"in l)
                var p = {
                    start: l.selectionStart,
                    end: l.selectionEnd
                };
            else
                e: {
                    p = (p = l.ownerDocument) && p.defaultView || window;
                    var x = p.getSelection && p.getSelection();
                    if (x && x.rangeCount !== 0) {
                        p = x.anchorNode;
                        var _ = x.anchorOffset
                          , R = x.focusNode;
                        x = x.focusOffset;
                        try {
                            p.nodeType,
                            R.nodeType
                        } catch {
                            p = null;
                            break e
                        }
                        var G = 0
                          , Q = -1
                          , ae = -1
                          , Ee = 0
                          , Ue = 0
                          , We = l
                          , Pe = null;
                        t: for (; ; ) {
                            for (var $e; We !== p || _ !== 0 && We.nodeType !== 3 || (Q = G + _),
                            We !== R || x !== 0 && We.nodeType !== 3 || (ae = G + x),
                            We.nodeType === 3 && (G += We.nodeValue.length),
                            ($e = We.firstChild) !== null; )
                                Pe = We,
                                We = $e;
                            for (; ; ) {
                                if (We === l)
                                    break t;
                                if (Pe === p && ++Ee === _ && (Q = G),
                                Pe === R && ++Ue === x && (ae = G),
                                ($e = We.nextSibling) !== null)
                                    break;
                                We = Pe,
                                Pe = We.parentNode
                            }
                            We = $e
                        }
                        p = Q === -1 || ae === -1 ? null : {
                            start: Q,
                            end: ae
                        }
                    } else
                        p = null
                }
            p = p || {
                start: 0,
                end: 0
            }
        } else
            p = null;
        for (sw = {
            focusedElem: l,
            selectionRange: p
        },
        xb = !1,
        li = d; li !== null; )
            if (d = li,
            l = d.child,
            (d.subtreeFlags & 1028) !== 0 && l !== null)
                l.return = d,
                li = l;
            else
                for (; li !== null; ) {
                    switch (d = li,
                    R = d.alternate,
                    l = d.flags,
                    d.tag) {
                    case 0:
                        if ((l & 4) !== 0 && (l = d.updateQueue,
                        l = l !== null ? l.events : null,
                        l !== null))
                            for (p = 0; p < l.length; p++)
                                _ = l[p],
                                _.ref.impl = _.nextImpl;
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((l & 1024) !== 0 && R !== null) {
                            l = void 0,
                            p = d,
                            _ = R.memoizedProps,
                            R = R.memoizedState,
                            x = p.stateNode;
                            try {
                                var vt = Jc(p.type, _);
                                l = x.getSnapshotBeforeUpdate(vt, R),
                                x.__reactInternalSnapshotBeforeUpdate = l
                            } catch (Ut) {
                                Gn(p, p.return, Ut)
                            }
                        }
                        break;
                    case 3:
                        if ((l & 1024) !== 0) {
                            if (l = d.stateNode.containerInfo,
                            p = l.nodeType,
                            p === 9)
                                uw(l);
                            else if (p === 1)
                                switch (l.nodeName) {
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    uw(l);
                                    break;
                                default:
                                    l.textContent = ""
                                }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((l & 1024) !== 0)
                            throw Error(r(163))
                    }
                    if (l = d.sibling,
                    l !== null) {
                        l.return = d.return,
                        li = l;
                        break
                    }
                    li = d.return
                }
    }
    function DD(l, d, p) {
        var x = p.flags;
        switch (p.tag) {
        case 0:
        case 11:
        case 15:
            Js(l, p),
            x & 4 && Qh(5, p);
            break;
        case 1:
            if (Js(l, p),
            x & 4)
                if (l = p.stateNode,
                d === null)
                    try {
                        l.componentDidMount()
                    } catch (G) {
                        Gn(p, p.return, G)
                    }
                else {
                    var _ = Jc(p.type, d.memoizedProps);
                    d = d.memoizedState;
                    try {
                        l.componentDidUpdate(_, d, l.__reactInternalSnapshotBeforeUpdate)
                    } catch (G) {
                        Gn(p, p.return, G)
                    }
                }
            x & 64 && _D(p),
            x & 512 && Kh(p, p.return);
            break;
        case 3:
            if (Js(l, p),
            x & 64 && (l = p.updateQueue,
            l !== null)) {
                if (d = null,
                p.child !== null)
                    switch (p.child.tag) {
                    case 27:
                    case 5:
                        d = p.child.stateNode;
                        break;
                    case 1:
                        d = p.child.stateNode
                    }
                try {
                    gR(l, d)
                } catch (G) {
                    Gn(p, p.return, G)
                }
            }
            break;
        case 27:
            d === null && x & 4 && PD(p);
        case 26:
        case 5:
            Js(l, p),
            d === null && x & 4 && AD(p),
            x & 512 && Kh(p, p.return);
            break;
        case 12:
            Js(l, p);
            break;
        case 31:
            Js(l, p),
            x & 4 && $D(l, p);
            break;
        case 13:
            Js(l, p),
            x & 4 && LD(l, p),
            x & 64 && (l = p.memoizedState,
            l !== null && (l = l.dehydrated,
            l !== null && (p = YY.bind(null, p),
            pZ(l, p))));
            break;
        case 22:
            if (x = p.memoizedState !== null || Ks,
            !x) {
                d = d !== null && d.memoizedState !== null || qr,
                _ = Ks;
                var R = qr;
                Ks = x,
                (qr = d) && !R ? el(l, p, (p.subtreeFlags & 8772) !== 0) : Js(l, p),
                Ks = _,
                qr = R
            }
            break;
        case 30:
            break;
        default:
            Js(l, p)
        }
    }
    function OD(l) {
        var d = l.alternate;
        d !== null && (l.alternate = null,
        OD(d)),
        l.child = null,
        l.deletions = null,
        l.sibling = null,
        l.tag === 5 && (d = l.stateNode,
        d !== null && ne(d)),
        l.stateNode = null,
        l.return = null,
        l.dependencies = null,
        l.memoizedProps = null,
        l.memoizedState = null,
        l.pendingProps = null,
        l.stateNode = null,
        l.updateQueue = null
    }
    var gr = null
      , to = !1;
    function Xs(l, d, p) {
        for (p = p.child; p !== null; )
            ID(l, d, p),
            p = p.sibling
    }
    function ID(l, d, p) {
        if (Pt && typeof Pt.onCommitFiberUnmount == "function")
            try {
                Pt.onCommitFiberUnmount(Ft, p)
            } catch {}
        switch (p.tag) {
        case 26:
            qr || ls(p, d),
            Xs(l, d, p),
            p.memoizedState ? p.memoizedState.count-- : p.stateNode && (p = p.stateNode,
            p.parentNode.removeChild(p));
            break;
        case 27:
            qr || ls(p, d);
            var x = gr
              , _ = to;
            Zl(p.type) && (gr = p.stateNode,
            to = !1),
            Xs(l, d, p),
            ap(p.stateNode),
            gr = x,
            to = _;
            break;
        case 5:
            qr || ls(p, d);
        case 6:
            if (x = gr,
            _ = to,
            gr = null,
            Xs(l, d, p),
            gr = x,
            to = _,
            gr !== null)
                if (to)
                    try {
                        (gr.nodeType === 9 ? gr.body : gr.nodeName === "HTML" ? gr.ownerDocument.body : gr).removeChild(p.stateNode)
                    } catch (R) {
                        Gn(p, d, R)
                    }
                else
                    try {
                        gr.removeChild(p.stateNode)
                    } catch (R) {
                        Gn(p, d, R)
                    }
            break;
        case 18:
            gr !== null && (to ? (l = gr,
            _O(l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l, p.stateNode),
            Hd(l)) : _O(gr, p.stateNode));
            break;
        case 4:
            x = gr,
            _ = to,
            gr = p.stateNode.containerInfo,
            to = !0,
            Xs(l, d, p),
            gr = x,
            to = _;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            Ul(2, p, d),
            qr || Ul(4, p, d),
            Xs(l, d, p);
            break;
        case 1:
            qr || (ls(p, d),
            x = p.stateNode,
            typeof x.componentWillUnmount == "function" && ED(p, d, x)),
            Xs(l, d, p);
            break;
        case 21:
            Xs(l, d, p);
            break;
        case 22:
            qr = (x = qr) || p.memoizedState !== null,
            Xs(l, d, p),
            qr = x;
            break;
        default:
            Xs(l, d, p)
        }
    }
    function $D(l, d) {
        if (d.memoizedState === null && (l = d.alternate,
        l !== null && (l = l.memoizedState,
        l !== null))) {
            l = l.dehydrated;
            try {
                Hd(l)
            } catch (p) {
                Gn(d, d.return, p)
            }
        }
    }
    function LD(l, d) {
        if (d.memoizedState === null && (l = d.alternate,
        l !== null && (l = l.memoizedState,
        l !== null && (l = l.dehydrated,
        l !== null))))
            try {
                Hd(l)
            } catch (p) {
                Gn(d, d.return, p)
            }
    }
    function FY(l) {
        switch (l.tag) {
        case 31:
        case 13:
        case 19:
            var d = l.stateNode;
            return d === null && (d = l.stateNode = new RD),
            d;
        case 22:
            return l = l.stateNode,
            d = l._retryCache,
            d === null && (d = l._retryCache = new RD),
            d;
        default:
            throw Error(r(435, l.tag))
        }
    }
    function Jy(l, d) {
        var p = FY(l);
        d.forEach(function(x) {
            if (!p.has(x)) {
                p.add(x);
                var _ = ZY.bind(null, l, x);
                x.then(_, _)
            }
        })
    }
    function no(l, d) {
        var p = d.deletions;
        if (p !== null)
            for (var x = 0; x < p.length; x++) {
                var _ = p[x]
                  , R = l
                  , G = d
                  , Q = G;
                e: for (; Q !== null; ) {
                    switch (Q.tag) {
                    case 27:
                        if (Zl(Q.type)) {
                            gr = Q.stateNode,
                            to = !1;
                            break e
                        }
                        break;
                    case 5:
                        gr = Q.stateNode,
                        to = !1;
                        break e;
                    case 3:
                    case 4:
                        gr = Q.stateNode.containerInfo,
                        to = !0;
                        break e
                    }
                    Q = Q.return
                }
                if (gr === null)
                    throw Error(r(160));
                ID(R, G, _),
                gr = null,
                to = !1,
                R = _.alternate,
                R !== null && (R.return = null),
                _.return = null
            }
        if (d.subtreeFlags & 13886)
            for (d = d.child; d !== null; )
                jD(d, l),
                d = d.sibling
    }
    var Ra = null;
    function jD(l, d) {
        var p = l.alternate
          , x = l.flags;
        switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            no(d, l),
            ro(l),
            x & 4 && (Ul(3, l, l.return),
            Qh(3, l),
            Ul(5, l, l.return));
            break;
        case 1:
            no(d, l),
            ro(l),
            x & 512 && (qr || p === null || ls(p, p.return)),
            x & 64 && Ks && (l = l.updateQueue,
            l !== null && (x = l.callbacks,
            x !== null && (p = l.shared.hiddenCallbacks,
            l.shared.hiddenCallbacks = p === null ? x : p.concat(x))));
            break;
        case 26:
            var _ = Ra;
            if (no(d, l),
            ro(l),
            x & 512 && (qr || p === null || ls(p, p.return)),
            x & 4) {
                var R = p !== null ? p.memoizedState : null;
                if (x = l.memoizedState,
                p === null)
                    if (x === null)
                        if (l.stateNode === null) {
                            e: {
                                x = l.type,
                                p = l.memoizedProps,
                                _ = _.ownerDocument || _;
                                t: switch (x) {
                                case "title":
                                    R = _.getElementsByTagName("title")[0],
                                    (!R || R[me] || R[ln] || R.namespaceURI === "http://www.w3.org/2000/svg" || R.hasAttribute("itemprop")) && (R = _.createElement(x),
                                    _.head.insertBefore(R, _.querySelector("head > title"))),
                                    pi(R, x, p),
                                    R[ln] = l,
                                    Nt(R),
                                    x = R;
                                    break e;
                                case "link":
                                    var G = jO("link", "href", _).get(x + (p.href || ""));
                                    if (G) {
                                        for (var Q = 0; Q < G.length; Q++)
                                            if (R = G[Q],
                                            R.getAttribute("href") === (p.href == null || p.href === "" ? null : p.href) && R.getAttribute("rel") === (p.rel == null ? null : p.rel) && R.getAttribute("title") === (p.title == null ? null : p.title) && R.getAttribute("crossorigin") === (p.crossOrigin == null ? null : p.crossOrigin)) {
                                                G.splice(Q, 1);
                                                break t
                                            }
                                    }
                                    R = _.createElement(x),
                                    pi(R, x, p),
                                    _.head.appendChild(R);
                                    break;
                                case "meta":
                                    if (G = jO("meta", "content", _).get(x + (p.content || ""))) {
                                        for (Q = 0; Q < G.length; Q++)
                                            if (R = G[Q],
                                            R.getAttribute("content") === (p.content == null ? null : "" + p.content) && R.getAttribute("name") === (p.name == null ? null : p.name) && R.getAttribute("property") === (p.property == null ? null : p.property) && R.getAttribute("http-equiv") === (p.httpEquiv == null ? null : p.httpEquiv) && R.getAttribute("charset") === (p.charSet == null ? null : p.charSet)) {
                                                G.splice(Q, 1);
                                                break t
                                            }
                                    }
                                    R = _.createElement(x),
                                    pi(R, x, p),
                                    _.head.appendChild(R);
                                    break;
                                default:
                                    throw Error(r(468, x))
                                }
                                R[ln] = l,
                                Nt(R),
                                x = R
                            }
                            l.stateNode = x
                        } else
                            BO(_, l.type, l.stateNode);
                    else
                        l.stateNode = LO(_, x, l.memoizedProps);
                else
                    R !== x ? (R === null ? p.stateNode !== null && (p = p.stateNode,
                    p.parentNode.removeChild(p)) : R.count--,
                    x === null ? BO(_, l.type, l.stateNode) : LO(_, x, l.memoizedProps)) : x === null && l.stateNode !== null && LC(l, l.memoizedProps, p.memoizedProps)
            }
            break;
        case 27:
            no(d, l),
            ro(l),
            x & 512 && (qr || p === null || ls(p, p.return)),
            p !== null && x & 4 && LC(l, l.memoizedProps, p.memoizedProps);
            break;
        case 5:
            if (no(d, l),
            ro(l),
            x & 512 && (qr || p === null || ls(p, p.return)),
            l.flags & 32) {
                _ = l.stateNode;
                try {
                    hd(_, "")
                } catch (vt) {
                    Gn(l, l.return, vt)
                }
            }
            x & 4 && l.stateNode != null && (_ = l.memoizedProps,
            LC(l, _, p !== null ? p.memoizedProps : _)),
            x & 1024 && (zC = !0);
            break;
        case 6:
            if (no(d, l),
            ro(l),
            x & 4) {
                if (l.stateNode === null)
                    throw Error(r(162));
                x = l.memoizedProps,
                p = l.stateNode;
                try {
                    p.nodeValue = x
                } catch (vt) {
                    Gn(l, l.return, vt)
                }
            }
            break;
        case 3:
            if (mb = null,
            _ = Ra,
            Ra = hb(d.containerInfo),
            no(d, l),
            Ra = _,
            ro(l),
            x & 4 && p !== null && p.memoizedState.isDehydrated)
                try {
                    Hd(d.containerInfo)
                } catch (vt) {
                    Gn(l, l.return, vt)
                }
            zC && (zC = !1,
            BD(l));
            break;
        case 4:
            x = Ra,
            Ra = hb(l.stateNode.containerInfo),
            no(d, l),
            ro(l),
            Ra = x;
            break;
        case 12:
            no(d, l),
            ro(l);
            break;
        case 31:
            no(d, l),
            ro(l),
            x & 4 && (x = l.updateQueue,
            x !== null && (l.updateQueue = null,
            Jy(l, x)));
            break;
        case 13:
            no(d, l),
            ro(l),
            l.child.flags & 8192 && l.memoizedState !== null != (p !== null && p.memoizedState !== null) && (tb = Oe()),
            x & 4 && (x = l.updateQueue,
            x !== null && (l.updateQueue = null,
            Jy(l, x)));
            break;
        case 22:
            _ = l.memoizedState !== null;
            var ae = p !== null && p.memoizedState !== null
              , Ee = Ks
              , Ue = qr;
            if (Ks = Ee || _,
            qr = Ue || ae,
            no(d, l),
            qr = Ue,
            Ks = Ee,
            ro(l),
            x & 8192)
                e: for (d = l.stateNode,
                d._visibility = _ ? d._visibility & -2 : d._visibility | 1,
                _ && (p === null || ae || Ks || qr || eu(l)),
                p = null,
                d = l; ; ) {
                    if (d.tag === 5 || d.tag === 26) {
                        if (p === null) {
                            ae = p = d;
                            try {
                                if (R = ae.stateNode,
                                _)
                                    G = R.style,
                                    typeof G.setProperty == "function" ? G.setProperty("display", "none", "important") : G.display = "none";
                                else {
                                    Q = ae.stateNode;
                                    var We = ae.memoizedProps.style
                                      , Pe = We != null && We.hasOwnProperty("display") ? We.display : null;
                                    Q.style.display = Pe == null || typeof Pe == "boolean" ? "" : ("" + Pe).trim()
                                }
                            } catch (vt) {
                                Gn(ae, ae.return, vt)
                            }
                        }
                    } else if (d.tag === 6) {
                        if (p === null) {
                            ae = d;
                            try {
                                ae.stateNode.nodeValue = _ ? "" : ae.memoizedProps
                            } catch (vt) {
                                Gn(ae, ae.return, vt)
                            }
                        }
                    } else if (d.tag === 18) {
                        if (p === null) {
                            ae = d;
                            try {
                                var $e = ae.stateNode;
                                _ ? EO($e, !0) : EO(ae.stateNode, !1)
                            } catch (vt) {
                                Gn(ae, ae.return, vt)
                            }
                        }
                    } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === l) && d.child !== null) {
                        d.child.return = d,
                        d = d.child;
                        continue
                    }
                    if (d === l)
                        break e;
                    for (; d.sibling === null; ) {
                        if (d.return === null || d.return === l)
                            break e;
                        p === d && (p = null),
                        d = d.return
                    }
                    p === d && (p = null),
                    d.sibling.return = d.return,
                    d = d.sibling
                }
            x & 4 && (x = l.updateQueue,
            x !== null && (p = x.retryQueue,
            p !== null && (x.retryQueue = null,
            Jy(l, p))));
            break;
        case 19:
            no(d, l),
            ro(l),
            x & 4 && (x = l.updateQueue,
            x !== null && (l.updateQueue = null,
            Jy(l, x)));
            break;
        case 30:
            break;
        case 21:
            break;
        default:
            no(d, l),
            ro(l)
        }
    }
    function ro(l) {
        var d = l.flags;
        if (d & 2) {
            try {
                for (var p, x = l.return; x !== null; ) {
                    if (MD(x)) {
                        p = x;
                        break
                    }
                    x = x.return
                }
                if (p == null)
                    throw Error(r(160));
                switch (p.tag) {
                case 27:
                    var _ = p.stateNode
                      , R = jC(l);
                    Xy(l, R, _);
                    break;
                case 5:
                    var G = p.stateNode;
                    p.flags & 32 && (hd(G, ""),
                    p.flags &= -33);
                    var Q = jC(l);
                    Xy(l, Q, G);
                    break;
                case 3:
                case 4:
                    var ae = p.stateNode.containerInfo
                      , Ee = jC(l);
                    BC(l, Ee, ae);
                    break;
                default:
                    throw Error(r(161))
                }
            } catch (Ue) {
                Gn(l, l.return, Ue)
            }
            l.flags &= -3
        }
        d & 4096 && (l.flags &= -4097)
    }
    function BD(l) {
        if (l.subtreeFlags & 1024)
            for (l = l.child; l !== null; ) {
                var d = l;
                BD(d),
                d.tag === 5 && d.flags & 1024 && d.stateNode.reset(),
                l = l.sibling
            }
    }
    function Js(l, d) {
        if (d.subtreeFlags & 8772)
            for (d = d.child; d !== null; )
                DD(l, d.alternate, d),
                d = d.sibling
    }
    function eu(l) {
        for (l = l.child; l !== null; ) {
            var d = l;
            switch (d.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Ul(4, d, d.return),
                eu(d);
                break;
            case 1:
                ls(d, d.return);
                var p = d.stateNode;
                typeof p.componentWillUnmount == "function" && ED(d, d.return, p),
                eu(d);
                break;
            case 27:
                ap(d.stateNode);
            case 26:
            case 5:
                ls(d, d.return),
                eu(d);
                break;
            case 22:
                d.memoizedState === null && eu(d);
                break;
            case 30:
                eu(d);
                break;
            default:
                eu(d)
            }
            l = l.sibling
        }
    }
    function el(l, d, p) {
        for (p = p && (d.subtreeFlags & 8772) !== 0,
        d = d.child; d !== null; ) {
            var x = d.alternate
              , _ = l
              , R = d
              , G = R.flags;
            switch (R.tag) {
            case 0:
            case 11:
            case 15:
                el(_, R, p),
                Qh(4, R);
                break;
            case 1:
                if (el(_, R, p),
                x = R,
                _ = x.stateNode,
                typeof _.componentDidMount == "function")
                    try {
                        _.componentDidMount()
                    } catch (Ee) {
                        Gn(x, x.return, Ee)
                    }
                if (x = R,
                _ = x.updateQueue,
                _ !== null) {
                    var Q = x.stateNode;
                    try {
                        var ae = _.shared.hiddenCallbacks;
                        if (ae !== null)
                            for (_.shared.hiddenCallbacks = null,
                            _ = 0; _ < ae.length; _++)
                                mR(ae[_], Q)
                    } catch (Ee) {
                        Gn(x, x.return, Ee)
                    }
                }
                p && G & 64 && _D(R),
                Kh(R, R.return);
                break;
            case 27:
                PD(R);
            case 26:
            case 5:
                el(_, R, p),
                p && x === null && G & 4 && AD(R),
                Kh(R, R.return);
                break;
            case 12:
                el(_, R, p);
                break;
            case 31:
                el(_, R, p),
                p && G & 4 && $D(_, R);
                break;
            case 13:
                el(_, R, p),
                p && G & 4 && LD(_, R);
                break;
            case 22:
                R.memoizedState === null && el(_, R, p),
                Kh(R, R.return);
                break;
            case 30:
                break;
            default:
                el(_, R, p)
            }
            d = d.sibling
        }
    }
    function FC(l, d) {
        var p = null;
        l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (p = l.memoizedState.cachePool.pool),
        l = null,
        d.memoizedState !== null && d.memoizedState.cachePool !== null && (l = d.memoizedState.cachePool.pool),
        l !== p && (l != null && l.refCount++,
        p != null && jh(p))
    }
    function NC(l, d) {
        l = null,
        d.alternate !== null && (l = d.alternate.memoizedState.cache),
        d = d.memoizedState.cache,
        d !== l && (d.refCount++,
        l != null && jh(l))
    }
    function Da(l, d, p, x) {
        if (d.subtreeFlags & 10256)
            for (d = d.child; d !== null; )
                zD(l, d, p, x),
                d = d.sibling
    }
    function zD(l, d, p, x) {
        var _ = d.flags;
        switch (d.tag) {
        case 0:
        case 11:
        case 15:
            Da(l, d, p, x),
            _ & 2048 && Qh(9, d);
            break;
        case 1:
            Da(l, d, p, x);
            break;
        case 3:
            Da(l, d, p, x),
            _ & 2048 && (l = null,
            d.alternate !== null && (l = d.alternate.memoizedState.cache),
            d = d.memoizedState.cache,
            d !== l && (d.refCount++,
            l != null && jh(l)));
            break;
        case 12:
            if (_ & 2048) {
                Da(l, d, p, x),
                l = d.stateNode;
                try {
                    var R = d.memoizedProps
                      , G = R.id
                      , Q = R.onPostCommit;
                    typeof Q == "function" && Q(G, d.alternate === null ? "mount" : "update", l.passiveEffectDuration, -0)
                } catch (ae) {
                    Gn(d, d.return, ae)
                }
            } else
                Da(l, d, p, x);
            break;
        case 31:
            Da(l, d, p, x);
            break;
        case 13:
            Da(l, d, p, x);
            break;
        case 23:
            break;
        case 22:
            R = d.stateNode,
            G = d.alternate,
            d.memoizedState !== null ? R._visibility & 2 ? Da(l, d, p, x) : Xh(l, d) : R._visibility & 2 ? Da(l, d, p, x) : (R._visibility |= 2,
            Od(l, d, p, x, (d.subtreeFlags & 10256) !== 0 || !1)),
            _ & 2048 && FC(G, d);
            break;
        case 24:
            Da(l, d, p, x),
            _ & 2048 && NC(d.alternate, d);
            break;
        default:
            Da(l, d, p, x)
        }
    }
    function Od(l, d, p, x, _) {
        for (_ = _ && ((d.subtreeFlags & 10256) !== 0 || !1),
        d = d.child; d !== null; ) {
            var R = l
              , G = d
              , Q = p
              , ae = x
              , Ee = G.flags;
            switch (G.tag) {
            case 0:
            case 11:
            case 15:
                Od(R, G, Q, ae, _),
                Qh(8, G);
                break;
            case 23:
                break;
            case 22:
                var Ue = G.stateNode;
                G.memoizedState !== null ? Ue._visibility & 2 ? Od(R, G, Q, ae, _) : Xh(R, G) : (Ue._visibility |= 2,
                Od(R, G, Q, ae, _)),
                _ && Ee & 2048 && FC(G.alternate, G);
                break;
            case 24:
                Od(R, G, Q, ae, _),
                _ && Ee & 2048 && NC(G.alternate, G);
                break;
            default:
                Od(R, G, Q, ae, _)
            }
            d = d.sibling
        }
    }
    function Xh(l, d) {
        if (d.subtreeFlags & 10256)
            for (d = d.child; d !== null; ) {
                var p = l
                  , x = d
                  , _ = x.flags;
                switch (x.tag) {
                case 22:
                    Xh(p, x),
                    _ & 2048 && FC(x.alternate, x);
                    break;
                case 24:
                    Xh(p, x),
                    _ & 2048 && NC(x.alternate, x);
                    break;
                default:
                    Xh(p, x)
                }
                d = d.sibling
            }
    }
    var Jh = 8192;
    function Id(l, d, p) {
        if (l.subtreeFlags & Jh)
            for (l = l.child; l !== null; )
                FD(l, d, p),
                l = l.sibling
    }
    function FD(l, d, p) {
        switch (l.tag) {
        case 26:
            Id(l, d, p),
            l.flags & Jh && l.memoizedState !== null && _Z(p, Ra, l.memoizedState, l.memoizedProps);
            break;
        case 5:
            Id(l, d, p);
            break;
        case 3:
        case 4:
            var x = Ra;
            Ra = hb(l.stateNode.containerInfo),
            Id(l, d, p),
            Ra = x;
            break;
        case 22:
            l.memoizedState === null && (x = l.alternate,
            x !== null && x.memoizedState !== null ? (x = Jh,
            Jh = 16777216,
            Id(l, d, p),
            Jh = x) : Id(l, d, p));
            break;
        default:
            Id(l, d, p)
        }
    }
    function ND(l) {
        var d = l.alternate;
        if (d !== null && (l = d.child,
        l !== null)) {
            d.child = null;
            do
                d = l.sibling,
                l.sibling = null,
                l = d;
            while (l !== null)
        }
    }
    function ep(l) {
        var d = l.deletions;
        if ((l.flags & 16) !== 0) {
            if (d !== null)
                for (var p = 0; p < d.length; p++) {
                    var x = d[p];
                    li = x,
                    VD(x, l)
                }
            ND(l)
        }
        if (l.subtreeFlags & 10256)
            for (l = l.child; l !== null; )
                UD(l),
                l = l.sibling
    }
    function UD(l) {
        switch (l.tag) {
        case 0:
        case 11:
        case 15:
            ep(l),
            l.flags & 2048 && Ul(9, l, l.return);
            break;
        case 3:
            ep(l);
            break;
        case 12:
            ep(l);
            break;
        case 22:
            var d = l.stateNode;
            l.memoizedState !== null && d._visibility & 2 && (l.return === null || l.return.tag !== 13) ? (d._visibility &= -3,
            eb(l)) : ep(l);
            break;
        default:
            ep(l)
        }
    }
    function eb(l) {
        var d = l.deletions;
        if ((l.flags & 16) !== 0) {
            if (d !== null)
                for (var p = 0; p < d.length; p++) {
                    var x = d[p];
                    li = x,
                    VD(x, l)
                }
            ND(l)
        }
        for (l = l.child; l !== null; ) {
            switch (d = l,
            d.tag) {
            case 0:
            case 11:
            case 15:
                Ul(8, d, d.return),
                eb(d);
                break;
            case 22:
                p = d.stateNode,
                p._visibility & 2 && (p._visibility &= -3,
                eb(d));
                break;
            default:
                eb(d)
            }
            l = l.sibling
        }
    }
    function VD(l, d) {
        for (; li !== null; ) {
            var p = li;
            switch (p.tag) {
            case 0:
            case 11:
            case 15:
                Ul(8, p, d);
                break;
            case 23:
            case 22:
                if (p.memoizedState !== null && p.memoizedState.cachePool !== null) {
                    var x = p.memoizedState.cachePool.pool;
                    x != null && x.refCount++
                }
                break;
            case 24:
                jh(p.memoizedState.cache)
            }
            if (x = p.child,
            x !== null)
                x.return = p,
                li = x;
            else
                e: for (p = l; li !== null; ) {
                    x = li;
                    var _ = x.sibling
                      , R = x.return;
                    if (OD(x),
                    x === p) {
                        li = null;
                        break e
                    }
                    if (_ !== null) {
                        _.return = R,
                        li = _;
                        break e
                    }
                    li = R
                }
        }
    }
    var NY = {
        getCacheForType: function(l) {
            var d = fi(Ur)
              , p = d.data.get(l);
            return p === void 0 && (p = l(),
            d.data.set(l, p)),
            p
        },
        cacheSignal: function() {
            return fi(Ur).controller.signal
        }
    }
      , UY = typeof WeakMap == "function" ? WeakMap : Map
      , Ln = 0
      , rr = null
      , fn = null
      , vn = 0
      , Wn = 0
      , Io = null
      , Vl = !1
      , $d = !1
      , UC = !1
      , tl = 0
      , Ar = 0
      , Hl = 0
      , tu = 0
      , VC = 0
      , $o = 0
      , Ld = 0
      , tp = null
      , io = null
      , HC = !1
      , tb = 0
      , HD = 0
      , nb = 1 / 0
      , rb = null
      , ql = null
      , ei = 0
      , Wl = null
      , jd = null
      , nl = 0
      , qC = 0
      , WC = null
      , qD = null
      , np = 0
      , GC = null;
    function Lo() {
        return (Ln & 2) !== 0 && vn !== 0 ? vn & -vn : j.T !== null ? JC() : Ir()
    }
    function WD() {
        if ($o === 0)
            if ((vn & 536870912) === 0 || Tn) {
                var l = Pn;
                Pn <<= 1,
                (Pn & 3932160) === 0 && (Pn = 262144),
                $o = l
            } else
                $o = 536870912;
        return l = Do.current,
        l !== null && (l.flags |= 32),
        $o
    }
    function oo(l, d, p) {
        (l === rr && (Wn === 2 || Wn === 9) || l.cancelPendingCommit !== null) && (Bd(l, 0),
        Gl(l, vn, $o, !1)),
        he(l, p),
        ((Ln & 2) === 0 || l !== rr) && (l === rr && ((Ln & 2) === 0 && (tu |= p),
        Ar === 4 && Gl(l, vn, $o, !1)),
        cs(l))
    }
    function GD(l, d, p) {
        if ((Ln & 6) !== 0)
            throw Error(r(327));
        var x = !p && (d & 127) === 0 && (d & l.expiredLanes) === 0 || mr(l, d)
          , _ = x ? qY(l, d) : ZC(l, d, !0)
          , R = x;
        do {
            if (_ === 0) {
                $d && !x && Gl(l, d, 0, !1);
                break
            } else {
                if (p = l.current.alternate,
                R && !VY(p)) {
                    _ = ZC(l, d, !1),
                    R = !1;
                    continue
                }
                if (_ === 2) {
                    if (R = d,
                    l.errorRecoveryDisabledLanes & R)
                        var G = 0;
                    else
                        G = l.pendingLanes & -536870913,
                        G = G !== 0 ? G : G & 536870912 ? 536870912 : 0;
                    if (G !== 0) {
                        d = G;
                        e: {
                            var Q = l;
                            _ = tp;
                            var ae = Q.current.memoizedState.isDehydrated;
                            if (ae && (Bd(Q, G).flags |= 256),
                            G = ZC(Q, G, !1),
                            G !== 2) {
                                if (UC && !ae) {
                                    Q.errorRecoveryDisabledLanes |= R,
                                    tu |= R,
                                    _ = 4;
                                    break e
                                }
                                R = io,
                                io = _,
                                R !== null && (io === null ? io = R : io.push.apply(io, R))
                            }
                            _ = G
                        }
                        if (R = !1,
                        _ !== 2)
                            continue
                    }
                }
                if (_ === 1) {
                    Bd(l, 0),
                    Gl(l, d, 0, !0);
                    break
                }
                e: {
                    switch (x = l,
                    R = _,
                    R) {
                    case 0:
                    case 1:
                        throw Error(r(345));
                    case 4:
                        if ((d & 4194048) !== d)
                            break;
                    case 6:
                        Gl(x, d, $o, !Vl);
                        break e;
                    case 2:
                        io = null;
                        break;
                    case 3:
                    case 5:
                        break;
                    default:
                        throw Error(r(329))
                    }
                    if ((d & 62914560) === d && (_ = tb + 300 - Oe(),
                    10 < _)) {
                        if (Gl(x, d, $o, !Vl),
                        vr(x, 0, !0) !== 0)
                            break e;
                        nl = d,
                        x.timeoutHandle = kO(YD.bind(null, x, p, io, rb, HC, d, $o, tu, Ld, Vl, R, "Throttled", -0, 0), _);
                        break e
                    }
                    YD(x, p, io, rb, HC, d, $o, tu, Ld, Vl, R, null, -0, 0)
                }
            }
            break
        } while (!0);
        cs(l)
    }
    function YD(l, d, p, x, _, R, G, Q, ae, Ee, Ue, We, Pe, $e) {
        if (l.timeoutHandle = -1,
        We = d.subtreeFlags,
        We & 8192 || (We & 16785408) === 16785408) {
            We = {
                stylesheets: null,
                count: 0,
                imgCount: 0,
                imgBytes: 0,
                suspenseyImages: [],
                waitingForImages: !0,
                waitingForViewTransition: !1,
                unsuspend: Ns
            },
            FD(d, R, We);
            var vt = (R & 62914560) === R ? tb - Oe() : (R & 4194048) === R ? HD - Oe() : 0;
            if (vt = EZ(We, vt),
            vt !== null) {
                nl = R,
                l.cancelPendingCommit = vt(nO.bind(null, l, d, R, p, x, _, G, Q, ae, Ue, We, null, Pe, $e)),
                Gl(l, R, G, !Ee);
                return
            }
        }
        nO(l, d, R, p, x, _, G, Q, ae)
    }
    function VY(l) {
        for (var d = l; ; ) {
            var p = d.tag;
            if ((p === 0 || p === 11 || p === 15) && d.flags & 16384 && (p = d.updateQueue,
            p !== null && (p = p.stores,
            p !== null)))
                for (var x = 0; x < p.length; x++) {
                    var _ = p[x]
                      , R = _.getSnapshot;
                    _ = _.value;
                    try {
                        if (!Po(R(), _))
                            return !1
                    } catch {
                        return !1
                    }
                }
            if (p = d.child,
            d.subtreeFlags & 16384 && p !== null)
                p.return = d,
                d = p;
            else {
                if (d === l)
                    break;
                for (; d.sibling === null; ) {
                    if (d.return === null || d.return === l)
                        return !0;
                    d = d.return
                }
                d.sibling.return = d.return,
                d = d.sibling
            }
        }
        return !0
    }
    function Gl(l, d, p, x) {
        d &= ~VC,
        d &= ~tu,
        l.suspendedLanes |= d,
        l.pingedLanes &= ~d,
        x && (l.warmLanes |= d),
        x = l.expirationTimes;
        for (var _ = d; 0 < _; ) {
            var R = 31 - ut(_)
              , G = 1 << R;
            x[R] = -1,
            _ &= ~G
        }
        p !== 0 && it(l, p, d)
    }
    function ib() {
        return (Ln & 6) === 0 ? (rp(0),
        !1) : !0
    }
    function YC() {
        if (fn !== null) {
            if (Wn === 0)
                var l = fn.return;
            else
                l = fn,
                qs = Wc = null,
                uC(l),
                Ad = null,
                zh = 0,
                l = fn;
            for (; l !== null; )
                TD(l.alternate, l),
                l = l.return;
            fn = null
        }
    }
    function Bd(l, d) {
        var p = l.timeoutHandle;
        p !== -1 && (l.timeoutHandle = -1,
        cZ(p)),
        p = l.cancelPendingCommit,
        p !== null && (l.cancelPendingCommit = null,
        p()),
        nl = 0,
        YC(),
        rr = l,
        fn = p = Vs(l.current, null),
        vn = d,
        Wn = 0,
        Io = null,
        Vl = !1,
        $d = mr(l, d),
        UC = !1,
        Ld = $o = VC = tu = Hl = Ar = 0,
        io = tp = null,
        HC = !1,
        (d & 8) !== 0 && (d |= d & 32);
        var x = l.entangledLanes;
        if (x !== 0)
            for (l = l.entanglements,
            x &= d; 0 < x; ) {
                var _ = 31 - ut(x)
                  , R = 1 << _;
                d |= l[_],
                x &= ~R
            }
        return tl = d,
        Ty(),
        p
    }
    function ZD(l, d) {
        nn = null,
        j.H = Gh,
        d === Ed || d === Oy ? (d = dR(),
        Wn = 3) : d === XS ? (d = dR(),
        Wn = 4) : Wn = d === _C ? 8 : d !== null && typeof d == "object" && typeof d.then == "function" ? 6 : 1,
        Io = d,
        fn === null && (Ar = 1,
        Gy(l, na(d, l.current)))
    }
    function QD() {
        var l = Do.current;
        return l === null ? !0 : (vn & 4194048) === vn ? aa === null : (vn & 62914560) === vn || (vn & 536870912) !== 0 ? l === aa : !1
    }
    function KD() {
        var l = j.H;
        return j.H = Gh,
        l === null ? Gh : l
    }
    function XD() {
        var l = j.A;
        return j.A = NY,
        l
    }
    function ob() {
        Ar = 4,
        Vl || (vn & 4194048) !== vn && Do.current !== null || ($d = !0),
        (Hl & 134217727) === 0 && (tu & 134217727) === 0 || rr === null || Gl(rr, vn, $o, !1)
    }
    function ZC(l, d, p) {
        var x = Ln;
        Ln |= 2;
        var _ = KD()
          , R = XD();
        (rr !== l || vn !== d) && (rb = null,
        Bd(l, d)),
        d = !1;
        var G = Ar;
        e: do
            try {
                if (Wn !== 0 && fn !== null) {
                    var Q = fn
                      , ae = Io;
                    switch (Wn) {
                    case 8:
                        YC(),
                        G = 6;
                        break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                        Do.current === null && (d = !0);
                        var Ee = Wn;
                        if (Wn = 0,
                        Io = null,
                        zd(l, Q, ae, Ee),
                        p && $d) {
                            G = 0;
                            break e
                        }
                        break;
                    default:
                        Ee = Wn,
                        Wn = 0,
                        Io = null,
                        zd(l, Q, ae, Ee)
                    }
                }
                HY(),
                G = Ar;
                break
            } catch (Ue) {
                ZD(l, Ue)
            }
        while (!0);
        return d && l.shellSuspendCounter++,
        qs = Wc = null,
        Ln = x,
        j.H = _,
        j.A = R,
        fn === null && (rr = null,
        vn = 0,
        Ty()),
        G
    }
    function HY() {
        for (; fn !== null; )
            JD(fn)
    }
    function qY(l, d) {
        var p = Ln;
        Ln |= 2;
        var x = KD()
          , _ = XD();
        rr !== l || vn !== d ? (rb = null,
        nb = Oe() + 500,
        Bd(l, d)) : $d = mr(l, d);
        e: do
            try {
                if (Wn !== 0 && fn !== null) {
                    d = fn;
                    var R = Io;
                    t: switch (Wn) {
                    case 1:
                        Wn = 0,
                        Io = null,
                        zd(l, d, R, 1);
                        break;
                    case 2:
                    case 9:
                        if (cR(R)) {
                            Wn = 0,
                            Io = null,
                            eO(d);
                            break
                        }
                        d = function() {
                            Wn !== 2 && Wn !== 9 || rr !== l || (Wn = 7),
                            cs(l)
                        }
                        ,
                        R.then(d, d);
                        break e;
                    case 3:
                        Wn = 7;
                        break e;
                    case 4:
                        Wn = 5;
                        break e;
                    case 7:
                        cR(R) ? (Wn = 0,
                        Io = null,
                        eO(d)) : (Wn = 0,
                        Io = null,
                        zd(l, d, R, 7));
                        break;
                    case 5:
                        var G = null;
                        switch (fn.tag) {
                        case 26:
                            G = fn.memoizedState;
                        case 5:
                        case 27:
                            var Q = fn;
                            if (G ? zO(G) : Q.stateNode.complete) {
                                Wn = 0,
                                Io = null;
                                var ae = Q.sibling;
                                if (ae !== null)
                                    fn = ae;
                                else {
                                    var Ee = Q.return;
                                    Ee !== null ? (fn = Ee,
                                    ab(Ee)) : fn = null
                                }
                                break t
                            }
                        }
                        Wn = 0,
                        Io = null,
                        zd(l, d, R, 5);
                        break;
                    case 6:
                        Wn = 0,
                        Io = null,
                        zd(l, d, R, 6);
                        break;
                    case 8:
                        YC(),
                        Ar = 6;
                        break e;
                    default:
                        throw Error(r(462))
                    }
                }
                WY();
                break
            } catch (Ue) {
                ZD(l, Ue)
            }
        while (!0);
        return qs = Wc = null,
        j.H = x,
        j.A = _,
        Ln = p,
        fn !== null ? 0 : (rr = null,
        vn = 0,
        Ty(),
        Ar)
    }
    function WY() {
        for (; fn !== null && !fe(); )
            JD(fn)
    }
    function JD(l) {
        var d = wD(l.alternate, l, tl);
        l.memoizedProps = l.pendingProps,
        d === null ? ab(l) : fn = d
    }
    function eO(l) {
        var d = l
          , p = d.alternate;
        switch (d.tag) {
        case 15:
        case 0:
            d = yD(p, d, d.pendingProps, d.type, void 0, vn);
            break;
        case 11:
            d = yD(p, d, d.pendingProps, d.type.render, d.ref, vn);
            break;
        case 5:
            uC(d);
        default:
            TD(p, d),
            d = fn = XP(d, tl),
            d = wD(p, d, tl)
        }
        l.memoizedProps = l.pendingProps,
        d === null ? ab(l) : fn = d
    }
    function zd(l, d, p, x) {
        qs = Wc = null,
        uC(d),
        Ad = null,
        zh = 0;
        var _ = d.return;
        try {
            if (IY(l, _, d, p, vn)) {
                Ar = 1,
                Gy(l, na(p, l.current)),
                fn = null;
                return
            }
        } catch (R) {
            if (_ !== null)
                throw fn = _,
                R;
            Ar = 1,
            Gy(l, na(p, l.current)),
            fn = null;
            return
        }
        d.flags & 32768 ? (Tn || x === 1 ? l = !0 : $d || (vn & 536870912) !== 0 ? l = !1 : (Vl = l = !0,
        (x === 2 || x === 9 || x === 3 || x === 6) && (x = Do.current,
        x !== null && x.tag === 13 && (x.flags |= 16384))),
        tO(d, l)) : ab(d)
    }
    function ab(l) {
        var d = l;
        do {
            if ((d.flags & 32768) !== 0) {
                tO(d, Vl);
                return
            }
            l = d.return;
            var p = jY(d.alternate, d, tl);
            if (p !== null) {
                fn = p;
                return
            }
            if (d = d.sibling,
            d !== null) {
                fn = d;
                return
            }
            fn = d = l
        } while (d !== null);
        Ar === 0 && (Ar = 5)
    }
    function tO(l, d) {
        do {
            var p = BY(l.alternate, l);
            if (p !== null) {
                p.flags &= 32767,
                fn = p;
                return
            }
            if (p = l.return,
            p !== null && (p.flags |= 32768,
            p.subtreeFlags = 0,
            p.deletions = null),
            !d && (l = l.sibling,
            l !== null)) {
                fn = l;
                return
            }
            fn = l = p
        } while (l !== null);
        Ar = 6,
        fn = null
    }
    function nO(l, d, p, x, _, R, G, Q, ae) {
        l.cancelPendingCommit = null;
        do
            sb();
        while (ei !== 0);
        if ((Ln & 6) !== 0)
            throw Error(r(327));
        if (d !== null) {
            if (d === l.current)
                throw Error(r(177));
            if (R = d.lanes | d.childLanes,
            R |= jS,
            Le(l, p, R, G, Q, ae),
            l === rr && (fn = rr = null,
            vn = 0),
            jd = d,
            Wl = l,
            nl = p,
            qC = R,
            WC = _,
            qD = x,
            (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? (l.callbackNode = null,
            l.callbackPriority = 0,
            QY(He, function() {
                return sO(),
                null
            })) : (l.callbackNode = null,
            l.callbackPriority = 0),
            x = (d.flags & 13878) !== 0,
            (d.subtreeFlags & 13878) !== 0 || x) {
                x = j.T,
                j.T = null,
                _ = N.p,
                N.p = 2,
                G = Ln,
                Ln |= 4;
                try {
                    zY(l, d, p)
                } finally {
                    Ln = G,
                    N.p = _,
                    j.T = x
                }
            }
            ei = 1,
            rO(),
            iO(),
            oO()
        }
    }
    function rO() {
        if (ei === 1) {
            ei = 0;
            var l = Wl
              , d = jd
              , p = (d.flags & 13878) !== 0;
            if ((d.subtreeFlags & 13878) !== 0 || p) {
                p = j.T,
                j.T = null;
                var x = N.p;
                N.p = 2;
                var _ = Ln;
                Ln |= 4;
                try {
                    jD(d, l);
                    var R = sw
                      , G = VP(l.containerInfo)
                      , Q = R.focusedElem
                      , ae = R.selectionRange;
                    if (G !== Q && Q && Q.ownerDocument && UP(Q.ownerDocument.documentElement, Q)) {
                        if (ae !== null && DS(Q)) {
                            var Ee = ae.start
                              , Ue = ae.end;
                            if (Ue === void 0 && (Ue = Ee),
                            "selectionStart"in Q)
                                Q.selectionStart = Ee,
                                Q.selectionEnd = Math.min(Ue, Q.value.length);
                            else {
                                var We = Q.ownerDocument || document
                                  , Pe = We && We.defaultView || window;
                                if (Pe.getSelection) {
                                    var $e = Pe.getSelection()
                                      , vt = Q.textContent.length
                                      , Ut = Math.min(ae.start, vt)
                                      , er = ae.end === void 0 ? Ut : Math.min(ae.end, vt);
                                    !$e.extend && Ut > er && (G = er,
                                    er = Ut,
                                    Ut = G);
                                    var be = NP(Q, Ut)
                                      , pe = NP(Q, er);
                                    if (be && pe && ($e.rangeCount !== 1 || $e.anchorNode !== be.node || $e.anchorOffset !== be.offset || $e.focusNode !== pe.node || $e.focusOffset !== pe.offset)) {
                                        var _e = We.createRange();
                                        _e.setStart(be.node, be.offset),
                                        $e.removeAllRanges(),
                                        Ut > er ? ($e.addRange(_e),
                                        $e.extend(pe.node, pe.offset)) : (_e.setEnd(pe.node, pe.offset),
                                        $e.addRange(_e))
                                    }
                                }
                            }
                        }
                        for (We = [],
                        $e = Q; $e = $e.parentNode; )
                            $e.nodeType === 1 && We.push({
                                element: $e,
                                left: $e.scrollLeft,
                                top: $e.scrollTop
                            });
                        for (typeof Q.focus == "function" && Q.focus(),
                        Q = 0; Q < We.length; Q++) {
                            var qe = We[Q];
                            qe.element.scrollLeft = qe.left,
                            qe.element.scrollTop = qe.top
                        }
                    }
                    xb = !!aw,
                    sw = aw = null
                } finally {
                    Ln = _,
                    N.p = x,
                    j.T = p
                }
            }
            l.current = d,
            ei = 2
        }
    }
    function iO() {
        if (ei === 2) {
            ei = 0;
            var l = Wl
              , d = jd
              , p = (d.flags & 8772) !== 0;
            if ((d.subtreeFlags & 8772) !== 0 || p) {
                p = j.T,
                j.T = null;
                var x = N.p;
                N.p = 2;
                var _ = Ln;
                Ln |= 4;
                try {
                    DD(l, d.alternate, d)
                } finally {
                    Ln = _,
                    N.p = x,
                    j.T = p
                }
            }
            ei = 3
        }
    }
    function oO() {
        if (ei === 4 || ei === 3) {
            ei = 0,
            Xe();
            var l = Wl
              , d = jd
              , p = nl
              , x = qD;
            (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? ei = 5 : (ei = 0,
            jd = Wl = null,
            aO(l, l.pendingLanes));
            var _ = l.pendingLanes;
            if (_ === 0 && (ql = null),
            dn(p),
            d = d.stateNode,
            Pt && typeof Pt.onCommitFiberRoot == "function")
                try {
                    Pt.onCommitFiberRoot(Ft, d, void 0, (d.current.flags & 128) === 128)
                } catch {}
            if (x !== null) {
                d = j.T,
                _ = N.p,
                N.p = 2,
                j.T = null;
                try {
                    for (var R = l.onRecoverableError, G = 0; G < x.length; G++) {
                        var Q = x[G];
                        R(Q.value, {
                            componentStack: Q.stack
                        })
                    }
                } finally {
                    j.T = d,
                    N.p = _
                }
            }
            (nl & 3) !== 0 && sb(),
            cs(l),
            _ = l.pendingLanes,
            (p & 261930) !== 0 && (_ & 42) !== 0 ? l === GC ? np++ : (np = 0,
            GC = l) : np = 0,
            rp(0)
        }
    }
    function aO(l, d) {
        (l.pooledCacheLanes &= d) === 0 && (d = l.pooledCache,
        d != null && (l.pooledCache = null,
        jh(d)))
    }
    function sb() {
        return rO(),
        iO(),
        oO(),
        sO()
    }
    function sO() {
        if (ei !== 5)
            return !1;
        var l = Wl
          , d = qC;
        qC = 0;
        var p = dn(nl)
          , x = j.T
          , _ = N.p;
        try {
            N.p = 32 > p ? 32 : p,
            j.T = null,
            p = WC,
            WC = null;
            var R = Wl
              , G = nl;
            if (ei = 0,
            jd = Wl = null,
            nl = 0,
            (Ln & 6) !== 0)
                throw Error(r(331));
            var Q = Ln;
            if (Ln |= 4,
            UD(R.current),
            zD(R, R.current, G, p),
            Ln = Q,
            rp(0, !1),
            Pt && typeof Pt.onPostCommitFiberRoot == "function")
                try {
                    Pt.onPostCommitFiberRoot(Ft, R)
                } catch {}
            return !0
        } finally {
            N.p = _,
            j.T = x,
            aO(l, d)
        }
    }
    function lO(l, d, p) {
        d = na(p, d),
        d = TC(l.stateNode, d, 2),
        l = zl(l, d, 2),
        l !== null && (he(l, 2),
        cs(l))
    }
    function Gn(l, d, p) {
        if (l.tag === 3)
            lO(l, l, p);
        else
            for (; d !== null; ) {
                if (d.tag === 3) {
                    lO(d, l, p);
                    break
                } else if (d.tag === 1) {
                    var x = d.stateNode;
                    if (typeof d.type.getDerivedStateFromError == "function" || typeof x.componentDidCatch == "function" && (ql === null || !ql.has(x))) {
                        l = na(p, l),
                        p = cD(2),
                        x = zl(d, p, 2),
                        x !== null && (uD(p, x, d, l),
                        he(x, 2),
                        cs(x));
                        break
                    }
                }
                d = d.return
            }
    }
    function QC(l, d, p) {
        var x = l.pingCache;
        if (x === null) {
            x = l.pingCache = new UY;
            var _ = new Set;
            x.set(d, _)
        } else
            _ = x.get(d),
            _ === void 0 && (_ = new Set,
            x.set(d, _));
        _.has(p) || (UC = !0,
        _.add(p),
        l = GY.bind(null, l, d, p),
        d.then(l, l))
    }
    function GY(l, d, p) {
        var x = l.pingCache;
        x !== null && x.delete(d),
        l.pingedLanes |= l.suspendedLanes & p,
        l.warmLanes &= ~p,
        rr === l && (vn & p) === p && (Ar === 4 || Ar === 3 && (vn & 62914560) === vn && 300 > Oe() - tb ? (Ln & 2) === 0 && Bd(l, 0) : VC |= p,
        Ld === vn && (Ld = 0)),
        cs(l)
    }
    function cO(l, d) {
        d === 0 && (d = At()),
        l = Vc(l, d),
        l !== null && (he(l, d),
        cs(l))
    }
    function YY(l) {
        var d = l.memoizedState
          , p = 0;
        d !== null && (p = d.retryLane),
        cO(l, p)
    }
    function ZY(l, d) {
        var p = 0;
        switch (l.tag) {
        case 31:
        case 13:
            var x = l.stateNode
              , _ = l.memoizedState;
            _ !== null && (p = _.retryLane);
            break;
        case 19:
            x = l.stateNode;
            break;
        case 22:
            x = l.stateNode._retryCache;
            break;
        default:
            throw Error(r(314))
        }
        x !== null && x.delete(d),
        cO(l, p)
    }
    function QY(l, d) {
        return X(l, d)
    }
    var lb = null
      , Fd = null
      , KC = !1
      , cb = !1
      , XC = !1
      , Yl = 0;
    function cs(l) {
        l !== Fd && l.next === null && (Fd === null ? lb = Fd = l : Fd = Fd.next = l),
        cb = !0,
        KC || (KC = !0,
        XY())
    }
    function rp(l, d) {
        if (!XC && cb) {
            XC = !0;
            do
                for (var p = !1, x = lb; x !== null; ) {
                    if (l !== 0) {
                        var _ = x.pendingLanes;
                        if (_ === 0)
                            var R = 0;
                        else {
                            var G = x.suspendedLanes
                              , Q = x.pingedLanes;
                            R = (1 << 31 - ut(42 | l) + 1) - 1,
                            R &= _ & ~(G & ~Q),
                            R = R & 201326741 ? R & 201326741 | 1 : R ? R | 2 : 0
                        }
                        R !== 0 && (p = !0,
                        hO(x, R))
                    } else
                        R = vn,
                        R = vr(x, x === rr ? R : 0, x.cancelPendingCommit !== null || x.timeoutHandle !== -1),
                        (R & 3) === 0 || mr(x, R) || (p = !0,
                        hO(x, R));
                    x = x.next
                }
            while (p);
            XC = !1
        }
    }
    function KY() {
        uO()
    }
    function uO() {
        cb = KC = !1;
        var l = 0;
        Yl !== 0 && lZ() && (l = Yl);
        for (var d = Oe(), p = null, x = lb; x !== null; ) {
            var _ = x.next
              , R = dO(x, d);
            R === 0 ? (x.next = null,
            p === null ? lb = _ : p.next = _,
            _ === null && (Fd = p)) : (p = x,
            (l !== 0 || (R & 3) !== 0) && (cb = !0)),
            x = _
        }
        ei !== 0 && ei !== 5 || rp(l),
        Yl !== 0 && (Yl = 0)
    }
    function dO(l, d) {
        for (var p = l.suspendedLanes, x = l.pingedLanes, _ = l.expirationTimes, R = l.pendingLanes & -62914561; 0 < R; ) {
            var G = 31 - ut(R)
              , Q = 1 << G
              , ae = _[G];
            ae === -1 ? ((Q & p) === 0 || (Q & x) !== 0) && (_[G] = kn(Q, d)) : ae <= d && (l.expiredLanes |= Q),
            R &= ~Q
        }
        if (d = rr,
        p = vn,
        p = vr(l, l === d ? p : 0, l.cancelPendingCommit !== null || l.timeoutHandle !== -1),
        x = l.callbackNode,
        p === 0 || l === d && (Wn === 2 || Wn === 9) || l.cancelPendingCommit !== null)
            return x !== null && x !== null && ce(x),
            l.callbackNode = null,
            l.callbackPriority = 0;
        if ((p & 3) === 0 || mr(l, p)) {
            if (d = p & -p,
            d === l.callbackPriority)
                return d;
            switch (x !== null && ce(x),
            dn(p)) {
            case 2:
            case 8:
                p = ke;
                break;
            case 32:
                p = He;
                break;
            case 268435456:
                p = lt;
                break;
            default:
                p = He
            }
            return x = fO.bind(null, l),
            p = X(p, x),
            l.callbackPriority = d,
            l.callbackNode = p,
            d
        }
        return x !== null && x !== null && ce(x),
        l.callbackPriority = 2,
        l.callbackNode = null,
        2
    }
    function fO(l, d) {
        if (ei !== 0 && ei !== 5)
            return l.callbackNode = null,
            l.callbackPriority = 0,
            null;
        var p = l.callbackNode;
        if (sb() && l.callbackNode !== p)
            return null;
        var x = vn;
        return x = vr(l, l === rr ? x : 0, l.cancelPendingCommit !== null || l.timeoutHandle !== -1),
        x === 0 ? null : (GD(l, x, d),
        dO(l, Oe()),
        l.callbackNode != null && l.callbackNode === p ? fO.bind(null, l) : null)
    }
    function hO(l, d) {
        if (sb())
            return null;
        GD(l, d, !0)
    }
    function XY() {
        uZ(function() {
            (Ln & 6) !== 0 ? X(le, KY) : uO()
        })
    }
    function JC() {
        if (Yl === 0) {
            var l = Td;
            l === 0 && (l = Mn,
            Mn <<= 1,
            (Mn & 261888) === 0 && (Mn = 256)),
            Yl = l
        }
        return Yl
    }
    function pO(l) {
        return l == null || typeof l == "symbol" || typeof l == "boolean" ? null : typeof l == "function" ? l : yy("" + l)
    }
    function mO(l, d) {
        var p = d.ownerDocument.createElement("input");
        return p.name = d.name,
        p.value = d.value,
        l.id && p.setAttribute("form", l.id),
        d.parentNode.insertBefore(p, d),
        l = new FormData(l),
        p.parentNode.removeChild(p),
        l
    }
    function JY(l, d, p, x, _) {
        if (d === "submit" && p && p.stateNode === _) {
            var R = pO((_[en] || null).action)
              , G = x.submitter;
            G && (d = (d = G[en] || null) ? pO(d.formAction) : G.getAttribute("formAction"),
            d !== null && (R = d,
            G = null));
            var Q = new Sy("action","action",null,x,_);
            l.push({
                event: Q,
                listeners: [{
                    instance: null,
                    listener: function() {
                        if (x.defaultPrevented) {
                            if (Yl !== 0) {
                                var ae = G ? mO(_, G) : new FormData(_);
                                xC(p, {
                                    pending: !0,
                                    data: ae,
                                    method: _.method,
                                    action: R
                                }, null, ae)
                            }
                        } else
                            typeof R == "function" && (Q.preventDefault(),
                            ae = G ? mO(_, G) : new FormData(_),
                            xC(p, {
                                pending: !0,
                                data: ae,
                                method: _.method,
                                action: R
                            }, R, ae))
                    },
                    currentTarget: _
                }]
            })
        }
    }
    for (var ew = 0; ew < LS.length; ew++) {
        var tw = LS[ew]
          , eZ = tw.toLowerCase()
          , tZ = tw[0].toUpperCase() + tw.slice(1);
        Pa(eZ, "on" + tZ)
    }
    Pa(WP, "onAnimationEnd"),
    Pa(GP, "onAnimationIteration"),
    Pa(YP, "onAnimationStart"),
    Pa("dblclick", "onDoubleClick"),
    Pa("focusin", "onFocus"),
    Pa("focusout", "onBlur"),
    Pa(yY, "onTransitionRun"),
    Pa(bY, "onTransitionStart"),
    Pa(xY, "onTransitionCancel"),
    Pa(ZP, "onTransitionEnd"),
    Mo("onMouseEnter", ["mouseout", "mouseover"]),
    Mo("onMouseLeave", ["mouseout", "mouseover"]),
    Mo("onPointerEnter", ["pointerout", "pointerover"]),
    Mo("onPointerLeave", ["pointerout", "pointerover"]),
    ui("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    ui("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    ui("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    ui("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    ui("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    ui("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var ip = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , nZ = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ip));
    function gO(l, d) {
        d = (d & 4) !== 0;
        for (var p = 0; p < l.length; p++) {
            var x = l[p]
              , _ = x.event;
            x = x.listeners;
            e: {
                var R = void 0;
                if (d)
                    for (var G = x.length - 1; 0 <= G; G--) {
                        var Q = x[G]
                          , ae = Q.instance
                          , Ee = Q.currentTarget;
                        if (Q = Q.listener,
                        ae !== R && _.isPropagationStopped())
                            break e;
                        R = Q,
                        _.currentTarget = Ee;
                        try {
                            R(_)
                        } catch (Ue) {
                            ky(Ue)
                        }
                        _.currentTarget = null,
                        R = ae
                    }
                else
                    for (G = 0; G < x.length; G++) {
                        if (Q = x[G],
                        ae = Q.instance,
                        Ee = Q.currentTarget,
                        Q = Q.listener,
                        ae !== R && _.isPropagationStopped())
                            break e;
                        R = Q,
                        _.currentTarget = Ee;
                        try {
                            R(_)
                        } catch (Ue) {
                            ky(Ue)
                        }
                        _.currentTarget = null,
                        R = ae
                    }
            }
        }
    }
    function hn(l, d) {
        var p = d[is];
        p === void 0 && (p = d[is] = new Set);
        var x = l + "__bubble";
        p.has(x) || (yO(d, l, 2, !1),
        p.add(x))
    }
    function nw(l, d, p) {
        var x = 0;
        d && (x |= 4),
        yO(p, l, x, d)
    }
    var ub = "_reactListening" + Math.random().toString(36).slice(2);
    function rw(l) {
        if (!l[ub]) {
            l[ub] = !0,
            _r.forEach(function(p) {
                p !== "selectionchange" && (nZ.has(p) || nw(p, !1, l),
                nw(p, !0, l))
            });
            var d = l.nodeType === 9 ? l : l.ownerDocument;
            d === null || d[ub] || (d[ub] = !0,
            nw("selectionchange", !1, d))
        }
    }
    function yO(l, d, p, x) {
        switch (WO(d)) {
        case 2:
            var _ = PZ;
            break;
        case 8:
            _ = RZ;
            break;
        default:
            _ = bw
        }
        p = _.bind(null, d, p, l),
        _ = void 0,
        !wS || d !== "touchstart" && d !== "touchmove" && d !== "wheel" || (_ = !0),
        x ? _ !== void 0 ? l.addEventListener(d, p, {
            capture: !0,
            passive: _
        }) : l.addEventListener(d, p, !0) : _ !== void 0 ? l.addEventListener(d, p, {
            passive: _
        }) : l.addEventListener(d, p, !1)
    }
    function iw(l, d, p, x, _) {
        var R = x;
        if ((d & 1) === 0 && (d & 2) === 0 && x !== null)
            e: for (; ; ) {
                if (x === null)
                    return;
                var G = x.tag;
                if (G === 3 || G === 4) {
                    var Q = x.stateNode.containerInfo;
                    if (Q === _)
                        break;
                    if (G === 4)
                        for (G = x.return; G !== null; ) {
                            var ae = G.tag;
                            if ((ae === 3 || ae === 4) && G.stateNode.containerInfo === _)
                                return;
                            G = G.return
                        }
                    for (; Q !== null; ) {
                        if (G = De(Q),
                        G === null)
                            return;
                        if (ae = G.tag,
                        ae === 5 || ae === 6 || ae === 26 || ae === 27) {
                            x = R = G;
                            continue e
                        }
                        Q = Q.parentNode
                    }
                }
                x = x.return
            }
        CP(function() {
            var Ee = R
              , Ue = SS(p)
              , We = [];
            e: {
                var Pe = QP.get(l);
                if (Pe !== void 0) {
                    var $e = Sy
                      , vt = l;
                    switch (l) {
                    case "keypress":
                        if (xy(p) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        $e = ZG;
                        break;
                    case "focusin":
                        vt = "focus",
                        $e = ES;
                        break;
                    case "focusout":
                        vt = "blur",
                        $e = ES;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        $e = ES;
                        break;
                    case "click":
                        if (p.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        $e = TP;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        $e = jG;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        $e = XG;
                        break;
                    case WP:
                    case GP:
                    case YP:
                        $e = FG;
                        break;
                    case ZP:
                        $e = eY;
                        break;
                    case "scroll":
                    case "scrollend":
                        $e = $G;
                        break;
                    case "wheel":
                        $e = nY;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        $e = UG;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        $e = EP;
                        break;
                    case "toggle":
                    case "beforetoggle":
                        $e = iY
                    }
                    var Ut = (d & 4) !== 0
                      , er = !Ut && (l === "scroll" || l === "scrollend")
                      , be = Ut ? Pe !== null ? Pe + "Capture" : null : Pe;
                    Ut = [];
                    for (var pe = Ee, _e; pe !== null; ) {
                        var qe = pe;
                        if (_e = qe.stateNode,
                        qe = qe.tag,
                        qe !== 5 && qe !== 26 && qe !== 27 || _e === null || be === null || (qe = _h(pe, be),
                        qe != null && Ut.push(op(pe, qe, _e))),
                        er)
                            break;
                        pe = pe.return
                    }
                    0 < Ut.length && (Pe = new $e(Pe,vt,null,p,Ue),
                    We.push({
                        event: Pe,
                        listeners: Ut
                    }))
                }
            }
            if ((d & 7) === 0) {
                e: {
                    if (Pe = l === "mouseover" || l === "pointerover",
                    $e = l === "mouseout" || l === "pointerout",
                    Pe && p !== vS && (vt = p.relatedTarget || p.fromElement) && (De(vt) || vt[si]))
                        break e;
                    if (($e || Pe) && (Pe = Ue.window === Ue ? Ue : (Pe = Ue.ownerDocument) ? Pe.defaultView || Pe.parentWindow : window,
                    $e ? (vt = p.relatedTarget || p.toElement,
                    $e = Ee,
                    vt = vt ? De(vt) : null,
                    vt !== null && (er = o(vt),
                    Ut = vt.tag,
                    vt !== er || Ut !== 5 && Ut !== 27 && Ut !== 6) && (vt = null)) : ($e = null,
                    vt = Ee),
                    $e !== vt)) {
                        if (Ut = TP,
                        qe = "onMouseLeave",
                        be = "onMouseEnter",
                        pe = "mouse",
                        (l === "pointerout" || l === "pointerover") && (Ut = EP,
                        qe = "onPointerLeave",
                        be = "onPointerEnter",
                        pe = "pointer"),
                        er = $e == null ? Pe : Wt($e),
                        _e = vt == null ? Pe : Wt(vt),
                        Pe = new Ut(qe,pe + "leave",$e,p,Ue),
                        Pe.target = er,
                        Pe.relatedTarget = _e,
                        qe = null,
                        De(Ue) === Ee && (Ut = new Ut(be,pe + "enter",vt,p,Ue),
                        Ut.target = _e,
                        Ut.relatedTarget = er,
                        qe = Ut),
                        er = qe,
                        $e && vt)
                            t: {
                                for (Ut = rZ,
                                be = $e,
                                pe = vt,
                                _e = 0,
                                qe = be; qe; qe = Ut(qe))
                                    _e++;
                                qe = 0;
                                for (var Dt = pe; Dt; Dt = Ut(Dt))
                                    qe++;
                                for (; 0 < _e - qe; )
                                    be = Ut(be),
                                    _e--;
                                for (; 0 < qe - _e; )
                                    pe = Ut(pe),
                                    qe--;
                                for (; _e--; ) {
                                    if (be === pe || pe !== null && be === pe.alternate) {
                                        Ut = be;
                                        break t
                                    }
                                    be = Ut(be),
                                    pe = Ut(pe)
                                }
                                Ut = null
                            }
                        else
                            Ut = null;
                        $e !== null && bO(We, Pe, $e, Ut, !1),
                        vt !== null && er !== null && bO(We, er, vt, Ut, !0)
                    }
                }
                e: {
                    if (Pe = Ee ? Wt(Ee) : window,
                    $e = Pe.nodeName && Pe.nodeName.toLowerCase(),
                    $e === "select" || $e === "input" && Pe.type === "file")
                        var Rn = $P;
                    else if (OP(Pe))
                        if (LP)
                            Rn = pY;
                        else {
                            Rn = fY;
                            var Et = dY
                        }
                    else
                        $e = Pe.nodeName,
                        !$e || $e.toLowerCase() !== "input" || Pe.type !== "checkbox" && Pe.type !== "radio" ? Ee && xS(Ee.elementType) && (Rn = $P) : Rn = hY;
                    if (Rn && (Rn = Rn(l, Ee))) {
                        IP(We, Rn, p, Ue);
                        break e
                    }
                    Et && Et(l, Pe, Ee),
                    l === "focusout" && Ee && Pe.type === "number" && Ee.memoizedProps.value != null && bS(Pe, "number", Pe.value)
                }
                switch (Et = Ee ? Wt(Ee) : window,
                l) {
                case "focusin":
                    (OP(Et) || Et.contentEditable === "true") && (yd = Et,
                    OS = Ee,
                    Ih = null);
                    break;
                case "focusout":
                    Ih = OS = yd = null;
                    break;
                case "mousedown":
                    IS = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    IS = !1,
                    HP(We, p, Ue);
                    break;
                case "selectionchange":
                    if (gY)
                        break;
                case "keydown":
                case "keyup":
                    HP(We, p, Ue)
                }
                var on;
                if (MS)
                    e: {
                        switch (l) {
                        case "compositionstart":
                            var Sn = "onCompositionStart";
                            break e;
                        case "compositionend":
                            Sn = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            Sn = "onCompositionUpdate";
                            break e
                        }
                        Sn = void 0
                    }
                else
                    gd ? RP(l, p) && (Sn = "onCompositionEnd") : l === "keydown" && p.keyCode === 229 && (Sn = "onCompositionStart");
                Sn && (AP && p.locale !== "ko" && (gd || Sn !== "onCompositionStart" ? Sn === "onCompositionEnd" && gd && (on = wP()) : (Dl = Ue,
                kS = "value"in Dl ? Dl.value : Dl.textContent,
                gd = !0)),
                Et = db(Ee, Sn),
                0 < Et.length && (Sn = new _P(Sn,l,null,p,Ue),
                We.push({
                    event: Sn,
                    listeners: Et
                }),
                on ? Sn.data = on : (on = DP(p),
                on !== null && (Sn.data = on)))),
                (on = aY ? sY(l, p) : lY(l, p)) && (Sn = db(Ee, "onBeforeInput"),
                0 < Sn.length && (Et = new _P("onBeforeInput","beforeinput",null,p,Ue),
                We.push({
                    event: Et,
                    listeners: Sn
                }),
                Et.data = on)),
                JY(We, l, Ee, p, Ue)
            }
            gO(We, d)
        })
    }
    function op(l, d, p) {
        return {
            instance: l,
            listener: d,
            currentTarget: p
        }
    }
    function db(l, d) {
        for (var p = d + "Capture", x = []; l !== null; ) {
            var _ = l
              , R = _.stateNode;
            if (_ = _.tag,
            _ !== 5 && _ !== 26 && _ !== 27 || R === null || (_ = _h(l, p),
            _ != null && x.unshift(op(l, _, R)),
            _ = _h(l, d),
            _ != null && x.push(op(l, _, R))),
            l.tag === 3)
                return x;
            l = l.return
        }
        return []
    }
    function rZ(l) {
        if (l === null)
            return null;
        do
            l = l.return;
        while (l && l.tag !== 5 && l.tag !== 27);
        return l || null
    }
    function bO(l, d, p, x, _) {
        for (var R = d._reactName, G = []; p !== null && p !== x; ) {
            var Q = p
              , ae = Q.alternate
              , Ee = Q.stateNode;
            if (Q = Q.tag,
            ae !== null && ae === x)
                break;
            Q !== 5 && Q !== 26 && Q !== 27 || Ee === null || (ae = Ee,
            _ ? (Ee = _h(p, R),
            Ee != null && G.unshift(op(p, Ee, ae))) : _ || (Ee = _h(p, R),
            Ee != null && G.push(op(p, Ee, ae)))),
            p = p.return
        }
        G.length !== 0 && l.push({
            event: d,
            listeners: G
        })
    }
    var iZ = /\r\n?/g
      , oZ = /\u0000|\uFFFD/g;
    function xO(l) {
        return (typeof l == "string" ? l : "" + l).replace(iZ, `
`).replace(oZ, "")
    }
    function vO(l, d) {
        return d = xO(d),
        xO(l) === d
    }
    function Jn(l, d, p, x, _, R) {
        switch (p) {
        case "children":
            typeof x == "string" ? d === "body" || d === "textarea" && x === "" || hd(l, x) : (typeof x == "number" || typeof x == "bigint") && d !== "body" && hd(l, "" + x);
            break;
        case "className":
            my(l, "class", x);
            break;
        case "tabIndex":
            my(l, "tabindex", x);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            my(l, p, x);
            break;
        case "style":
            vP(l, x, R);
            break;
        case "data":
            if (d !== "object") {
                my(l, "data", x);
                break
            }
        case "src":
        case "href":
            if (x === "" && (d !== "a" || p !== "href")) {
                l.removeAttribute(p);
                break
            }
            if (x == null || typeof x == "function" || typeof x == "symbol" || typeof x == "boolean") {
                l.removeAttribute(p);
                break
            }
            x = yy("" + x),
            l.setAttribute(p, x);
            break;
        case "action":
        case "formAction":
            if (typeof x == "function") {
                l.setAttribute(p, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
            } else
                typeof R == "function" && (p === "formAction" ? (d !== "input" && Jn(l, d, "name", _.name, _, null),
                Jn(l, d, "formEncType", _.formEncType, _, null),
                Jn(l, d, "formMethod", _.formMethod, _, null),
                Jn(l, d, "formTarget", _.formTarget, _, null)) : (Jn(l, d, "encType", _.encType, _, null),
                Jn(l, d, "method", _.method, _, null),
                Jn(l, d, "target", _.target, _, null)));
            if (x == null || typeof x == "symbol" || typeof x == "boolean") {
                l.removeAttribute(p);
                break
            }
            x = yy("" + x),
            l.setAttribute(p, x);
            break;
        case "onClick":
            x != null && (l.onclick = Ns);
            break;
        case "onScroll":
            x != null && hn("scroll", l);
            break;
        case "onScrollEnd":
            x != null && hn("scrollend", l);
            break;
        case "dangerouslySetInnerHTML":
            if (x != null) {
                if (typeof x != "object" || !("__html"in x))
                    throw Error(r(61));
                if (p = x.__html,
                p != null) {
                    if (_.children != null)
                        throw Error(r(60));
                    l.innerHTML = p
                }
            }
            break;
        case "multiple":
            l.multiple = x && typeof x != "function" && typeof x != "symbol";
            break;
        case "muted":
            l.muted = x && typeof x != "function" && typeof x != "symbol";
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
            break;
        case "autoFocus":
            break;
        case "xlinkHref":
            if (x == null || typeof x == "function" || typeof x == "boolean" || typeof x == "symbol") {
                l.removeAttribute("xlink:href");
                break
            }
            p = yy("" + x),
            l.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", p);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            x != null && typeof x != "function" && typeof x != "symbol" ? l.setAttribute(p, "" + x) : l.removeAttribute(p);
            break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            x && typeof x != "function" && typeof x != "symbol" ? l.setAttribute(p, "") : l.removeAttribute(p);
            break;
        case "capture":
        case "download":
            x === !0 ? l.setAttribute(p, "") : x !== !1 && x != null && typeof x != "function" && typeof x != "symbol" ? l.setAttribute(p, x) : l.removeAttribute(p);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            x != null && typeof x != "function" && typeof x != "symbol" && !isNaN(x) && 1 <= x ? l.setAttribute(p, x) : l.removeAttribute(p);
            break;
        case "rowSpan":
        case "start":
            x == null || typeof x == "function" || typeof x == "symbol" || isNaN(x) ? l.removeAttribute(p) : l.setAttribute(p, x);
            break;
        case "popover":
            hn("beforetoggle", l),
            hn("toggle", l),
            py(l, "popover", x);
            break;
        case "xlinkActuate":
            Fs(l, "http://www.w3.org/1999/xlink", "xlink:actuate", x);
            break;
        case "xlinkArcrole":
            Fs(l, "http://www.w3.org/1999/xlink", "xlink:arcrole", x);
            break;
        case "xlinkRole":
            Fs(l, "http://www.w3.org/1999/xlink", "xlink:role", x);
            break;
        case "xlinkShow":
            Fs(l, "http://www.w3.org/1999/xlink", "xlink:show", x);
            break;
        case "xlinkTitle":
            Fs(l, "http://www.w3.org/1999/xlink", "xlink:title", x);
            break;
        case "xlinkType":
            Fs(l, "http://www.w3.org/1999/xlink", "xlink:type", x);
            break;
        case "xmlBase":
            Fs(l, "http://www.w3.org/XML/1998/namespace", "xml:base", x);
            break;
        case "xmlLang":
            Fs(l, "http://www.w3.org/XML/1998/namespace", "xml:lang", x);
            break;
        case "xmlSpace":
            Fs(l, "http://www.w3.org/XML/1998/namespace", "xml:space", x);
            break;
        case "is":
            py(l, "is", x);
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            (!(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (p = OG.get(p) || p,
            py(l, p, x))
        }
    }
    function ow(l, d, p, x, _, R) {
        switch (p) {
        case "style":
            vP(l, x, R);
            break;
        case "dangerouslySetInnerHTML":
            if (x != null) {
                if (typeof x != "object" || !("__html"in x))
                    throw Error(r(61));
                if (p = x.__html,
                p != null) {
                    if (_.children != null)
                        throw Error(r(60));
                    l.innerHTML = p
                }
            }
            break;
        case "children":
            typeof x == "string" ? hd(l, x) : (typeof x == "number" || typeof x == "bigint") && hd(l, "" + x);
            break;
        case "onScroll":
            x != null && hn("scroll", l);
            break;
        case "onScrollEnd":
            x != null && hn("scrollend", l);
            break;
        case "onClick":
            x != null && (l.onclick = Ns);
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            if (!Ii.hasOwnProperty(p))
                e: {
                    if (p[0] === "o" && p[1] === "n" && (_ = p.endsWith("Capture"),
                    d = p.slice(2, _ ? p.length - 7 : void 0),
                    R = l[en] || null,
                    R = R != null ? R[p] : null,
                    typeof R == "function" && l.removeEventListener(d, R, _),
                    typeof x == "function")) {
                        typeof R != "function" && R !== null && (p in l ? l[p] = null : l.hasAttribute(p) && l.removeAttribute(p)),
                        l.addEventListener(d, x, _);
                        break e
                    }
                    p in l ? l[p] = x : x === !0 ? l.setAttribute(p, "") : py(l, p, x)
                }
        }
    }
    function pi(l, d, p) {
        switch (d) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "img":
            hn("error", l),
            hn("load", l);
            var x = !1, _ = !1, R;
            for (R in p)
                if (p.hasOwnProperty(R)) {
                    var G = p[R];
                    if (G != null)
                        switch (R) {
                        case "src":
                            x = !0;
                            break;
                        case "srcSet":
                            _ = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(r(137, d));
                        default:
                            Jn(l, d, R, G, p, null)
                        }
                }
            _ && Jn(l, d, "srcSet", p.srcSet, p, null),
            x && Jn(l, d, "src", p.src, p, null);
            return;
        case "input":
            hn("invalid", l);
            var Q = R = G = _ = null
              , ae = null
              , Ee = null;
            for (x in p)
                if (p.hasOwnProperty(x)) {
                    var Ue = p[x];
                    if (Ue != null)
                        switch (x) {
                        case "name":
                            _ = Ue;
                            break;
                        case "type":
                            G = Ue;
                            break;
                        case "checked":
                            ae = Ue;
                            break;
                        case "defaultChecked":
                            Ee = Ue;
                            break;
                        case "value":
                            R = Ue;
                            break;
                        case "defaultValue":
                            Q = Ue;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (Ue != null)
                                throw Error(r(137, d));
                            break;
                        default:
                            Jn(l, d, x, Ue, p, null)
                        }
                }
            gP(l, R, Q, ae, Ee, G, _, !1);
            return;
        case "select":
            hn("invalid", l),
            x = G = R = null;
            for (_ in p)
                if (p.hasOwnProperty(_) && (Q = p[_],
                Q != null))
                    switch (_) {
                    case "value":
                        R = Q;
                        break;
                    case "defaultValue":
                        G = Q;
                        break;
                    case "multiple":
                        x = Q;
                    default:
                        Jn(l, d, _, Q, p, null)
                    }
            d = R,
            p = G,
            l.multiple = !!x,
            d != null ? fd(l, !!x, d, !1) : p != null && fd(l, !!x, p, !0);
            return;
        case "textarea":
            hn("invalid", l),
            R = _ = x = null;
            for (G in p)
                if (p.hasOwnProperty(G) && (Q = p[G],
                Q != null))
                    switch (G) {
                    case "value":
                        x = Q;
                        break;
                    case "defaultValue":
                        _ = Q;
                        break;
                    case "children":
                        R = Q;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (Q != null)
                            throw Error(r(91));
                        break;
                    default:
                        Jn(l, d, G, Q, p, null)
                    }
            bP(l, x, _, R);
            return;
        case "option":
            for (ae in p)
                if (p.hasOwnProperty(ae) && (x = p[ae],
                x != null))
                    switch (ae) {
                    case "selected":
                        l.selected = x && typeof x != "function" && typeof x != "symbol";
                        break;
                    default:
                        Jn(l, d, ae, x, p, null)
                    }
            return;
        case "dialog":
            hn("beforetoggle", l),
            hn("toggle", l),
            hn("cancel", l),
            hn("close", l);
            break;
        case "iframe":
        case "object":
            hn("load", l);
            break;
        case "video":
        case "audio":
            for (x = 0; x < ip.length; x++)
                hn(ip[x], l);
            break;
        case "image":
            hn("error", l),
            hn("load", l);
            break;
        case "details":
            hn("toggle", l);
            break;
        case "embed":
        case "source":
        case "link":
            hn("error", l),
            hn("load", l);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
            for (Ee in p)
                if (p.hasOwnProperty(Ee) && (x = p[Ee],
                x != null))
                    switch (Ee) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(r(137, d));
                    default:
                        Jn(l, d, Ee, x, p, null)
                    }
            return;
        default:
            if (xS(d)) {
                for (Ue in p)
                    p.hasOwnProperty(Ue) && (x = p[Ue],
                    x !== void 0 && ow(l, d, Ue, x, p, void 0));
                return
            }
        }
        for (Q in p)
            p.hasOwnProperty(Q) && (x = p[Q],
            x != null && Jn(l, d, Q, x, p, null))
    }
    function aZ(l, d, p, x) {
        switch (d) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "input":
            var _ = null
              , R = null
              , G = null
              , Q = null
              , ae = null
              , Ee = null
              , Ue = null;
            for ($e in p) {
                var We = p[$e];
                if (p.hasOwnProperty($e) && We != null)
                    switch ($e) {
                    case "checked":
                        break;
                    case "value":
                        break;
                    case "defaultValue":
                        ae = We;
                    default:
                        x.hasOwnProperty($e) || Jn(l, d, $e, null, x, We)
                    }
            }
            for (var Pe in x) {
                var $e = x[Pe];
                if (We = p[Pe],
                x.hasOwnProperty(Pe) && ($e != null || We != null))
                    switch (Pe) {
                    case "type":
                        R = $e;
                        break;
                    case "name":
                        _ = $e;
                        break;
                    case "checked":
                        Ee = $e;
                        break;
                    case "defaultChecked":
                        Ue = $e;
                        break;
                    case "value":
                        G = $e;
                        break;
                    case "defaultValue":
                        Q = $e;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if ($e != null)
                            throw Error(r(137, d));
                        break;
                    default:
                        $e !== We && Jn(l, d, Pe, $e, x, We)
                    }
            }
            yS(l, G, Q, ae, Ee, Ue, R, _);
            return;
        case "select":
            $e = G = Q = Pe = null;
            for (R in p)
                if (ae = p[R],
                p.hasOwnProperty(R) && ae != null)
                    switch (R) {
                    case "value":
                        break;
                    case "multiple":
                        $e = ae;
                    default:
                        x.hasOwnProperty(R) || Jn(l, d, R, null, x, ae)
                    }
            for (_ in x)
                if (R = x[_],
                ae = p[_],
                x.hasOwnProperty(_) && (R != null || ae != null))
                    switch (_) {
                    case "value":
                        Pe = R;
                        break;
                    case "defaultValue":
                        Q = R;
                        break;
                    case "multiple":
                        G = R;
                    default:
                        R !== ae && Jn(l, d, _, R, x, ae)
                    }
            d = Q,
            p = G,
            x = $e,
            Pe != null ? fd(l, !!p, Pe, !1) : !!x != !!p && (d != null ? fd(l, !!p, d, !0) : fd(l, !!p, p ? [] : "", !1));
            return;
        case "textarea":
            $e = Pe = null;
            for (Q in p)
                if (_ = p[Q],
                p.hasOwnProperty(Q) && _ != null && !x.hasOwnProperty(Q))
                    switch (Q) {
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        Jn(l, d, Q, null, x, _)
                    }
            for (G in x)
                if (_ = x[G],
                R = p[G],
                x.hasOwnProperty(G) && (_ != null || R != null))
                    switch (G) {
                    case "value":
                        Pe = _;
                        break;
                    case "defaultValue":
                        $e = _;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (_ != null)
                            throw Error(r(91));
                        break;
                    default:
                        _ !== R && Jn(l, d, G, _, x, R)
                    }
            yP(l, Pe, $e);
            return;
        case "option":
            for (var vt in p)
                if (Pe = p[vt],
                p.hasOwnProperty(vt) && Pe != null && !x.hasOwnProperty(vt))
                    switch (vt) {
                    case "selected":
                        l.selected = !1;
                        break;
                    default:
                        Jn(l, d, vt, null, x, Pe)
                    }
            for (ae in x)
                if (Pe = x[ae],
                $e = p[ae],
                x.hasOwnProperty(ae) && Pe !== $e && (Pe != null || $e != null))
                    switch (ae) {
                    case "selected":
                        l.selected = Pe && typeof Pe != "function" && typeof Pe != "symbol";
                        break;
                    default:
                        Jn(l, d, ae, Pe, x, $e)
                    }
            return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
            for (var Ut in p)
                Pe = p[Ut],
                p.hasOwnProperty(Ut) && Pe != null && !x.hasOwnProperty(Ut) && Jn(l, d, Ut, null, x, Pe);
            for (Ee in x)
                if (Pe = x[Ee],
                $e = p[Ee],
                x.hasOwnProperty(Ee) && Pe !== $e && (Pe != null || $e != null))
                    switch (Ee) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Pe != null)
                            throw Error(r(137, d));
                        break;
                    default:
                        Jn(l, d, Ee, Pe, x, $e)
                    }
            return;
        default:
            if (xS(d)) {
                for (var er in p)
                    Pe = p[er],
                    p.hasOwnProperty(er) && Pe !== void 0 && !x.hasOwnProperty(er) && ow(l, d, er, void 0, x, Pe);
                for (Ue in x)
                    Pe = x[Ue],
                    $e = p[Ue],
                    !x.hasOwnProperty(Ue) || Pe === $e || Pe === void 0 && $e === void 0 || ow(l, d, Ue, Pe, x, $e);
                return
            }
        }
        for (var be in p)
            Pe = p[be],
            p.hasOwnProperty(be) && Pe != null && !x.hasOwnProperty(be) && Jn(l, d, be, null, x, Pe);
        for (We in x)
            Pe = x[We],
            $e = p[We],
            !x.hasOwnProperty(We) || Pe === $e || Pe == null && $e == null || Jn(l, d, We, Pe, x, $e)
    }
    function SO(l) {
        switch (l) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
            return !0;
        default:
            return !1
        }
    }
    function sZ() {
        if (typeof performance.getEntriesByType == "function") {
            for (var l = 0, d = 0, p = performance.getEntriesByType("resource"), x = 0; x < p.length; x++) {
                var _ = p[x]
                  , R = _.transferSize
                  , G = _.initiatorType
                  , Q = _.duration;
                if (R && Q && SO(G)) {
                    for (G = 0,
                    Q = _.responseEnd,
                    x += 1; x < p.length; x++) {
                        var ae = p[x]
                          , Ee = ae.startTime;
                        if (Ee > Q)
                            break;
                        var Ue = ae.transferSize
                          , We = ae.initiatorType;
                        Ue && SO(We) && (ae = ae.responseEnd,
                        G += Ue * (ae < Q ? 1 : (Q - Ee) / (ae - Ee)))
                    }
                    if (--x,
                    d += 8 * (R + G) / (_.duration / 1e3),
                    l++,
                    10 < l)
                        break
                }
            }
            if (0 < l)
                return d / l / 1e6
        }
        return navigator.connection && (l = navigator.connection.downlink,
        typeof l == "number") ? l : 5
    }
    var aw = null
      , sw = null;
    function fb(l) {
        return l.nodeType === 9 ? l : l.ownerDocument
    }
    function CO(l) {
        switch (l) {
        case "http://www.w3.org/2000/svg":
            return 1;
        case "http://www.w3.org/1998/Math/MathML":
            return 2;
        default:
            return 0
        }
    }
    function wO(l, d) {
        if (l === 0)
            switch (d) {
            case "svg":
                return 1;
            case "math":
                return 2;
            default:
                return 0
            }
        return l === 1 && d === "foreignObject" ? 0 : l
    }
    function lw(l, d) {
        return l === "textarea" || l === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.children == "bigint" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null
    }
    var cw = null;
    function lZ() {
        var l = window.event;
        return l && l.type === "popstate" ? l === cw ? !1 : (cw = l,
        !0) : (cw = null,
        !1)
    }
    var kO = typeof setTimeout == "function" ? setTimeout : void 0
      , cZ = typeof clearTimeout == "function" ? clearTimeout : void 0
      , TO = typeof Promise == "function" ? Promise : void 0
      , uZ = typeof queueMicrotask == "function" ? queueMicrotask : typeof TO < "u" ? function(l) {
        return TO.resolve(null).then(l).catch(dZ)
    }
    : kO;
    function dZ(l) {
        setTimeout(function() {
            throw l
        })
    }
    function Zl(l) {
        return l === "head"
    }
    function _O(l, d) {
        var p = d
          , x = 0;
        do {
            var _ = p.nextSibling;
            if (l.removeChild(p),
            _ && _.nodeType === 8)
                if (p = _.data,
                p === "/$" || p === "/&") {
                    if (x === 0) {
                        l.removeChild(_),
                        Hd(d);
                        return
                    }
                    x--
                } else if (p === "$" || p === "$?" || p === "$~" || p === "$!" || p === "&")
                    x++;
                else if (p === "html")
                    ap(l.ownerDocument.documentElement);
                else if (p === "head") {
                    p = l.ownerDocument.head,
                    ap(p);
                    for (var R = p.firstChild; R; ) {
                        var G = R.nextSibling
                          , Q = R.nodeName;
                        R[me] || Q === "SCRIPT" || Q === "STYLE" || Q === "LINK" && R.rel.toLowerCase() === "stylesheet" || p.removeChild(R),
                        R = G
                    }
                } else
                    p === "body" && ap(l.ownerDocument.body);
            p = _
        } while (p);
        Hd(d)
    }
    function EO(l, d) {
        var p = l;
        l = 0;
        do {
            var x = p.nextSibling;
            if (p.nodeType === 1 ? d ? (p._stashedDisplay = p.style.display,
            p.style.display = "none") : (p.style.display = p._stashedDisplay || "",
            p.getAttribute("style") === "" && p.removeAttribute("style")) : p.nodeType === 3 && (d ? (p._stashedText = p.nodeValue,
            p.nodeValue = "") : p.nodeValue = p._stashedText || ""),
            x && x.nodeType === 8)
                if (p = x.data,
                p === "/$") {
                    if (l === 0)
                        break;
                    l--
                } else
                    p !== "$" && p !== "$?" && p !== "$~" && p !== "$!" || l++;
            p = x
        } while (p)
    }
    function uw(l) {
        var d = l.firstChild;
        for (d && d.nodeType === 10 && (d = d.nextSibling); d; ) {
            var p = d;
            switch (d = d.nextSibling,
            p.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
                uw(p),
                ne(p);
                continue;
            case "SCRIPT":
            case "STYLE":
                continue;
            case "LINK":
                if (p.rel.toLowerCase() === "stylesheet")
                    continue
            }
            l.removeChild(p)
        }
    }
    function fZ(l, d, p, x) {
        for (; l.nodeType === 1; ) {
            var _ = p;
            if (l.nodeName.toLowerCase() !== d.toLowerCase()) {
                if (!x && (l.nodeName !== "INPUT" || l.type !== "hidden"))
                    break
            } else if (x) {
                if (!l[me])
                    switch (d) {
                    case "meta":
                        if (!l.hasAttribute("itemprop"))
                            break;
                        return l;
                    case "link":
                        if (R = l.getAttribute("rel"),
                        R === "stylesheet" && l.hasAttribute("data-precedence"))
                            break;
                        if (R !== _.rel || l.getAttribute("href") !== (_.href == null || _.href === "" ? null : _.href) || l.getAttribute("crossorigin") !== (_.crossOrigin == null ? null : _.crossOrigin) || l.getAttribute("title") !== (_.title == null ? null : _.title))
                            break;
                        return l;
                    case "style":
                        if (l.hasAttribute("data-precedence"))
                            break;
                        return l;
                    case "script":
                        if (R = l.getAttribute("src"),
                        (R !== (_.src == null ? null : _.src) || l.getAttribute("type") !== (_.type == null ? null : _.type) || l.getAttribute("crossorigin") !== (_.crossOrigin == null ? null : _.crossOrigin)) && R && l.hasAttribute("async") && !l.hasAttribute("itemprop"))
                            break;
                        return l;
                    default:
                        return l
                    }
            } else if (d === "input" && l.type === "hidden") {
                var R = _.name == null ? null : "" + _.name;
                if (_.type === "hidden" && l.getAttribute("name") === R)
                    return l
            } else
                return l;
            if (l = sa(l.nextSibling),
            l === null)
                break
        }
        return null
    }
    function hZ(l, d, p) {
        if (d === "")
            return null;
        for (; l.nodeType !== 3; )
            if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !p || (l = sa(l.nextSibling),
            l === null))
                return null;
        return l
    }
    function AO(l, d) {
        for (; l.nodeType !== 8; )
            if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !d || (l = sa(l.nextSibling),
            l === null))
                return null;
        return l
    }
    function dw(l) {
        return l.data === "$?" || l.data === "$~"
    }
    function fw(l) {
        return l.data === "$!" || l.data === "$?" && l.ownerDocument.readyState !== "loading"
    }
    function pZ(l, d) {
        var p = l.ownerDocument;
        if (l.data === "$~")
            l._reactRetry = d;
        else if (l.data !== "$?" || p.readyState !== "loading")
            d();
        else {
            var x = function() {
                d(),
                p.removeEventListener("DOMContentLoaded", x)
            };
            p.addEventListener("DOMContentLoaded", x),
            l._reactRetry = x
        }
    }
    function sa(l) {
        for (; l != null; l = l.nextSibling) {
            var d = l.nodeType;
            if (d === 1 || d === 3)
                break;
            if (d === 8) {
                if (d = l.data,
                d === "$" || d === "$!" || d === "$?" || d === "$~" || d === "&" || d === "F!" || d === "F")
                    break;
                if (d === "/$" || d === "/&")
                    return null
            }
        }
        return l
    }
    var hw = null;
    function MO(l) {
        l = l.nextSibling;
        for (var d = 0; l; ) {
            if (l.nodeType === 8) {
                var p = l.data;
                if (p === "/$" || p === "/&") {
                    if (d === 0)
                        return sa(l.nextSibling);
                    d--
                } else
                    p !== "$" && p !== "$!" && p !== "$?" && p !== "$~" && p !== "&" || d++
            }
            l = l.nextSibling
        }
        return null
    }
    function PO(l) {
        l = l.previousSibling;
        for (var d = 0; l; ) {
            if (l.nodeType === 8) {
                var p = l.data;
                if (p === "$" || p === "$!" || p === "$?" || p === "$~" || p === "&") {
                    if (d === 0)
                        return l;
                    d--
                } else
                    p !== "/$" && p !== "/&" || d++
            }
            l = l.previousSibling
        }
        return null
    }
    function RO(l, d, p) {
        switch (d = fb(p),
        l) {
        case "html":
            if (l = d.documentElement,
            !l)
                throw Error(r(452));
            return l;
        case "head":
            if (l = d.head,
            !l)
                throw Error(r(453));
            return l;
        case "body":
            if (l = d.body,
            !l)
                throw Error(r(454));
            return l;
        default:
            throw Error(r(451))
        }
    }
    function ap(l) {
        for (var d = l.attributes; d.length; )
            l.removeAttributeNode(d[0]);
        ne(l)
    }
    var la = new Map
      , DO = new Set;
    function hb(l) {
        return typeof l.getRootNode == "function" ? l.getRootNode() : l.nodeType === 9 ? l : l.ownerDocument
    }
    var rl = N.d;
    N.d = {
        f: mZ,
        r: gZ,
        D: yZ,
        C: bZ,
        L: xZ,
        m: vZ,
        X: CZ,
        S: SZ,
        M: wZ
    };
    function mZ() {
        var l = rl.f()
          , d = ib();
        return l || d
    }
    function gZ(l) {
        var d = Ze(l);
        d !== null && d.tag === 5 && d.type === "form" ? ZR(d) : rl.r(l)
    }
    var Nd = typeof document > "u" ? null : document;
    function OO(l, d, p) {
        var x = Nd;
        if (x && typeof d == "string" && d) {
            var _ = ea(d);
            _ = 'link[rel="' + l + '"][href="' + _ + '"]',
            typeof p == "string" && (_ += '[crossorigin="' + p + '"]'),
            DO.has(_) || (DO.add(_),
            l = {
                rel: l,
                crossOrigin: p,
                href: d
            },
            x.querySelector(_) === null && (d = x.createElement("link"),
            pi(d, "link", l),
            Nt(d),
            x.head.appendChild(d)))
        }
    }
    function yZ(l) {
        rl.D(l),
        OO("dns-prefetch", l, null)
    }
    function bZ(l, d) {
        rl.C(l, d),
        OO("preconnect", l, d)
    }
    function xZ(l, d, p) {
        rl.L(l, d, p);
        var x = Nd;
        if (x && l && d) {
            var _ = 'link[rel="preload"][as="' + ea(d) + '"]';
            d === "image" && p && p.imageSrcSet ? (_ += '[imagesrcset="' + ea(p.imageSrcSet) + '"]',
            typeof p.imageSizes == "string" && (_ += '[imagesizes="' + ea(p.imageSizes) + '"]')) : _ += '[href="' + ea(l) + '"]';
            var R = _;
            switch (d) {
            case "style":
                R = Ud(l);
                break;
            case "script":
                R = Vd(l)
            }
            la.has(R) || (l = h({
                rel: "preload",
                href: d === "image" && p && p.imageSrcSet ? void 0 : l,
                as: d
            }, p),
            la.set(R, l),
            x.querySelector(_) !== null || d === "style" && x.querySelector(sp(R)) || d === "script" && x.querySelector(lp(R)) || (d = x.createElement("link"),
            pi(d, "link", l),
            Nt(d),
            x.head.appendChild(d)))
        }
    }
    function vZ(l, d) {
        rl.m(l, d);
        var p = Nd;
        if (p && l) {
            var x = d && typeof d.as == "string" ? d.as : "script"
              , _ = 'link[rel="modulepreload"][as="' + ea(x) + '"][href="' + ea(l) + '"]'
              , R = _;
            switch (x) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                R = Vd(l)
            }
            if (!la.has(R) && (l = h({
                rel: "modulepreload",
                href: l
            }, d),
            la.set(R, l),
            p.querySelector(_) === null)) {
                switch (x) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                    if (p.querySelector(lp(R)))
                        return
                }
                x = p.createElement("link"),
                pi(x, "link", l),
                Nt(x),
                p.head.appendChild(x)
            }
        }
    }
    function SZ(l, d, p) {
        rl.S(l, d, p);
        var x = Nd;
        if (x && l) {
            var _ = Zt(x).hoistableStyles
              , R = Ud(l);
            d = d || "default";
            var G = _.get(R);
            if (!G) {
                var Q = {
                    loading: 0,
                    preload: null
                };
                if (G = x.querySelector(sp(R)))
                    Q.loading = 5;
                else {
                    l = h({
                        rel: "stylesheet",
                        href: l,
                        "data-precedence": d
                    }, p),
                    (p = la.get(R)) && pw(l, p);
                    var ae = G = x.createElement("link");
                    Nt(ae),
                    pi(ae, "link", l),
                    ae._p = new Promise(function(Ee, Ue) {
                        ae.onload = Ee,
                        ae.onerror = Ue
                    }
                    ),
                    ae.addEventListener("load", function() {
                        Q.loading |= 1
                    }),
                    ae.addEventListener("error", function() {
                        Q.loading |= 2
                    }),
                    Q.loading |= 4,
                    pb(G, d, x)
                }
                G = {
                    type: "stylesheet",
                    instance: G,
                    count: 1,
                    state: Q
                },
                _.set(R, G)
            }
        }
    }
    function CZ(l, d) {
        rl.X(l, d);
        var p = Nd;
        if (p && l) {
            var x = Zt(p).hoistableScripts
              , _ = Vd(l)
              , R = x.get(_);
            R || (R = p.querySelector(lp(_)),
            R || (l = h({
                src: l,
                async: !0
            }, d),
            (d = la.get(_)) && mw(l, d),
            R = p.createElement("script"),
            Nt(R),
            pi(R, "link", l),
            p.head.appendChild(R)),
            R = {
                type: "script",
                instance: R,
                count: 1,
                state: null
            },
            x.set(_, R))
        }
    }
    function wZ(l, d) {
        rl.M(l, d);
        var p = Nd;
        if (p && l) {
            var x = Zt(p).hoistableScripts
              , _ = Vd(l)
              , R = x.get(_);
            R || (R = p.querySelector(lp(_)),
            R || (l = h({
                src: l,
                async: !0,
                type: "module"
            }, d),
            (d = la.get(_)) && mw(l, d),
            R = p.createElement("script"),
            Nt(R),
            pi(R, "link", l),
            p.head.appendChild(R)),
            R = {
                type: "script",
                instance: R,
                count: 1,
                state: null
            },
            x.set(_, R))
        }
    }
    function IO(l, d, p, x) {
        var _ = (_ = ee.current) ? hb(_) : null;
        if (!_)
            throw Error(r(446));
        switch (l) {
        case "meta":
        case "title":
            return null;
        case "style":
            return typeof p.precedence == "string" && typeof p.href == "string" ? (d = Ud(p.href),
            p = Zt(_).hoistableStyles,
            x = p.get(d),
            x || (x = {
                type: "style",
                instance: null,
                count: 0,
                state: null
            },
            p.set(d, x)),
            x) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        case "link":
            if (p.rel === "stylesheet" && typeof p.href == "string" && typeof p.precedence == "string") {
                l = Ud(p.href);
                var R = Zt(_).hoistableStyles
                  , G = R.get(l);
                if (G || (_ = _.ownerDocument || _,
                G = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                        loading: 0,
                        preload: null
                    }
                },
                R.set(l, G),
                (R = _.querySelector(sp(l))) && !R._p && (G.instance = R,
                G.state.loading = 5),
                la.has(l) || (p = {
                    rel: "preload",
                    as: "style",
                    href: p.href,
                    crossOrigin: p.crossOrigin,
                    integrity: p.integrity,
                    media: p.media,
                    hrefLang: p.hrefLang,
                    referrerPolicy: p.referrerPolicy
                },
                la.set(l, p),
                R || kZ(_, l, p, G.state))),
                d && x === null)
                    throw Error(r(528, ""));
                return G
            }
            if (d && x !== null)
                throw Error(r(529, ""));
            return null;
        case "script":
            return d = p.async,
            p = p.src,
            typeof p == "string" && d && typeof d != "function" && typeof d != "symbol" ? (d = Vd(p),
            p = Zt(_).hoistableScripts,
            x = p.get(d),
            x || (x = {
                type: "script",
                instance: null,
                count: 0,
                state: null
            },
            p.set(d, x)),
            x) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        default:
            throw Error(r(444, l))
        }
    }
    function Ud(l) {
        return 'href="' + ea(l) + '"'
    }
    function sp(l) {
        return 'link[rel="stylesheet"][' + l + "]"
    }
    function $O(l) {
        return h({}, l, {
            "data-precedence": l.precedence,
            precedence: null
        })
    }
    function kZ(l, d, p, x) {
        l.querySelector('link[rel="preload"][as="style"][' + d + "]") ? x.loading = 1 : (d = l.createElement("link"),
        x.preload = d,
        d.addEventListener("load", function() {
            return x.loading |= 1
        }),
        d.addEventListener("error", function() {
            return x.loading |= 2
        }),
        pi(d, "link", p),
        Nt(d),
        l.head.appendChild(d))
    }
    function Vd(l) {
        return '[src="' + ea(l) + '"]'
    }
    function lp(l) {
        return "script[async]" + l
    }
    function LO(l, d, p) {
        if (d.count++,
        d.instance === null)
            switch (d.type) {
            case "style":
                var x = l.querySelector('style[data-href~="' + ea(p.href) + '"]');
                if (x)
                    return d.instance = x,
                    Nt(x),
                    x;
                var _ = h({}, p, {
                    "data-href": p.href,
                    "data-precedence": p.precedence,
                    href: null,
                    precedence: null
                });
                return x = (l.ownerDocument || l).createElement("style"),
                Nt(x),
                pi(x, "style", _),
                pb(x, p.precedence, l),
                d.instance = x;
            case "stylesheet":
                _ = Ud(p.href);
                var R = l.querySelector(sp(_));
                if (R)
                    return d.state.loading |= 4,
                    d.instance = R,
                    Nt(R),
                    R;
                x = $O(p),
                (_ = la.get(_)) && pw(x, _),
                R = (l.ownerDocument || l).createElement("link"),
                Nt(R);
                var G = R;
                return G._p = new Promise(function(Q, ae) {
                    G.onload = Q,
                    G.onerror = ae
                }
                ),
                pi(R, "link", x),
                d.state.loading |= 4,
                pb(R, p.precedence, l),
                d.instance = R;
            case "script":
                return R = Vd(p.src),
                (_ = l.querySelector(lp(R))) ? (d.instance = _,
                Nt(_),
                _) : (x = p,
                (_ = la.get(R)) && (x = h({}, p),
                mw(x, _)),
                l = l.ownerDocument || l,
                _ = l.createElement("script"),
                Nt(_),
                pi(_, "link", x),
                l.head.appendChild(_),
                d.instance = _);
            case "void":
                return null;
            default:
                throw Error(r(443, d.type))
            }
        else
            d.type === "stylesheet" && (d.state.loading & 4) === 0 && (x = d.instance,
            d.state.loading |= 4,
            pb(x, p.precedence, l));
        return d.instance
    }
    function pb(l, d, p) {
        for (var x = p.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), _ = x.length ? x[x.length - 1] : null, R = _, G = 0; G < x.length; G++) {
            var Q = x[G];
            if (Q.dataset.precedence === d)
                R = Q;
            else if (R !== _)
                break
        }
        R ? R.parentNode.insertBefore(l, R.nextSibling) : (d = p.nodeType === 9 ? p.head : p,
        d.insertBefore(l, d.firstChild))
    }
    function pw(l, d) {
        l.crossOrigin == null && (l.crossOrigin = d.crossOrigin),
        l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy),
        l.title == null && (l.title = d.title)
    }
    function mw(l, d) {
        l.crossOrigin == null && (l.crossOrigin = d.crossOrigin),
        l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy),
        l.integrity == null && (l.integrity = d.integrity)
    }
    var mb = null;
    function jO(l, d, p) {
        if (mb === null) {
            var x = new Map
              , _ = mb = new Map;
            _.set(p, x)
        } else
            _ = mb,
            x = _.get(p),
            x || (x = new Map,
            _.set(p, x));
        if (x.has(l))
            return x;
        for (x.set(l, null),
        p = p.getElementsByTagName(l),
        _ = 0; _ < p.length; _++) {
            var R = p[_];
            if (!(R[me] || R[ln] || l === "link" && R.getAttribute("rel") === "stylesheet") && R.namespaceURI !== "http://www.w3.org/2000/svg") {
                var G = R.getAttribute(d) || "";
                G = l + G;
                var Q = x.get(G);
                Q ? Q.push(R) : x.set(G, [R])
            }
        }
        return x
    }
    function BO(l, d, p) {
        l = l.ownerDocument || l,
        l.head.insertBefore(p, d === "title" ? l.querySelector("head > title") : null)
    }
    function TZ(l, d, p) {
        if (p === 1 || d.itemProp != null)
            return !1;
        switch (l) {
        case "meta":
        case "title":
            return !0;
        case "style":
            if (typeof d.precedence != "string" || typeof d.href != "string" || d.href === "")
                break;
            return !0;
        case "link":
            if (typeof d.rel != "string" || typeof d.href != "string" || d.href === "" || d.onLoad || d.onError)
                break;
            switch (d.rel) {
            case "stylesheet":
                return l = d.disabled,
                typeof d.precedence == "string" && l == null;
            default:
                return !0
            }
        case "script":
            if (d.async && typeof d.async != "function" && typeof d.async != "symbol" && !d.onLoad && !d.onError && d.src && typeof d.src == "string")
                return !0
        }
        return !1
    }
    function zO(l) {
        return !(l.type === "stylesheet" && (l.state.loading & 3) === 0)
    }
    function _Z(l, d, p, x) {
        if (p.type === "stylesheet" && (typeof x.media != "string" || matchMedia(x.media).matches !== !1) && (p.state.loading & 4) === 0) {
            if (p.instance === null) {
                var _ = Ud(x.href)
                  , R = d.querySelector(sp(_));
                if (R) {
                    d = R._p,
                    d !== null && typeof d == "object" && typeof d.then == "function" && (l.count++,
                    l = gb.bind(l),
                    d.then(l, l)),
                    p.state.loading |= 4,
                    p.instance = R,
                    Nt(R);
                    return
                }
                R = d.ownerDocument || d,
                x = $O(x),
                (_ = la.get(_)) && pw(x, _),
                R = R.createElement("link"),
                Nt(R);
                var G = R;
                G._p = new Promise(function(Q, ae) {
                    G.onload = Q,
                    G.onerror = ae
                }
                ),
                pi(R, "link", x),
                p.instance = R
            }
            l.stylesheets === null && (l.stylesheets = new Map),
            l.stylesheets.set(p, d),
            (d = p.state.preload) && (p.state.loading & 3) === 0 && (l.count++,
            p = gb.bind(l),
            d.addEventListener("load", p),
            d.addEventListener("error", p))
        }
    }
    var gw = 0;
    function EZ(l, d) {
        return l.stylesheets && l.count === 0 && bb(l, l.stylesheets),
        0 < l.count || 0 < l.imgCount ? function(p) {
            var x = setTimeout(function() {
                if (l.stylesheets && bb(l, l.stylesheets),
                l.unsuspend) {
                    var R = l.unsuspend;
                    l.unsuspend = null,
                    R()
                }
            }, 6e4 + d);
            0 < l.imgBytes && gw === 0 && (gw = 62500 * sZ());
            var _ = setTimeout(function() {
                if (l.waitingForImages = !1,
                l.count === 0 && (l.stylesheets && bb(l, l.stylesheets),
                l.unsuspend)) {
                    var R = l.unsuspend;
                    l.unsuspend = null,
                    R()
                }
            }, (l.imgBytes > gw ? 50 : 800) + d);
            return l.unsuspend = p,
            function() {
                l.unsuspend = null,
                clearTimeout(x),
                clearTimeout(_)
            }
        }
        : null
    }
    function gb() {
        if (this.count--,
        this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
            if (this.stylesheets)
                bb(this, this.stylesheets);
            else if (this.unsuspend) {
                var l = this.unsuspend;
                this.unsuspend = null,
                l()
            }
        }
    }
    var yb = null;
    function bb(l, d) {
        l.stylesheets = null,
        l.unsuspend !== null && (l.count++,
        yb = new Map,
        d.forEach(AZ, l),
        yb = null,
        gb.call(l))
    }
    function AZ(l, d) {
        if (!(d.state.loading & 4)) {
            var p = yb.get(l);
            if (p)
                var x = p.get(null);
            else {
                p = new Map,
                yb.set(l, p);
                for (var _ = l.querySelectorAll("link[data-precedence],style[data-precedence]"), R = 0; R < _.length; R++) {
                    var G = _[R];
                    (G.nodeName === "LINK" || G.getAttribute("media") !== "not all") && (p.set(G.dataset.precedence, G),
                    x = G)
                }
                x && p.set(null, x)
            }
            _ = d.instance,
            G = _.getAttribute("data-precedence"),
            R = p.get(G) || x,
            R === x && p.set(null, _),
            p.set(G, _),
            this.count++,
            x = gb.bind(this),
            _.addEventListener("load", x),
            _.addEventListener("error", x),
            R ? R.parentNode.insertBefore(_, R.nextSibling) : (l = l.nodeType === 9 ? l.head : l,
            l.insertBefore(_, l.firstChild)),
            d.state.loading |= 4
        }
    }
    var cp = {
        $$typeof: k,
        Provider: null,
        Consumer: null,
        _currentValue: H,
        _currentValue2: H,
        _threadCount: 0
    };
    function MZ(l, d, p, x, _, R, G, Q, ae) {
        this.tag = 1,
        this.containerInfo = l,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
        this.callbackPriority = 0,
        this.expirationTimes = nr(-1),
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = nr(0),
        this.hiddenUpdates = nr(null),
        this.identifierPrefix = x,
        this.onUncaughtError = _,
        this.onCaughtError = R,
        this.onRecoverableError = G,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = ae,
        this.incompleteTransitions = new Map
    }
    function FO(l, d, p, x, _, R, G, Q, ae, Ee, Ue, We) {
        return l = new MZ(l,d,p,G,ae,Ee,Ue,We,Q),
        d = 1,
        R === !0 && (d |= 24),
        R = Ro(3, null, null, d),
        l.current = R,
        R.stateNode = l,
        d = ZS(),
        d.refCount++,
        l.pooledCache = d,
        d.refCount++,
        R.memoizedState = {
            element: x,
            isDehydrated: p,
            cache: d
        },
        JS(R),
        l
    }
    function NO(l) {
        return l ? (l = vd,
        l) : vd
    }
    function UO(l, d, p, x, _, R) {
        _ = NO(_),
        x.context === null ? x.context = _ : x.pendingContext = _,
        x = Bl(d),
        x.payload = {
            element: p
        },
        R = R === void 0 ? null : R,
        R !== null && (x.callback = R),
        p = zl(l, x, d),
        p !== null && (oo(p, l, d),
        Nh(p, l, d))
    }
    function VO(l, d) {
        if (l = l.memoizedState,
        l !== null && l.dehydrated !== null) {
            var p = l.retryLane;
            l.retryLane = p !== 0 && p < d ? p : d
        }
    }
    function yw(l, d) {
        VO(l, d),
        (l = l.alternate) && VO(l, d)
    }
    function HO(l) {
        if (l.tag === 13 || l.tag === 31) {
            var d = Vc(l, 67108864);
            d !== null && oo(d, l, 67108864),
            yw(l, 67108864)
        }
    }
    function qO(l) {
        if (l.tag === 13 || l.tag === 31) {
            var d = Lo();
            d = qt(d);
            var p = Vc(l, d);
            p !== null && oo(p, l, d),
            yw(l, d)
        }
    }
    var xb = !0;
    function PZ(l, d, p, x) {
        var _ = j.T;
        j.T = null;
        var R = N.p;
        try {
            N.p = 2,
            bw(l, d, p, x)
        } finally {
            N.p = R,
            j.T = _
        }
    }
    function RZ(l, d, p, x) {
        var _ = j.T;
        j.T = null;
        var R = N.p;
        try {
            N.p = 8,
            bw(l, d, p, x)
        } finally {
            N.p = R,
            j.T = _
        }
    }
    function bw(l, d, p, x) {
        if (xb) {
            var _ = xw(x);
            if (_ === null)
                iw(l, d, x, vb, p),
                GO(l, x);
            else if (OZ(_, l, d, p, x))
                x.stopPropagation();
            else if (GO(l, x),
            d & 4 && -1 < DZ.indexOf(l)) {
                for (; _ !== null; ) {
                    var R = Ze(_);
                    if (R !== null)
                        switch (R.tag) {
                        case 3:
                            if (R = R.stateNode,
                            R.current.memoizedState.isDehydrated) {
                                var G = Kn(R.pendingLanes);
                                if (G !== 0) {
                                    var Q = R;
                                    for (Q.pendingLanes |= 2,
                                    Q.entangledLanes |= 2; G; ) {
                                        var ae = 1 << 31 - ut(G);
                                        Q.entanglements[1] |= ae,
                                        G &= ~ae
                                    }
                                    cs(R),
                                    (Ln & 6) === 0 && (nb = Oe() + 500,
                                    rp(0))
                                }
                            }
                            break;
                        case 31:
                        case 13:
                            Q = Vc(R, 2),
                            Q !== null && oo(Q, R, 2),
                            ib(),
                            yw(R, 2)
                        }
                    if (R = xw(x),
                    R === null && iw(l, d, x, vb, p),
                    R === _)
                        break;
                    _ = R
                }
                _ !== null && x.stopPropagation()
            } else
                iw(l, d, x, null, p)
        }
    }
    function xw(l) {
        return l = SS(l),
        vw(l)
    }
    var vb = null;
    function vw(l) {
        if (vb = null,
        l = De(l),
        l !== null) {
            var d = o(l);
            if (d === null)
                l = null;
            else {
                var p = d.tag;
                if (p === 13) {
                    if (l = a(d),
                    l !== null)
                        return l;
                    l = null
                } else if (p === 31) {
                    if (l = s(d),
                    l !== null)
                        return l;
                    l = null
                } else if (p === 3) {
                    if (d.stateNode.current.memoizedState.isDehydrated)
                        return d.tag === 3 ? d.stateNode.containerInfo : null;
                    l = null
                } else
                    d !== l && (l = null)
            }
        }
        return vb = l,
        null
    }
    function WO(l) {
        switch (l) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 8;
        case "message":
            switch (Re()) {
            case le:
                return 2;
            case ke:
                return 8;
            case He:
            case st:
                return 32;
            case lt:
                return 268435456;
            default:
                return 32
            }
        default:
            return 32
        }
    }
    var Sw = !1
      , Ql = null
      , Kl = null
      , Xl = null
      , up = new Map
      , dp = new Map
      , Jl = []
      , DZ = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function GO(l, d) {
        switch (l) {
        case "focusin":
        case "focusout":
            Ql = null;
            break;
        case "dragenter":
        case "dragleave":
            Kl = null;
            break;
        case "mouseover":
        case "mouseout":
            Xl = null;
            break;
        case "pointerover":
        case "pointerout":
            up.delete(d.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            dp.delete(d.pointerId)
        }
    }
    function fp(l, d, p, x, _, R) {
        return l === null || l.nativeEvent !== R ? (l = {
            blockedOn: d,
            domEventName: p,
            eventSystemFlags: x,
            nativeEvent: R,
            targetContainers: [_]
        },
        d !== null && (d = Ze(d),
        d !== null && HO(d)),
        l) : (l.eventSystemFlags |= x,
        d = l.targetContainers,
        _ !== null && d.indexOf(_) === -1 && d.push(_),
        l)
    }
    function OZ(l, d, p, x, _) {
        switch (d) {
        case "focusin":
            return Ql = fp(Ql, l, d, p, x, _),
            !0;
        case "dragenter":
            return Kl = fp(Kl, l, d, p, x, _),
            !0;
        case "mouseover":
            return Xl = fp(Xl, l, d, p, x, _),
            !0;
        case "pointerover":
            var R = _.pointerId;
            return up.set(R, fp(up.get(R) || null, l, d, p, x, _)),
            !0;
        case "gotpointercapture":
            return R = _.pointerId,
            dp.set(R, fp(dp.get(R) || null, l, d, p, x, _)),
            !0
        }
        return !1
    }
    function YO(l) {
        var d = De(l.target);
        if (d !== null) {
            var p = o(d);
            if (p !== null) {
                if (d = p.tag,
                d === 13) {
                    if (d = a(p),
                    d !== null) {
                        l.blockedOn = d,
                        Ki(l.priority, function() {
                            qO(p)
                        });
                        return
                    }
                } else if (d === 31) {
                    if (d = s(p),
                    d !== null) {
                        l.blockedOn = d,
                        Ki(l.priority, function() {
                            qO(p)
                        });
                        return
                    }
                } else if (d === 3 && p.stateNode.current.memoizedState.isDehydrated) {
                    l.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
                    return
                }
            }
        }
        l.blockedOn = null
    }
    function Sb(l) {
        if (l.blockedOn !== null)
            return !1;
        for (var d = l.targetContainers; 0 < d.length; ) {
            var p = xw(l.nativeEvent);
            if (p === null) {
                p = l.nativeEvent;
                var x = new p.constructor(p.type,p);
                vS = x,
                p.target.dispatchEvent(x),
                vS = null
            } else
                return d = Ze(p),
                d !== null && HO(d),
                l.blockedOn = p,
                !1;
            d.shift()
        }
        return !0
    }
    function ZO(l, d, p) {
        Sb(l) && p.delete(d)
    }
    function IZ() {
        Sw = !1,
        Ql !== null && Sb(Ql) && (Ql = null),
        Kl !== null && Sb(Kl) && (Kl = null),
        Xl !== null && Sb(Xl) && (Xl = null),
        up.forEach(ZO),
        dp.forEach(ZO)
    }
    function Cb(l, d) {
        l.blockedOn === d && (l.blockedOn = null,
        Sw || (Sw = !0,
        e.unstable_scheduleCallback(e.unstable_NormalPriority, IZ)))
    }
    var wb = null;
    function QO(l) {
        wb !== l && (wb = l,
        e.unstable_scheduleCallback(e.unstable_NormalPriority, function() {
            wb === l && (wb = null);
            for (var d = 0; d < l.length; d += 3) {
                var p = l[d]
                  , x = l[d + 1]
                  , _ = l[d + 2];
                if (typeof x != "function") {
                    if (vw(x || p) === null)
                        continue;
                    break
                }
                var R = Ze(p);
                R !== null && (l.splice(d, 3),
                d -= 3,
                xC(R, {
                    pending: !0,
                    data: _,
                    method: p.method,
                    action: x
                }, x, _))
            }
        }))
    }
    function Hd(l) {
        function d(ae) {
            return Cb(ae, l)
        }
        Ql !== null && Cb(Ql, l),
        Kl !== null && Cb(Kl, l),
        Xl !== null && Cb(Xl, l),
        up.forEach(d),
        dp.forEach(d);
        for (var p = 0; p < Jl.length; p++) {
            var x = Jl[p];
            x.blockedOn === l && (x.blockedOn = null)
        }
        for (; 0 < Jl.length && (p = Jl[0],
        p.blockedOn === null); )
            YO(p),
            p.blockedOn === null && Jl.shift();
        if (p = (l.ownerDocument || l).$$reactFormReplay,
        p != null)
            for (x = 0; x < p.length; x += 3) {
                var _ = p[x]
                  , R = p[x + 1]
                  , G = _[en] || null;
                if (typeof R == "function")
                    G || QO(p);
                else if (G) {
                    var Q = null;
                    if (R && R.hasAttribute("formAction")) {
                        if (_ = R,
                        G = R[en] || null)
                            Q = G.formAction;
                        else if (vw(_) !== null)
                            continue
                    } else
                        Q = G.action;
                    typeof Q == "function" ? p[x + 1] = Q : (p.splice(x, 3),
                    x -= 3),
                    QO(p)
                }
            }
    }
    function KO() {
        function l(R) {
            R.canIntercept && R.info === "react-transition" && R.intercept({
                handler: function() {
                    return new Promise(function(G) {
                        return _ = G
                    }
                    )
                },
                focusReset: "manual",
                scroll: "manual"
            })
        }
        function d() {
            _ !== null && (_(),
            _ = null),
            x || setTimeout(p, 20)
        }
        function p() {
            if (!x && !navigation.transition) {
                var R = navigation.currentEntry;
                R && R.url != null && navigation.navigate(R.url, {
                    state: R.getState(),
                    info: "react-transition",
                    history: "replace"
                })
            }
        }
        if (typeof navigation == "object") {
            var x = !1
              , _ = null;
            return navigation.addEventListener("navigate", l),
            navigation.addEventListener("navigatesuccess", d),
            navigation.addEventListener("navigateerror", d),
            setTimeout(p, 100),
            function() {
                x = !0,
                navigation.removeEventListener("navigate", l),
                navigation.removeEventListener("navigatesuccess", d),
                navigation.removeEventListener("navigateerror", d),
                _ !== null && (_(),
                _ = null)
            }
        }
    }
    function Cw(l) {
        this._internalRoot = l
    }
    kb.prototype.render = Cw.prototype.render = function(l) {
        var d = this._internalRoot;
        if (d === null)
            throw Error(r(409));
        var p = d.current
          , x = Lo();
        UO(p, x, l, d, null, null)
    }
    ,
    kb.prototype.unmount = Cw.prototype.unmount = function() {
        var l = this._internalRoot;
        if (l !== null) {
            this._internalRoot = null;
            var d = l.containerInfo;
            UO(l.current, 2, null, l, null, null),
            ib(),
            d[si] = null
        }
    }
    ;
    function kb(l) {
        this._internalRoot = l
    }
    kb.prototype.unstable_scheduleHydration = function(l) {
        if (l) {
            var d = Ir();
            l = {
                blockedOn: null,
                target: l,
                priority: d
            };
            for (var p = 0; p < Jl.length && d !== 0 && d < Jl[p].priority; p++)
                ;
            Jl.splice(p, 0, l),
            p === 0 && YO(l)
        }
    }
    ;
    var XO = t.version;
    if (XO !== "19.2.0")
        throw Error(r(527, XO, "19.2.0"));
    N.findDOMNode = function(l) {
        var d = l._reactInternals;
        if (d === void 0)
            throw typeof l.render == "function" ? Error(r(188)) : (l = Object.keys(l).join(","),
            Error(r(268, l)));
        return l = u(d),
        l = l !== null ? f(l) : null,
        l = l === null ? null : l.stateNode,
        l
    }
    ;
    var $Z = {
        bundleType: 0,
        version: "19.2.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: j,
        reconcilerVersion: "19.2.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var Tb = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Tb.isDisabled && Tb.supportsFiber)
            try {
                Ft = Tb.inject($Z),
                Pt = Tb
            } catch {}
    }
    return pp.createRoot = function(l, d) {
        if (!i(l))
            throw Error(r(299));
        var p = !1
          , x = ""
          , _ = oD
          , R = aD
          , G = sD;
        return d != null && (d.unstable_strictMode === !0 && (p = !0),
        d.identifierPrefix !== void 0 && (x = d.identifierPrefix),
        d.onUncaughtError !== void 0 && (_ = d.onUncaughtError),
        d.onCaughtError !== void 0 && (R = d.onCaughtError),
        d.onRecoverableError !== void 0 && (G = d.onRecoverableError)),
        d = FO(l, 1, !1, null, null, p, x, null, _, R, G, KO),
        l[si] = d.current,
        rw(l),
        new Cw(d)
    }
    ,
    pp.hydrateRoot = function(l, d, p) {
        if (!i(l))
            throw Error(r(299));
        var x = !1
          , _ = ""
          , R = oD
          , G = aD
          , Q = sD
          , ae = null;
        return p != null && (p.unstable_strictMode === !0 && (x = !0),
        p.identifierPrefix !== void 0 && (_ = p.identifierPrefix),
        p.onUncaughtError !== void 0 && (R = p.onUncaughtError),
        p.onCaughtError !== void 0 && (G = p.onCaughtError),
        p.onRecoverableError !== void 0 && (Q = p.onRecoverableError),
        p.formState !== void 0 && (ae = p.formState)),
        d = FO(l, 1, !0, d, p ?? null, x, _, ae, R, G, Q, KO),
        d.context = NO(null),
        p = d.current,
        x = Lo(),
        x = qt(x),
        _ = Bl(x),
        _.callback = null,
        zl(p, _, x),
        p = x,
        d.current.lanes = p,
        he(d, p),
        cs(d),
        l[si] = d.current,
        rw(l),
        new kb(d)
    }
    ,
    pp.version = "19.2.0",
    pp
}
var lI;
function qZ() {
    if (lI)
        return kw.exports;
    lI = 1;
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
    }
    return e(),
    kw.exports = HZ(),
    kw.exports
}
var WZ = qZ()
  , A = Tv();
const bt = es(A)
  , o0 = jZ({
    __proto__: null,
    default: bt
}, [A]);
/**
 * react-router v7.9.4
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var cI = "popstate";
function GZ(e={}) {
    function t(r, i) {
        let {pathname: o, search: a, hash: s} = r.location;
        return C2("", {
            pathname: o,
            search: a,
            hash: s
        }, i.state && i.state.usr || null, i.state && i.state.key || "default")
    }
    function n(r, i) {
        return typeof i == "string" ? i : jm(i)
    }
    return ZZ(t, n, null, e)
}
function Sr(e, t) {
    if (e === !1 || e === null || typeof e > "u")
        throw new Error(t)
}
function ks(e, t) {
    if (!e) {
        typeof console < "u" && console.warn(t);
        try {
            throw new Error(t)
        } catch {}
    }
}
function YZ() {
    return Math.random().toString(36).substring(2, 10)
}
function uI(e, t) {
    return {
        usr: e.state,
        key: e.key,
        idx: t
    }
}
function C2(e, t, n=null, r) {
    return {
        pathname: typeof e == "string" ? e : e.pathname,
        search: "",
        hash: "",
        ...typeof t == "string" ? sh(t) : t,
        state: n,
        key: t && t.key || r || YZ()
    }
}
function jm({pathname: e="/", search: t="", hash: n=""}) {
    return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n),
    e
}
function sh(e) {
    let t = {};
    if (e) {
        let n = e.indexOf("#");
        n >= 0 && (t.hash = e.substring(n),
        e = e.substring(0, n));
        let r = e.indexOf("?");
        r >= 0 && (t.search = e.substring(r),
        e = e.substring(0, r)),
        e && (t.pathname = e)
    }
    return t
}
function ZZ(e, t, n, r={}) {
    let {window: i=document.defaultView, v5Compat: o=!1} = r
      , a = i.history
      , s = "POP"
      , c = null
      , u = f();
    u == null && (u = 0,
    a.replaceState({
        ...a.state,
        idx: u
    }, ""));
    function f() {
        return (a.state || {
            idx: null
        }).idx
    }
    function h() {
        s = "POP";
        let S = f()
          , C = S == null ? null : S - u;
        u = S,
        c && c({
            action: s,
            location: v.location,
            delta: C
        })
    }
    function m(S, C) {
        s = "PUSH";
        let w = C2(v.location, S, C);
        u = f() + 1;
        let k = uI(w, u)
          , T = v.createHref(w);
        try {
            a.pushState(k, "", T)
        } catch (E) {
            if (E instanceof DOMException && E.name === "DataCloneError")
                throw E;
            i.location.assign(T)
        }
        o && c && c({
            action: s,
            location: v.location,
            delta: 1
        })
    }
    function y(S, C) {
        s = "REPLACE";
        let w = C2(v.location, S, C);
        u = f();
        let k = uI(w, u)
          , T = v.createHref(w);
        a.replaceState(k, "", T),
        o && c && c({
            action: s,
            location: v.location,
            delta: 0
        })
    }
    function b(S) {
        return QZ(S)
    }
    let v = {
        get action() {
            return s
        },
        get location() {
            return e(i, a)
        },
        listen(S) {
            if (c)
                throw new Error("A history only accepts one active listener");
            return i.addEventListener(cI, h),
            c = S,
            () => {
                i.removeEventListener(cI, h),
                c = null
            }
        },
        createHref(S) {
            return t(i, S)
        },
        createURL: b,
        encodeLocation(S) {
            let C = b(S);
            return {
                pathname: C.pathname,
                search: C.search,
                hash: C.hash
            }
        },
        push: m,
        replace: y,
        go(S) {
            return a.go(S)
        }
    };
    return v
}
function QZ(e, t=!1) {
    let n = "http://localhost";
    typeof window < "u" && (n = window.location.origin !== "null" ? window.location.origin : window.location.href),
    Sr(n, "No window.location.(origin|href) available to create URL");
    let r = typeof e == "string" ? e : jm(e);
    return r = r.replace(/ $/, "%20"),
    !t && r.startsWith("//") && (r = n + r),
    new URL(r,n)
}
function eF(e, t, n="/") {
    return KZ(e, t, n, !1)
}
function KZ(e, t, n, r) {
    let i = typeof t == "string" ? sh(t) : t
      , o = Sl(i.pathname || "/", n);
    if (o == null)
        return null;
    let a = tF(e);
    XZ(a);
    let s = null;
    for (let c = 0; s == null && c < a.length; ++c) {
        let u = cQ(o);
        s = sQ(a[c], u, r)
    }
    return s
}
function tF(e, t=[], n=[], r="", i=!1) {
    let o = (a, s, c=i, u) => {
        let f = {
            relativePath: u === void 0 ? a.path || "" : u,
            caseSensitive: a.caseSensitive === !0,
            childrenIndex: s,
            route: a
        };
        if (f.relativePath.startsWith("/")) {
            if (!f.relativePath.startsWith(r) && c)
                return;
            Sr(f.relativePath.startsWith(r), `Absolute route path "${f.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
            f.relativePath = f.relativePath.slice(r.length)
        }
        let h = yl([r, f.relativePath])
          , m = n.concat(f);
        a.children && a.children.length > 0 && (Sr(a.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${h}".`),
        tF(a.children, t, m, h, c)),
        !(a.path == null && !a.index) && t.push({
            path: h,
            score: oQ(h, a.index),
            routesMeta: m
        })
    }
    ;
    return e.forEach( (a, s) => {
        if (a.path === "" || !a.path?.includes("?"))
            o(a, s);
        else
            for (let c of nF(a.path))
                o(a, s, !0, c)
    }
    ),
    t
}
function nF(e) {
    let t = e.split("/");
    if (t.length === 0)
        return [];
    let[n,...r] = t
      , i = n.endsWith("?")
      , o = n.replace(/\?$/, "");
    if (r.length === 0)
        return i ? [o, ""] : [o];
    let a = nF(r.join("/"))
      , s = [];
    return s.push(...a.map(c => c === "" ? o : [o, c].join("/"))),
    i && s.push(...a),
    s.map(c => e.startsWith("/") && c === "" ? "/" : c)
}
function XZ(e) {
    e.sort( (t, n) => t.score !== n.score ? n.score - t.score : aQ(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex)))
}
var JZ = /^:[\w-]+$/
  , eQ = 3
  , tQ = 2
  , nQ = 1
  , rQ = 10
  , iQ = -2
  , dI = e => e === "*";
function oQ(e, t) {
    let n = e.split("/")
      , r = n.length;
    return n.some(dI) && (r += iQ),
    t && (r += tQ),
    n.filter(i => !dI(i)).reduce( (i, o) => i + (JZ.test(o) ? eQ : o === "" ? nQ : rQ), r)
}
function aQ(e, t) {
    return e.length === t.length && e.slice(0, -1).every( (r, i) => r === t[i]) ? e[e.length - 1] - t[t.length - 1] : 0
}
function sQ(e, t, n=!1) {
    let {routesMeta: r} = e
      , i = {}
      , o = "/"
      , a = [];
    for (let s = 0; s < r.length; ++s) {
        let c = r[s]
          , u = s === r.length - 1
          , f = o === "/" ? t : t.slice(o.length) || "/"
          , h = a0({
            path: c.relativePath,
            caseSensitive: c.caseSensitive,
            end: u
        }, f)
          , m = c.route;
        if (!h && u && n && !r[r.length - 1].route.index && (h = a0({
            path: c.relativePath,
            caseSensitive: c.caseSensitive,
            end: !1
        }, f)),
        !h)
            return null;
        Object.assign(i, h.params),
        a.push({
            params: i,
            pathname: yl([o, h.pathname]),
            pathnameBase: hQ(yl([o, h.pathnameBase])),
            route: m
        }),
        h.pathnameBase !== "/" && (o = yl([o, h.pathnameBase]))
    }
    return a
}
function a0(e, t) {
    typeof e == "string" && (e = {
        path: e,
        caseSensitive: !1,
        end: !0
    });
    let[n,r] = lQ(e.path, e.caseSensitive, e.end)
      , i = t.match(n);
    if (!i)
        return null;
    let o = i[0]
      , a = o.replace(/(.)\/+$/, "$1")
      , s = i.slice(1);
    return {
        params: r.reduce( (u, {paramName: f, isOptional: h}, m) => {
            if (f === "*") {
                let b = s[m] || "";
                a = o.slice(0, o.length - b.length).replace(/(.)\/+$/, "$1")
            }
            const y = s[m];
            return h && !y ? u[f] = void 0 : u[f] = (y || "").replace(/%2F/g, "/"),
            u
        }
        , {}),
        pathname: o,
        pathnameBase: a,
        pattern: e
    }
}
function lQ(e, t=!1, n=!0) {
    ks(e === "*" || !e.endsWith("*") || e.endsWith("/*"), `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`);
    let r = []
      , i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (a, s, c) => (r.push({
        paramName: s,
        isOptional: c != null
    }),
    c ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
    return e.endsWith("*") ? (r.push({
        paramName: "*"
    }),
    i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i,t ? void 0 : "i"), r]
}
function cQ(e) {
    try {
        return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/")
    } catch (t) {
        return ks(!1, `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`),
        e
    }
}
function Sl(e, t) {
    if (t === "/")
        return e;
    if (!e.toLowerCase().startsWith(t.toLowerCase()))
        return null;
    let n = t.endsWith("/") ? t.length - 1 : t.length
      , r = e.charAt(n);
    return r && r !== "/" ? null : e.slice(n) || "/"
}
function uQ(e, t="/") {
    let {pathname: n, search: r="", hash: i=""} = typeof e == "string" ? sh(e) : e;
    return {
        pathname: n ? n.startsWith("/") ? n : dQ(n, t) : t,
        search: pQ(r),
        hash: mQ(i)
    }
}
function dQ(e, t) {
    let n = t.replace(/\/+$/, "").split("/");
    return e.split("/").forEach(i => {
        i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i)
    }
    ),
    n.length > 1 ? n.join("/") : "/"
}
function Mw(e, t, n, r) {
    return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function fQ(e) {
    return e.filter( (t, n) => n === 0 || t.route.path && t.route.path.length > 0)
}
function rF(e) {
    let t = fQ(e);
    return t.map( (n, r) => r === t.length - 1 ? n.pathname : n.pathnameBase)
}
function iF(e, t, n, r=!1) {
    let i;
    typeof e == "string" ? i = sh(e) : (i = {
        ...e
    },
    Sr(!i.pathname || !i.pathname.includes("?"), Mw("?", "pathname", "search", i)),
    Sr(!i.pathname || !i.pathname.includes("#"), Mw("#", "pathname", "hash", i)),
    Sr(!i.search || !i.search.includes("#"), Mw("#", "search", "hash", i)));
    let o = e === "" || i.pathname === "", a = o ? "/" : i.pathname, s;
    if (a == null)
        s = n;
    else {
        let h = t.length - 1;
        if (!r && a.startsWith("..")) {
            let m = a.split("/");
            for (; m[0] === ".."; )
                m.shift(),
                h -= 1;
            i.pathname = m.join("/")
        }
        s = h >= 0 ? t[h] : "/"
    }
    let c = uQ(i, s)
      , u = a && a !== "/" && a.endsWith("/")
      , f = (o || a === ".") && n.endsWith("/");
    return !c.pathname.endsWith("/") && (u || f) && (c.pathname += "/"),
    c
}
var yl = e => e.join("/").replace(/\/\/+/g, "/")
  , hQ = e => e.replace(/\/+$/, "").replace(/^\/*/, "/")
  , pQ = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e
  , mQ = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
function gQ(e) {
    return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data"in e
}
var oF = ["POST", "PUT", "PATCH", "DELETE"];
new Set(oF);
var yQ = ["GET", ...oF];
new Set(yQ);
var lh = A.createContext(null);
lh.displayName = "DataRouter";
var _v = A.createContext(null);
_v.displayName = "DataRouterState";
A.createContext(!1);
var aF = A.createContext({
    isTransitioning: !1
});
aF.displayName = "ViewTransition";
var bQ = A.createContext(new Map);
bQ.displayName = "Fetchers";
var xQ = A.createContext(null);
xQ.displayName = "Await";
var Rs = A.createContext(null);
Rs.displayName = "Navigation";
var vg = A.createContext(null);
vg.displayName = "Location";
var Ds = A.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
Ds.displayName = "Route";
var X_ = A.createContext(null);
X_.displayName = "RouteError";
function vQ(e, {relative: t}={}) {
    Sr(Sg(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: n, navigator: r} = A.useContext(Rs)
      , {hash: i, pathname: o, search: a} = Cg(e, {
        relative: t
    })
      , s = o;
    return n !== "/" && (s = o === "/" ? n : yl([n, o])),
    r.createHref({
        pathname: s,
        search: a,
        hash: i
    })
}
function Sg() {
    return A.useContext(vg) != null
}
function Ec() {
    return Sr(Sg(), "useLocation() may be used only in the context of a <Router> component."),
    A.useContext(vg).location
}
var sF = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function lF(e) {
    A.useContext(Rs).static || A.useLayoutEffect(e)
}
function Os() {
    let {isDataRoute: e} = A.useContext(Ds);
    return e ? $Q() : SQ()
}
function SQ() {
    Sr(Sg(), "useNavigate() may be used only in the context of a <Router> component.");
    let e = A.useContext(lh)
      , {basename: t, navigator: n} = A.useContext(Rs)
      , {matches: r} = A.useContext(Ds)
      , {pathname: i} = Ec()
      , o = JSON.stringify(rF(r))
      , a = A.useRef(!1);
    return lF( () => {
        a.current = !0
    }
    ),
    A.useCallback( (c, u={}) => {
        if (ks(a.current, sF),
        !a.current)
            return;
        if (typeof c == "number") {
            n.go(c);
            return
        }
        let f = iF(c, JSON.parse(o), i, u.relative === "path");
        e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : yl([t, f.pathname])),
        (u.replace ? n.replace : n.push)(f, u.state, u)
    }
    , [t, n, o, i, e])
}
var CQ = A.createContext(null);
function wQ(e) {
    let t = A.useContext(Ds).outlet;
    return A.useMemo( () => t && A.createElement(CQ.Provider, {
        value: e
    }, t), [t, e])
}
function Cg(e, {relative: t}={}) {
    let {matches: n} = A.useContext(Ds)
      , {pathname: r} = Ec()
      , i = JSON.stringify(rF(n));
    return A.useMemo( () => iF(e, JSON.parse(i), r, t === "path"), [e, i, r, t])
}
function kQ(e, t) {
    return cF(e, t)
}
function cF(e, t, n, r, i) {
    Sr(Sg(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: o} = A.useContext(Rs)
      , {matches: a} = A.useContext(Ds)
      , s = a[a.length - 1]
      , c = s ? s.params : {}
      , u = s ? s.pathname : "/"
      , f = s ? s.pathnameBase : "/"
      , h = s && s.route;
    {
        let w = h && h.path || "";
        uF(u, !h || w.endsWith("*") || w.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${w}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${w}"> to <Route path="${w === "/" ? "*" : `${w}/*`}">.`)
    }
    let m = Ec(), y;
    if (t) {
        let w = typeof t == "string" ? sh(t) : t;
        Sr(f === "/" || w.pathname?.startsWith(f), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${f}" but pathname "${w.pathname}" was given in the \`location\` prop.`),
        y = w
    } else
        y = m;
    let b = y.pathname || "/"
      , v = b;
    if (f !== "/") {
        let w = f.replace(/^\//, "").split("/");
        v = "/" + b.replace(/^\//, "").split("/").slice(w.length).join("/")
    }
    let S = eF(e, {
        pathname: v
    });
    ks(h || S != null, `No routes matched location "${y.pathname}${y.search}${y.hash}" `),
    ks(S == null || S[S.length - 1].route.element !== void 0 || S[S.length - 1].route.Component !== void 0 || S[S.length - 1].route.lazy !== void 0, `Matched leaf route at location "${y.pathname}${y.search}${y.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let C = MQ(S && S.map(w => Object.assign({}, w, {
        params: Object.assign({}, c, w.params),
        pathname: yl([f, o.encodeLocation ? o.encodeLocation(w.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : w.pathname]),
        pathnameBase: w.pathnameBase === "/" ? f : yl([f, o.encodeLocation ? o.encodeLocation(w.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : w.pathnameBase])
    })), a, n, r, i);
    return t && C ? A.createElement(vg.Provider, {
        value: {
            location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...y
            },
            navigationType: "POP"
        }
    }, C) : C
}
function TQ() {
    let e = IQ()
      , t = gQ(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e)
      , n = e instanceof Error ? e.stack : null
      , r = "rgba(200,200,200, 0.5)"
      , i = {
        padding: "0.5rem",
        backgroundColor: r
    }
      , o = {
        padding: "2px 4px",
        backgroundColor: r
    }
      , a = null;
    return console.error("Error handled by React Router default ErrorBoundary:", e),
    a = A.createElement(A.Fragment, null, A.createElement("p", null, " Hey developer "), A.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", A.createElement("code", {
        style: o
    }, "ErrorBoundary"), " or", " ", A.createElement("code", {
        style: o
    }, "errorElement"), " prop on your route.")),
    A.createElement(A.Fragment, null, A.createElement("h2", null, "Unexpected Application Error!"), A.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, t), n ? A.createElement("pre", {
        style: i
    }, n) : null, a)
}
var _Q = A.createElement(TQ, null)
  , EQ = class extends A.Component {
    constructor(e) {
        super(e),
        this.state = {
            location: e.location,
            revalidation: e.revalidation,
            error: e.error
        }
    }
    static getDerivedStateFromError(e) {
        return {
            error: e
        }
    }
    static getDerivedStateFromProps(e, t) {
        return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
            error: e.error,
            location: e.location,
            revalidation: e.revalidation
        } : {
            error: e.error !== void 0 ? e.error : t.error,
            location: t.location,
            revalidation: e.revalidation || t.revalidation
        }
    }
    componentDidCatch(e, t) {
        this.props.unstable_onError ? this.props.unstable_onError(e, t) : console.error("React Router caught the following error during render", e)
    }
    render() {
        return this.state.error !== void 0 ? A.createElement(Ds.Provider, {
            value: this.props.routeContext
        }, A.createElement(X_.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function AQ({routeContext: e, match: t, children: n}) {
    let r = A.useContext(lh);
    return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id),
    A.createElement(Ds.Provider, {
        value: e
    }, n)
}
function MQ(e, t=[], n=null, r=null, i=null) {
    if (e == null) {
        if (!n)
            return null;
        if (n.errors)
            e = n.matches;
        else if (t.length === 0 && !n.initialized && n.matches.length > 0)
            e = n.matches;
        else
            return null
    }
    let o = e
      , a = n?.errors;
    if (a != null) {
        let u = o.findIndex(f => f.route.id && a?.[f.route.id] !== void 0);
        Sr(u >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`),
        o = o.slice(0, Math.min(o.length, u + 1))
    }
    let s = !1
      , c = -1;
    if (n)
        for (let u = 0; u < o.length; u++) {
            let f = o[u];
            if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (c = u),
            f.route.id) {
                let {loaderData: h, errors: m} = n
                  , y = f.route.loader && !h.hasOwnProperty(f.route.id) && (!m || m[f.route.id] === void 0);
                if (f.route.lazy || y) {
                    s = !0,
                    c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]];
                    break
                }
            }
        }
    return o.reduceRight( (u, f, h) => {
        let m, y = !1, b = null, v = null;
        n && (m = a && f.route.id ? a[f.route.id] : void 0,
        b = f.route.errorElement || _Q,
        s && (c < 0 && h === 0 ? (uF("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        y = !0,
        v = null) : c === h && (y = !0,
        v = f.route.hydrateFallbackElement || null)));
        let S = t.concat(o.slice(0, h + 1))
          , C = () => {
            let w;
            return m ? w = b : y ? w = v : f.route.Component ? w = A.createElement(f.route.Component, null) : f.route.element ? w = f.route.element : w = u,
            A.createElement(AQ, {
                match: f,
                routeContext: {
                    outlet: u,
                    matches: S,
                    isDataRoute: n != null
                },
                children: w
            })
        }
        ;
        return n && (f.route.ErrorBoundary || f.route.errorElement || h === 0) ? A.createElement(EQ, {
            location: n.location,
            revalidation: n.revalidation,
            component: b,
            error: m,
            children: C(),
            routeContext: {
                outlet: null,
                matches: S,
                isDataRoute: !0
            },
            unstable_onError: r
        }) : C()
    }
    , null)
}
function J_(e) {
    return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function PQ(e) {
    let t = A.useContext(lh);
    return Sr(t, J_(e)),
    t
}
function RQ(e) {
    let t = A.useContext(_v);
    return Sr(t, J_(e)),
    t
}
function DQ(e) {
    let t = A.useContext(Ds);
    return Sr(t, J_(e)),
    t
}
function eE(e) {
    let t = DQ(e)
      , n = t.matches[t.matches.length - 1];
    return Sr(n.route.id, `${e} can only be used on routes that contain a unique "id"`),
    n.route.id
}
function OQ() {
    return eE("useRouteId")
}
function IQ() {
    let e = A.useContext(X_)
      , t = RQ("useRouteError")
      , n = eE("useRouteError");
    return e !== void 0 ? e : t.errors?.[n]
}
function $Q() {
    let {router: e} = PQ("useNavigate")
      , t = eE("useNavigate")
      , n = A.useRef(!1);
    return lF( () => {
        n.current = !0
    }
    ),
    A.useCallback(async (i, o={}) => {
        ks(n.current, sF),
        n.current && (typeof i == "number" ? e.navigate(i) : await e.navigate(i, {
            fromRouteId: t,
            ...o
        }))
    }
    , [e, t])
}
var fI = {};
function uF(e, t, n) {
    !t && !fI[e] && (fI[e] = !0,
    ks(!1, n))
}
A.memo(LQ);
function LQ({routes: e, future: t, state: n, unstable_onError: r}) {
    return cF(e, void 0, n, r, t)
}
function jQ(e) {
    return wQ(e.context)
}
function wi(e) {
    Sr(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}
function BQ({basename: e="/", children: t=null, location: n, navigationType: r="POP", navigator: i, static: o=!1}) {
    Sr(!Sg(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let a = e.replace(/^\/*/, "/")
      , s = A.useMemo( () => ({
        basename: a,
        navigator: i,
        static: o,
        future: {}
    }), [a, i, o]);
    typeof n == "string" && (n = sh(n));
    let {pathname: c="/", search: u="", hash: f="", state: h=null, key: m="default"} = n
      , y = A.useMemo( () => {
        let b = Sl(c, a);
        return b == null ? null : {
            location: {
                pathname: b,
                search: u,
                hash: f,
                state: h,
                key: m
            },
            navigationType: r
        }
    }
    , [a, c, u, f, h, m, r]);
    return ks(y != null, `<Router basename="${a}"> is not able to match the URL "${c}${u}${f}" because it does not start with the basename, so the <Router> won't render anything.`),
    y == null ? null : A.createElement(Rs.Provider, {
        value: s
    }, A.createElement(vg.Provider, {
        children: t,
        value: y
    }))
}
function zQ({children: e, location: t}) {
    return kQ(w2(e), t)
}
function w2(e, t=[]) {
    let n = [];
    return A.Children.forEach(e, (r, i) => {
        if (!A.isValidElement(r))
            return;
        let o = [...t, i];
        if (r.type === A.Fragment) {
            n.push.apply(n, w2(r.props.children, o));
            return
        }
        Sr(r.type === wi, `[${typeof r.type == "string" ? r.type : r.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),
        Sr(!r.props.index || !r.props.children, "An index route cannot have child routes.");
        let a = {
            id: r.props.id || o.join("-"),
            caseSensitive: r.props.caseSensitive,
            element: r.props.element,
            Component: r.props.Component,
            index: r.props.index,
            path: r.props.path,
            middleware: r.props.middleware,
            loader: r.props.loader,
            action: r.props.action,
            hydrateFallbackElement: r.props.hydrateFallbackElement,
            HydrateFallback: r.props.HydrateFallback,
            errorElement: r.props.errorElement,
            ErrorBoundary: r.props.ErrorBoundary,
            hasErrorBoundary: r.props.hasErrorBoundary === !0 || r.props.ErrorBoundary != null || r.props.errorElement != null,
            shouldRevalidate: r.props.shouldRevalidate,
            handle: r.props.handle,
            lazy: r.props.lazy
        };
        r.props.children && (a.children = w2(r.props.children, o)),
        n.push(a)
    }
    ),
    n
}
var Sx = "get"
  , Cx = "application/x-www-form-urlencoded";
function Ev(e) {
    return e != null && typeof e.tagName == "string"
}
function FQ(e) {
    return Ev(e) && e.tagName.toLowerCase() === "button"
}
function NQ(e) {
    return Ev(e) && e.tagName.toLowerCase() === "form"
}
function UQ(e) {
    return Ev(e) && e.tagName.toLowerCase() === "input"
}
function VQ(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}
function HQ(e, t) {
    return e.button === 0 && (!t || t === "_self") && !VQ(e)
}
var _b = null;
function qQ() {
    if (_b === null)
        try {
            new FormData(document.createElement("form"),0),
            _b = !1
        } catch {
            _b = !0
        }
    return _b
}
var WQ = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Pw(e) {
    return e != null && !WQ.has(e) ? (ks(!1, `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Cx}"`),
    null) : e
}
function GQ(e, t) {
    let n, r, i, o, a;
    if (NQ(e)) {
        let s = e.getAttribute("action");
        r = s ? Sl(s, t) : null,
        n = e.getAttribute("method") || Sx,
        i = Pw(e.getAttribute("enctype")) || Cx,
        o = new FormData(e)
    } else if (FQ(e) || UQ(e) && (e.type === "submit" || e.type === "image")) {
        let s = e.form;
        if (s == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let c = e.getAttribute("formaction") || s.getAttribute("action");
        if (r = c ? Sl(c, t) : null,
        n = e.getAttribute("formmethod") || s.getAttribute("method") || Sx,
        i = Pw(e.getAttribute("formenctype")) || Pw(s.getAttribute("enctype")) || Cx,
        o = new FormData(s,e),
        !qQ()) {
            let {name: u, type: f, value: h} = e;
            if (f === "image") {
                let m = u ? `${u}.` : "";
                o.append(`${m}x`, "0"),
                o.append(`${m}y`, "0")
            } else
                u && o.append(u, h)
        }
    } else {
        if (Ev(e))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        n = Sx,
        r = null,
        i = Cx,
        a = e
    }
    return o && i === "text/plain" && (a = o,
    o = void 0),
    {
        action: r,
        method: n.toLowerCase(),
        encType: i,
        formData: o,
        body: a
    }
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function tE(e, t) {
    if (e === !1 || e === null || typeof e > "u")
        throw new Error(t)
}
function YQ(e, t, n) {
    let r = typeof e == "string" ? new URL(e,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : e;
    return r.pathname === "/" ? r.pathname = `_root.${n}` : t && Sl(r.pathname, t) === "/" ? r.pathname = `${t.replace(/\/$/, "")}/_root.${n}` : r.pathname = `${r.pathname.replace(/\/$/, "")}.${n}`,
    r
}
async function ZQ(e, t) {
    if (e.id in t)
        return t[e.id];
    try {
        let n = await import(e.module);
        return t[e.id] = n,
        n
    } catch (n) {
        return console.error(`Error loading route module \`${e.module}\`, reloading page...`),
        console.error(n),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function QQ(e) {
    return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string"
}
async function KQ(e, t, n) {
    let r = await Promise.all(e.map(async i => {
        let o = t.routes[i.route.id];
        if (o) {
            let a = await ZQ(o, n);
            return a.links ? a.links() : []
        }
        return []
    }
    ));
    return tK(r.flat(1).filter(QQ).filter(i => i.rel === "stylesheet" || i.rel === "preload").map(i => i.rel === "stylesheet" ? {
        ...i,
        rel: "prefetch",
        as: "style"
    } : {
        ...i,
        rel: "prefetch"
    }))
}
function hI(e, t, n, r, i, o) {
    let a = (c, u) => n[u] ? c.route.id !== n[u].route.id : !0
      , s = (c, u) => n[u].pathname !== c.pathname || n[u].route.path?.endsWith("*") && n[u].params["*"] !== c.params["*"];
    return o === "assets" ? t.filter( (c, u) => a(c, u) || s(c, u)) : o === "data" ? t.filter( (c, u) => {
        let f = r.routes[c.route.id];
        if (!f || !f.hasLoader)
            return !1;
        if (a(c, u) || s(c, u))
            return !0;
        if (c.route.shouldRevalidate) {
            let h = c.route.shouldRevalidate({
                currentUrl: new URL(i.pathname + i.search + i.hash,window.origin),
                currentParams: n[0]?.params || {},
                nextUrl: new URL(e,window.origin),
                nextParams: c.params,
                defaultShouldRevalidate: !0
            });
            if (typeof h == "boolean")
                return h
        }
        return !0
    }
    ) : []
}
function XQ(e, t, {includeHydrateFallback: n}={}) {
    return JQ(e.map(r => {
        let i = t.routes[r.route.id];
        if (!i)
            return [];
        let o = [i.module];
        return i.clientActionModule && (o = o.concat(i.clientActionModule)),
        i.clientLoaderModule && (o = o.concat(i.clientLoaderModule)),
        n && i.hydrateFallbackModule && (o = o.concat(i.hydrateFallbackModule)),
        i.imports && (o = o.concat(i.imports)),
        o
    }
    ).flat(1))
}
function JQ(e) {
    return [...new Set(e)]
}
function eK(e) {
    let t = {}
      , n = Object.keys(e).sort();
    for (let r of n)
        t[r] = e[r];
    return t
}
function tK(e, t) {
    let n = new Set;
    return new Set(t),
    e.reduce( (r, i) => {
        let o = JSON.stringify(eK(i));
        return n.has(o) || (n.add(o),
        r.push({
            key: o,
            link: i
        })),
        r
    }
    , [])
}
function dF() {
    let e = A.useContext(lh);
    return tE(e, "You must render this element inside a <DataRouterContext.Provider> element"),
    e
}
function nK() {
    let e = A.useContext(_v);
    return tE(e, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    e
}
var nE = A.createContext(void 0);
nE.displayName = "FrameworkContext";
function fF() {
    let e = A.useContext(nE);
    return tE(e, "You must render this element inside a <HydratedRouter> element"),
    e
}
function rK(e, t) {
    let n = A.useContext(nE)
      , [r,i] = A.useState(!1)
      , [o,a] = A.useState(!1)
      , {onFocus: s, onBlur: c, onMouseEnter: u, onMouseLeave: f, onTouchStart: h} = t
      , m = A.useRef(null);
    A.useEffect( () => {
        if (e === "render" && a(!0),
        e === "viewport") {
            let v = C => {
                C.forEach(w => {
                    a(w.isIntersecting)
                }
                )
            }
              , S = new IntersectionObserver(v,{
                threshold: .5
            });
            return m.current && S.observe(m.current),
            () => {
                S.disconnect()
            }
        }
    }
    , [e]),
    A.useEffect( () => {
        if (r) {
            let v = setTimeout( () => {
                a(!0)
            }
            , 100);
            return () => {
                clearTimeout(v)
            }
        }
    }
    , [r]);
    let y = () => {
        i(!0)
    }
      , b = () => {
        i(!1),
        a(!1)
    }
    ;
    return n ? e !== "intent" ? [o, m, {}] : [o, m, {
        onFocus: mp(s, y),
        onBlur: mp(c, b),
        onMouseEnter: mp(u, y),
        onMouseLeave: mp(f, b),
        onTouchStart: mp(h, y)
    }] : [!1, m, {}]
}
function mp(e, t) {
    return n => {
        e && e(n),
        n.defaultPrevented || t(n)
    }
}
function iK({page: e, ...t}) {
    let {router: n} = dF()
      , r = A.useMemo( () => eF(n.routes, e, n.basename), [n.routes, e, n.basename]);
    return r ? A.createElement(aK, {
        page: e,
        matches: r,
        ...t
    }) : null
}
function oK(e) {
    let {manifest: t, routeModules: n} = fF()
      , [r,i] = A.useState([]);
    return A.useEffect( () => {
        let o = !1;
        return KQ(e, t, n).then(a => {
            o || i(a)
        }
        ),
        () => {
            o = !0
        }
    }
    , [e, t, n]),
    r
}
function aK({page: e, matches: t, ...n}) {
    let r = Ec()
      , {manifest: i, routeModules: o} = fF()
      , {basename: a} = dF()
      , {loaderData: s, matches: c} = nK()
      , u = A.useMemo( () => hI(e, t, c, i, r, "data"), [e, t, c, i, r])
      , f = A.useMemo( () => hI(e, t, c, i, r, "assets"), [e, t, c, i, r])
      , h = A.useMemo( () => {
        if (e === r.pathname + r.search + r.hash)
            return [];
        let b = new Set
          , v = !1;
        if (t.forEach(C => {
            let w = i.routes[C.route.id];
            !w || !w.hasLoader || (!u.some(k => k.route.id === C.route.id) && C.route.id in s && o[C.route.id]?.shouldRevalidate || w.hasClientLoader ? v = !0 : b.add(C.route.id))
        }
        ),
        b.size === 0)
            return [];
        let S = YQ(e, a, "data");
        return v && b.size > 0 && S.searchParams.set("_routes", t.filter(C => b.has(C.route.id)).map(C => C.route.id).join(",")),
        [S.pathname + S.search]
    }
    , [a, s, r, i, u, t, e, o])
      , m = A.useMemo( () => XQ(f, i), [f, i])
      , y = oK(f);
    return A.createElement(A.Fragment, null, h.map(b => A.createElement("link", {
        key: b,
        rel: "prefetch",
        as: "fetch",
        href: b,
        ...n
    })), m.map(b => A.createElement("link", {
        key: b,
        rel: "modulepreload",
        href: b,
        ...n
    })), y.map( ({key: b, link: v}) => A.createElement("link", {
        key: b,
        nonce: n.nonce,
        ...v
    })))
}
function sK(...e) {
    return t => {
        e.forEach(n => {
            typeof n == "function" ? n(t) : n != null && (n.current = t)
        }
        )
    }
}
var hF = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    hF && (window.__reactRouterVersion = "7.9.4")
} catch {}
function lK({basename: e, children: t, window: n}) {
    let r = A.useRef();
    r.current == null && (r.current = GZ({
        window: n,
        v5Compat: !0
    }));
    let i = r.current
      , [o,a] = A.useState({
        action: i.action,
        location: i.location
    })
      , s = A.useCallback(c => {
        A.startTransition( () => a(c))
    }
    , [a]);
    return A.useLayoutEffect( () => i.listen(s), [i, s]),
    A.createElement(BQ, {
        basename: e,
        children: t,
        location: o.location,
        navigationType: o.action,
        navigator: i
    })
}
var pF = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , mF = A.forwardRef(function({onClick: t, discover: n="render", prefetch: r="none", relative: i, reloadDocument: o, replace: a, state: s, target: c, to: u, preventScrollReset: f, viewTransition: h, ...m}, y) {
    let {basename: b} = A.useContext(Rs), v = typeof u == "string" && pF.test(u), S, C = !1;
    if (typeof u == "string" && v && (S = u,
    hF))
        try {
            let z = new URL(window.location.href)
              , O = u.startsWith("//") ? new URL(z.protocol + u) : new URL(u)
              , I = Sl(O.pathname, b);
            O.origin === z.origin && I != null ? u = I + O.search + O.hash : C = !0
        } catch {
            ks(!1, `<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let w = vQ(u, {
        relative: i
    })
      , [k,T,E] = rK(r, m)
      , P = fK(u, {
        replace: a,
        state: s,
        target: c,
        preventScrollReset: f,
        relative: i,
        viewTransition: h
    });
    function D(z) {
        t && t(z),
        z.defaultPrevented || P(z)
    }
    let $ = A.createElement("a", {
        ...m,
        ...E,
        href: S || w,
        onClick: C || o ? t : D,
        ref: sK(y, T),
        target: c,
        "data-discover": !v && n === "render" ? "true" : void 0
    });
    return k && !v ? A.createElement(A.Fragment, null, $, A.createElement(iK, {
        page: w
    })) : $
});
mF.displayName = "Link";
var cK = A.forwardRef(function({"aria-current": t="page", caseSensitive: n=!1, className: r="", end: i=!1, style: o, to: a, viewTransition: s, children: c, ...u}, f) {
    let h = Cg(a, {
        relative: u.relative
    })
      , m = Ec()
      , y = A.useContext(_v)
      , {navigator: b, basename: v} = A.useContext(Rs)
      , S = y != null && yK(h) && s === !0
      , C = b.encodeLocation ? b.encodeLocation(h).pathname : h.pathname
      , w = m.pathname
      , k = y && y.navigation && y.navigation.location ? y.navigation.location.pathname : null;
    n || (w = w.toLowerCase(),
    k = k ? k.toLowerCase() : null,
    C = C.toLowerCase()),
    k && v && (k = Sl(k, v) || k);
    const T = C !== "/" && C.endsWith("/") ? C.length - 1 : C.length;
    let E = w === C || !i && w.startsWith(C) && w.charAt(T) === "/", P = k != null && (k === C || !i && k.startsWith(C) && k.charAt(C.length) === "/"), D = {
        isActive: E,
        isPending: P,
        isTransitioning: S
    }, $ = E ? t : void 0, z;
    typeof r == "function" ? z = r(D) : z = [r, E ? "active" : null, P ? "pending" : null, S ? "transitioning" : null].filter(Boolean).join(" ");
    let O = typeof o == "function" ? o(D) : o;
    return A.createElement(mF, {
        ...u,
        "aria-current": $,
        className: z,
        ref: f,
        style: O,
        to: a,
        viewTransition: s
    }, typeof c == "function" ? c(D) : c)
});
cK.displayName = "NavLink";
var uK = A.forwardRef( ({discover: e="render", fetcherKey: t, navigate: n, reloadDocument: r, replace: i, state: o, method: a=Sx, action: s, onSubmit: c, relative: u, preventScrollReset: f, viewTransition: h, ...m}, y) => {
    let b = mK()
      , v = gK(s, {
        relative: u
    })
      , S = a.toLowerCase() === "get" ? "get" : "post"
      , C = typeof s == "string" && pF.test(s)
      , w = k => {
        if (c && c(k),
        k.defaultPrevented)
            return;
        k.preventDefault();
        let T = k.nativeEvent.submitter
          , E = T?.getAttribute("formmethod") || a;
        b(T || k.currentTarget, {
            fetcherKey: t,
            method: E,
            navigate: n,
            replace: i,
            state: o,
            relative: u,
            preventScrollReset: f,
            viewTransition: h
        })
    }
    ;
    return A.createElement("form", {
        ref: y,
        method: S,
        action: v,
        onSubmit: r ? c : w,
        ...m,
        "data-discover": !C && e === "render" ? "true" : void 0
    })
}
);
uK.displayName = "Form";
function dK(e) {
    return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function gF(e) {
    let t = A.useContext(lh);
    return Sr(t, dK(e)),
    t
}
function fK(e, {target: t, replace: n, state: r, preventScrollReset: i, relative: o, viewTransition: a}={}) {
    let s = Os()
      , c = Ec()
      , u = Cg(e, {
        relative: o
    });
    return A.useCallback(f => {
        if (HQ(f, t)) {
            f.preventDefault();
            let h = n !== void 0 ? n : jm(c) === jm(u);
            s(e, {
                replace: h,
                state: r,
                preventScrollReset: i,
                relative: o,
                viewTransition: a
            })
        }
    }
    , [c, s, u, n, r, t, e, i, o, a])
}
var hK = 0
  , pK = () => `__${String(++hK)}__`;
function mK() {
    let {router: e} = gF("useSubmit")
      , {basename: t} = A.useContext(Rs)
      , n = OQ();
    return A.useCallback(async (r, i={}) => {
        let {action: o, method: a, encType: s, formData: c, body: u} = GQ(r, t);
        if (i.navigate === !1) {
            let f = i.fetcherKey || pK();
            await e.fetch(f, n, i.action || o, {
                preventScrollReset: i.preventScrollReset,
                formData: c,
                body: u,
                formMethod: i.method || a,
                formEncType: i.encType || s,
                flushSync: i.flushSync
            })
        } else
            await e.navigate(i.action || o, {
                preventScrollReset: i.preventScrollReset,
                formData: c,
                body: u,
                formMethod: i.method || a,
                formEncType: i.encType || s,
                replace: i.replace,
                state: i.state,
                fromRouteId: n,
                flushSync: i.flushSync,
                viewTransition: i.viewTransition
            })
    }
    , [e, t, n])
}
function gK(e, {relative: t}={}) {
    let {basename: n} = A.useContext(Rs)
      , r = A.useContext(Ds);
    Sr(r, "useFormAction must be used inside a RouteContext");
    let[i] = r.matches.slice(-1)
      , o = {
        ...Cg(e || ".", {
            relative: t
        })
    }
      , a = Ec();
    if (e == null) {
        o.search = a.search;
        let s = new URLSearchParams(o.search)
          , c = s.getAll("index");
        if (c.some(f => f === "")) {
            s.delete("index"),
            c.filter(h => h).forEach(h => s.append("index", h));
            let f = s.toString();
            o.search = f ? `?${f}` : ""
        }
    }
    return (!e || e === ".") && i.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"),
    n !== "/" && (o.pathname = o.pathname === "/" ? n : yl([n, o.pathname])),
    jm(o)
}
function yK(e, {relative: t}={}) {
    let n = A.useContext(aF);
    Sr(n != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: r} = gF("useViewTransitionState")
      , i = Cg(e, {
        relative: t
    });
    if (!n.isTransitioning)
        return !1;
    let o = Sl(n.currentLocation.pathname, r) || n.currentLocation.pathname
      , a = Sl(n.nextLocation.pathname, r) || n.nextLocation.pathname;
    return a0(i.pathname, a) != null || a0(i.pathname, o) != null
}
var yF = J5();
const Eb = es(yF);
var Rw = {
    exports: {}
}
  , Dw = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pI;
function bK() {
    if (pI)
        return Dw;
    pI = 1;
    var e = Tv();
    function t(c, u) {
        return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u
    }
    var n = typeof Object.is == "function" ? Object.is : t
      , r = e.useSyncExternalStore
      , i = e.useRef
      , o = e.useEffect
      , a = e.useMemo
      , s = e.useDebugValue;
    return Dw.useSyncExternalStoreWithSelector = function(c, u, f, h, m) {
        var y = i(null);
        if (y.current === null) {
            var b = {
                hasValue: !1,
                value: null
            };
            y.current = b
        } else
            b = y.current;
        y = a(function() {
            function S(E) {
                if (!C) {
                    if (C = !0,
                    w = E,
                    E = h(E),
                    m !== void 0 && b.hasValue) {
                        var P = b.value;
                        if (m(P, E))
                            return k = P
                    }
                    return k = E
                }
                if (P = k,
                n(w, E))
                    return P;
                var D = h(E);
                return m !== void 0 && m(P, D) ? (w = E,
                P) : (w = E,
                k = D)
            }
            var C = !1, w, k, T = f === void 0 ? null : f;
            return [function() {
                return S(u())
            }
            , T === null ? void 0 : function() {
                return S(T())
            }
            ]
        }, [u, f, h, m]);
        var v = r(c, y[0], y[1]);
        return o(function() {
            b.hasValue = !0,
            b.value = v
        }, [v]),
        s(v),
        v
    }
    ,
    Dw
}
var mI;
function xK() {
    return mI || (mI = 1,
    Rw.exports = bK()),
    Rw.exports
}
var vK = xK();
function bF(e) {
    e()
}
function SK() {
    let e = null
      , t = null;
    return {
        clear() {
            e = null,
            t = null
        },
        notify() {
            bF( () => {
                let n = e;
                for (; n; )
                    n.callback(),
                    n = n.next
            }
            )
        },
        get() {
            const n = [];
            let r = e;
            for (; r; )
                n.push(r),
                r = r.next;
            return n
        },
        subscribe(n) {
            let r = !0;
            const i = t = {
                callback: n,
                next: null,
                prev: t
            };
            return i.prev ? i.prev.next = i : e = i,
            function() {
                !r || e === null || (r = !1,
                i.next ? i.next.prev = i.prev : t = i.prev,
                i.prev ? i.prev.next = i.next : e = i.next)
            }
        }
    }
}
var gI = {
    notify() {},
    get: () => []
};
function CK(e, t) {
    let n, r = gI, i = 0, o = !1;
    function a(v) {
        f();
        const S = r.subscribe(v);
        let C = !1;
        return () => {
            C || (C = !0,
            S(),
            h())
        }
    }
    function s() {
        r.notify()
    }
    function c() {
        b.onStateChange && b.onStateChange()
    }
    function u() {
        return o
    }
    function f() {
        i++,
        n || (n = e.subscribe(c),
        r = SK())
    }
    function h() {
        i--,
        n && i === 0 && (n(),
        n = void 0,
        r.clear(),
        r = gI)
    }
    function m() {
        o || (o = !0,
        f())
    }
    function y() {
        o && (o = !1,
        h())
    }
    const b = {
        addNestedSub: a,
        notifyNestedSubs: s,
        handleChangeWrapper: c,
        isSubscribed: u,
        trySubscribe: m,
        tryUnsubscribe: y,
        getListeners: () => r
    };
    return b
}
var wK = () => typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , kK = wK()
  , TK = () => typeof navigator < "u" && navigator.product === "ReactNative"
  , _K = TK()
  , EK = () => kK || _K ? A.useLayoutEffect : A.useEffect
  , AK = EK();
function yI(e, t) {
    return e === t ? e !== 0 || t !== 0 || 1 / e === 1 / t : e !== e && t !== t
}
function um(e, t) {
    if (yI(e, t))
        return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
    const n = Object.keys(e)
      , r = Object.keys(t);
    if (n.length !== r.length)
        return !1;
    for (let i = 0; i < n.length; i++)
        if (!Object.prototype.hasOwnProperty.call(t, n[i]) || !yI(e[n[i]], t[n[i]]))
            return !1;
    return !0
}
var MK = Symbol.for("react-redux-context")
  , PK = typeof globalThis < "u" ? globalThis : {};
function RK() {
    if (!A.createContext)
        return {};
    const e = PK[MK] ??= new Map;
    let t = e.get(A.createContext);
    return t || (t = A.createContext(null),
    e.set(A.createContext, t)),
    t
}
var gc = RK();
function DK(e) {
    const {children: t, context: n, serverState: r, store: i} = e
      , o = A.useMemo( () => {
        const c = CK(i);
        return {
            store: i,
            subscription: c,
            getServerState: r ? () => r : void 0
        }
    }
    , [i, r])
      , a = A.useMemo( () => i.getState(), [i]);
    AK( () => {
        const {subscription: c} = o;
        return c.onStateChange = c.notifyNestedSubs,
        c.trySubscribe(),
        a !== i.getState() && c.notifyNestedSubs(),
        () => {
            c.tryUnsubscribe(),
            c.onStateChange = void 0
        }
    }
    , [o, a]);
    const s = n || gc;
    return A.createElement(s.Provider, {
        value: o
    }, t)
}
var OK = DK;
function rE(e=gc) {
    return function() {
        return A.useContext(e)
    }
}
var xF = rE();
function vF(e=gc) {
    const t = e === gc ? xF : rE(e)
      , n = () => {
        const {store: r} = t();
        return r
    }
    ;
    return Object.assign(n, {
        withTypes: () => n
    }),
    n
}
var SF = vF();
function IK(e=gc) {
    const t = e === gc ? SF : vF(e)
      , n = () => t().dispatch;
    return Object.assign(n, {
        withTypes: () => n
    }),
    n
}
var $K = IK()
  , LK = (e, t) => e === t;
function jK(e=gc) {
    const t = e === gc ? xF : rE(e)
      , n = (r, i={}) => {
        const {equalityFn: o=LK} = typeof i == "function" ? {
            equalityFn: i
        } : i
          , a = t()
          , {store: s, subscription: c, getServerState: u} = a;
        A.useRef(!0);
        const f = A.useCallback({
            [r.name](m) {
                return r(m)
            }
        }[r.name], [r])
          , h = vK.useSyncExternalStoreWithSelector(c.addNestedSub, s.getState, u || s.getState, f, o);
        return A.useDebugValue(h),
        h
    }
    ;
    return Object.assign(n, {
        withTypes: () => n
    }),
    n
}
var CF = jK()
  , BK = bF
  , ch = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(e) {
        return this.listeners.add(e),
        this.onSubscribe(),
        () => {
            this.listeners.delete(e),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , zK = {
    setTimeout: (e, t) => setTimeout(e, t),
    clearTimeout: e => clearTimeout(e),
    setInterval: (e, t) => setInterval(e, t),
    clearInterval: e => clearInterval(e)
}
  , FK = class {
    #e = zK;
    #t = !1;
    setTimeoutProvider(e) {
        this.#e = e
    }
    setTimeout(e, t) {
        return this.#e.setTimeout(e, t)
    }
    clearTimeout(e) {
        this.#e.clearTimeout(e)
    }
    setInterval(e, t) {
        return this.#e.setInterval(e, t)
    }
    clearInterval(e) {
        this.#e.clearInterval(e)
    }
}
  , xu = new FK;
function NK(e) {
    setTimeout(e, 0)
}
var $u = typeof window > "u" || "Deno"in globalThis;
function Bi() {}
function UK(e, t) {
    return typeof e == "function" ? e(t) : e
}
function k2(e) {
    return typeof e == "number" && e >= 0 && e !== 1 / 0
}
function wF(e, t) {
    return Math.max(e + (t || 0) - Date.now(), 0)
}
function fc(e, t) {
    return typeof e == "function" ? e(t) : e
}
function pa(e, t) {
    return typeof e == "function" ? e(t) : e
}
function bI(e, t) {
    const {type: n="all", exact: r, fetchStatus: i, predicate: o, queryKey: a, stale: s} = e;
    if (a) {
        if (r) {
            if (t.queryHash !== iE(a, t.options))
                return !1
        } else if (!Bm(t.queryKey, a))
            return !1
    }
    if (n !== "all") {
        const c = t.isActive();
        if (n === "active" && !c || n === "inactive" && c)
            return !1
    }
    return !(typeof s == "boolean" && t.isStale() !== s || i && i !== t.state.fetchStatus || o && !o(t))
}
function xI(e, t) {
    const {exact: n, status: r, predicate: i, mutationKey: o} = e;
    if (o) {
        if (!t.options.mutationKey)
            return !1;
        if (n) {
            if (Lu(t.options.mutationKey) !== Lu(o))
                return !1
        } else if (!Bm(t.options.mutationKey, o))
            return !1
    }
    return !(r && t.state.status !== r || i && !i(t))
}
function iE(e, t) {
    return (t?.queryKeyHashFn || Lu)(e)
}
function Lu(e) {
    return JSON.stringify(e, (t, n) => T2(n) ? Object.keys(n).sort().reduce( (r, i) => (r[i] = n[i],
    r), {}) : n)
}
function Bm(e, t) {
    return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every(n => Bm(e[n], t[n])) : !1
}
var VK = Object.prototype.hasOwnProperty;
function kF(e, t) {
    if (e === t)
        return e;
    const n = vI(e) && vI(t);
    if (!n && !(T2(e) && T2(t)))
        return t;
    const i = (n ? e : Object.keys(e)).length
      , o = n ? t : Object.keys(t)
      , a = o.length
      , s = n ? new Array(a) : {};
    let c = 0;
    for (let u = 0; u < a; u++) {
        const f = n ? u : o[u]
          , h = e[f]
          , m = t[f];
        if (h === m) {
            s[f] = h,
            (n ? u < i : VK.call(e, f)) && c++;
            continue
        }
        if (h === null || m === null || typeof h != "object" || typeof m != "object") {
            s[f] = m;
            continue
        }
        const y = kF(h, m);
        s[f] = y,
        y === h && c++
    }
    return i === a && c === i ? e : s
}
function s0(e, t) {
    if (!t || Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (e[n] !== t[n])
            return !1;
    return !0
}
function vI(e) {
    return Array.isArray(e) && e.length === Object.keys(e).length
}
function T2(e) {
    if (!SI(e))
        return !1;
    const t = e.constructor;
    if (t === void 0)
        return !0;
    const n = t.prototype;
    return !(!SI(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype)
}
function SI(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
function HK(e) {
    return new Promise(t => {
        xu.setTimeout(t, e)
    }
    )
}
function _2(e, t, n) {
    return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? kF(e, t) : t
}
function qK(e, t, n=0) {
    const r = [...e, t];
    return n && r.length > n ? r.slice(1) : r
}
function WK(e, t, n=0) {
    const r = [t, ...e];
    return n && r.length > n ? r.slice(0, -1) : r
}
var oE = Symbol();
function TF(e, t) {
    return !e.queryFn && t?.initialPromise ? () => t.initialPromise : !e.queryFn || e.queryFn === oE ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn
}
function _F(e, t) {
    return typeof e == "function" ? e(...t) : !!e
}
var GK = class extends ch {
    #e;
    #t;
    #n;
    constructor() {
        super(),
        this.#n = e => {
            if (!$u && window.addEventListener) {
                const t = () => e();
                return window.addEventListener("visibilitychange", t, !1),
                () => {
                    window.removeEventListener("visibilitychange", t)
                }
            }
        }
    }
    onSubscribe() {
        this.#t || this.setEventListener(this.#n)
    }
    onUnsubscribe() {
        this.hasListeners() || (this.#t?.(),
        this.#t = void 0)
    }
    setEventListener(e) {
        this.#n = e,
        this.#t?.(),
        this.#t = e(t => {
            typeof t == "boolean" ? this.setFocused(t) : this.onFocus()
        }
        )
    }
    setFocused(e) {
        this.#e !== e && (this.#e = e,
        this.onFocus())
    }
    onFocus() {
        const e = this.isFocused();
        this.listeners.forEach(t => {
            t(e)
        }
        )
    }
    isFocused() {
        return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden"
    }
}
  , aE = new GK;
function E2() {
    let e, t;
    const n = new Promise( (i, o) => {
        e = i,
        t = o
    }
    );
    n.status = "pending",
    n.catch( () => {}
    );
    function r(i) {
        Object.assign(n, i),
        delete n.resolve,
        delete n.reject
    }
    return n.resolve = i => {
        r({
            status: "fulfilled",
            value: i
        }),
        e(i)
    }
    ,
    n.reject = i => {
        r({
            status: "rejected",
            reason: i
        }),
        t(i)
    }
    ,
    n
}
var YK = NK;
function ZK() {
    let e = []
      , t = 0
      , n = s => {
        s()
    }
      , r = s => {
        s()
    }
      , i = YK;
    const o = s => {
        t ? e.push(s) : i( () => {
            n(s)
        }
        )
    }
      , a = () => {
        const s = e;
        e = [],
        s.length && i( () => {
            r( () => {
                s.forEach(c => {
                    n(c)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: s => {
            let c;
            t++;
            try {
                c = s()
            } finally {
                t--,
                t || a()
            }
            return c
        }
        ,
        batchCalls: s => (...c) => {
            o( () => {
                s(...c)
            }
            )
        }
        ,
        schedule: o,
        setNotifyFunction: s => {
            n = s
        }
        ,
        setBatchNotifyFunction: s => {
            r = s
        }
        ,
        setScheduler: s => {
            i = s
        }
    }
}
var ni = ZK()
  , QK = class extends ch {
    #e = !0;
    #t;
    #n;
    constructor() {
        super(),
        this.#n = e => {
            if (!$u && window.addEventListener) {
                const t = () => e(!0)
                  , n = () => e(!1);
                return window.addEventListener("online", t, !1),
                window.addEventListener("offline", n, !1),
                () => {
                    window.removeEventListener("online", t),
                    window.removeEventListener("offline", n)
                }
            }
        }
    }
    onSubscribe() {
        this.#t || this.setEventListener(this.#n)
    }
    onUnsubscribe() {
        this.hasListeners() || (this.#t?.(),
        this.#t = void 0)
    }
    setEventListener(e) {
        this.#n = e,
        this.#t?.(),
        this.#t = e(this.setOnline.bind(this))
    }
    setOnline(e) {
        this.#e !== e && (this.#e = e,
        this.listeners.forEach(n => {
            n(e)
        }
        ))
    }
    isOnline() {
        return this.#e
    }
}
  , l0 = new QK;
function KK(e) {
    return Math.min(1e3 * 2 ** e, 3e4)
}
function EF(e) {
    return (e ?? "online") === "online" ? l0.isOnline() : !0
}
var A2 = class extends Error {
    constructor(e) {
        super("CancelledError"),
        this.revert = e?.revert,
        this.silent = e?.silent
    }
}
;
function AF(e) {
    let t = !1, n = 0, r;
    const i = E2()
      , o = () => i.status !== "pending"
      , a = v => {
        if (!o()) {
            const S = new A2(v);
            m(S),
            e.onCancel?.(S)
        }
    }
      , s = () => {
        t = !0
    }
      , c = () => {
        t = !1
    }
      , u = () => aE.isFocused() && (e.networkMode === "always" || l0.isOnline()) && e.canRun()
      , f = () => EF(e.networkMode) && e.canRun()
      , h = v => {
        o() || (r?.(),
        i.resolve(v))
    }
      , m = v => {
        o() || (r?.(),
        i.reject(v))
    }
      , y = () => new Promise(v => {
        r = S => {
            (o() || u()) && v(S)
        }
        ,
        e.onPause?.()
    }
    ).then( () => {
        r = void 0,
        o() || e.onContinue?.()
    }
    )
      , b = () => {
        if (o())
            return;
        let v;
        const S = n === 0 ? e.initialPromise : void 0;
        try {
            v = S ?? e.fn()
        } catch (C) {
            v = Promise.reject(C)
        }
        Promise.resolve(v).then(h).catch(C => {
            if (o())
                return;
            const w = e.retry ?? ($u ? 0 : 3)
              , k = e.retryDelay ?? KK
              , T = typeof k == "function" ? k(n, C) : k
              , E = w === !0 || typeof w == "number" && n < w || typeof w == "function" && w(n, C);
            if (t || !E) {
                m(C);
                return
            }
            n++,
            e.onFail?.(n, C),
            HK(T).then( () => u() ? void 0 : y()).then( () => {
                t ? m(C) : b()
            }
            )
        }
        )
    }
    ;
    return {
        promise: i,
        status: () => i.status,
        cancel: a,
        continue: () => (r?.(),
        i),
        cancelRetry: s,
        continueRetry: c,
        canStart: f,
        start: () => (f() ? b() : y().then(b),
        i)
    }
}
var MF = class {
    #e;
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        k2(this.gcTime) && (this.#e = xu.setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(e) {
        this.gcTime = Math.max(this.gcTime || 0, e ?? ($u ? 1 / 0 : 300 * 1e3))
    }
    clearGcTimeout() {
        this.#e && (xu.clearTimeout(this.#e),
        this.#e = void 0)
    }
}
  , XK = class extends MF {
    #e;
    #t;
    #n;
    #i;
    #r;
    #a;
    #s;
    constructor(e) {
        super(),
        this.#s = !1,
        this.#a = e.defaultOptions,
        this.setOptions(e.options),
        this.observers = [],
        this.#i = e.client,
        this.#n = this.#i.getQueryCache(),
        this.queryKey = e.queryKey,
        this.queryHash = e.queryHash,
        this.#e = CI(this.options),
        this.state = e.state ?? this.#e,
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        return this.#r?.promise
    }
    setOptions(e) {
        if (this.options = {
            ...this.#a,
            ...e
        },
        this.updateGcTime(this.options.gcTime),
        this.state && this.state.data === void 0) {
            const t = CI(this.options);
            t.data !== void 0 && (this.setData(t.data, {
                updatedAt: t.dataUpdatedAt,
                manual: !0
            }),
            this.#e = t)
        }
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && this.#n.remove(this)
    }
    setData(e, t) {
        const n = _2(this.state.data, e, this.options);
        return this.#o({
            data: n,
            type: "success",
            dataUpdatedAt: t?.updatedAt,
            manual: t?.manual
        }),
        n
    }
    setState(e, t) {
        this.#o({
            type: "setState",
            state: e,
            setStateOptions: t
        })
    }
    cancel(e) {
        const t = this.#r?.promise;
        return this.#r?.cancel(e),
        t ? t.then(Bi).catch(Bi) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(this.#e)
    }
    isActive() {
        return this.observers.some(e => pa(e.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === oE || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStatic() {
        return this.getObserversCount() > 0 ? this.observers.some(e => fc(e.options.staleTime, this) === "static") : !1
    }
    isStale() {
        return this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated
    }
    isStaleByTime(e=0) {
        return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !wF(this.state.dataUpdatedAt, e)
    }
    onFocus() {
        this.observers.find(t => t.shouldFetchOnWindowFocus())?.refetch({
            cancelRefetch: !1
        }),
        this.#r?.continue()
    }
    onOnline() {
        this.observers.find(t => t.shouldFetchOnReconnect())?.refetch({
            cancelRefetch: !1
        }),
        this.#r?.continue()
    }
    addObserver(e) {
        this.observers.includes(e) || (this.observers.push(e),
        this.clearGcTimeout(),
        this.#n.notify({
            type: "observerAdded",
            query: this,
            observer: e
        }))
    }
    removeObserver(e) {
        this.observers.includes(e) && (this.observers = this.observers.filter(t => t !== e),
        this.observers.length || (this.#r && (this.#s ? this.#r.cancel({
            revert: !0
        }) : this.#r.cancelRetry()),
        this.scheduleGc()),
        this.#n.notify({
            type: "observerRemoved",
            query: this,
            observer: e
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || this.#o({
            type: "invalidate"
        })
    }
    async fetch(e, t) {
        if (this.state.fetchStatus !== "idle" && this.#r?.status() !== "rejected") {
            if (this.state.data !== void 0 && t?.cancelRefetch)
                this.cancel({
                    silent: !0
                });
            else if (this.#r)
                return this.#r.continueRetry(),
                this.#r.promise
        }
        if (e && this.setOptions(e),
        !this.options.queryFn) {
            const s = this.observers.find(c => c.options.queryFn);
            s && this.setOptions(s.options)
        }
        const n = new AbortController
          , r = s => {
            Object.defineProperty(s, "signal", {
                enumerable: !0,
                get: () => (this.#s = !0,
                n.signal)
            })
        }
          , i = () => {
            const s = TF(this.options, t)
              , u = ( () => {
                const f = {
                    client: this.#i,
                    queryKey: this.queryKey,
                    meta: this.meta
                };
                return r(f),
                f
            }
            )();
            return this.#s = !1,
            this.options.persister ? this.options.persister(s, u, this) : s(u)
        }
          , a = ( () => {
            const s = {
                fetchOptions: t,
                options: this.options,
                queryKey: this.queryKey,
                client: this.#i,
                state: this.state,
                fetchFn: i
            };
            return r(s),
            s
        }
        )();
        this.options.behavior?.onFetch(a, this),
        this.#t = this.state,
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && this.#o({
            type: "fetch",
            meta: a.fetchOptions?.meta
        }),
        this.#r = AF({
            initialPromise: t?.initialPromise,
            fn: a.fetchFn,
            onCancel: s => {
                s instanceof A2 && s.revert && this.setState({
                    ...this.#t,
                    fetchStatus: "idle"
                }),
                n.abort()
            }
            ,
            onFail: (s, c) => {
                this.#o({
                    type: "failed",
                    failureCount: s,
                    error: c
                })
            }
            ,
            onPause: () => {
                this.#o({
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                this.#o({
                    type: "continue"
                })
            }
            ,
            retry: a.options.retry,
            retryDelay: a.options.retryDelay,
            networkMode: a.options.networkMode,
            canRun: () => !0
        });
        try {
            const s = await this.#r.start();
            if (s === void 0)
                throw new Error(`${this.queryHash} data is undefined`);
            return this.setData(s),
            this.#n.config.onSuccess?.(s, this),
            this.#n.config.onSettled?.(s, this.state.error, this),
            s
        } catch (s) {
            if (s instanceof A2) {
                if (s.silent)
                    return this.#r.promise;
                if (s.revert) {
                    if (this.state.data === void 0)
                        throw s;
                    return this.state.data
                }
            }
            throw this.#o({
                type: "error",
                error: s
            }),
            this.#n.config.onError?.(s, this),
            this.#n.config.onSettled?.(this.state.data, s, this),
            s
        } finally {
            this.scheduleGc()
        }
    }
    #o(e) {
        const t = n => {
            switch (e.type) {
            case "failed":
                return {
                    ...n,
                    fetchFailureCount: e.failureCount,
                    fetchFailureReason: e.error
                };
            case "pause":
                return {
                    ...n,
                    fetchStatus: "paused"
                };
            case "continue":
                return {
                    ...n,
                    fetchStatus: "fetching"
                };
            case "fetch":
                return {
                    ...n,
                    ...PF(n.data, this.options),
                    fetchMeta: e.meta ?? null
                };
            case "success":
                const r = {
                    ...n,
                    data: e.data,
                    dataUpdateCount: n.dataUpdateCount + 1,
                    dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
                    error: null,
                    isInvalidated: !1,
                    status: "success",
                    ...!e.manual && {
                        fetchStatus: "idle",
                        fetchFailureCount: 0,
                        fetchFailureReason: null
                    }
                };
                return this.#t = e.manual ? r : void 0,
                r;
            case "error":
                const i = e.error;
                return {
                    ...n,
                    error: i,
                    errorUpdateCount: n.errorUpdateCount + 1,
                    errorUpdatedAt: Date.now(),
                    fetchFailureCount: n.fetchFailureCount + 1,
                    fetchFailureReason: i,
                    fetchStatus: "idle",
                    status: "error"
                };
            case "invalidate":
                return {
                    ...n,
                    isInvalidated: !0
                };
            case "setState":
                return {
                    ...n,
                    ...e.state
                }
            }
        }
        ;
        this.state = t(this.state),
        ni.batch( () => {
            this.observers.forEach(n => {
                n.onQueryUpdate()
            }
            ),
            this.#n.notify({
                query: this,
                type: "updated",
                action: e
            })
        }
        )
    }
}
;
function PF(e, t) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: EF(t.networkMode) ? "fetching" : "paused",
        ...e === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function CI(e) {
    const t = typeof e.initialData == "function" ? e.initialData() : e.initialData
      , n = t !== void 0
      , r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
    return {
        data: t,
        dataUpdateCount: 0,
        dataUpdatedAt: n ? r ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: n ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var JK = class extends ch {
    constructor(e, t) {
        super(),
        this.options = t,
        this.#e = e,
        this.#o = null,
        this.#s = E2(),
        this.bindMethods(),
        this.setOptions(t)
    }
    #e;
    #t = void 0;
    #n = void 0;
    #i = void 0;
    #r;
    #a;
    #s;
    #o;
    #m;
    #f;
    #h;
    #c;
    #u;
    #l;
    #p = new Set;
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (this.#t.addObserver(this),
        wI(this.#t, this.options) ? this.#d() : this.updateResult(),
        this.#x())
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return M2(this.#t, this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return M2(this.#t, this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        this.#v(),
        this.#S(),
        this.#t.removeObserver(this)
    }
    setOptions(e) {
        const t = this.options
          , n = this.#t;
        if (this.options = this.#e.defaultQueryOptions(e),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof pa(this.options.enabled, this.#t) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        this.#C(),
        this.#t.setOptions(this.options),
        t._defaulted && !s0(this.options, t) && this.#e.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.#t,
            observer: this
        });
        const r = this.hasListeners();
        r && kI(this.#t, n, this.options, t) && this.#d(),
        this.updateResult(),
        r && (this.#t !== n || pa(this.options.enabled, this.#t) !== pa(t.enabled, this.#t) || fc(this.options.staleTime, this.#t) !== fc(t.staleTime, this.#t)) && this.#g();
        const i = this.#y();
        r && (this.#t !== n || pa(this.options.enabled, this.#t) !== pa(t.enabled, this.#t) || i !== this.#l) && this.#b(i)
    }
    getOptimisticResult(e) {
        const t = this.#e.getQueryCache().build(this.#e, e)
          , n = this.createResult(t, e);
        return tX(this, n) && (this.#i = n,
        this.#a = this.options,
        this.#r = this.#t.state),
        n
    }
    getCurrentResult() {
        return this.#i
    }
    trackResult(e, t) {
        return new Proxy(e,{
            get: (n, r) => (this.trackProp(r),
            t?.(r),
            r === "promise" && (this.trackProp("data"),
            !this.options.experimental_prefetchInRender && this.#s.status === "pending" && this.#s.reject(new Error("experimental_prefetchInRender feature flag is not enabled"))),
            Reflect.get(n, r))
        })
    }
    trackProp(e) {
        this.#p.add(e)
    }
    getCurrentQuery() {
        return this.#t
    }
    refetch({...e}={}) {
        return this.fetch({
            ...e
        })
    }
    fetchOptimistic(e) {
        const t = this.#e.defaultQueryOptions(e)
          , n = this.#e.getQueryCache().build(this.#e, t);
        return n.fetch().then( () => this.createResult(n, t))
    }
    fetch(e) {
        return this.#d({
            ...e,
            cancelRefetch: e.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        this.#i))
    }
    #d(e) {
        this.#C();
        let t = this.#t.fetch(this.options, e);
        return e?.throwOnError || (t = t.catch(Bi)),
        t
    }
    #g() {
        this.#v();
        const e = fc(this.options.staleTime, this.#t);
        if ($u || this.#i.isStale || !k2(e))
            return;
        const n = wF(this.#i.dataUpdatedAt, e) + 1;
        this.#c = xu.setTimeout( () => {
            this.#i.isStale || this.updateResult()
        }
        , n)
    }
    #y() {
        return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.#t) : this.options.refetchInterval) ?? !1
    }
    #b(e) {
        this.#S(),
        this.#l = e,
        !($u || pa(this.options.enabled, this.#t) === !1 || !k2(this.#l) || this.#l === 0) && (this.#u = xu.setInterval( () => {
            (this.options.refetchIntervalInBackground || aE.isFocused()) && this.#d()
        }
        , this.#l))
    }
    #x() {
        this.#g(),
        this.#b(this.#y())
    }
    #v() {
        this.#c && (xu.clearTimeout(this.#c),
        this.#c = void 0)
    }
    #S() {
        this.#u && (xu.clearInterval(this.#u),
        this.#u = void 0)
    }
    createResult(e, t) {
        const n = this.#t
          , r = this.options
          , i = this.#i
          , o = this.#r
          , a = this.#a
          , c = e !== n ? e.state : this.#n
          , {state: u} = e;
        let f = {
            ...u
        }, h = !1, m;
        if (t._optimisticResults) {
            const $ = this.hasListeners()
              , z = !$ && wI(e, t)
              , O = $ && kI(e, n, t, r);
            (z || O) && (f = {
                ...f,
                ...PF(u.data, e.options)
            }),
            t._optimisticResults === "isRestoring" && (f.fetchStatus = "idle")
        }
        let {error: y, errorUpdatedAt: b, status: v} = f;
        m = f.data;
        let S = !1;
        if (t.placeholderData !== void 0 && m === void 0 && v === "pending") {
            let $;
            i?.isPlaceholderData && t.placeholderData === a?.placeholderData ? ($ = i.data,
            S = !0) : $ = typeof t.placeholderData == "function" ? t.placeholderData(this.#h?.state.data, this.#h) : t.placeholderData,
            $ !== void 0 && (v = "success",
            m = _2(i?.data, $, t),
            h = !0)
        }
        if (t.select && m !== void 0 && !S)
            if (i && m === o?.data && t.select === this.#m)
                m = this.#f;
            else
                try {
                    this.#m = t.select,
                    m = t.select(m),
                    m = _2(i?.data, m, t),
                    this.#f = m,
                    this.#o = null
                } catch ($) {
                    this.#o = $
                }
        this.#o && (y = this.#o,
        m = this.#f,
        b = Date.now(),
        v = "error");
        const C = f.fetchStatus === "fetching"
          , w = v === "pending"
          , k = v === "error"
          , T = w && C
          , E = m !== void 0
          , D = {
            status: v,
            fetchStatus: f.fetchStatus,
            isPending: w,
            isSuccess: v === "success",
            isError: k,
            isInitialLoading: T,
            isLoading: T,
            data: m,
            dataUpdatedAt: f.dataUpdatedAt,
            error: y,
            errorUpdatedAt: b,
            failureCount: f.fetchFailureCount,
            failureReason: f.fetchFailureReason,
            errorUpdateCount: f.errorUpdateCount,
            isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
            isFetchedAfterMount: f.dataUpdateCount > c.dataUpdateCount || f.errorUpdateCount > c.errorUpdateCount,
            isFetching: C,
            isRefetching: C && !w,
            isLoadingError: k && !E,
            isPaused: f.fetchStatus === "paused",
            isPlaceholderData: h,
            isRefetchError: k && E,
            isStale: sE(e, t),
            refetch: this.refetch,
            promise: this.#s,
            isEnabled: pa(t.enabled, e) !== !1
        };
        if (this.options.experimental_prefetchInRender) {
            const $ = I => {
                D.status === "error" ? I.reject(D.error) : D.data !== void 0 && I.resolve(D.data)
            }
              , z = () => {
                const I = this.#s = D.promise = E2();
                $(I)
            }
              , O = this.#s;
            switch (O.status) {
            case "pending":
                e.queryHash === n.queryHash && $(O);
                break;
            case "fulfilled":
                (D.status === "error" || D.data !== O.value) && z();
                break;
            case "rejected":
                (D.status !== "error" || D.error !== O.reason) && z();
                break
            }
        }
        return D
    }
    updateResult() {
        const e = this.#i
          , t = this.createResult(this.#t, this.options);
        if (this.#r = this.#t.state,
        this.#a = this.options,
        this.#r.data !== void 0 && (this.#h = this.#t),
        s0(t, e))
            return;
        this.#i = t;
        const n = () => {
            if (!e)
                return !0;
            const {notifyOnChangeProps: r} = this.options
              , i = typeof r == "function" ? r() : r;
            if (i === "all" || !i && !this.#p.size)
                return !0;
            const o = new Set(i ?? this.#p);
            return this.options.throwOnError && o.add("error"),
            Object.keys(this.#i).some(a => {
                const s = a;
                return this.#i[s] !== e[s] && o.has(s)
            }
            )
        }
        ;
        this.#w({
            listeners: n()
        })
    }
    #C() {
        const e = this.#e.getQueryCache().build(this.#e, this.options);
        if (e === this.#t)
            return;
        const t = this.#t;
        this.#t = e,
        this.#n = e.state,
        this.hasListeners() && (t?.removeObserver(this),
        e.addObserver(this))
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && this.#x()
    }
    #w(e) {
        ni.batch( () => {
            e.listeners && this.listeners.forEach(t => {
                t(this.#i)
            }
            ),
            this.#e.getQueryCache().notify({
                query: this.#t,
                type: "observerResultsUpdated"
            })
        }
        )
    }
}
;
function eX(e, t) {
    return pa(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1)
}
function wI(e, t) {
    return eX(e, t) || e.state.data !== void 0 && M2(e, t, t.refetchOnMount)
}
function M2(e, t, n) {
    if (pa(t.enabled, e) !== !1 && fc(t.staleTime, e) !== "static") {
        const r = typeof n == "function" ? n(e) : n;
        return r === "always" || r !== !1 && sE(e, t)
    }
    return !1
}
function kI(e, t, n, r) {
    return (e !== t || pa(r.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && sE(e, n)
}
function sE(e, t) {
    return pa(t.enabled, e) !== !1 && e.isStaleByTime(fc(t.staleTime, e))
}
function tX(e, t) {
    return !s0(e.getCurrentResult(), t)
}
function TI(e) {
    return {
        onFetch: (t, n) => {
            const r = t.options
              , i = t.fetchOptions?.meta?.fetchMore?.direction
              , o = t.state.data?.pages || []
              , a = t.state.data?.pageParams || [];
            let s = {
                pages: [],
                pageParams: []
            }
              , c = 0;
            const u = async () => {
                let f = !1;
                const h = b => {
                    Object.defineProperty(b, "signal", {
                        enumerable: !0,
                        get: () => (t.signal.aborted ? f = !0 : t.signal.addEventListener("abort", () => {
                            f = !0
                        }
                        ),
                        t.signal)
                    })
                }
                  , m = TF(t.options, t.fetchOptions)
                  , y = async (b, v, S) => {
                    if (f)
                        return Promise.reject();
                    if (v == null && b.pages.length)
                        return Promise.resolve(b);
                    const w = ( () => {
                        const P = {
                            client: t.client,
                            queryKey: t.queryKey,
                            pageParam: v,
                            direction: S ? "backward" : "forward",
                            meta: t.options.meta
                        };
                        return h(P),
                        P
                    }
                    )()
                      , k = await m(w)
                      , {maxPages: T} = t.options
                      , E = S ? WK : qK;
                    return {
                        pages: E(b.pages, k, T),
                        pageParams: E(b.pageParams, v, T)
                    }
                }
                ;
                if (i && o.length) {
                    const b = i === "backward"
                      , v = b ? nX : _I
                      , S = {
                        pages: o,
                        pageParams: a
                    }
                      , C = v(r, S);
                    s = await y(S, C, b)
                } else {
                    const b = e ?? o.length;
                    do {
                        const v = c === 0 ? a[0] ?? r.initialPageParam : _I(r, s);
                        if (c > 0 && v == null)
                            break;
                        s = await y(s, v),
                        c++
                    } while (c < b)
                }
                return s
            }
            ;
            t.options.persister ? t.fetchFn = () => t.options.persister?.(u, {
                client: t.client,
                queryKey: t.queryKey,
                meta: t.options.meta,
                signal: t.signal
            }, n) : t.fetchFn = u
        }
    }
}
function _I(e, {pages: t, pageParams: n}) {
    const r = t.length - 1;
    return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0
}
function nX(e, {pages: t, pageParams: n}) {
    return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, n[0], n) : void 0
}
var rX = class extends MF {
    #e;
    #t;
    #n;
    #i;
    constructor(e) {
        super(),
        this.#e = e.client,
        this.mutationId = e.mutationId,
        this.#n = e.mutationCache,
        this.#t = [],
        this.state = e.state || RF(),
        this.setOptions(e.options),
        this.scheduleGc()
    }
    setOptions(e) {
        this.options = e,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(e) {
        this.#t.includes(e) || (this.#t.push(e),
        this.clearGcTimeout(),
        this.#n.notify({
            type: "observerAdded",
            mutation: this,
            observer: e
        }))
    }
    removeObserver(e) {
        this.#t = this.#t.filter(t => t !== e),
        this.scheduleGc(),
        this.#n.notify({
            type: "observerRemoved",
            mutation: this,
            observer: e
        })
    }
    optionalRemove() {
        this.#t.length || (this.state.status === "pending" ? this.scheduleGc() : this.#n.remove(this))
    }
    continue() {
        return this.#i?.continue() ?? this.execute(this.state.variables)
    }
    async execute(e) {
        const t = () => {
            this.#r({
                type: "continue"
            })
        }
          , n = {
            client: this.#e,
            meta: this.options.meta,
            mutationKey: this.options.mutationKey
        };
        this.#i = AF({
            fn: () => this.options.mutationFn ? this.options.mutationFn(e, n) : Promise.reject(new Error("No mutationFn found")),
            onFail: (o, a) => {
                this.#r({
                    type: "failed",
                    failureCount: o,
                    error: a
                })
            }
            ,
            onPause: () => {
                this.#r({
                    type: "pause"
                })
            }
            ,
            onContinue: t,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => this.#n.canRun(this)
        });
        const r = this.state.status === "pending"
          , i = !this.#i.canStart();
        try {
            if (r)
                t();
            else {
                this.#r({
                    type: "pending",
                    variables: e,
                    isPaused: i
                }),
                await this.#n.config.onMutate?.(e, this, n);
                const a = await this.options.onMutate?.(e, n);
                a !== this.state.context && this.#r({
                    type: "pending",
                    context: a,
                    variables: e,
                    isPaused: i
                })
            }
            const o = await this.#i.start();
            return await this.#n.config.onSuccess?.(o, e, this.state.context, this, n),
            await this.options.onSuccess?.(o, e, this.state.context, n),
            await this.#n.config.onSettled?.(o, null, this.state.variables, this.state.context, this, n),
            await this.options.onSettled?.(o, null, e, this.state.context, n),
            this.#r({
                type: "success",
                data: o
            }),
            o
        } catch (o) {
            try {
                throw await this.#n.config.onError?.(o, e, this.state.context, this, n),
                await this.options.onError?.(o, e, this.state.context, n),
                await this.#n.config.onSettled?.(void 0, o, this.state.variables, this.state.context, this, n),
                await this.options.onSettled?.(void 0, o, e, this.state.context, n),
                o
            } finally {
                this.#r({
                    type: "error",
                    error: o
                })
            }
        } finally {
            this.#n.runNext(this)
        }
    }
    #r(e) {
        const t = n => {
            switch (e.type) {
            case "failed":
                return {
                    ...n,
                    failureCount: e.failureCount,
                    failureReason: e.error
                };
            case "pause":
                return {
                    ...n,
                    isPaused: !0
                };
            case "continue":
                return {
                    ...n,
                    isPaused: !1
                };
            case "pending":
                return {
                    ...n,
                    context: e.context,
                    data: void 0,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    isPaused: e.isPaused,
                    status: "pending",
                    variables: e.variables,
                    submittedAt: Date.now()
                };
            case "success":
                return {
                    ...n,
                    data: e.data,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    status: "success",
                    isPaused: !1
                };
            case "error":
                return {
                    ...n,
                    data: void 0,
                    error: e.error,
                    failureCount: n.failureCount + 1,
                    failureReason: e.error,
                    isPaused: !1,
                    status: "error"
                }
            }
        }
        ;
        this.state = t(this.state),
        ni.batch( () => {
            this.#t.forEach(n => {
                n.onMutationUpdate(e)
            }
            ),
            this.#n.notify({
                mutation: this,
                type: "updated",
                action: e
            })
        }
        )
    }
}
;
function RF() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var iX = class extends ch {
    constructor(e={}) {
        super(),
        this.config = e,
        this.#e = new Set,
        this.#t = new Map,
        this.#n = 0
    }
    #e;
    #t;
    #n;
    build(e, t, n) {
        const r = new rX({
            client: e,
            mutationCache: this,
            mutationId: ++this.#n,
            options: e.defaultMutationOptions(t),
            state: n
        });
        return this.add(r),
        r
    }
    add(e) {
        this.#e.add(e);
        const t = Ab(e);
        if (typeof t == "string") {
            const n = this.#t.get(t);
            n ? n.push(e) : this.#t.set(t, [e])
        }
        this.notify({
            type: "added",
            mutation: e
        })
    }
    remove(e) {
        if (this.#e.delete(e)) {
            const t = Ab(e);
            if (typeof t == "string") {
                const n = this.#t.get(t);
                if (n)
                    if (n.length > 1) {
                        const r = n.indexOf(e);
                        r !== -1 && n.splice(r, 1)
                    } else
                        n[0] === e && this.#t.delete(t)
            }
        }
        this.notify({
            type: "removed",
            mutation: e
        })
    }
    canRun(e) {
        const t = Ab(e);
        if (typeof t == "string") {
            const r = this.#t.get(t)?.find(i => i.state.status === "pending");
            return !r || r === e
        } else
            return !0
    }
    runNext(e) {
        const t = Ab(e);
        return typeof t == "string" ? this.#t.get(t)?.find(r => r !== e && r.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve()
    }
    clear() {
        ni.batch( () => {
            this.#e.forEach(e => {
                this.notify({
                    type: "removed",
                    mutation: e
                })
            }
            ),
            this.#e.clear(),
            this.#t.clear()
        }
        )
    }
    getAll() {
        return Array.from(this.#e)
    }
    find(e) {
        const t = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => xI(t, n))
    }
    findAll(e={}) {
        return this.getAll().filter(t => xI(e, t))
    }
    notify(e) {
        ni.batch( () => {
            this.listeners.forEach(t => {
                t(e)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const e = this.getAll().filter(t => t.state.isPaused);
        return ni.batch( () => Promise.all(e.map(t => t.continue().catch(Bi))))
    }
}
;
function Ab(e) {
    return e.options.scope?.id
}
var oX = class extends ch {
    #e;
    #t = void 0;
    #n;
    #i;
    constructor(t, n) {
        super(),
        this.#e = t,
        this.setOptions(n),
        this.bindMethods(),
        this.#r()
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this),
        this.reset = this.reset.bind(this)
    }
    setOptions(t) {
        const n = this.options;
        this.options = this.#e.defaultMutationOptions(t),
        s0(this.options, n) || this.#e.getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: this.#n,
            observer: this
        }),
        n?.mutationKey && this.options.mutationKey && Lu(n.mutationKey) !== Lu(this.options.mutationKey) ? this.reset() : this.#n?.state.status === "pending" && this.#n.setOptions(this.options)
    }
    onUnsubscribe() {
        this.hasListeners() || this.#n?.removeObserver(this)
    }
    onMutationUpdate(t) {
        this.#r(),
        this.#a(t)
    }
    getCurrentResult() {
        return this.#t
    }
    reset() {
        this.#n?.removeObserver(this),
        this.#n = void 0,
        this.#r(),
        this.#a()
    }
    mutate(t, n) {
        return this.#i = n,
        this.#n?.removeObserver(this),
        this.#n = this.#e.getMutationCache().build(this.#e, this.options),
        this.#n.addObserver(this),
        this.#n.execute(t)
    }
    #r() {
        const t = this.#n?.state ?? RF();
        this.#t = {
            ...t,
            isPending: t.status === "pending",
            isSuccess: t.status === "success",
            isError: t.status === "error",
            isIdle: t.status === "idle",
            mutate: this.mutate,
            reset: this.reset
        }
    }
    #a(t) {
        ni.batch( () => {
            if (this.#i && this.hasListeners()) {
                const n = this.#t.variables
                  , r = this.#t.context
                  , i = {
                    client: this.#e,
                    meta: this.options.meta,
                    mutationKey: this.options.mutationKey
                };
                t?.type === "success" ? (this.#i.onSuccess?.(t.data, n, r, i),
                this.#i.onSettled?.(t.data, null, n, r, i)) : t?.type === "error" && (this.#i.onError?.(t.error, n, r, i),
                this.#i.onSettled?.(void 0, t.error, n, r, i))
            }
            this.listeners.forEach(n => {
                n(this.#t)
            }
            )
        }
        )
    }
}
  , aX = class extends ch {
    constructor(e={}) {
        super(),
        this.config = e,
        this.#e = new Map
    }
    #e;
    build(e, t, n) {
        const r = t.queryKey
          , i = t.queryHash ?? iE(r, t);
        let o = this.get(i);
        return o || (o = new XK({
            client: e,
            queryKey: r,
            queryHash: i,
            options: e.defaultQueryOptions(t),
            state: n,
            defaultOptions: e.getQueryDefaults(r)
        }),
        this.add(o)),
        o
    }
    add(e) {
        this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e),
        this.notify({
            type: "added",
            query: e
        }))
    }
    remove(e) {
        const t = this.#e.get(e.queryHash);
        t && (e.destroy(),
        t === e && this.#e.delete(e.queryHash),
        this.notify({
            type: "removed",
            query: e
        }))
    }
    clear() {
        ni.batch( () => {
            this.getAll().forEach(e => {
                this.remove(e)
            }
            )
        }
        )
    }
    get(e) {
        return this.#e.get(e)
    }
    getAll() {
        return [...this.#e.values()]
    }
    find(e) {
        const t = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => bI(t, n))
    }
    findAll(e={}) {
        const t = this.getAll();
        return Object.keys(e).length > 0 ? t.filter(n => bI(e, n)) : t
    }
    notify(e) {
        ni.batch( () => {
            this.listeners.forEach(t => {
                t(e)
            }
            )
        }
        )
    }
    onFocus() {
        ni.batch( () => {
            this.getAll().forEach(e => {
                e.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        ni.batch( () => {
            this.getAll().forEach(e => {
                e.onOnline()
            }
            )
        }
        )
    }
}
  , sX = class {
    #e;
    #t;
    #n;
    #i;
    #r;
    #a;
    #s;
    #o;
    constructor(e={}) {
        this.#e = e.queryCache || new aX,
        this.#t = e.mutationCache || new iX,
        this.#n = e.defaultOptions || {},
        this.#i = new Map,
        this.#r = new Map,
        this.#a = 0
    }
    mount() {
        this.#a++,
        this.#a === 1 && (this.#s = aE.subscribe(async e => {
            e && (await this.resumePausedMutations(),
            this.#e.onFocus())
        }
        ),
        this.#o = l0.subscribe(async e => {
            e && (await this.resumePausedMutations(),
            this.#e.onOnline())
        }
        ))
    }
    unmount() {
        this.#a--,
        this.#a === 0 && (this.#s?.(),
        this.#s = void 0,
        this.#o?.(),
        this.#o = void 0)
    }
    isFetching(e) {
        return this.#e.findAll({
            ...e,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(e) {
        return this.#t.findAll({
            ...e,
            status: "pending"
        }).length
    }
    getQueryData(e) {
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return this.#e.get(t.queryHash)?.state.data
    }
    ensureQueryData(e) {
        const t = this.defaultQueryOptions(e)
          , n = this.#e.build(this, t)
          , r = n.state.data;
        return r === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(fc(t.staleTime, n)) && this.prefetchQuery(t),
        Promise.resolve(r))
    }
    getQueriesData(e) {
        return this.#e.findAll(e).map( ({queryKey: t, state: n}) => {
            const r = n.data;
            return [t, r]
        }
        )
    }
    setQueryData(e, t, n) {
        const r = this.defaultQueryOptions({
            queryKey: e
        })
          , o = this.#e.get(r.queryHash)?.state.data
          , a = UK(t, o);
        if (a !== void 0)
            return this.#e.build(this, r).setData(a, {
                ...n,
                manual: !0
            })
    }
    setQueriesData(e, t, n) {
        return ni.batch( () => this.#e.findAll(e).map( ({queryKey: r}) => [r, this.setQueryData(r, t, n)]))
    }
    getQueryState(e) {
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return this.#e.get(t.queryHash)?.state
    }
    removeQueries(e) {
        const t = this.#e;
        ni.batch( () => {
            t.findAll(e).forEach(n => {
                t.remove(n)
            }
            )
        }
        )
    }
    resetQueries(e, t) {
        const n = this.#e;
        return ni.batch( () => (n.findAll(e).forEach(r => {
            r.reset()
        }
        ),
        this.refetchQueries({
            type: "active",
            ...e
        }, t)))
    }
    cancelQueries(e, t={}) {
        const n = {
            revert: !0,
            ...t
        }
          , r = ni.batch( () => this.#e.findAll(e).map(i => i.cancel(n)));
        return Promise.all(r).then(Bi).catch(Bi)
    }
    invalidateQueries(e, t={}) {
        return ni.batch( () => (this.#e.findAll(e).forEach(n => {
            n.invalidate()
        }
        ),
        e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries({
            ...e,
            type: e?.refetchType ?? e?.type ?? "active"
        }, t)))
    }
    refetchQueries(e, t={}) {
        const n = {
            ...t,
            cancelRefetch: t.cancelRefetch ?? !0
        }
          , r = ni.batch( () => this.#e.findAll(e).filter(i => !i.isDisabled() && !i.isStatic()).map(i => {
            let o = i.fetch(void 0, n);
            return n.throwOnError || (o = o.catch(Bi)),
            i.state.fetchStatus === "paused" ? Promise.resolve() : o
        }
        ));
        return Promise.all(r).then(Bi)
    }
    fetchQuery(e) {
        const t = this.defaultQueryOptions(e);
        t.retry === void 0 && (t.retry = !1);
        const n = this.#e.build(this, t);
        return n.isStaleByTime(fc(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data)
    }
    prefetchQuery(e) {
        return this.fetchQuery(e).then(Bi).catch(Bi)
    }
    fetchInfiniteQuery(e) {
        return e.behavior = TI(e.pages),
        this.fetchQuery(e)
    }
    prefetchInfiniteQuery(e) {
        return this.fetchInfiniteQuery(e).then(Bi).catch(Bi)
    }
    ensureInfiniteQueryData(e) {
        return e.behavior = TI(e.pages),
        this.ensureQueryData(e)
    }
    resumePausedMutations() {
        return l0.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return this.#e
    }
    getMutationCache() {
        return this.#t
    }
    getDefaultOptions() {
        return this.#n
    }
    setDefaultOptions(e) {
        this.#n = e
    }
    setQueryDefaults(e, t) {
        this.#i.set(Lu(e), {
            queryKey: e,
            defaultOptions: t
        })
    }
    getQueryDefaults(e) {
        const t = [...this.#i.values()]
          , n = {};
        return t.forEach(r => {
            Bm(e, r.queryKey) && Object.assign(n, r.defaultOptions)
        }
        ),
        n
    }
    setMutationDefaults(e, t) {
        this.#r.set(Lu(e), {
            mutationKey: e,
            defaultOptions: t
        })
    }
    getMutationDefaults(e) {
        const t = [...this.#r.values()]
          , n = {};
        return t.forEach(r => {
            Bm(e, r.mutationKey) && Object.assign(n, r.defaultOptions)
        }
        ),
        n
    }
    defaultQueryOptions(e) {
        if (e._defaulted)
            return e;
        const t = {
            ...this.#n.queries,
            ...this.getQueryDefaults(e.queryKey),
            ...e,
            _defaulted: !0
        };
        return t.queryHash || (t.queryHash = iE(t.queryKey, t)),
        t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"),
        t.throwOnError === void 0 && (t.throwOnError = !!t.suspense),
        !t.networkMode && t.persister && (t.networkMode = "offlineFirst"),
        t.queryFn === oE && (t.enabled = !1),
        t
    }
    defaultMutationOptions(e) {
        return e?._defaulted ? e : {
            ...this.#n.mutations,
            ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
            ...e,
            _defaulted: !0
        }
    }
    clear() {
        this.#e.clear(),
        this.#t.clear()
    }
}
  , DF = A.createContext(void 0)
  , uh = e => {
    const t = A.useContext(DF);
    if (!t)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return t
}
  , lX = ({client: e, children: t}) => (A.useEffect( () => (e.mount(),
() => {
    e.unmount()
}
), [e]),
g.jsx(DF.Provider, {
    value: e,
    children: t
}))
  , OF = A.createContext(!1)
  , cX = () => A.useContext(OF);
OF.Provider;
function uX() {
    let e = !1;
    return {
        clearReset: () => {
            e = !1
        }
        ,
        reset: () => {
            e = !0
        }
        ,
        isReset: () => e
    }
}
var dX = A.createContext(uX())
  , fX = () => A.useContext(dX)
  , hX = (e, t) => {
    (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1))
}
  , pX = e => {
    A.useEffect( () => {
        e.clearReset()
    }
    , [e])
}
  , mX = ({result: e, errorResetBoundary: t, throwOnError: n, query: r, suspense: i}) => e.isError && !t.isReset() && !e.isFetching && r && (i && e.data === void 0 || _F(n, [e.error, r]))
  , gX = e => {
    if (e.suspense) {
        const n = i => i === "static" ? i : Math.max(i ?? 1e3, 1e3)
          , r = e.staleTime;
        e.staleTime = typeof r == "function" ? (...i) => n(r(...i)) : n(r),
        typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3))
    }
}
  , yX = (e, t) => e.isLoading && e.isFetching && !t
  , bX = (e, t) => e?.suspense && t.isPending
  , EI = (e, t, n) => t.fetchOptimistic(e).catch( () => {
    n.clearReset()
}
);
function xX(e, t, n) {
    const r = cX()
      , i = fX()
      , o = uh()
      , a = o.defaultQueryOptions(e);
    o.getDefaultOptions().queries?._experimental_beforeQuery?.(a),
    a._optimisticResults = r ? "isRestoring" : "optimistic",
    gX(a),
    hX(a, i),
    pX(i);
    const s = !o.getQueryCache().get(a.queryHash)
      , [c] = A.useState( () => new t(o,a))
      , u = c.getOptimisticResult(a)
      , f = !r && e.subscribed !== !1;
    if (A.useSyncExternalStore(A.useCallback(h => {
        const m = f ? c.subscribe(ni.batchCalls(h)) : Bi;
        return c.updateResult(),
        m
    }
    , [c, f]), () => c.getCurrentResult(), () => c.getCurrentResult()),
    A.useEffect( () => {
        c.setOptions(a)
    }
    , [a, c]),
    bX(a, u))
        throw EI(a, c, i);
    if (mX({
        result: u,
        errorResetBoundary: i,
        throwOnError: a.throwOnError,
        query: o.getQueryCache().get(a.queryHash),
        suspense: a.suspense
    }))
        throw u.error;
    return o.getDefaultOptions().queries?._experimental_afterQuery?.(a, u),
    a.experimental_prefetchInRender && !$u && yX(u, r) && (s ? EI(a, c, i) : o.getQueryCache().get(a.queryHash)?.promise)?.catch(Bi).finally( () => {
        c.updateResult()
    }
    ),
    a.notifyOnChangeProps ? u : c.trackResult(u)
}
function Is(e, t) {
    return xX(e, JK)
}
function wg(e, t) {
    const n = uh()
      , [r] = A.useState( () => new oX(n,e));
    A.useEffect( () => {
        r.setOptions(e)
    }
    , [r, e]);
    const i = A.useSyncExternalStore(A.useCallback(a => r.subscribe(ni.batchCalls(a)), [r]), () => r.getCurrentResult(), () => r.getCurrentResult())
      , o = A.useCallback( (a, s) => {
        r.mutate(a, s).catch(Bi)
    }
    , [r]);
    if (i.error && _F(r.options.throwOnError, [i.error]))
        throw i.error;
    return {
        ...i,
        mutate: o,
        mutateAsync: i.mutate
    }
}
const zm = {
    black: "#000",
    white: "#fff"
}
  , qd = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828"
}
  , Wd = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2"
}
  , vX = {
    500: "#673ab7"
}
  , Gd = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0"
}
  , Yd = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b"
}
  , Zd = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20"
}
  , gp = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100"
}
  , SX = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
};
function Cl(e, ...t) {
    const n = new URL(`https://mui.com/production-error/?code=${e}`);
    return t.forEach(r => n.searchParams.append("args[]", r)),
    `Minified MUI error #${e}; visit ${n} for the full message.`
}
const xa = "$$material";
function ge() {
    return ge = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
                ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }
    ,
    ge.apply(null, arguments)
}
function CX(e) {
    if (e.sheet)
        return e.sheet;
    for (var t = 0; t < document.styleSheets.length; t++)
        if (document.styleSheets[t].ownerNode === e)
            return document.styleSheets[t]
}
function wX(e) {
    var t = document.createElement("style");
    return t.setAttribute("data-emotion", e.key),
    e.nonce !== void 0 && t.setAttribute("nonce", e.nonce),
    t.appendChild(document.createTextNode("")),
    t.setAttribute("data-s", ""),
    t
}
var kX = (function() {
    function e(n) {
        var r = this;
        this._insertTag = function(i) {
            var o;
            r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling,
            r.container.insertBefore(i, o),
            r.tags.push(i)
        }
        ,
        this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy,
        this.tags = [],
        this.ctr = 0,
        this.nonce = n.nonce,
        this.key = n.key,
        this.container = n.container,
        this.prepend = n.prepend,
        this.insertionPoint = n.insertionPoint,
        this.before = null
    }
    var t = e.prototype;
    return t.hydrate = function(r) {
        r.forEach(this._insertTag)
    }
    ,
    t.insert = function(r) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(wX(this));
        var i = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
            var o = CX(i);
            try {
                o.insertRule(r, o.cssRules.length)
            } catch {}
        } else
            i.appendChild(document.createTextNode(r));
        this.ctr++
    }
    ,
    t.flush = function() {
        this.tags.forEach(function(r) {
            var i;
            return (i = r.parentNode) == null ? void 0 : i.removeChild(r)
        }),
        this.tags = [],
        this.ctr = 0
    }
    ,
    e
}
)()
  , ki = "-ms-"
  , c0 = "-moz-"
  , jn = "-webkit-"
  , IF = "comm"
  , lE = "rule"
  , cE = "decl"
  , TX = "@import"
  , $F = "@keyframes"
  , _X = "@layer"
  , EX = Math.abs
  , Av = String.fromCharCode
  , AX = Object.assign;
function MX(e, t) {
    return xi(e, 0) ^ 45 ? (((t << 2 ^ xi(e, 0)) << 2 ^ xi(e, 1)) << 2 ^ xi(e, 2)) << 2 ^ xi(e, 3) : 0
}
function LF(e) {
    return e.trim()
}
function PX(e, t) {
    return (e = t.exec(e)) ? e[0] : e
}
function Bn(e, t, n) {
    return e.replace(t, n)
}
function P2(e, t) {
    return e.indexOf(t)
}
function xi(e, t) {
    return e.charCodeAt(t) | 0
}
function Fm(e, t, n) {
    return e.slice(t, n)
}
function ys(e) {
    return e.length
}
function uE(e) {
    return e.length
}
function Mb(e, t) {
    return t.push(e),
    e
}
function RX(e, t) {
    return e.map(t).join("")
}
var Mv = 1
  , Ff = 1
  , jF = 0
  , So = 0
  , Zr = 0
  , dh = "";
function Pv(e, t, n, r, i, o, a) {
    return {
        value: e,
        root: t,
        parent: n,
        type: r,
        props: i,
        children: o,
        line: Mv,
        column: Ff,
        length: a,
        return: ""
    }
}
function yp(e, t) {
    return AX(Pv("", null, null, "", null, null, 0), e, {
        length: -e.length
    }, t)
}
function DX() {
    return Zr
}
function OX() {
    return Zr = So > 0 ? xi(dh, --So) : 0,
    Ff--,
    Zr === 10 && (Ff = 1,
    Mv--),
    Zr
}
function Wo() {
    return Zr = So < jF ? xi(dh, So++) : 0,
    Ff++,
    Zr === 10 && (Ff = 1,
    Mv++),
    Zr
}
function Ss() {
    return xi(dh, So)
}
function wx() {
    return So
}
function kg(e, t) {
    return Fm(dh, e, t)
}
function Nm(e) {
    switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function BF(e) {
    return Mv = Ff = 1,
    jF = ys(dh = e),
    So = 0,
    []
}
function zF(e) {
    return dh = "",
    e
}
function kx(e) {
    return LF(kg(So - 1, R2(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}
function IX(e) {
    for (; (Zr = Ss()) && Zr < 33; )
        Wo();
    return Nm(e) > 2 || Nm(Zr) > 3 ? "" : " "
}
function $X(e, t) {
    for (; --t && Wo() && !(Zr < 48 || Zr > 102 || Zr > 57 && Zr < 65 || Zr > 70 && Zr < 97); )
        ;
    return kg(e, wx() + (t < 6 && Ss() == 32 && Wo() == 32))
}
function R2(e) {
    for (; Wo(); )
        switch (Zr) {
        case e:
            return So;
        case 34:
        case 39:
            e !== 34 && e !== 39 && R2(Zr);
            break;
        case 40:
            e === 41 && R2(e);
            break;
        case 92:
            Wo();
            break
        }
    return So
}
function LX(e, t) {
    for (; Wo() && e + Zr !== 57; )
        if (e + Zr === 84 && Ss() === 47)
            break;
    return "/*" + kg(t, So - 1) + "*" + Av(e === 47 ? e : Wo())
}
function jX(e) {
    for (; !Nm(Ss()); )
        Wo();
    return kg(e, So)
}
function BX(e) {
    return zF(Tx("", null, null, null, [""], e = BF(e), 0, [0], e))
}
function Tx(e, t, n, r, i, o, a, s, c) {
    for (var u = 0, f = 0, h = a, m = 0, y = 0, b = 0, v = 1, S = 1, C = 1, w = 0, k = "", T = i, E = o, P = r, D = k; S; )
        switch (b = w,
        w = Wo()) {
        case 40:
            if (b != 108 && xi(D, h - 1) == 58) {
                P2(D += Bn(kx(w), "&", "&\f"), "&\f") != -1 && (C = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            D += kx(w);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            D += IX(b);
            break;
        case 92:
            D += $X(wx() - 1, 7);
            continue;
        case 47:
            switch (Ss()) {
            case 42:
            case 47:
                Mb(zX(LX(Wo(), wx()), t, n), c);
                break;
            default:
                D += "/"
            }
            break;
        case 123 * v:
            s[u++] = ys(D) * C;
        case 125 * v:
        case 59:
        case 0:
            switch (w) {
            case 0:
            case 125:
                S = 0;
            case 59 + f:
                C == -1 && (D = Bn(D, /\f/g, "")),
                y > 0 && ys(D) - h && Mb(y > 32 ? MI(D + ";", r, n, h - 1) : MI(Bn(D, " ", "") + ";", r, n, h - 2), c);
                break;
            case 59:
                D += ";";
            default:
                if (Mb(P = AI(D, t, n, u, f, i, s, k, T = [], E = [], h), o),
                w === 123)
                    if (f === 0)
                        Tx(D, t, P, P, T, o, h, s, E);
                    else
                        switch (m === 99 && xi(D, 3) === 110 ? 100 : m) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            Tx(e, P, P, r && Mb(AI(e, P, P, 0, 0, i, s, k, i, T = [], h), E), i, E, h, s, r ? T : E);
                            break;
                        default:
                            Tx(D, P, P, P, [""], E, 0, s, E)
                        }
            }
            u = f = y = 0,
            v = C = 1,
            k = D = "",
            h = a;
            break;
        case 58:
            h = 1 + ys(D),
            y = b;
        default:
            if (v < 1) {
                if (w == 123)
                    --v;
                else if (w == 125 && v++ == 0 && OX() == 125)
                    continue
            }
            switch (D += Av(w),
            w * v) {
            case 38:
                C = f > 0 ? 1 : (D += "\f",
                -1);
                break;
            case 44:
                s[u++] = (ys(D) - 1) * C,
                C = 1;
                break;
            case 64:
                Ss() === 45 && (D += kx(Wo())),
                m = Ss(),
                f = h = ys(k = D += jX(wx())),
                w++;
                break;
            case 45:
                b === 45 && ys(D) == 2 && (v = 0)
            }
        }
    return o
}
function AI(e, t, n, r, i, o, a, s, c, u, f) {
    for (var h = i - 1, m = i === 0 ? o : [""], y = uE(m), b = 0, v = 0, S = 0; b < r; ++b)
        for (var C = 0, w = Fm(e, h + 1, h = EX(v = a[b])), k = e; C < y; ++C)
            (k = LF(v > 0 ? m[C] + " " + w : Bn(w, /&\f/g, m[C]))) && (c[S++] = k);
    return Pv(e, t, n, i === 0 ? lE : s, c, u, f)
}
function zX(e, t, n) {
    return Pv(e, t, n, IF, Av(DX()), Fm(e, 2, -2), 0)
}
function MI(e, t, n, r) {
    return Pv(e, t, n, cE, Fm(e, 0, r), Fm(e, r + 1, -1), r)
}
function yf(e, t) {
    for (var n = "", r = uE(e), i = 0; i < r; i++)
        n += t(e[i], i, e, t) || "";
    return n
}
function FX(e, t, n, r) {
    switch (e.type) {
    case _X:
        if (e.children.length)
            break;
    case TX:
    case cE:
        return e.return = e.return || e.value;
    case IF:
        return "";
    case $F:
        return e.return = e.value + "{" + yf(e.children, r) + "}";
    case lE:
        e.value = e.props.join(",")
    }
    return ys(n = yf(e.children, r)) ? e.return = e.value + "{" + n + "}" : ""
}
function NX(e) {
    var t = uE(e);
    return function(n, r, i, o) {
        for (var a = "", s = 0; s < t; s++)
            a += e[s](n, r, i, o) || "";
        return a
    }
}
function UX(e) {
    return function(t) {
        t.root || (t = t.return) && e(t)
    }
}
function FF(e) {
    var t = Object.create(null);
    return function(n) {
        return t[n] === void 0 && (t[n] = e(n)),
        t[n]
    }
}
var VX = function(t, n, r) {
    for (var i = 0, o = 0; i = o,
    o = Ss(),
    i === 38 && o === 12 && (n[r] = 1),
    !Nm(o); )
        Wo();
    return kg(t, So)
}
  , HX = function(t, n) {
    var r = -1
      , i = 44;
    do
        switch (Nm(i)) {
        case 0:
            i === 38 && Ss() === 12 && (n[r] = 1),
            t[r] += VX(So - 1, n, r);
            break;
        case 2:
            t[r] += kx(i);
            break;
        case 4:
            if (i === 44) {
                t[++r] = Ss() === 58 ? "&\f" : "",
                n[r] = t[r].length;
                break
            }
        default:
            t[r] += Av(i)
        }
    while (i = Wo());
    return t
}
  , qX = function(t, n) {
    return zF(HX(BF(t), n))
}
  , PI = new WeakMap
  , WX = function(t) {
    if (!(t.type !== "rule" || !t.parent || t.length < 1)) {
        for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
            if (r = r.parent,
            !r)
                return;
        if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !PI.get(r)) && !i) {
            PI.set(t, !0);
            for (var o = [], a = qX(n, o), s = r.props, c = 0, u = 0; c < a.length; c++)
                for (var f = 0; f < s.length; f++,
                u++)
                    t.props[u] = o[c] ? a[c].replace(/&\f/g, s[f]) : s[f] + " " + a[c]
        }
    }
}
  , GX = function(t) {
    if (t.type === "decl") {
        var n = t.value;
        n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && (t.return = "",
        t.value = "")
    }
};
function NF(e, t) {
    switch (MX(e, t)) {
    case 5103:
        return jn + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
        return jn + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
        return jn + e + c0 + e + ki + e + e;
    case 6828:
    case 4268:
        return jn + e + ki + e + e;
    case 6165:
        return jn + e + ki + "flex-" + e + e;
    case 5187:
        return jn + e + Bn(e, /(\w+).+(:[^]+)/, jn + "box-$1$2" + ki + "flex-$1$2") + e;
    case 5443:
        return jn + e + ki + "flex-item-" + Bn(e, /flex-|-self/, "") + e;
    case 4675:
        return jn + e + ki + "flex-line-pack" + Bn(e, /align-content|flex-|-self/, "") + e;
    case 5548:
        return jn + e + ki + Bn(e, "shrink", "negative") + e;
    case 5292:
        return jn + e + ki + Bn(e, "basis", "preferred-size") + e;
    case 6060:
        return jn + "box-" + Bn(e, "-grow", "") + jn + e + ki + Bn(e, "grow", "positive") + e;
    case 4554:
        return jn + Bn(e, /([^-])(transform)/g, "$1" + jn + "$2") + e;
    case 6187:
        return Bn(Bn(Bn(e, /(zoom-|grab)/, jn + "$1"), /(image-set)/, jn + "$1"), e, "") + e;
    case 5495:
    case 3959:
        return Bn(e, /(image-set\([^]*)/, jn + "$1$`$1");
    case 4968:
        return Bn(Bn(e, /(.+:)(flex-)?(.*)/, jn + "box-pack:$3" + ki + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + jn + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
        return Bn(e, /(.+)-inline(.+)/, jn + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
        if (ys(e) - 1 - t > 6)
            switch (xi(e, t + 1)) {
            case 109:
                if (xi(e, t + 4) !== 45)
                    break;
            case 102:
                return Bn(e, /(.+:)(.+)-([^]+)/, "$1" + jn + "$2-$3$1" + c0 + (xi(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
            case 115:
                return ~P2(e, "stretch") ? NF(Bn(e, "stretch", "fill-available"), t) + e : e
            }
        break;
    case 4949:
        if (xi(e, t + 1) !== 115)
            break;
    case 6444:
        switch (xi(e, ys(e) - 3 - (~P2(e, "!important") && 10))) {
        case 107:
            return Bn(e, ":", ":" + jn) + e;
        case 101:
            return Bn(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + jn + (xi(e, 14) === 45 ? "inline-" : "") + "box$3$1" + jn + "$2$3$1" + ki + "$2box$3") + e
        }
        break;
    case 5936:
        switch (xi(e, t + 11)) {
        case 114:
            return jn + e + ki + Bn(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
            return jn + e + ki + Bn(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
            return jn + e + ki + Bn(e, /[svh]\w+-[tblr]{2}/, "lr") + e
        }
        return jn + e + ki + e + e
    }
    return e
}
var YX = function(t, n, r, i) {
    if (t.length > -1 && !t.return)
        switch (t.type) {
        case cE:
            t.return = NF(t.value, t.length);
            break;
        case $F:
            return yf([yp(t, {
                value: Bn(t.value, "@", "@" + jn)
            })], i);
        case lE:
            if (t.length)
                return RX(t.props, function(o) {
                    switch (PX(o, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                        return yf([yp(t, {
                            props: [Bn(o, /:(read-\w+)/, ":" + c0 + "$1")]
                        })], i);
                    case "::placeholder":
                        return yf([yp(t, {
                            props: [Bn(o, /:(plac\w+)/, ":" + jn + "input-$1")]
                        }), yp(t, {
                            props: [Bn(o, /:(plac\w+)/, ":" + c0 + "$1")]
                        }), yp(t, {
                            props: [Bn(o, /:(plac\w+)/, ki + "input-$1")]
                        })], i)
                    }
                    return ""
                })
        }
}
  , ZX = [YX]
  , QX = function(t) {
    var n = t.key;
    if (n === "css") {
        var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(r, function(v) {
            var S = v.getAttribute("data-emotion");
            S.indexOf(" ") !== -1 && (document.head.appendChild(v),
            v.setAttribute("data-s", ""))
        })
    }
    var i = t.stylisPlugins || ZX, o = {}, a, s = [];
    a = t.container || document.head,
    Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function(v) {
        for (var S = v.getAttribute("data-emotion").split(" "), C = 1; C < S.length; C++)
            o[S[C]] = !0;
        s.push(v)
    });
    var c, u = [WX, GX];
    {
        var f, h = [FX, UX(function(v) {
            f.insert(v)
        })], m = NX(u.concat(i, h)), y = function(S) {
            return yf(BX(S), m)
        };
        c = function(S, C, w, k) {
            f = w,
            y(S ? S + "{" + C.styles + "}" : C.styles),
            k && (b.inserted[C.name] = !0)
        }
    }
    var b = {
        key: n,
        sheet: new kX({
            key: n,
            container: a,
            nonce: t.nonce,
            speedy: t.speedy,
            prepend: t.prepend,
            insertionPoint: t.insertionPoint
        }),
        nonce: t.nonce,
        inserted: o,
        registered: {},
        insert: c
    };
    return b.sheet.hydrate(s),
    b
}
  , Ow = {
    exports: {}
}
  , Nn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RI;
function KX() {
    if (RI)
        return Nn;
    RI = 1;
    var e = typeof Symbol == "function" && Symbol.for
      , t = e ? Symbol.for("react.element") : 60103
      , n = e ? Symbol.for("react.portal") : 60106
      , r = e ? Symbol.for("react.fragment") : 60107
      , i = e ? Symbol.for("react.strict_mode") : 60108
      , o = e ? Symbol.for("react.profiler") : 60114
      , a = e ? Symbol.for("react.provider") : 60109
      , s = e ? Symbol.for("react.context") : 60110
      , c = e ? Symbol.for("react.async_mode") : 60111
      , u = e ? Symbol.for("react.concurrent_mode") : 60111
      , f = e ? Symbol.for("react.forward_ref") : 60112
      , h = e ? Symbol.for("react.suspense") : 60113
      , m = e ? Symbol.for("react.suspense_list") : 60120
      , y = e ? Symbol.for("react.memo") : 60115
      , b = e ? Symbol.for("react.lazy") : 60116
      , v = e ? Symbol.for("react.block") : 60121
      , S = e ? Symbol.for("react.fundamental") : 60117
      , C = e ? Symbol.for("react.responder") : 60118
      , w = e ? Symbol.for("react.scope") : 60119;
    function k(E) {
        if (typeof E == "object" && E !== null) {
            var P = E.$$typeof;
            switch (P) {
            case t:
                switch (E = E.type,
                E) {
                case c:
                case u:
                case r:
                case o:
                case i:
                case h:
                    return E;
                default:
                    switch (E = E && E.$$typeof,
                    E) {
                    case s:
                    case f:
                    case b:
                    case y:
                    case a:
                        return E;
                    default:
                        return P
                    }
                }
            case n:
                return P
            }
        }
    }
    function T(E) {
        return k(E) === u
    }
    return Nn.AsyncMode = c,
    Nn.ConcurrentMode = u,
    Nn.ContextConsumer = s,
    Nn.ContextProvider = a,
    Nn.Element = t,
    Nn.ForwardRef = f,
    Nn.Fragment = r,
    Nn.Lazy = b,
    Nn.Memo = y,
    Nn.Portal = n,
    Nn.Profiler = o,
    Nn.StrictMode = i,
    Nn.Suspense = h,
    Nn.isAsyncMode = function(E) {
        return T(E) || k(E) === c
    }
    ,
    Nn.isConcurrentMode = T,
    Nn.isContextConsumer = function(E) {
        return k(E) === s
    }
    ,
    Nn.isContextProvider = function(E) {
        return k(E) === a
    }
    ,
    Nn.isElement = function(E) {
        return typeof E == "object" && E !== null && E.$$typeof === t
    }
    ,
    Nn.isForwardRef = function(E) {
        return k(E) === f
    }
    ,
    Nn.isFragment = function(E) {
        return k(E) === r
    }
    ,
    Nn.isLazy = function(E) {
        return k(E) === b
    }
    ,
    Nn.isMemo = function(E) {
        return k(E) === y
    }
    ,
    Nn.isPortal = function(E) {
        return k(E) === n
    }
    ,
    Nn.isProfiler = function(E) {
        return k(E) === o
    }
    ,
    Nn.isStrictMode = function(E) {
        return k(E) === i
    }
    ,
    Nn.isSuspense = function(E) {
        return k(E) === h
    }
    ,
    Nn.isValidElementType = function(E) {
        return typeof E == "string" || typeof E == "function" || E === r || E === u || E === o || E === i || E === h || E === m || typeof E == "object" && E !== null && (E.$$typeof === b || E.$$typeof === y || E.$$typeof === a || E.$$typeof === s || E.$$typeof === f || E.$$typeof === S || E.$$typeof === C || E.$$typeof === w || E.$$typeof === v)
    }
    ,
    Nn.typeOf = k,
    Nn
}
var DI;
function XX() {
    return DI || (DI = 1,
    Ow.exports = KX()),
    Ow.exports
}
var Iw, OI;
function JX() {
    if (OI)
        return Iw;
    OI = 1;
    var e = XX()
      , t = {
        childContextTypes: !0,
        contextType: !0,
        contextTypes: !0,
        defaultProps: !0,
        displayName: !0,
        getDefaultProps: !0,
        getDerivedStateFromError: !0,
        getDerivedStateFromProps: !0,
        mixins: !0,
        propTypes: !0,
        type: !0
    }
      , n = {
        name: !0,
        length: !0,
        prototype: !0,
        caller: !0,
        callee: !0,
        arguments: !0,
        arity: !0
    }
      , r = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    }
      , i = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    }
      , o = {};
    o[e.ForwardRef] = r,
    o[e.Memo] = i;
    function a(b) {
        return e.isMemo(b) ? i : o[b.$$typeof] || t
    }
    var s = Object.defineProperty
      , c = Object.getOwnPropertyNames
      , u = Object.getOwnPropertySymbols
      , f = Object.getOwnPropertyDescriptor
      , h = Object.getPrototypeOf
      , m = Object.prototype;
    function y(b, v, S) {
        if (typeof v != "string") {
            if (m) {
                var C = h(v);
                C && C !== m && y(b, C, S)
            }
            var w = c(v);
            u && (w = w.concat(u(v)));
            for (var k = a(b), T = a(v), E = 0; E < w.length; ++E) {
                var P = w[E];
                if (!n[P] && !(S && S[P]) && !(T && T[P]) && !(k && k[P])) {
                    var D = f(v, P);
                    try {
                        s(b, P, D)
                    } catch {}
                }
            }
        }
        return b
    }
    return Iw = y,
    Iw
}
JX();
var eJ = !0;
function UF(e, t, n) {
    var r = "";
    return n.split(" ").forEach(function(i) {
        e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ")
    }),
    r
}
var dE = function(t, n, r) {
    var i = t.key + "-" + n.name;
    (r === !1 || eJ === !1) && t.registered[i] === void 0 && (t.registered[i] = n.styles)
}
  , fE = function(t, n, r) {
    dE(t, n, r);
    var i = t.key + "-" + n.name;
    if (t.inserted[n.name] === void 0) {
        var o = n;
        do
            t.insert(n === o ? "." + i : "", o, t.sheet, !0),
            o = o.next;
        while (o !== void 0)
    }
};
function tJ(e) {
    for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r,
    i -= 4)
        n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24,
        n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16),
        n ^= n >>> 24,
        t = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (i) {
    case 3:
        t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
        t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
        t ^= e.charCodeAt(r) & 255,
        t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16)
    }
    return t ^= t >>> 13,
    t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16),
    ((t ^ t >>> 15) >>> 0).toString(36)
}
var nJ = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
}
  , rJ = /[A-Z]|^ms/g
  , iJ = /_EMO_([^_]+?)_([^]*?)_EMO_/g
  , VF = function(t) {
    return t.charCodeAt(1) === 45
}
  , II = function(t) {
    return t != null && typeof t != "boolean"
}
  , $w = FF(function(e) {
    return VF(e) ? e : e.replace(rJ, "-$&").toLowerCase()
})
  , $I = function(t, n) {
    switch (t) {
    case "animation":
    case "animationName":
        if (typeof n == "string")
            return n.replace(iJ, function(r, i, o) {
                return bs = {
                    name: i,
                    styles: o,
                    next: bs
                },
                i
            })
    }
    return nJ[t] !== 1 && !VF(t) && typeof n == "number" && n !== 0 ? n + "px" : n
};
function Um(e, t, n) {
    if (n == null)
        return "";
    var r = n;
    if (r.__emotion_styles !== void 0)
        return r;
    switch (typeof n) {
    case "boolean":
        return "";
    case "object":
        {
            var i = n;
            if (i.anim === 1)
                return bs = {
                    name: i.name,
                    styles: i.styles,
                    next: bs
                },
                i.name;
            var o = n;
            if (o.styles !== void 0) {
                var a = o.next;
                if (a !== void 0)
                    for (; a !== void 0; )
                        bs = {
                            name: a.name,
                            styles: a.styles,
                            next: bs
                        },
                        a = a.next;
                var s = o.styles + ";";
                return s
            }
            return oJ(e, t, n)
        }
    case "function":
        {
            if (e !== void 0) {
                var c = bs
                  , u = n(e);
                return bs = c,
                Um(e, t, u)
            }
            break
        }
    }
    var f = n;
    if (t == null)
        return f;
    var h = t[f];
    return h !== void 0 ? h : f
}
function oJ(e, t, n) {
    var r = "";
    if (Array.isArray(n))
        for (var i = 0; i < n.length; i++)
            r += Um(e, t, n[i]) + ";";
    else
        for (var o in n) {
            var a = n[o];
            if (typeof a != "object") {
                var s = a;
                t != null && t[s] !== void 0 ? r += o + "{" + t[s] + "}" : II(s) && (r += $w(o) + ":" + $I(o, s) + ";")
            } else if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
                for (var c = 0; c < a.length; c++)
                    II(a[c]) && (r += $w(o) + ":" + $I(o, a[c]) + ";");
            else {
                var u = Um(e, t, a);
                switch (o) {
                case "animation":
                case "animationName":
                    {
                        r += $w(o) + ":" + u + ";";
                        break
                    }
                default:
                    r += o + "{" + u + "}"
                }
            }
        }
    return r
}
var LI = /label:\s*([^\s;{]+)\s*(;|$)/g, bs;
function Tg(e, t, n) {
    if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
        return e[0];
    var r = !0
      , i = "";
    bs = void 0;
    var o = e[0];
    if (o == null || o.raw === void 0)
        r = !1,
        i += Um(n, t, o);
    else {
        var a = o;
        i += a[0]
    }
    for (var s = 1; s < e.length; s++)
        if (i += Um(n, t, e[s]),
        r) {
            var c = o;
            i += c[s]
        }
    LI.lastIndex = 0;
    for (var u = "", f; (f = LI.exec(i)) !== null; )
        u += "-" + f[1];
    var h = tJ(i) + u;
    return {
        name: h,
        styles: i,
        next: bs
    }
}
var aJ = function(t) {
    return t()
}
  , HF = o0.useInsertionEffect ? o0.useInsertionEffect : !1
  , qF = HF || aJ
  , jI = HF || A.useLayoutEffect
  , WF = A.createContext(typeof HTMLElement < "u" ? QX({
    key: "css"
}) : null);
WF.Provider;
var hE = function(t) {
    return A.forwardRef(function(n, r) {
        var i = A.useContext(WF);
        return t(n, i, r)
    })
}
  , _g = A.createContext({})
  , pE = {}.hasOwnProperty
  , D2 = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__"
  , sJ = function(t, n) {
    var r = {};
    for (var i in n)
        pE.call(n, i) && (r[i] = n[i]);
    return r[D2] = t,
    r
}
  , lJ = function(t) {
    var n = t.cache
      , r = t.serialized
      , i = t.isStringTag;
    return dE(n, r, i),
    qF(function() {
        return fE(n, r, i)
    }),
    null
}
  , cJ = hE(function(e, t, n) {
    var r = e.css;
    typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
    var i = e[D2]
      , o = [r]
      , a = "";
    typeof e.className == "string" ? a = UF(t.registered, o, e.className) : e.className != null && (a = e.className + " ");
    var s = Tg(o, void 0, A.useContext(_g));
    a += t.key + "-" + s.name;
    var c = {};
    for (var u in e)
        pE.call(e, u) && u !== "css" && u !== D2 && (c[u] = e[u]);
    return c.className = a,
    n && (c.ref = n),
    A.createElement(A.Fragment, null, A.createElement(lJ, {
        cache: t,
        serialized: s,
        isStringTag: typeof i == "string"
    }), A.createElement(i, c))
})
  , uJ = cJ
  , BI = function(t, n) {
    var r = arguments;
    if (n == null || !pE.call(n, "css"))
        return A.createElement.apply(void 0, r);
    var i = r.length
      , o = new Array(i);
    o[0] = uJ,
    o[1] = sJ(t, n);
    for (var a = 2; a < i; a++)
        o[a] = r[a];
    return A.createElement.apply(null, o)
};
(function(e) {
    var t;
    t || (t = e.JSX || (e.JSX = {}))
}
)(BI || (BI = {}));
var dJ = hE(function(e, t) {
    var n = e.styles
      , r = Tg([n], void 0, A.useContext(_g))
      , i = A.useRef();
    return jI(function() {
        var o = t.key + "-global"
          , a = new t.sheet.constructor({
            key: o,
            nonce: t.sheet.nonce,
            container: t.sheet.container,
            speedy: t.sheet.isSpeedy
        })
          , s = !1
          , c = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
        return t.sheet.tags.length && (a.before = t.sheet.tags[0]),
        c !== null && (s = !0,
        c.setAttribute("data-emotion", o),
        a.hydrate([c])),
        i.current = [a, s],
        function() {
            a.flush()
        }
    }, [t]),
    jI(function() {
        var o = i.current
          , a = o[0]
          , s = o[1];
        if (s) {
            o[1] = !1;
            return
        }
        if (r.next !== void 0 && fE(t, r.next, !0),
        a.tags.length) {
            var c = a.tags[a.tags.length - 1].nextElementSibling;
            a.before = c,
            a.flush()
        }
        t.insert("", r, a, !1)
    }, [t, r.name]),
    null
});
function Ac() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return Tg(t)
}
function $s() {
    var e = Ac.apply(void 0, arguments)
      , t = "animation-" + e.name;
    return {
        name: t,
        styles: "@keyframes " + t + "{" + e.styles + "}",
        anim: 1,
        toString: function() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
        }
    }
}
var fJ = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
  , hJ = FF(function(e) {
    return fJ.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91
})
  , pJ = hJ
  , mJ = function(t) {
    return t !== "theme"
}
  , zI = function(t) {
    return typeof t == "string" && t.charCodeAt(0) > 96 ? pJ : mJ
}
  , FI = function(t, n, r) {
    var i;
    if (n) {
        var o = n.shouldForwardProp;
        i = t.__emotion_forwardProp && o ? function(a) {
            return t.__emotion_forwardProp(a) && o(a)
        }
        : o
    }
    return typeof i != "function" && r && (i = t.__emotion_forwardProp),
    i
}
  , gJ = function(t) {
    var n = t.cache
      , r = t.serialized
      , i = t.isStringTag;
    return dE(n, r, i),
    qF(function() {
        return fE(n, r, i)
    }),
    null
}
  , yJ = function e(t, n) {
    var r = t.__emotion_real === t, i = r && t.__emotion_base || t, o, a;
    n !== void 0 && (o = n.label,
    a = n.target);
    var s = FI(t, n, r)
      , c = s || zI(i)
      , u = !c("as");
    return function() {
        var f = arguments
          , h = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
        if (o !== void 0 && h.push("label:" + o + ";"),
        f[0] == null || f[0].raw === void 0)
            h.push.apply(h, f);
        else {
            var m = f[0];
            h.push(m[0]);
            for (var y = f.length, b = 1; b < y; b++)
                h.push(f[b], m[b])
        }
        var v = hE(function(S, C, w) {
            var k = u && S.as || i
              , T = ""
              , E = []
              , P = S;
            if (S.theme == null) {
                P = {};
                for (var D in S)
                    P[D] = S[D];
                P.theme = A.useContext(_g)
            }
            typeof S.className == "string" ? T = UF(C.registered, E, S.className) : S.className != null && (T = S.className + " ");
            var $ = Tg(h.concat(E), C.registered, P);
            T += C.key + "-" + $.name,
            a !== void 0 && (T += " " + a);
            var z = u && s === void 0 ? zI(k) : c
              , O = {};
            for (var I in S)
                u && I === "as" || z(I) && (O[I] = S[I]);
            return O.className = T,
            w && (O.ref = w),
            A.createElement(A.Fragment, null, A.createElement(gJ, {
                cache: C,
                serialized: $,
                isStringTag: typeof k == "string"
            }), A.createElement(k, O))
        });
        return v.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")",
        v.defaultProps = t.defaultProps,
        v.__emotion_real = v,
        v.__emotion_base = i,
        v.__emotion_styles = h,
        v.__emotion_forwardProp = s,
        Object.defineProperty(v, "toString", {
            value: function() {
                return "." + a
            }
        }),
        v.withComponent = function(S, C) {
            var w = e(S, ge({}, n, C, {
                shouldForwardProp: FI(v, C, !0)
            }));
            return w.apply(void 0, h)
        }
        ,
        v
    }
}
  , bJ = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]
  , O2 = yJ.bind(null);
bJ.forEach(function(e) {
    O2[e] = O2(e)
});
var Lw = {
    exports: {}
}, jw, NI;
function xJ() {
    if (NI)
        return jw;
    NI = 1;
    var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return jw = e,
    jw
}
var Bw, UI;
function vJ() {
    if (UI)
        return Bw;
    UI = 1;
    var e = xJ();
    function t() {}
    function n() {}
    return n.resetWarningCache = t,
    Bw = function() {
        function r(a, s, c, u, f, h) {
            if (h !== e) {
                var m = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw m.name = "Invariant Violation",
                m
            }
        }
        r.isRequired = r;
        function i() {
            return r
        }
        var o = {
            array: r,
            bigint: r,
            bool: r,
            func: r,
            number: r,
            object: r,
            string: r,
            symbol: r,
            any: r,
            arrayOf: i,
            element: r,
            elementType: r,
            instanceOf: i,
            node: r,
            objectOf: i,
            oneOf: i,
            oneOfType: i,
            shape: i,
            exact: i,
            checkPropTypes: n,
            resetWarningCache: t
        };
        return o.PropTypes = o,
        o
    }
    ,
    Bw
}
var VI;
function SJ() {
    return VI || (VI = 1,
    Lw.exports = vJ()()),
    Lw.exports
}
var CJ = SJ();
const ze = es(CJ);
function wJ(e) {
    return e == null || Object.keys(e).length === 0
}
function GF(e) {
    const {styles: t, defaultTheme: n={}} = e
      , r = typeof t == "function" ? i => t(wJ(i) ? n : i) : t;
    return g.jsx(dJ, {
        styles: r
    })
}
function YF(e, t) {
    return O2(e, t)
}
function kJ(e, t) {
    Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles))
}
const HI = [];
function hc(e) {
    return HI[0] = e,
    Tg(HI)
}
var zw = {
    exports: {}
}
  , tr = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qI;
function TJ() {
    if (qI)
        return tr;
    qI = 1;
    var e = Symbol.for("react.transitional.element")
      , t = Symbol.for("react.portal")
      , n = Symbol.for("react.fragment")
      , r = Symbol.for("react.strict_mode")
      , i = Symbol.for("react.profiler")
      , o = Symbol.for("react.consumer")
      , a = Symbol.for("react.context")
      , s = Symbol.for("react.forward_ref")
      , c = Symbol.for("react.suspense")
      , u = Symbol.for("react.suspense_list")
      , f = Symbol.for("react.memo")
      , h = Symbol.for("react.lazy")
      , m = Symbol.for("react.view_transition")
      , y = Symbol.for("react.client.reference");
    function b(v) {
        if (typeof v == "object" && v !== null) {
            var S = v.$$typeof;
            switch (S) {
            case e:
                switch (v = v.type,
                v) {
                case n:
                case i:
                case r:
                case c:
                case u:
                case m:
                    return v;
                default:
                    switch (v = v && v.$$typeof,
                    v) {
                    case a:
                    case s:
                    case h:
                    case f:
                        return v;
                    case o:
                        return v;
                    default:
                        return S
                    }
                }
            case t:
                return S
            }
        }
    }
    return tr.ContextConsumer = o,
    tr.ContextProvider = a,
    tr.Element = e,
    tr.ForwardRef = s,
    tr.Fragment = n,
    tr.Lazy = h,
    tr.Memo = f,
    tr.Portal = t,
    tr.Profiler = i,
    tr.StrictMode = r,
    tr.Suspense = c,
    tr.SuspenseList = u,
    tr.isContextConsumer = function(v) {
        return b(v) === o
    }
    ,
    tr.isContextProvider = function(v) {
        return b(v) === a
    }
    ,
    tr.isElement = function(v) {
        return typeof v == "object" && v !== null && v.$$typeof === e
    }
    ,
    tr.isForwardRef = function(v) {
        return b(v) === s
    }
    ,
    tr.isFragment = function(v) {
        return b(v) === n
    }
    ,
    tr.isLazy = function(v) {
        return b(v) === h
    }
    ,
    tr.isMemo = function(v) {
        return b(v) === f
    }
    ,
    tr.isPortal = function(v) {
        return b(v) === t
    }
    ,
    tr.isProfiler = function(v) {
        return b(v) === i
    }
    ,
    tr.isStrictMode = function(v) {
        return b(v) === r
    }
    ,
    tr.isSuspense = function(v) {
        return b(v) === c
    }
    ,
    tr.isSuspenseList = function(v) {
        return b(v) === u
    }
    ,
    tr.isValidElementType = function(v) {
        return typeof v == "string" || typeof v == "function" || v === n || v === i || v === r || v === c || v === u || typeof v == "object" && v !== null && (v.$$typeof === h || v.$$typeof === f || v.$$typeof === a || v.$$typeof === o || v.$$typeof === s || v.$$typeof === y || v.getModuleId !== void 0)
    }
    ,
    tr.typeOf = b,
    tr
}
var WI;
function _J() {
    return WI || (WI = 1,
    zw.exports = TJ()),
    zw.exports
}
var ZF = _J();
function vs(e) {
    if (typeof e != "object" || e === null)
        return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
}
function QF(e) {
    if (A.isValidElement(e) || ZF.isValidElementType(e) || !vs(e))
        return e;
    const t = {};
    return Object.keys(e).forEach(n => {
        t[n] = QF(e[n])
    }
    ),
    t
}
function ci(e, t, n={
    clone: !0
}) {
    const r = n.clone ? {
        ...e
    } : e;
    return vs(e) && vs(t) && Object.keys(t).forEach(i => {
        A.isValidElement(t[i]) || ZF.isValidElementType(t[i]) ? r[i] = t[i] : vs(t[i]) && Object.prototype.hasOwnProperty.call(e, i) && vs(e[i]) ? r[i] = ci(e[i], t[i], n) : n.clone ? r[i] = vs(t[i]) ? QF(t[i]) : t[i] : r[i] = t[i]
    }
    ),
    r
}
const EJ = e => {
    const t = Object.keys(e).map(n => ({
        key: n,
        val: e[n]
    })) || [];
    return t.sort( (n, r) => n.val - r.val),
    t.reduce( (n, r) => ({
        ...n,
        [r.key]: r.val
    }), {})
}
;
function AJ(e) {
    const {values: t={
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536
    }, unit: n="px", step: r=5, ...i} = e
      , o = EJ(t)
      , a = Object.keys(o);
    function s(m) {
        return `@media (min-width:${typeof t[m] == "number" ? t[m] : m}${n})`
    }
    function c(m) {
        return `@media (max-width:${(typeof t[m] == "number" ? t[m] : m) - r / 100}${n})`
    }
    function u(m, y) {
        const b = a.indexOf(y);
        return `@media (min-width:${typeof t[m] == "number" ? t[m] : m}${n}) and (max-width:${(b !== -1 && typeof t[a[b]] == "number" ? t[a[b]] : y) - r / 100}${n})`
    }
    function f(m) {
        return a.indexOf(m) + 1 < a.length ? u(m, a[a.indexOf(m) + 1]) : s(m)
    }
    function h(m) {
        const y = a.indexOf(m);
        return y === 0 ? s(a[1]) : y === a.length - 1 ? c(a[y]) : u(m, a[a.indexOf(m) + 1]).replace("@media", "@media not all and")
    }
    return {
        keys: a,
        values: o,
        up: s,
        down: c,
        between: u,
        only: f,
        not: h,
        unit: n,
        ...i
    }
}
function GI(e, t) {
    if (!e.containerQueries)
        return t;
    const n = Object.keys(t).filter(r => r.startsWith("@container")).sort( (r, i) => {
        const o = /min-width:\s*([0-9.]+)/;
        return +(r.match(o)?.[1] || 0) - +(i.match(o)?.[1] || 0)
    }
    );
    return n.length ? n.reduce( (r, i) => {
        const o = t[i];
        return delete r[i],
        r[i] = o,
        r
    }
    , {
        ...t
    }) : t
}
function MJ(e, t) {
    return t === "@" || t.startsWith("@") && (e.some(n => t.startsWith(`@${n}`)) || !!t.match(/^@\d/))
}
function PJ(e, t) {
    const n = t.match(/^@([^/]+)?\/?(.+)?$/);
    if (!n)
        return null;
    const [,r,i] = n
      , o = Number.isNaN(+r) ? r || 0 : +r;
    return e.containerQueries(i).up(o)
}
function RJ(e) {
    const t = (o, a) => o.replace("@media", a ? `@container ${a}` : "@container");
    function n(o, a) {
        o.up = (...s) => t(e.breakpoints.up(...s), a),
        o.down = (...s) => t(e.breakpoints.down(...s), a),
        o.between = (...s) => t(e.breakpoints.between(...s), a),
        o.only = (...s) => t(e.breakpoints.only(...s), a),
        o.not = (...s) => {
            const c = t(e.breakpoints.not(...s), a);
            return c.includes("not all and") ? c.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : c
        }
    }
    const r = {}
      , i = o => (n(r, o),
    r);
    return n(i),
    {
        ...e,
        containerQueries: i
    }
}
const DJ = {
    borderRadius: 4
};
function dm(e, t) {
    return t ? ci(e, t, {
        clone: !1
    }) : e
}
const Rv = {
    xs: 0,
    sm: 600,
    md: 900,
    lg: 1200,
    xl: 1536
}
  , YI = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: e => `@media (min-width:${Rv[e]}px)`
}
  , OJ = {
    containerQueries: e => ({
        up: t => {
            let n = typeof t == "number" ? t : Rv[t] || t;
            return typeof n == "number" && (n = `${n}px`),
            e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`
        }
    })
};
function Qa(e, t, n) {
    const r = e.theme || {};
    if (Array.isArray(t)) {
        const o = r.breakpoints || YI;
        return t.reduce( (a, s, c) => (a[o.up(o.keys[c])] = n(t[c]),
        a), {})
    }
    if (typeof t == "object") {
        const o = r.breakpoints || YI;
        return Object.keys(t).reduce( (a, s) => {
            if (MJ(o.keys, s)) {
                const c = PJ(r.containerQueries ? r : OJ, s);
                c && (a[c] = n(t[s], s))
            } else if (Object.keys(o.values || Rv).includes(s)) {
                const c = o.up(s);
                a[c] = n(t[s], s)
            } else {
                const c = s;
                a[c] = t[c]
            }
            return a
        }
        , {})
    }
    return n(t)
}
function KF(e={}) {
    return e.keys?.reduce( (n, r) => {
        const i = e.up(r);
        return n[i] = {},
        n
    }
    , {}) || {}
}
function I2(e, t) {
    return e.reduce( (n, r) => {
        const i = n[r];
        return (!i || Object.keys(i).length === 0) && delete n[r],
        n
    }
    , t)
}
function IJ(e, ...t) {
    const n = KF(e)
      , r = [n, ...t].reduce( (i, o) => ci(i, o), {});
    return I2(Object.keys(n), r)
}
function $J(e, t) {
    if (typeof e != "object")
        return {};
    const n = {}
      , r = Object.keys(t);
    return Array.isArray(e) ? r.forEach( (i, o) => {
        o < e.length && (n[i] = !0)
    }
    ) : r.forEach(i => {
        e[i] != null && (n[i] = !0)
    }
    ),
    n
}
function Fw({values: e, breakpoints: t, base: n}) {
    const r = n || $J(e, t)
      , i = Object.keys(r);
    if (i.length === 0)
        return e;
    let o;
    return i.reduce( (a, s, c) => (Array.isArray(e) ? (a[s] = e[c] != null ? e[c] : e[o],
    o = c) : typeof e == "object" ? (a[s] = e[s] != null ? e[s] : e[o],
    o = s) : a[s] = e,
    a), {})
}
function Te(e) {
    if (typeof e != "string")
        throw new Error(Cl(7));
    return e.charAt(0).toUpperCase() + e.slice(1)
}
function Dv(e, t, n=!0) {
    if (!t || typeof t != "string")
        return null;
    if (e && e.vars && n) {
        const r = `vars.${t}`.split(".").reduce( (i, o) => i && i[o] ? i[o] : null, e);
        if (r != null)
            return r
    }
    return t.split(".").reduce( (r, i) => r && r[i] != null ? r[i] : null, e)
}
function u0(e, t, n, r=n) {
    let i;
    return typeof e == "function" ? i = e(n) : Array.isArray(e) ? i = e[n] || r : i = Dv(e, n) || r,
    t && (i = t(i, r, e)),
    i
}
function zr(e) {
    const {prop: t, cssProperty: n=e.prop, themeKey: r, transform: i} = e
      , o = a => {
        if (a[t] == null)
            return null;
        const s = a[t]
          , c = a.theme
          , u = Dv(c, r) || {};
        return Qa(a, s, h => {
            let m = u0(u, i, h);
            return h === m && typeof h == "string" && (m = u0(u, i, `${t}${h === "default" ? "" : Te(h)}`, h)),
            n === !1 ? m : {
                [n]: m
            }
        }
        )
    }
    ;
    return o.propTypes = {},
    o.filterProps = [t],
    o
}
function LJ(e) {
    const t = {};
    return n => (t[n] === void 0 && (t[n] = e(n)),
    t[n])
}
const jJ = {
    m: "margin",
    p: "padding"
}
  , BJ = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
}
  , ZI = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
}
  , zJ = LJ(e => {
    if (e.length > 2)
        if (ZI[e])
            e = ZI[e];
        else
            return [e];
    const [t,n] = e.split("")
      , r = jJ[t]
      , i = BJ[n] || "";
    return Array.isArray(i) ? i.map(o => r + o) : [r + i]
}
)
  , mE = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"]
  , gE = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...mE, ...gE];
function Eg(e, t, n, r) {
    const i = Dv(e, t, !0) ?? n;
    return typeof i == "number" || typeof i == "string" ? o => typeof o == "string" ? o : typeof i == "string" ? i.startsWith("var(") && o === 0 ? 0 : i.startsWith("var(") && o === 1 ? i : `calc(${o} * ${i})` : i * o : Array.isArray(i) ? o => {
        if (typeof o == "string")
            return o;
        const a = Math.abs(o)
          , s = i[a];
        return o >= 0 ? s : typeof s == "number" ? -s : typeof s == "string" && s.startsWith("var(") ? `calc(-1 * ${s})` : `-${s}`
    }
    : typeof i == "function" ? i : () => {}
}
function Ov(e) {
    return Eg(e, "spacing", 8)
}
function ju(e, t) {
    return typeof t == "string" || t == null ? t : e(t)
}
function FJ(e, t) {
    return n => e.reduce( (r, i) => (r[i] = ju(t, n),
    r), {})
}
function NJ(e, t, n, r) {
    if (!t.includes(n))
        return null;
    const i = zJ(n)
      , o = FJ(i, r)
      , a = e[n];
    return Qa(e, a, o)
}
function XF(e, t) {
    const n = Ov(e.theme);
    return Object.keys(e).map(r => NJ(e, t, r, n)).reduce(dm, {})
}
function Mr(e) {
    return XF(e, mE)
}
Mr.propTypes = {};
Mr.filterProps = mE;
function Pr(e) {
    return XF(e, gE)
}
Pr.propTypes = {};
Pr.filterProps = gE;
function JF(e=8, t=Ov({
    spacing: e
})) {
    if (e.mui)
        return e;
    const n = (...r) => (r.length === 0 ? [1] : r).map(o => {
        const a = t(o);
        return typeof a == "number" ? `${a}px` : a
    }
    ).join(" ");
    return n.mui = !0,
    n
}
function Iv(...e) {
    const t = e.reduce( (r, i) => (i.filterProps.forEach(o => {
        r[o] = i
    }
    ),
    r), {})
      , n = r => Object.keys(r).reduce( (i, o) => t[o] ? dm(i, t[o](r)) : i, {});
    return n.propTypes = {},
    n.filterProps = e.reduce( (r, i) => r.concat(i.filterProps), []),
    n
}
function ga(e) {
    return typeof e != "number" ? e : `${e}px solid`
}
function Ea(e, t) {
    return zr({
        prop: e,
        themeKey: "borders",
        transform: t
    })
}
const UJ = Ea("border", ga)
  , VJ = Ea("borderTop", ga)
  , HJ = Ea("borderRight", ga)
  , qJ = Ea("borderBottom", ga)
  , WJ = Ea("borderLeft", ga)
  , GJ = Ea("borderColor")
  , YJ = Ea("borderTopColor")
  , ZJ = Ea("borderRightColor")
  , QJ = Ea("borderBottomColor")
  , KJ = Ea("borderLeftColor")
  , XJ = Ea("outline", ga)
  , JJ = Ea("outlineColor")
  , $v = e => {
    if (e.borderRadius !== void 0 && e.borderRadius !== null) {
        const t = Eg(e.theme, "shape.borderRadius", 4)
          , n = r => ({
            borderRadius: ju(t, r)
        });
        return Qa(e, e.borderRadius, n)
    }
    return null
}
;
$v.propTypes = {};
$v.filterProps = ["borderRadius"];
Iv(UJ, VJ, HJ, qJ, WJ, GJ, YJ, ZJ, QJ, KJ, $v, XJ, JJ);
const Lv = e => {
    if (e.gap !== void 0 && e.gap !== null) {
        const t = Eg(e.theme, "spacing", 8)
          , n = r => ({
            gap: ju(t, r)
        });
        return Qa(e, e.gap, n)
    }
    return null
}
;
Lv.propTypes = {};
Lv.filterProps = ["gap"];
const jv = e => {
    if (e.columnGap !== void 0 && e.columnGap !== null) {
        const t = Eg(e.theme, "spacing", 8)
          , n = r => ({
            columnGap: ju(t, r)
        });
        return Qa(e, e.columnGap, n)
    }
    return null
}
;
jv.propTypes = {};
jv.filterProps = ["columnGap"];
const Bv = e => {
    if (e.rowGap !== void 0 && e.rowGap !== null) {
        const t = Eg(e.theme, "spacing", 8)
          , n = r => ({
            rowGap: ju(t, r)
        });
        return Qa(e, e.rowGap, n)
    }
    return null
}
;
Bv.propTypes = {};
Bv.filterProps = ["rowGap"];
const eee = zr({
    prop: "gridColumn"
})
  , tee = zr({
    prop: "gridRow"
})
  , nee = zr({
    prop: "gridAutoFlow"
})
  , ree = zr({
    prop: "gridAutoColumns"
})
  , iee = zr({
    prop: "gridAutoRows"
})
  , oee = zr({
    prop: "gridTemplateColumns"
})
  , aee = zr({
    prop: "gridTemplateRows"
})
  , see = zr({
    prop: "gridTemplateAreas"
})
  , lee = zr({
    prop: "gridArea"
});
Iv(Lv, jv, Bv, eee, tee, nee, ree, iee, oee, aee, see, lee);
function bf(e, t) {
    return t === "grey" ? t : e
}
const cee = zr({
    prop: "color",
    themeKey: "palette",
    transform: bf
})
  , uee = zr({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: bf
})
  , dee = zr({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: bf
});
Iv(cee, uee, dee);
function Ho(e) {
    return e <= 1 && e !== 0 ? `${e * 100}%` : e
}
const fee = zr({
    prop: "width",
    transform: Ho
})
  , yE = e => {
    if (e.maxWidth !== void 0 && e.maxWidth !== null) {
        const t = n => {
            const r = e.theme?.breakpoints?.values?.[n] || Rv[n];
            return r ? e.theme?.breakpoints?.unit !== "px" ? {
                maxWidth: `${r}${e.theme.breakpoints.unit}`
            } : {
                maxWidth: r
            } : {
                maxWidth: Ho(n)
            }
        }
        ;
        return Qa(e, e.maxWidth, t)
    }
    return null
}
;
yE.filterProps = ["maxWidth"];
const hee = zr({
    prop: "minWidth",
    transform: Ho
})
  , pee = zr({
    prop: "height",
    transform: Ho
})
  , mee = zr({
    prop: "maxHeight",
    transform: Ho
})
  , gee = zr({
    prop: "minHeight",
    transform: Ho
});
zr({
    prop: "size",
    cssProperty: "width",
    transform: Ho
});
zr({
    prop: "size",
    cssProperty: "height",
    transform: Ho
});
const yee = zr({
    prop: "boxSizing"
});
Iv(fee, yE, hee, pee, mee, gee, yee);
const Ag = {
    border: {
        themeKey: "borders",
        transform: ga
    },
    borderTop: {
        themeKey: "borders",
        transform: ga
    },
    borderRight: {
        themeKey: "borders",
        transform: ga
    },
    borderBottom: {
        themeKey: "borders",
        transform: ga
    },
    borderLeft: {
        themeKey: "borders",
        transform: ga
    },
    borderColor: {
        themeKey: "palette"
    },
    borderTopColor: {
        themeKey: "palette"
    },
    borderRightColor: {
        themeKey: "palette"
    },
    borderBottomColor: {
        themeKey: "palette"
    },
    borderLeftColor: {
        themeKey: "palette"
    },
    outline: {
        themeKey: "borders",
        transform: ga
    },
    outlineColor: {
        themeKey: "palette"
    },
    borderRadius: {
        themeKey: "shape.borderRadius",
        style: $v
    },
    color: {
        themeKey: "palette",
        transform: bf
    },
    bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: bf
    },
    backgroundColor: {
        themeKey: "palette",
        transform: bf
    },
    p: {
        style: Pr
    },
    pt: {
        style: Pr
    },
    pr: {
        style: Pr
    },
    pb: {
        style: Pr
    },
    pl: {
        style: Pr
    },
    px: {
        style: Pr
    },
    py: {
        style: Pr
    },
    padding: {
        style: Pr
    },
    paddingTop: {
        style: Pr
    },
    paddingRight: {
        style: Pr
    },
    paddingBottom: {
        style: Pr
    },
    paddingLeft: {
        style: Pr
    },
    paddingX: {
        style: Pr
    },
    paddingY: {
        style: Pr
    },
    paddingInline: {
        style: Pr
    },
    paddingInlineStart: {
        style: Pr
    },
    paddingInlineEnd: {
        style: Pr
    },
    paddingBlock: {
        style: Pr
    },
    paddingBlockStart: {
        style: Pr
    },
    paddingBlockEnd: {
        style: Pr
    },
    m: {
        style: Mr
    },
    mt: {
        style: Mr
    },
    mr: {
        style: Mr
    },
    mb: {
        style: Mr
    },
    ml: {
        style: Mr
    },
    mx: {
        style: Mr
    },
    my: {
        style: Mr
    },
    margin: {
        style: Mr
    },
    marginTop: {
        style: Mr
    },
    marginRight: {
        style: Mr
    },
    marginBottom: {
        style: Mr
    },
    marginLeft: {
        style: Mr
    },
    marginX: {
        style: Mr
    },
    marginY: {
        style: Mr
    },
    marginInline: {
        style: Mr
    },
    marginInlineStart: {
        style: Mr
    },
    marginInlineEnd: {
        style: Mr
    },
    marginBlock: {
        style: Mr
    },
    marginBlockStart: {
        style: Mr
    },
    marginBlockEnd: {
        style: Mr
    },
    displayPrint: {
        cssProperty: !1,
        transform: e => ({
            "@media print": {
                display: e
            }
        })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: {
        style: Lv
    },
    rowGap: {
        style: Bv
    },
    columnGap: {
        style: jv
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: {
        themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: {
        themeKey: "shadows"
    },
    width: {
        transform: Ho
    },
    maxWidth: {
        style: yE
    },
    minWidth: {
        transform: Ho
    },
    height: {
        transform: Ho
    },
    maxHeight: {
        transform: Ho
    },
    minHeight: {
        transform: Ho
    },
    boxSizing: {},
    font: {
        themeKey: "font"
    },
    fontFamily: {
        themeKey: "typography"
    },
    fontSize: {
        themeKey: "typography"
    },
    fontStyle: {
        themeKey: "typography"
    },
    fontWeight: {
        themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
        cssProperty: !1,
        themeKey: "typography"
    }
};
function bee(...e) {
    const t = e.reduce( (r, i) => r.concat(Object.keys(i)), [])
      , n = new Set(t);
    return e.every(r => n.size === Object.keys(r).length)
}
function xee(e, t) {
    return typeof e == "function" ? e(t) : e
}
function vee() {
    function e(n, r, i, o) {
        const a = {
            [n]: r,
            theme: i
        }
          , s = o[n];
        if (!s)
            return {
                [n]: r
            };
        const {cssProperty: c=n, themeKey: u, transform: f, style: h} = s;
        if (r == null)
            return null;
        if (u === "typography" && r === "inherit")
            return {
                [n]: r
            };
        const m = Dv(i, u) || {};
        return h ? h(a) : Qa(a, r, b => {
            let v = u0(m, f, b);
            return b === v && typeof b == "string" && (v = u0(m, f, `${n}${b === "default" ? "" : Te(b)}`, b)),
            c === !1 ? v : {
                [c]: v
            }
        }
        )
    }
    function t(n) {
        const {sx: r, theme: i={}, nested: o} = n || {};
        if (!r)
            return null;
        const a = i.unstable_sxConfig ?? Ag;
        function s(c) {
            let u = c;
            if (typeof c == "function")
                u = c(i);
            else if (typeof c != "object")
                return c;
            if (!u)
                return null;
            const f = KF(i.breakpoints)
              , h = Object.keys(f);
            let m = f;
            return Object.keys(u).forEach(y => {
                const b = xee(u[y], i);
                if (b != null)
                    if (typeof b == "object")
                        if (a[y])
                            m = dm(m, e(y, b, i, a));
                        else {
                            const v = Qa({
                                theme: i
                            }, b, S => ({
                                [y]: S
                            }));
                            bee(v, b) ? m[y] = t({
                                sx: b,
                                theme: i,
                                nested: !0
                            }) : m = dm(m, v)
                        }
                    else
                        m = dm(m, e(y, b, i, a))
            }
            ),
            !o && i.modularCssLayers ? {
                "@layer sx": GI(i, I2(h, m))
            } : GI(i, I2(h, m))
        }
        return Array.isArray(r) ? r.map(s) : s(r)
    }
    return t
}
const yc = vee();
yc.filterProps = ["sx"];
function See(e, t) {
    const n = this;
    if (n.vars) {
        if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
            return {};
        let r = n.getColorSchemeSelector(e);
        return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`),
        {
            [r]: t
        })
    }
    return n.palette.mode === e ? t : {}
}
function Mg(e={}, ...t) {
    const {breakpoints: n={}, palette: r={}, spacing: i, shape: o={}, ...a} = e
      , s = AJ(n)
      , c = JF(i);
    let u = ci({
        breakpoints: s,
        direction: "ltr",
        components: {},
        palette: {
            mode: "light",
            ...r
        },
        spacing: c,
        shape: {
            ...DJ,
            ...o
        }
    }, a);
    return u = RJ(u),
    u.applyStyles = See,
    u = t.reduce( (f, h) => ci(f, h), u),
    u.unstable_sxConfig = {
        ...Ag,
        ...a?.unstable_sxConfig
    },
    u.unstable_sx = function(h) {
        return yc({
            sx: h,
            theme: this
        })
    }
    ,
    u
}
function Cee(e) {
    return Object.keys(e).length === 0
}
function zv(e=null) {
    const t = A.useContext(_g);
    return !t || Cee(t) ? e : t
}
const wee = Mg();
function Pg(e=wee) {
    return zv(e)
}
function Nw(e) {
    const t = hc(e);
    return e !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`),
    t) : e
}
function eN({styles: e, themeId: t, defaultTheme: n={}}) {
    const r = Pg(n)
      , i = t && r[t] || r;
    let o = typeof e == "function" ? e(i) : e;
    return i.modularCssLayers && (Array.isArray(o) ? o = o.map(a => Nw(typeof a == "function" ? a(i) : a)) : o = Nw(o)),
    g.jsx(GF, {
        styles: o
    })
}
const kee = e => {
    const t = {
        systemProps: {},
        otherProps: {}
    }
      , n = e?.theme?.unstable_sxConfig ?? Ag;
    return Object.keys(e).forEach(r => {
        n[r] ? t.systemProps[r] = e[r] : t.otherProps[r] = e[r]
    }
    ),
    t
}
;
function Fv(e) {
    const {sx: t, ...n} = e
      , {systemProps: r, otherProps: i} = kee(n);
    let o;
    return Array.isArray(t) ? o = [r, ...t] : typeof t == "function" ? o = (...a) => {
        const s = t(...a);
        return vs(s) ? {
            ...r,
            ...s
        } : r
    }
    : o = {
        ...r,
        ...t
    },
    {
        ...i,
        sx: o
    }
}
const QI = e => e
  , Tee = () => {
    let e = QI;
    return {
        configure(t) {
            e = t
        },
        generate(t) {
            return e(t)
        },
        reset() {
            e = QI
        }
    }
}
  , tN = Tee();
function nN(e) {
    var t, n, r = "";
    if (typeof e == "string" || typeof e == "number")
        r += e;
    else if (typeof e == "object")
        if (Array.isArray(e)) {
            var i = e.length;
            for (t = 0; t < i; t++)
                e[t] && (n = nN(e[t])) && (r && (r += " "),
                r += n)
        } else
            for (n in e)
                e[n] && (r && (r += " "),
                r += n);
    return r
}
function Ne() {
    for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)
        (e = arguments[n]) && (t = nN(e)) && (r && (r += " "),
        r += t);
    return r
}
function _ee(e={}) {
    const {themeId: t, defaultTheme: n, defaultClassName: r="MuiBox-root", generateClassName: i} = e
      , o = YF("div", {
        shouldForwardProp: s => s !== "theme" && s !== "sx" && s !== "as"
    })(yc);
    return A.forwardRef(function(c, u) {
        const f = Pg(n)
          , {className: h, component: m="div", ...y} = Fv(c);
        return g.jsx(o, {
            as: m,
            ref: u,
            className: Ne(h, i ? i(r) : r),
            theme: t && f[t] || f,
            ...y
        })
    })
}
const Eee = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
};
function rt(e, t, n="Mui") {
    const r = Eee[t];
    return r ? `${n}-${r}` : `${tN.generate(e)}-${t}`
}
function ot(e, t, n="Mui") {
    const r = {};
    return t.forEach(i => {
        r[i] = rt(e, i, n)
    }
    ),
    r
}
function rN(e) {
    const {variants: t, ...n} = e
      , r = {
        variants: t,
        style: hc(n),
        isProcessed: !0
    };
    return r.style === n || t && t.forEach(i => {
        typeof i.style != "function" && (i.style = hc(i.style))
    }
    ),
    r
}
const Aee = Mg();
function _x(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as"
}
function vu(e, t) {
    return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`),
    e
}
function Mee(e) {
    return e ? (t, n) => n[e] : null
}
function Pee(e, t, n) {
    e.theme = Dee(e.theme) ? n : e.theme[t] || e.theme
}
function Ex(e, t, n) {
    const r = typeof t == "function" ? t(e) : t;
    if (Array.isArray(r))
        return r.flatMap(i => Ex(e, i, n));
    if (Array.isArray(r?.variants)) {
        let i;
        if (r.isProcessed)
            i = n ? vu(r.style, n) : r.style;
        else {
            const {variants: o, ...a} = r;
            i = n ? vu(hc(a), n) : a
        }
        return iN(e, r.variants, [i], n)
    }
    return r?.isProcessed ? n ? vu(hc(r.style), n) : r.style : n ? vu(hc(r), n) : r
}
function iN(e, t, n=[], r=void 0) {
    let i;
    e: for (let o = 0; o < t.length; o += 1) {
        const a = t[o];
        if (typeof a.props == "function") {
            if (i ??= {
                ...e,
                ...e.ownerState,
                ownerState: e.ownerState
            },
            !a.props(i))
                continue
        } else
            for (const s in a.props)
                if (e[s] !== a.props[s] && e.ownerState?.[s] !== a.props[s])
                    continue e;
        typeof a.style == "function" ? (i ??= {
            ...e,
            ...e.ownerState,
            ownerState: e.ownerState
        },
        n.push(r ? vu(hc(a.style(i)), r) : a.style(i))) : n.push(r ? vu(hc(a.style), r) : a.style)
    }
    return n
}
function oN(e={}) {
    const {themeId: t, defaultTheme: n=Aee, rootShouldForwardProp: r=_x, slotShouldForwardProp: i=_x} = e;
    function o(s) {
        Pee(s, t, n)
    }
    return (s, c={}) => {
        kJ(s, P => P.filter(D => D !== yc));
        const {name: u, slot: f, skipVariantsResolver: h, skipSx: m, overridesResolver: y=Mee(Iee(f)), ...b} = c
          , v = u && u.startsWith("Mui") || f ? "components" : "custom"
          , S = h !== void 0 ? h : f && f !== "Root" && f !== "root" || !1
          , C = m || !1;
        let w = _x;
        f === "Root" || f === "root" ? w = r : f ? w = i : Oee(s) && (w = void 0);
        const k = YF(s, {
            shouldForwardProp: w,
            label: Ree(),
            ...b
        })
          , T = P => {
            if (P.__emotion_real === P)
                return P;
            if (typeof P == "function")
                return function($) {
                    return Ex($, P, $.theme.modularCssLayers ? v : void 0)
                }
                ;
            if (vs(P)) {
                const D = rN(P);
                return function(z) {
                    return D.variants ? Ex(z, D, z.theme.modularCssLayers ? v : void 0) : z.theme.modularCssLayers ? vu(D.style, v) : D.style
                }
            }
            return P
        }
          , E = (...P) => {
            const D = []
              , $ = P.map(T)
              , z = [];
            if (D.push(o),
            u && y && z.push(function(B) {
                const F = B.theme.components?.[u]?.styleOverrides;
                if (!F)
                    return null;
                const j = {};
                for (const N in F)
                    j[N] = Ex(B, F[N], B.theme.modularCssLayers ? "theme" : void 0);
                return y(B, j)
            }),
            u && !S && z.push(function(B) {
                const F = B.theme?.components?.[u]?.variants;
                return F ? iN(B, F, [], B.theme.modularCssLayers ? "theme" : void 0) : null
            }),
            C || z.push(yc),
            Array.isArray($[0])) {
                const M = $.shift()
                  , B = new Array(D.length).fill("")
                  , L = new Array(z.length).fill("");
                let F;
                F = [...B, ...M, ...L],
                F.raw = [...B, ...M.raw, ...L],
                D.unshift(F)
            }
            const O = [...D, ...$, ...z]
              , I = k(...O);
            return s.muiName && (I.muiName = s.muiName),
            I
        }
        ;
        return k.withConfig && (E.withConfig = k.withConfig),
        E
    }
}
function Ree(e, t) {
    return void 0
}
function Dee(e) {
    for (const t in e)
        return !1;
    return !0
}
function Oee(e) {
    return typeof e == "string" && e.charCodeAt(0) > 96
}
function Iee(e) {
    return e && e.charAt(0).toLowerCase() + e.slice(1)
}
const aN = oN();
function Vm(e, t, n=!1) {
    const r = {
        ...t
    };
    for (const i in e)
        if (Object.prototype.hasOwnProperty.call(e, i)) {
            const o = i;
            if (o === "components" || o === "slots")
                r[o] = {
                    ...e[o],
                    ...r[o]
                };
            else if (o === "componentsProps" || o === "slotProps") {
                const a = e[o]
                  , s = t[o];
                if (!s)
                    r[o] = a || {};
                else if (!a)
                    r[o] = s;
                else {
                    r[o] = {
                        ...s
                    };
                    for (const c in a)
                        if (Object.prototype.hasOwnProperty.call(a, c)) {
                            const u = c;
                            r[o][u] = Vm(a[u], s[u], n)
                        }
                }
            } else
                o === "className" && n && t.className ? r.className = Ne(e?.className, t?.className) : o === "style" && n && t.style ? r.style = {
                    ...e?.style,
                    ...t?.style
                } : r[o] === void 0 && (r[o] = e[o])
        }
    return r
}
function sN(e) {
    const {theme: t, name: n, props: r} = e;
    return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : Vm(t.components[n].defaultProps, r)
}
function bE({props: e, name: t, defaultTheme: n, themeId: r}) {
    let i = Pg(n);
    return r && (i = i[r] || i),
    sN({
        theme: i,
        name: t,
        props: e
    })
}
const Cr = typeof window < "u" ? A.useLayoutEffect : A.useEffect;
function $ee(e, t, n, r, i) {
    const [o,a] = A.useState( () => i && n ? n(e).matches : r ? r(e).matches : t);
    return Cr( () => {
        if (!n)
            return;
        const s = n(e)
          , c = () => {
            a(s.matches)
        }
        ;
        return c(),
        s.addEventListener("change", c),
        () => {
            s.removeEventListener("change", c)
        }
    }
    , [e, n]),
    o
}
const Lee = {
    ...o0
}
  , lN = Lee.useSyncExternalStore;
function jee(e, t, n, r, i) {
    const o = A.useCallback( () => t, [t])
      , a = A.useMemo( () => {
        if (i && n)
            return () => n(e).matches;
        if (r !== null) {
            const {matches: f} = r(e);
            return () => f
        }
        return o
    }
    , [o, e, r, i, n])
      , [s,c] = A.useMemo( () => {
        if (n === null)
            return [o, () => () => {}
            ];
        const f = n(e);
        return [ () => f.matches, h => (f.addEventListener("change", h),
        () => {
            f.removeEventListener("change", h)
        }
        )]
    }
    , [o, n, e]);
    return lN(c, s, a)
}
function cN(e={}) {
    const {themeId: t} = e;
    return function(r, i={}) {
        let o = zv();
        o && t && (o = o[t] || o);
        const a = typeof window < "u" && typeof window.matchMedia < "u"
          , {defaultMatches: s=!1, matchMedia: c=a ? window.matchMedia : null, ssrMatchMedia: u=null, noSsr: f=!1} = sN({
            name: "MuiUseMediaQuery",
            props: i,
            theme: o
        });
        let h = typeof r == "function" ? r(o) : r;
        return h = h.replace(/^@media( ?)/m, ""),
        h.includes("print") && console.warn(["MUI: You have provided a `print` query to the `useMediaQuery` hook.", "Using the print media query to modify print styles can lead to unexpected results.", "Consider using the `displayPrint` field in the `sx` prop instead.", "More information about `displayPrint` on our docs: https://mui.com/system/display/#display-in-print."].join(`
`)),
        (lN !== void 0 ? jee : $ee)(h, s, c, u, f)
    }
}
cN();
function Bee(e, t=Number.MIN_SAFE_INTEGER, n=Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, n))
}
function xE(e, t=0, n=1) {
    return Bee(e, t, n)
}
function zee(e) {
    e = e.slice(1);
    const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`,"g");
    let n = e.match(t);
    return n && n[0].length === 1 && (n = n.map(r => r + r)),
    n ? `rgb${n.length === 4 ? "a" : ""}(${n.map( (r, i) => i < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : ""
}
function bc(e) {
    if (e.type)
        return e;
    if (e.charAt(0) === "#")
        return bc(zee(e));
    const t = e.indexOf("(")
      , n = e.substring(0, t);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
        throw new Error(Cl(9, e));
    let r = e.substring(t + 1, e.length - 1), i;
    if (n === "color") {
        if (r = r.split(" "),
        i = r.shift(),
        r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)),
        !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(i))
            throw new Error(Cl(10, i))
    } else
        r = r.split(",");
    return r = r.map(o => parseFloat(o)),
    {
        type: n,
        values: r,
        colorSpace: i
    }
}
const Fee = e => {
    const t = bc(e);
    return t.values.slice(0, 3).map( (n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ")
}
  , Qp = (e, t) => {
    try {
        return Fee(e)
    } catch {
        return e
    }
}
;
function Nv(e) {
    const {type: t, colorSpace: n} = e;
    let {values: r} = e;
    return t.includes("rgb") ? r = r.map( (i, o) => o < 3 ? parseInt(i, 10) : i) : t.includes("hsl") && (r[1] = `${r[1]}%`,
    r[2] = `${r[2]}%`),
    t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`,
    `${t}(${r})`
}
function uN(e) {
    e = bc(e);
    const {values: t} = e
      , n = t[0]
      , r = t[1] / 100
      , i = t[2] / 100
      , o = r * Math.min(i, 1 - i)
      , a = (u, f=(u + n / 30) % 12) => i - o * Math.max(Math.min(f - 3, 9 - f, 1), -1);
    let s = "rgb";
    const c = [Math.round(a(0) * 255), Math.round(a(8) * 255), Math.round(a(4) * 255)];
    return e.type === "hsla" && (s += "a",
    c.push(t[3])),
    Nv({
        type: s,
        values: c
    })
}
function $2(e) {
    e = bc(e);
    let t = e.type === "hsl" || e.type === "hsla" ? bc(uN(e)).values : e.values;
    return t = t.map(n => (e.type !== "color" && (n /= 255),
    n <= .03928 ? n / 12.92 : ((n + .055) / 1.055) ** 2.4)),
    Number((.2126 * t[0] + .7152 * t[1] + .0722 * t[2]).toFixed(3))
}
function Nee(e, t) {
    const n = $2(e)
      , r = $2(t);
    return (Math.max(n, r) + .05) / (Math.min(n, r) + .05)
}
function Ts(e, t) {
    return e = bc(e),
    t = xE(t),
    (e.type === "rgb" || e.type === "hsl") && (e.type += "a"),
    e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t,
    Nv(e)
}
function nu(e, t, n) {
    try {
        return Ts(e, t)
    } catch {
        return e
    }
}
function Uv(e, t) {
    if (e = bc(e),
    t = xE(t),
    e.type.includes("hsl"))
        e.values[2] *= 1 - t;
    else if (e.type.includes("rgb") || e.type.includes("color"))
        for (let n = 0; n < 3; n += 1)
            e.values[n] *= 1 - t;
    return Nv(e)
}
function Yn(e, t, n) {
    try {
        return Uv(e, t)
    } catch {
        return e
    }
}
function Vv(e, t) {
    if (e = bc(e),
    t = xE(t),
    e.type.includes("hsl"))
        e.values[2] += (100 - e.values[2]) * t;
    else if (e.type.includes("rgb"))
        for (let n = 0; n < 3; n += 1)
            e.values[n] += (255 - e.values[n]) * t;
    else if (e.type.includes("color"))
        for (let n = 0; n < 3; n += 1)
            e.values[n] += (1 - e.values[n]) * t;
    return Nv(e)
}
function Zn(e, t, n) {
    try {
        return Vv(e, t)
    } catch {
        return e
    }
}
function L2(e, t=.15) {
    return $2(e) > .5 ? Uv(e, t) : Vv(e, t)
}
function Pb(e, t, n) {
    try {
        return L2(e, t)
    } catch {
        return e
    }
}
const dN = A.createContext(null);
function vE() {
    return A.useContext(dN)
}
const Uee = typeof Symbol == "function" && Symbol.for
  , Vee = Uee ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function Hee(e, t) {
    return typeof t == "function" ? t(e) : {
        ...e,
        ...t
    }
}
function qee(e) {
    const {children: t, theme: n} = e
      , r = vE()
      , i = A.useMemo( () => {
        const o = r === null ? {
            ...n
        } : Hee(r, n);
        return o != null && (o[Vee] = r !== null),
        o
    }
    , [n, r]);
    return g.jsx(dN.Provider, {
        value: i,
        children: t
    })
}
const fN = A.createContext();
function Wee({value: e, ...t}) {
    return g.jsx(fN.Provider, {
        value: e ?? !0,
        ...t
    })
}
const Si = () => A.useContext(fN) ?? !1
  , hN = A.createContext(void 0);
function Gee({value: e, children: t}) {
    return g.jsx(hN.Provider, {
        value: e,
        children: t
    })
}
function Yee(e) {
    const {theme: t, name: n, props: r} = e;
    if (!t || !t.components || !t.components[n])
        return r;
    const i = t.components[n];
    return i.defaultProps ? Vm(i.defaultProps, r, t.components.mergeClassNameAndStyle) : !i.styleOverrides && !i.variants ? Vm(i, r, t.components.mergeClassNameAndStyle) : r
}
function Zee({props: e, name: t}) {
    const n = A.useContext(hN);
    return Yee({
        props: e,
        name: t,
        theme: {
            components: n
        }
    })
}
let KI = 0;
function Qee(e) {
    const [t,n] = A.useState(e)
      , r = e || t;
    return A.useEffect( () => {
        t == null && (KI += 1,
        n(`mui-${KI}`))
    }
    , [t]),
    r
}
const Kee = {
    ...o0
}
  , XI = Kee.useId;
function Gi(e) {
    if (XI !== void 0) {
        const t = XI();
        return e ?? t
    }
    return Qee(e)
}
function Xee(e) {
    const t = zv()
      , n = Gi() || ""
      , {modularCssLayers: r} = e;
    let i = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
    return !r || t !== null ? i = "" : typeof r == "string" ? i = r.replace(/mui(?!\.)/g, i) : i = `@layer ${i};`,
    Cr( () => {
        const o = document.querySelector("head");
        if (!o)
            return;
        const a = o.firstChild;
        if (i) {
            if (a && a.hasAttribute?.("data-mui-layer-order") && a.getAttribute("data-mui-layer-order") === n)
                return;
            const s = document.createElement("style");
            s.setAttribute("data-mui-layer-order", n),
            s.textContent = i,
            o.prepend(s)
        } else
            o.querySelector(`style[data-mui-layer-order="${n}"]`)?.remove()
    }
    , [i, n]),
    i ? g.jsx(eN, {
        styles: i
    }) : null
}
const JI = {};
function e$(e, t, n, r=!1) {
    return A.useMemo( () => {
        const i = e && t[e] || t;
        if (typeof n == "function") {
            const o = n(i)
              , a = e ? {
                ...t,
                [e]: o
            } : o;
            return r ? () => a : a
        }
        return e ? {
            ...t,
            [e]: n
        } : {
            ...t,
            ...n
        }
    }
    , [e, t, n, r])
}
function pN(e) {
    const {children: t, theme: n, themeId: r} = e
      , i = zv(JI)
      , o = vE() || JI
      , a = e$(r, i, n)
      , s = e$(r, o, n, !0)
      , c = (r ? a[r] : a).direction === "rtl"
      , u = Xee(a);
    return g.jsx(qee, {
        theme: s,
        children: g.jsx(_g.Provider, {
            value: a,
            children: g.jsx(Wee, {
                value: c,
                children: g.jsxs(Gee, {
                    value: r ? a[r].components : a.components,
                    children: [u, t]
                })
            })
        })
    })
}
const t$ = {
    theme: void 0
};
function Jee(e) {
    let t, n;
    return function(i) {
        let o = t;
        return (o === void 0 || i.theme !== n) && (t$.theme = i.theme,
        o = rN(e(t$)),
        t = o,
        n = i.theme),
        o
    }
}
const SE = "mode"
  , CE = "color-scheme"
  , ete = "data-color-scheme";
function tte(e) {
    const {defaultMode: t="system", defaultLightColorScheme: n="light", defaultDarkColorScheme: r="dark", modeStorageKey: i=SE, colorSchemeStorageKey: o=CE, attribute: a=ete, colorSchemeNode: s="document.documentElement", nonce: c} = e || {};
    let u = ""
      , f = a;
    if (a === "class" && (f = ".%s"),
    a === "data" && (f = "[data-%s]"),
    f.startsWith(".")) {
        const m = f.substring(1);
        u += `${s}.classList.remove('${m}'.replace('%s', light), '${m}'.replace('%s', dark));
      ${s}.classList.add('${m}'.replace('%s', colorScheme));`
    }
    const h = f.match(/\[([^[\]]+)\]/);
    if (h) {
        const [m,y] = h[1].split("=");
        y || (u += `${s}.removeAttribute('${m}'.replace('%s', light));
      ${s}.removeAttribute('${m}'.replace('%s', dark));`),
        u += `
      ${s}.setAttribute('${m}'.replace('%s', colorScheme), ${y ? `${y}.replace('%s', colorScheme)` : '""'});`
    } else
        u += `${s}.setAttribute('${f}', colorScheme);`;
    return g.jsx("script", {
        suppressHydrationWarning: !0,
        nonce: typeof window > "u" ? c : "",
        dangerouslySetInnerHTML: {
            __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${i}') || '${t}';
  const dark = localStorage.getItem('${o}-dark') || '${r}';
  const light = localStorage.getItem('${o}-light') || '${n}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${u}
  }
} catch(e){}})();`
        }
    }, "mui-color-scheme-init")
}
function nte() {}
const rte = ({key: e, storageWindow: t}) => (!t && typeof window < "u" && (t = window),
{
    get(n) {
        if (typeof window > "u")
            return;
        if (!t)
            return n;
        let r;
        try {
            r = t.localStorage.getItem(e)
        } catch {}
        return r || n
    },
    set: n => {
        if (t)
            try {
                t.localStorage.setItem(e, n)
            } catch {}
    }
    ,
    subscribe: n => {
        if (!t)
            return nte;
        const r = i => {
            const o = i.newValue;
            i.key === e && n(o)
        }
        ;
        return t.addEventListener("storage", r),
        () => {
            t.removeEventListener("storage", r)
        }
    }
});
function Uw() {}
function n$(e) {
    if (typeof window < "u" && typeof window.matchMedia == "function" && e === "system")
        return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
}
function mN(e, t) {
    if (e.mode === "light" || e.mode === "system" && e.systemMode === "light")
        return t("light");
    if (e.mode === "dark" || e.mode === "system" && e.systemMode === "dark")
        return t("dark")
}
function ite(e) {
    return mN(e, t => {
        if (t === "light")
            return e.lightColorScheme;
        if (t === "dark")
            return e.darkColorScheme
    }
    )
}
function ote(e) {
    const {defaultMode: t="light", defaultLightColorScheme: n, defaultDarkColorScheme: r, supportedColorSchemes: i=[], modeStorageKey: o=SE, colorSchemeStorageKey: a=CE, storageWindow: s=typeof window > "u" ? void 0 : window, storageManager: c=rte, noSsr: u=!1} = e
      , f = i.join(",")
      , h = i.length > 1
      , m = A.useMemo( () => c?.({
        key: o,
        storageWindow: s
    }), [c, o, s])
      , y = A.useMemo( () => c?.({
        key: `${a}-light`,
        storageWindow: s
    }), [c, a, s])
      , b = A.useMemo( () => c?.({
        key: `${a}-dark`,
        storageWindow: s
    }), [c, a, s])
      , [v,S] = A.useState( () => {
        const $ = m?.get(t) || t
          , z = y?.get(n) || n
          , O = b?.get(r) || r;
        return {
            mode: $,
            systemMode: n$($),
            lightColorScheme: z,
            darkColorScheme: O
        }
    }
    )
      , [C,w] = A.useState(u || !h);
    A.useEffect( () => {
        w(!0)
    }
    , []);
    const k = ite(v)
      , T = A.useCallback($ => {
        S(z => {
            if ($ === z.mode)
                return z;
            const O = $ ?? t;
            return m?.set(O),
            {
                ...z,
                mode: O,
                systemMode: n$(O)
            }
        }
        )
    }
    , [m, t])
      , E = A.useCallback($ => {
        $ ? typeof $ == "string" ? $ && !f.includes($) ? console.error(`\`${$}\` does not exist in \`theme.colorSchemes\`.`) : S(z => {
            const O = {
                ...z
            };
            return mN(z, I => {
                I === "light" && (y?.set($),
                O.lightColorScheme = $),
                I === "dark" && (b?.set($),
                O.darkColorScheme = $)
            }
            ),
            O
        }
        ) : S(z => {
            const O = {
                ...z
            }
              , I = $.light === null ? n : $.light
              , M = $.dark === null ? r : $.dark;
            return I && (f.includes(I) ? (O.lightColorScheme = I,
            y?.set(I)) : console.error(`\`${I}\` does not exist in \`theme.colorSchemes\`.`)),
            M && (f.includes(M) ? (O.darkColorScheme = M,
            b?.set(M)) : console.error(`\`${M}\` does not exist in \`theme.colorSchemes\`.`)),
            O
        }
        ) : S(z => (y?.set(n),
        b?.set(r),
        {
            ...z,
            lightColorScheme: n,
            darkColorScheme: r
        }))
    }
    , [f, y, b, n, r])
      , P = A.useCallback($ => {
        v.mode === "system" && S(z => {
            const O = $?.matches ? "dark" : "light";
            return z.systemMode === O ? z : {
                ...z,
                systemMode: O
            }
        }
        )
    }
    , [v.mode])
      , D = A.useRef(P);
    return D.current = P,
    A.useEffect( () => {
        if (typeof window.matchMedia != "function" || !h)
            return;
        const $ = (...O) => D.current(...O)
          , z = window.matchMedia("(prefers-color-scheme: dark)");
        return z.addListener($),
        $(z),
        () => {
            z.removeListener($)
        }
    }
    , [h]),
    A.useEffect( () => {
        if (h) {
            const $ = m?.subscribe(I => {
                (!I || ["light", "dark", "system"].includes(I)) && T(I || t)
            }
            ) || Uw
              , z = y?.subscribe(I => {
                (!I || f.match(I)) && E({
                    light: I
                })
            }
            ) || Uw
              , O = b?.subscribe(I => {
                (!I || f.match(I)) && E({
                    dark: I
                })
            }
            ) || Uw;
            return () => {
                $(),
                z(),
                O()
            }
        }
    }
    , [E, T, f, t, s, h, m, y, b]),
    {
        ...v,
        mode: C ? v.mode : void 0,
        systemMode: C ? v.systemMode : void 0,
        colorScheme: C ? k : void 0,
        setMode: T,
        setColorScheme: E
    }
}
const ate = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function ste(e) {
    const {themeId: t, theme: n={}, modeStorageKey: r=SE, colorSchemeStorageKey: i=CE, disableTransitionOnChange: o=!1, defaultColorScheme: a, resolveTheme: s} = e
      , c = {
        allColorSchemes: [],
        colorScheme: void 0,
        darkColorScheme: void 0,
        lightColorScheme: void 0,
        mode: void 0,
        setColorScheme: () => {}
        ,
        setMode: () => {}
        ,
        systemMode: void 0
    }
      , u = A.createContext(void 0)
      , f = () => A.useContext(u) || c
      , h = {}
      , m = {};
    function y(C) {
        const {children: w, theme: k, modeStorageKey: T=r, colorSchemeStorageKey: E=i, disableTransitionOnChange: P=o, storageManager: D, storageWindow: $=typeof window > "u" ? void 0 : window, documentNode: z=typeof document > "u" ? void 0 : document, colorSchemeNode: O=typeof document > "u" ? void 0 : document.documentElement, disableNestedContext: I=!1, disableStyleSheetGeneration: M=!1, defaultMode: B="system", forceThemeRerender: L=!1, noSsr: F} = C
          , j = A.useRef(!1)
          , N = vE()
          , H = A.useContext(u)
          , Z = !!H && !I
          , q = A.useMemo( () => k || (typeof n == "function" ? n() : n), [k])
          , V = q[t]
          , Y = V || q
          , {colorSchemes: W=h, components: te=m, cssVarPrefix: K} = Y
          , ee = Object.keys(W).filter(le => !!W[le]).join(",")
          , re = A.useMemo( () => ee.split(","), [ee])
          , ie = typeof a == "string" ? a : a.light
          , J = typeof a == "string" ? a : a.dark
          , oe = W[ie] && W[J] ? B : W[Y.defaultColorScheme]?.palette?.mode || Y.palette?.mode
          , {mode: we, setMode: xe, systemMode: se, lightColorScheme: de, darkColorScheme: Se, colorScheme: Ce, setColorScheme: Ye} = ote({
            supportedColorSchemes: re,
            defaultLightColorScheme: ie,
            defaultDarkColorScheme: J,
            modeStorageKey: T,
            colorSchemeStorageKey: E,
            defaultMode: oe,
            storageManager: D,
            storageWindow: $,
            noSsr: F
        });
        let ye = we
          , Ke = Ce;
        Z && (ye = H.mode,
        Ke = H.colorScheme);
        let X = Ke || Y.defaultColorScheme;
        Y.vars && !L && (X = Y.defaultColorScheme);
        const ce = A.useMemo( () => {
            const le = Y.generateThemeVars?.() || Y.vars
              , ke = {
                ...Y,
                components: te,
                colorSchemes: W,
                cssVarPrefix: K,
                vars: le
            };
            if (typeof ke.generateSpacing == "function" && (ke.spacing = ke.generateSpacing()),
            X) {
                const He = W[X];
                He && typeof He == "object" && Object.keys(He).forEach(st => {
                    He[st] && typeof He[st] == "object" ? ke[st] = {
                        ...ke[st],
                        ...He[st]
                    } : ke[st] = He[st]
                }
                )
            }
            return s ? s(ke) : ke
        }
        , [Y, X, te, W, K])
          , fe = Y.colorSchemeSelector;
        Cr( () => {
            if (Ke && O && fe && fe !== "media") {
                const le = fe;
                let ke = fe;
                if (le === "class" && (ke = ".%s"),
                le === "data" && (ke = "[data-%s]"),
                le?.startsWith("data-") && !le.includes("%s") && (ke = `[${le}="%s"]`),
                ke.startsWith("."))
                    O.classList.remove(...re.map(He => ke.substring(1).replace("%s", He))),
                    O.classList.add(ke.substring(1).replace("%s", Ke));
                else {
                    const He = ke.replace("%s", Ke).match(/\[([^\]]+)\]/);
                    if (He) {
                        const [st,lt] = He[1].split("=");
                        lt || re.forEach(et => {
                            O.removeAttribute(st.replace(Ke, et))
                        }
                        ),
                        O.setAttribute(st, lt ? lt.replace(/"|'/g, "") : "")
                    } else
                        O.setAttribute(ke, Ke)
                }
            }
        }
        , [Ke, fe, O, re]),
        A.useEffect( () => {
            let le;
            if (P && j.current && z) {
                const ke = z.createElement("style");
                ke.appendChild(z.createTextNode(ate)),
                z.head.appendChild(ke),
                window.getComputedStyle(z.body),
                le = setTimeout( () => {
                    z.head.removeChild(ke)
                }
                , 1)
            }
            return () => {
                clearTimeout(le)
            }
        }
        , [Ke, P, z]),
        A.useEffect( () => (j.current = !0,
        () => {
            j.current = !1
        }
        ), []);
        const Xe = A.useMemo( () => ({
            allColorSchemes: re,
            colorScheme: Ke,
            darkColorScheme: Se,
            lightColorScheme: de,
            mode: ye,
            setColorScheme: Ye,
            setMode: xe,
            systemMode: se
        }), [re, Ke, Se, de, ye, Ye, xe, se, ce.colorSchemeSelector]);
        let Oe = !0;
        (M || Y.cssVariables === !1 || Z && N?.cssVarPrefix === K) && (Oe = !1);
        const Re = g.jsxs(A.Fragment, {
            children: [g.jsx(pN, {
                themeId: V ? t : void 0,
                theme: ce,
                children: w
            }), Oe && g.jsx(GF, {
                styles: ce.generateStyleSheets?.() || []
            })]
        });
        return Z ? Re : g.jsx(u.Provider, {
            value: Xe,
            children: Re
        })
    }
    const b = typeof a == "string" ? a : a.light
      , v = typeof a == "string" ? a : a.dark;
    return {
        CssVarsProvider: y,
        useColorScheme: f,
        getInitColorSchemeScript: C => tte({
            colorSchemeStorageKey: i,
            defaultLightColorScheme: b,
            defaultDarkColorScheme: v,
            modeStorageKey: r,
            ...C
        })
    }
}
function lte(e="") {
    function t(...r) {
        if (!r.length)
            return "";
        const i = r[0];
        return typeof i == "string" && !i.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${i}${t(...r.slice(1))})` : `, ${i}`
    }
    return (r, ...i) => `var(--${e ? `${e}-` : ""}${r}${t(...i)})`
}
const r$ = (e, t, n, r=[]) => {
    let i = e;
    t.forEach( (o, a) => {
        a === t.length - 1 ? Array.isArray(i) ? i[Number(o)] = n : i && typeof i == "object" && (i[o] = n) : i && typeof i == "object" && (i[o] || (i[o] = r.includes(o) ? [] : {}),
        i = i[o])
    }
    )
}
  , cte = (e, t, n) => {
    function r(i, o=[], a=[]) {
        Object.entries(i).forEach( ([s,c]) => {
            (!n || n && !n([...o, s])) && c != null && (typeof c == "object" && Object.keys(c).length > 0 ? r(c, [...o, s], Array.isArray(c) ? [...a, s] : a) : t([...o, s], c, a))
        }
        )
    }
    r(e)
}
  , ute = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some(r => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function Vw(e, t) {
    const {prefix: n, shouldSkipGeneratingVar: r} = t || {}
      , i = {}
      , o = {}
      , a = {};
    return cte(e, (s, c, u) => {
        if ((typeof c == "string" || typeof c == "number") && (!r || !r(s, c))) {
            const f = `--${n ? `${n}-` : ""}${s.join("-")}`
              , h = ute(s, c);
            Object.assign(i, {
                [f]: h
            }),
            r$(o, s, `var(${f})`, u),
            r$(a, s, `var(${f}, ${h})`, u)
        }
    }
    , s => s[0] === "vars"),
    {
        css: i,
        vars: o,
        varsWithDefaults: a
    }
}
function dte(e, t={}) {
    const {getSelector: n=C, disableCssColorScheme: r, colorSchemeSelector: i, enableContrastVars: o} = t
      , {colorSchemes: a={}, components: s, defaultColorScheme: c="light", ...u} = e
      , {vars: f, css: h, varsWithDefaults: m} = Vw(u, t);
    let y = m;
    const b = {}
      , {[c]: v, ...S} = a;
    if (Object.entries(S || {}).forEach( ([T,E]) => {
        const {vars: P, css: D, varsWithDefaults: $} = Vw(E, t);
        y = ci(y, $),
        b[T] = {
            css: D,
            vars: P
        }
    }
    ),
    v) {
        const {css: T, vars: E, varsWithDefaults: P} = Vw(v, t);
        y = ci(y, P),
        b[c] = {
            css: T,
            vars: E
        }
    }
    function C(T, E) {
        let P = i;
        if (i === "class" && (P = ".%s"),
        i === "data" && (P = "[data-%s]"),
        i?.startsWith("data-") && !i.includes("%s") && (P = `[${i}="%s"]`),
        T) {
            if (P === "media")
                return e.defaultColorScheme === T ? ":root" : {
                    [`@media (prefers-color-scheme: ${a[T]?.palette?.mode || T})`]: {
                        ":root": E
                    }
                };
            if (P)
                return e.defaultColorScheme === T ? `:root, ${P.replace("%s", String(T))}` : P.replace("%s", String(T))
        }
        return ":root"
    }
    return {
        vars: y,
        generateThemeVars: () => {
            let T = {
                ...f
            };
            return Object.entries(b).forEach( ([,{vars: E}]) => {
                T = ci(T, E)
            }
            ),
            T
        }
        ,
        generateStyleSheets: () => {
            const T = []
              , E = e.defaultColorScheme || "light";
            function P(z, O) {
                Object.keys(O).length && T.push(typeof z == "string" ? {
                    [z]: {
                        ...O
                    }
                } : z)
            }
            P(n(void 0, {
                ...h
            }), h);
            const {[E]: D, ...$} = b;
            if (D) {
                const {css: z} = D
                  , O = a[E]?.palette?.mode
                  , I = !r && O ? {
                    colorScheme: O,
                    ...z
                } : {
                    ...z
                };
                P(n(E, {
                    ...I
                }), I)
            }
            return Object.entries($).forEach( ([z,{css: O}]) => {
                const I = a[z]?.palette?.mode
                  , M = !r && I ? {
                    colorScheme: I,
                    ...O
                } : {
                    ...O
                };
                P(n(z, {
                    ...M
                }), M)
            }
            ),
            o && T.push({
                ":root": {
                    "--__l-threshold": "0.7",
                    "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
                    "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
                }
            }),
            T
        }
    }
}
function fte(e) {
    return function(n) {
        return e === "media" ? `@media (prefers-color-scheme: ${n})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&"
    }
}
function tt(e, t, n=void 0) {
    const r = {};
    for (const i in e) {
        const o = e[i];
        let a = ""
          , s = !0;
        for (let c = 0; c < o.length; c += 1) {
            const u = o[c];
            u && (a += (s === !0 ? "" : " ") + t(u),
            s = !1,
            n && n[u] && (a += " " + n[u]))
        }
        r[i] = a
    }
    return r
}
function fm(e, t) {
    return A.isValidElement(e) && t.indexOf(e.type.muiName ?? e.type?._payload?.value?.muiName) !== -1
}
const hte = (e, t) => e.filter(n => t.includes(n))
  , fh = (e, t, n) => {
    const r = e.keys[0];
    Array.isArray(t) ? t.forEach( (i, o) => {
        n( (a, s) => {
            o <= e.keys.length - 1 && (o === 0 ? Object.assign(a, s) : a[e.up(e.keys[o])] = s)
        }
        , i)
    }
    ) : t && typeof t == "object" ? (Object.keys(t).length > e.keys.length ? e.keys : hte(e.keys, Object.keys(t))).forEach(o => {
        if (e.keys.includes(o)) {
            const a = t[o];
            a !== void 0 && n( (s, c) => {
                r === o ? Object.assign(s, c) : s[e.up(o)] = c
            }
            , a)
        }
    }
    ) : (typeof t == "number" || typeof t == "string") && n( (i, o) => {
        Object.assign(i, o)
    }
    , t)
}
;
function d0(e) {
    return `--Grid-${e}Spacing`
}
function Hv(e) {
    return `--Grid-parent-${e}Spacing`
}
const i$ = "--Grid-columns"
  , xf = "--Grid-parent-columns"
  , pte = ({theme: e, ownerState: t}) => {
    const n = {};
    return fh(e.breakpoints, t.size, (r, i) => {
        let o = {};
        i === "grow" && (o = {
            flexBasis: 0,
            flexGrow: 1,
            maxWidth: "100%"
        }),
        i === "auto" && (o = {
            flexBasis: "auto",
            flexGrow: 0,
            flexShrink: 0,
            maxWidth: "none",
            width: "auto"
        }),
        typeof i == "number" && (o = {
            flexGrow: 0,
            flexBasis: "auto",
            width: `calc(100% * ${i} / var(${xf}) - (var(${xf}) - ${i}) * (var(${Hv("column")}) / var(${xf})))`
        }),
        r(n, o)
    }
    ),
    n
}
  , mte = ({theme: e, ownerState: t}) => {
    const n = {};
    return fh(e.breakpoints, t.offset, (r, i) => {
        let o = {};
        i === "auto" && (o = {
            marginLeft: "auto"
        }),
        typeof i == "number" && (o = {
            marginLeft: i === 0 ? "0px" : `calc(100% * ${i} / var(${xf}) + var(${Hv("column")}) * ${i} / var(${xf}))`
        }),
        r(n, o)
    }
    ),
    n
}
  , gte = ({theme: e, ownerState: t}) => {
    if (!t.container)
        return {};
    const n = {
        [i$]: 12
    };
    return fh(e.breakpoints, t.columns, (r, i) => {
        const o = i ?? 12;
        r(n, {
            [i$]: o,
            "> *": {
                [xf]: o
            }
        })
    }
    ),
    n
}
  , yte = ({theme: e, ownerState: t}) => {
    if (!t.container)
        return {};
    const n = {};
    return fh(e.breakpoints, t.rowSpacing, (r, i) => {
        const o = typeof i == "string" ? i : e.spacing?.(i);
        r(n, {
            [d0("row")]: o,
            "> *": {
                [Hv("row")]: o
            }
        })
    }
    ),
    n
}
  , bte = ({theme: e, ownerState: t}) => {
    if (!t.container)
        return {};
    const n = {};
    return fh(e.breakpoints, t.columnSpacing, (r, i) => {
        const o = typeof i == "string" ? i : e.spacing?.(i);
        r(n, {
            [d0("column")]: o,
            "> *": {
                [Hv("column")]: o
            }
        })
    }
    ),
    n
}
  , xte = ({theme: e, ownerState: t}) => {
    if (!t.container)
        return {};
    const n = {};
    return fh(e.breakpoints, t.direction, (r, i) => {
        r(n, {
            flexDirection: i
        })
    }
    ),
    n
}
  , vte = ({ownerState: e}) => ({
    minWidth: 0,
    boxSizing: "border-box",
    ...e.container && {
        display: "flex",
        flexWrap: "wrap",
        ...e.wrap && e.wrap !== "wrap" && {
            flexWrap: e.wrap
        },
        gap: `var(${d0("row")}) var(${d0("column")})`
    }
})
  , Ste = e => {
    const t = [];
    return Object.entries(e).forEach( ([n,r]) => {
        r !== !1 && r !== void 0 && t.push(`grid-${n}-${String(r)}`)
    }
    ),
    t
}
  , Cte = (e, t="xs") => {
    function n(r) {
        return r === void 0 ? !1 : typeof r == "string" && !Number.isNaN(Number(r)) || typeof r == "number" && r > 0
    }
    if (n(e))
        return [`spacing-${t}-${String(e)}`];
    if (typeof e == "object" && !Array.isArray(e)) {
        const r = [];
        return Object.entries(e).forEach( ([i,o]) => {
            n(o) && r.push(`spacing-${i}-${String(o)}`)
        }
        ),
        r
    }
    return []
}
  , wte = e => e === void 0 ? [] : typeof e == "object" ? Object.entries(e).map( ([t,n]) => `direction-${t}-${n}`) : [`direction-xs-${String(e)}`];
function kte(e, t) {
    e.item !== void 0 && delete e.item,
    e.zeroMinWidth !== void 0 && delete e.zeroMinWidth,
    t.keys.forEach(n => {
        e[n] !== void 0 && delete e[n]
    }
    )
}
const Tte = Mg()
  , _te = aN("div", {
    name: "MuiGrid",
    slot: "Root"
});
function Ete(e) {
    return bE({
        props: e,
        name: "MuiGrid",
        defaultTheme: Tte
    })
}
function Ate(e={}) {
    const {createStyledComponent: t=_te, useThemeProps: n=Ete, useTheme: r=Pg, componentName: i="MuiGrid"} = e
      , o = (u, f) => {
        const {container: h, direction: m, spacing: y, wrap: b, size: v} = u
          , S = {
            root: ["root", h && "container", b !== "wrap" && `wrap-xs-${String(b)}`, ...wte(m), ...Ste(v), ...h ? Cte(y, f.breakpoints.keys[0]) : []]
        };
        return tt(S, C => rt(i, C), {})
    }
    ;
    function a(u, f, h= () => !0) {
        const m = {};
        return u === null || (Array.isArray(u) ? u.forEach( (y, b) => {
            y !== null && h(y) && f.keys[b] && (m[f.keys[b]] = y)
        }
        ) : typeof u == "object" ? Object.keys(u).forEach(y => {
            const b = u[y];
            b != null && h(b) && (m[y] = b)
        }
        ) : m[f.keys[0]] = u),
        m
    }
    const s = t(gte, bte, yte, pte, xte, vte, mte)
      , c = A.forwardRef(function(f, h) {
        const m = r()
          , y = n(f)
          , b = Fv(y);
        kte(b, m.breakpoints);
        const {className: v, children: S, columns: C=12, container: w=!1, component: k="div", direction: T="row", wrap: E="wrap", size: P={}, offset: D={}, spacing: $=0, rowSpacing: z=$, columnSpacing: O=$, unstable_level: I=0, ...M} = b
          , B = a(P, m.breakpoints, V => V !== !1)
          , L = a(D, m.breakpoints)
          , F = f.columns ?? (I ? void 0 : C)
          , j = f.spacing ?? (I ? void 0 : $)
          , N = f.rowSpacing ?? f.spacing ?? (I ? void 0 : z)
          , H = f.columnSpacing ?? f.spacing ?? (I ? void 0 : O)
          , Z = {
            ...b,
            level: I,
            columns: F,
            container: w,
            direction: T,
            wrap: E,
            spacing: j,
            rowSpacing: N,
            columnSpacing: H,
            size: B,
            offset: L
        }
          , q = o(Z, m);
        return g.jsx(s, {
            ref: h,
            as: k,
            ownerState: Z,
            className: Ne(q.root, v),
            ...M,
            children: A.Children.map(S, V => A.isValidElement(V) && fm(V, ["Grid"]) && w && V.props.container ? A.cloneElement(V, {
                unstable_level: V.props?.unstable_level ?? I + 1
            }) : V)
        })
    });
    return c.muiName = "Grid",
    c
}
const Mte = Mg()
  , Pte = aN("div", {
    name: "MuiStack",
    slot: "Root"
});
function Rte(e) {
    return bE({
        props: e,
        name: "MuiStack",
        defaultTheme: Mte
    })
}
function Dte(e, t) {
    const n = A.Children.toArray(e).filter(Boolean);
    return n.reduce( (r, i, o) => (r.push(i),
    o < n.length - 1 && r.push(A.cloneElement(t, {
        key: `separator-${o}`
    })),
    r), [])
}
const Ote = e => ({
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
})[e]
  , Ite = ({ownerState: e, theme: t}) => {
    let n = {
        display: "flex",
        flexDirection: "column",
        ...Qa({
            theme: t
        }, Fw({
            values: e.direction,
            breakpoints: t.breakpoints.values
        }), r => ({
            flexDirection: r
        }))
    };
    if (e.spacing) {
        const r = Ov(t)
          , i = Object.keys(t.breakpoints.values).reduce( (c, u) => ((typeof e.spacing == "object" && e.spacing[u] != null || typeof e.direction == "object" && e.direction[u] != null) && (c[u] = !0),
        c), {})
          , o = Fw({
            values: e.direction,
            base: i
        })
          , a = Fw({
            values: e.spacing,
            base: i
        });
        typeof o == "object" && Object.keys(o).forEach( (c, u, f) => {
            if (!o[c]) {
                const m = u > 0 ? o[f[u - 1]] : "column";
                o[c] = m
            }
        }
        ),
        n = ci(n, Qa({
            theme: t
        }, a, (c, u) => e.useFlexGap ? {
            gap: ju(r, c)
        } : {
            "& > :not(style):not(style)": {
                margin: 0
            },
            "& > :not(style) ~ :not(style)": {
                [`margin${Ote(u ? o[u] : e.direction)}`]: ju(r, c)
            }
        }))
    }
    return n = IJ(t.breakpoints, n),
    n
}
;
function $te(e={}) {
    const {createStyledComponent: t=Pte, useThemeProps: n=Rte, componentName: r="MuiStack"} = e
      , i = () => tt({
        root: ["root"]
    }, c => rt(r, c), {})
      , o = t(Ite);
    return A.forwardRef(function(c, u) {
        const f = n(c)
          , h = Fv(f)
          , {component: m="div", direction: y="column", spacing: b=0, divider: v, children: S, className: C, useFlexGap: w=!1, ...k} = h
          , T = {
            direction: y,
            spacing: b,
            useFlexGap: w
        }
          , E = i();
        return g.jsx(o, {
            as: m,
            ownerState: T,
            ref: u,
            className: Ne(E.root, C),
            ...k,
            children: v ? Dte(S, v) : S
        })
    })
}
function gN() {
    return {
        text: {
            primary: "rgba(0, 0, 0, 0.87)",
            secondary: "rgba(0, 0, 0, 0.6)",
            disabled: "rgba(0, 0, 0, 0.38)"
        },
        divider: "rgba(0, 0, 0, 0.12)",
        background: {
            paper: zm.white,
            default: zm.white
        },
        action: {
            active: "rgba(0, 0, 0, 0.54)",
            hover: "rgba(0, 0, 0, 0.04)",
            hoverOpacity: .04,
            selected: "rgba(0, 0, 0, 0.08)",
            selectedOpacity: .08,
            disabled: "rgba(0, 0, 0, 0.26)",
            disabledBackground: "rgba(0, 0, 0, 0.12)",
            disabledOpacity: .38,
            focus: "rgba(0, 0, 0, 0.12)",
            focusOpacity: .12,
            activatedOpacity: .12
        }
    }
}
const yN = gN();
function bN() {
    return {
        text: {
            primary: zm.white,
            secondary: "rgba(255, 255, 255, 0.7)",
            disabled: "rgba(255, 255, 255, 0.5)",
            icon: "rgba(255, 255, 255, 0.5)"
        },
        divider: "rgba(255, 255, 255, 0.12)",
        background: {
            paper: "#121212",
            default: "#121212"
        },
        action: {
            active: zm.white,
            hover: "rgba(255, 255, 255, 0.08)",
            hoverOpacity: .08,
            selected: "rgba(255, 255, 255, 0.16)",
            selectedOpacity: .16,
            disabled: "rgba(255, 255, 255, 0.3)",
            disabledBackground: "rgba(255, 255, 255, 0.12)",
            disabledOpacity: .38,
            focus: "rgba(255, 255, 255, 0.12)",
            focusOpacity: .12,
            activatedOpacity: .24
        }
    }
}
const j2 = bN();
function o$(e, t, n, r) {
    const i = r.light || r
      , o = r.dark || r * 1.5;
    e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = Vv(e.main, i) : t === "dark" && (e.dark = Uv(e.main, o)))
}
function a$(e, t, n, r, i) {
    const o = i.light || i
      , a = i.dark || i * 1.5;
    t[n] || (t.hasOwnProperty(r) ? t[n] = t[r] : n === "light" ? t.light = `color-mix(in ${e}, ${t.main}, #fff ${(o * 100).toFixed(0)}%)` : n === "dark" && (t.dark = `color-mix(in ${e}, ${t.main}, #000 ${(a * 100).toFixed(0)}%)`))
}
function Lte(e="light") {
    return e === "dark" ? {
        main: Gd[200],
        light: Gd[50],
        dark: Gd[400]
    } : {
        main: Gd[700],
        light: Gd[400],
        dark: Gd[800]
    }
}
function jte(e="light") {
    return e === "dark" ? {
        main: Wd[200],
        light: Wd[50],
        dark: Wd[400]
    } : {
        main: Wd[500],
        light: Wd[300],
        dark: Wd[700]
    }
}
function Bte(e="light") {
    return e === "dark" ? {
        main: qd[500],
        light: qd[300],
        dark: qd[700]
    } : {
        main: qd[700],
        light: qd[400],
        dark: qd[800]
    }
}
function zte(e="light") {
    return e === "dark" ? {
        main: Yd[400],
        light: Yd[300],
        dark: Yd[700]
    } : {
        main: Yd[700],
        light: Yd[500],
        dark: Yd[900]
    }
}
function Fte(e="light") {
    return e === "dark" ? {
        main: Zd[400],
        light: Zd[300],
        dark: Zd[700]
    } : {
        main: Zd[800],
        light: Zd[500],
        dark: Zd[900]
    }
}
function Nte(e="light") {
    return e === "dark" ? {
        main: gp[400],
        light: gp[300],
        dark: gp[700]
    } : {
        main: "#ed6c02",
        light: gp[500],
        dark: gp[900]
    }
}
function Ute(e) {
    return `oklch(from ${e} var(--__l) 0 h / var(--__a))`
}
function wE(e) {
    const {mode: t="light", contrastThreshold: n=3, tonalOffset: r=.2, colorSpace: i, ...o} = e
      , a = e.primary || Lte(t)
      , s = e.secondary || jte(t)
      , c = e.error || Bte(t)
      , u = e.info || zte(t)
      , f = e.success || Fte(t)
      , h = e.warning || Nte(t);
    function m(S) {
        return i ? Ute(S) : Nee(S, j2.text.primary) >= n ? j2.text.primary : yN.text.primary
    }
    const y = ({color: S, name: C, mainShade: w=500, lightShade: k=300, darkShade: T=700}) => {
        if (S = {
            ...S
        },
        !S.main && S[w] && (S.main = S[w]),
        !S.hasOwnProperty("main"))
            throw new Error(Cl(11, C ? ` (${C})` : "", w));
        if (typeof S.main != "string")
            throw new Error(Cl(12, C ? ` (${C})` : "", JSON.stringify(S.main)));
        return i ? (a$(i, S, "light", k, r),
        a$(i, S, "dark", T, r)) : (o$(S, "light", k, r),
        o$(S, "dark", T, r)),
        S.contrastText || (S.contrastText = m(S.main)),
        S
    }
    ;
    let b;
    return t === "light" ? b = gN() : t === "dark" && (b = bN()),
    ci({
        common: {
            ...zm
        },
        mode: t,
        primary: y({
            color: a,
            name: "primary"
        }),
        secondary: y({
            color: s,
            name: "secondary",
            mainShade: "A400",
            lightShade: "A200",
            darkShade: "A700"
        }),
        error: y({
            color: c,
            name: "error"
        }),
        warning: y({
            color: h,
            name: "warning"
        }),
        info: y({
            color: u,
            name: "info"
        }),
        success: y({
            color: f,
            name: "success"
        }),
        grey: SX,
        contrastThreshold: n,
        getContrastText: m,
        augmentColor: y,
        tonalOffset: r,
        ...b
    }, o)
}
function Vte(e) {
    const t = {};
    return Object.entries(e).forEach(r => {
        const [i,o] = r;
        typeof o == "object" && (t[i] = `${o.fontStyle ? `${o.fontStyle} ` : ""}${o.fontVariant ? `${o.fontVariant} ` : ""}${o.fontWeight ? `${o.fontWeight} ` : ""}${o.fontStretch ? `${o.fontStretch} ` : ""}${o.fontSize || ""}${o.lineHeight ? `/${o.lineHeight} ` : ""}${o.fontFamily || ""}`)
    }
    ),
    t
}
function Hte(e, t) {
    return {
        toolbar: {
            minHeight: 56,
            [e.up("xs")]: {
                "@media (orientation: landscape)": {
                    minHeight: 48
                }
            },
            [e.up("sm")]: {
                minHeight: 64
            }
        },
        ...t
    }
}
function qte(e) {
    return Math.round(e * 1e5) / 1e5
}
const s$ = {
    textTransform: "uppercase"
}
  , l$ = '"Roboto", "Helvetica", "Arial", sans-serif';
function xN(e, t) {
    const {fontFamily: n=l$, fontSize: r=14, fontWeightLight: i=300, fontWeightRegular: o=400, fontWeightMedium: a=500, fontWeightBold: s=700, htmlFontSize: c=16, allVariants: u, pxToRem: f, ...h} = typeof t == "function" ? t(e) : t
      , m = r / 14
      , y = f || (S => `${S / c * m}rem`)
      , b = (S, C, w, k, T) => ({
        fontFamily: n,
        fontWeight: S,
        fontSize: y(C),
        lineHeight: w,
        ...n === l$ ? {
            letterSpacing: `${qte(k / C)}em`
        } : {},
        ...T,
        ...u
    })
      , v = {
        h1: b(i, 96, 1.167, -1.5),
        h2: b(i, 60, 1.2, -.5),
        h3: b(o, 48, 1.167, 0),
        h4: b(o, 34, 1.235, .25),
        h5: b(o, 24, 1.334, 0),
        h6: b(a, 20, 1.6, .15),
        subtitle1: b(o, 16, 1.75, .15),
        subtitle2: b(a, 14, 1.57, .1),
        body1: b(o, 16, 1.5, .15),
        body2: b(o, 14, 1.43, .15),
        button: b(a, 14, 1.75, .4, s$),
        caption: b(o, 12, 1.66, .4),
        overline: b(o, 12, 2.66, 1, s$),
        inherit: {
            fontFamily: "inherit",
            fontWeight: "inherit",
            fontSize: "inherit",
            lineHeight: "inherit",
            letterSpacing: "inherit"
        }
    };
    return ci({
        htmlFontSize: c,
        pxToRem: y,
        fontFamily: n,
        fontSize: r,
        fontWeightLight: i,
        fontWeightRegular: o,
        fontWeightMedium: a,
        fontWeightBold: s,
        ...v
    }, h, {
        clone: !1
    })
}
const Wte = .2
  , Gte = .14
  , Yte = .12;
function yr(...e) {
    return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${Wte})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${Gte})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${Yte})`].join(",")
}
const Zte = ["none", yr(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), yr(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), yr(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), yr(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), yr(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), yr(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), yr(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), yr(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), yr(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), yr(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), yr(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), yr(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), yr(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), yr(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), yr(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), yr(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), yr(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), yr(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), yr(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), yr(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), yr(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), yr(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), yr(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), yr(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)]
  , Qte = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}
  , vN = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195
};
function c$(e) {
    return `${Math.round(e)}ms`
}
function Kte(e) {
    if (!e)
        return 0;
    const t = e / 36;
    return Math.min(Math.round((4 + 15 * t ** .25 + t / 5) * 10), 3e3)
}
function Xte(e) {
    const t = {
        ...Qte,
        ...e.easing
    }
      , n = {
        ...vN,
        ...e.duration
    };
    return {
        getAutoHeightDuration: Kte,
        create: (i=["all"], o={}) => {
            const {duration: a=n.standard, easing: s=t.easeInOut, delay: c=0, ...u} = o;
            return (Array.isArray(i) ? i : [i]).map(f => `${f} ${typeof a == "string" ? a : c$(a)} ${s} ${typeof c == "string" ? c : c$(c)}`).join(",")
        }
        ,
        ...e,
        easing: t,
        duration: n
    }
}
const Jte = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
};
function ene(e) {
    return vs(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e)
}
function SN(e={}) {
    const t = {
        ...e
    };
    function n(r) {
        const i = Object.entries(r);
        for (let o = 0; o < i.length; o++) {
            const [a,s] = i[o];
            !ene(s) || a.startsWith("unstable_") ? delete r[a] : vs(s) && (r[a] = {
                ...s
            },
            n(r[a]))
        }
    }
    return n(t),
    `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`
}
function u$(e) {
    return typeof e == "number" ? `${(e * 100).toFixed(0)}%` : `calc((${e}) * 100%)`
}
const tne = e => {
    if (!Number.isNaN(+e))
        return +e;
    const t = e.match(/\d*\.?\d+/g);
    if (!t)
        return 0;
    let n = 0;
    for (let r = 0; r < t.length; r += 1)
        n += +t[r];
    return n
}
;
function nne(e) {
    Object.assign(e, {
        alpha(t, n) {
            const r = this || e;
            return r.colorSpace ? `oklch(from ${t} l c h / ${typeof n == "string" ? `calc(${n})` : n})` : r.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof n == "string" ? `calc(${n})` : n})` : Ts(t, tne(n))
        },
        lighten(t, n) {
            const r = this || e;
            return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #fff ${u$(n)})` : Vv(t, n)
        },
        darken(t, n) {
            const r = this || e;
            return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #000 ${u$(n)})` : Uv(t, n)
        }
    })
}
function B2(e={}, ...t) {
    const {breakpoints: n, mixins: r={}, spacing: i, palette: o={}, transitions: a={}, typography: s={}, shape: c, colorSpace: u, ...f} = e;
    if (e.vars && e.generateThemeVars === void 0)
        throw new Error(Cl(20));
    const h = wE({
        ...o,
        colorSpace: u
    })
      , m = Mg(e);
    let y = ci(m, {
        mixins: Hte(m.breakpoints, r),
        palette: h,
        shadows: Zte.slice(),
        typography: xN(h, s),
        transitions: Xte(a),
        zIndex: {
            ...Jte
        }
    });
    return y = ci(y, f),
    y = t.reduce( (b, v) => ci(b, v), y),
    y.unstable_sxConfig = {
        ...Ag,
        ...f?.unstable_sxConfig
    },
    y.unstable_sx = function(v) {
        return yc({
            sx: v,
            theme: this
        })
    }
    ,
    y.toRuntimeSource = SN,
    nne(y),
    y
}
function z2(e) {
    let t;
    return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2,
    Math.round(t * 10) / 1e3
}
const rne = [...Array(25)].map( (e, t) => {
    if (t === 0)
        return "none";
    const n = z2(t);
    return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`
}
);
function CN(e) {
    return {
        inputPlaceholder: e === "dark" ? .5 : .42,
        inputUnderline: e === "dark" ? .7 : .42,
        switchTrackDisabled: e === "dark" ? .2 : .12,
        switchTrack: e === "dark" ? .3 : .38
    }
}
function wN(e) {
    return e === "dark" ? rne : []
}
function ine(e) {
    const {palette: t={
        mode: "light"
    }, opacity: n, overlays: r, colorSpace: i, ...o} = e
      , a = wE({
        ...t,
        colorSpace: i
    });
    return {
        palette: a,
        opacity: {
            ...CN(a.mode),
            ...n
        },
        overlays: r || wN(a.mode),
        ...o
    }
}
function one(e) {
    return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/)
}
const ane = e => [...[...Array(25)].map( (t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`]
  , sne = e => (t, n) => {
    const r = e.rootSelector || ":root"
      , i = e.colorSchemeSelector;
    let o = i;
    if (i === "class" && (o = ".%s"),
    i === "data" && (o = "[data-%s]"),
    i?.startsWith("data-") && !i.includes("%s") && (o = `[${i}="%s"]`),
    e.defaultColorScheme === t) {
        if (t === "dark") {
            const a = {};
            return ane(e.cssVarPrefix).forEach(s => {
                a[s] = n[s],
                delete n[s]
            }
            ),
            o === "media" ? {
                [r]: n,
                "@media (prefers-color-scheme: dark)": {
                    [r]: a
                }
            } : o ? {
                [o.replace("%s", t)]: a,
                [`${r}, ${o.replace("%s", t)}`]: n
            } : {
                [r]: {
                    ...n,
                    ...a
                }
            }
        }
        if (o && o !== "media")
            return `${r}, ${o.replace("%s", String(t))}`
    } else if (t) {
        if (o === "media")
            return {
                [`@media (prefers-color-scheme: ${String(t)})`]: {
                    [r]: n
                }
            };
        if (o)
            return o.replace("%s", String(t))
    }
    return r
}
;
function lne(e, t) {
    t.forEach(n => {
        e[n] || (e[n] = {})
    }
    )
}
function Ve(e, t, n) {
    !e[t] && n && (e[t] = n)
}
function Kp(e) {
    return typeof e != "string" || !e.startsWith("hsl") ? e : uN(e)
}
function il(e, t) {
    `${t}Channel`in e || (e[`${t}Channel`] = Qp(Kp(e[t])))
}
function cne(e) {
    return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px"
}
const us = e => {
    try {
        return e()
    } catch {}
}
  , une = (e="mui") => lte(e);
function Hw(e, t, n, r, i) {
    if (!n)
        return;
    n = n === !0 ? {} : n;
    const o = i === "dark" ? "dark" : "light";
    if (!r) {
        t[i] = ine({
            ...n,
            palette: {
                mode: o,
                ...n?.palette
            },
            colorSpace: e
        });
        return
    }
    const {palette: a, ...s} = B2({
        ...r,
        palette: {
            mode: o,
            ...n?.palette
        },
        colorSpace: e
    });
    return t[i] = {
        ...n,
        palette: a,
        opacity: {
            ...CN(o),
            ...n?.opacity
        },
        overlays: n?.overlays || wN(o)
    },
    s
}
function dne(e={}, ...t) {
    const {colorSchemes: n={
        light: !0
    }, defaultColorScheme: r, disableCssColorScheme: i=!1, cssVarPrefix: o="mui", nativeColor: a=!1, shouldSkipGeneratingVar: s=one, colorSchemeSelector: c=n.light && n.dark ? "media" : void 0, rootSelector: u=":root", ...f} = e
      , h = Object.keys(n)[0]
      , m = r || (n.light && h !== "light" ? "light" : h)
      , y = une(o)
      , {[m]: b, light: v, dark: S, ...C} = n
      , w = {
        ...C
    };
    let k = b;
    if ((m === "dark" && !("dark"in n) || m === "light" && !("light"in n)) && (k = !0),
    !k)
        throw new Error(Cl(21, m));
    let T;
    a && (T = "oklch");
    const E = Hw(T, w, k, f, m);
    v && !w.light && Hw(T, w, v, void 0, "light"),
    S && !w.dark && Hw(T, w, S, void 0, "dark");
    let P = {
        defaultColorScheme: m,
        ...E,
        cssVarPrefix: o,
        colorSchemeSelector: c,
        rootSelector: u,
        getCssVar: y,
        colorSchemes: w,
        font: {
            ...Vte(E.typography),
            ...E.font
        },
        spacing: cne(f.spacing)
    };
    Object.keys(P.colorSchemes).forEach(I => {
        const M = P.colorSchemes[I].palette
          , B = F => {
            const j = F.split("-")
              , N = j[1]
              , H = j[2];
            return y(F, M[N][H])
        }
        ;
        M.mode === "light" && (Ve(M.common, "background", "#fff"),
        Ve(M.common, "onBackground", "#000")),
        M.mode === "dark" && (Ve(M.common, "background", "#000"),
        Ve(M.common, "onBackground", "#fff"));
        function L(F, j, N) {
            if (T) {
                let H;
                return F === nu && (H = `transparent ${((1 - N) * 100).toFixed(0)}%`),
                F === Yn && (H = `#000 ${(N * 100).toFixed(0)}%`),
                F === Zn && (H = `#fff ${(N * 100).toFixed(0)}%`),
                `color-mix(in ${T}, ${j}, ${H})`
            }
            return F(j, N)
        }
        if (lne(M, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]),
        M.mode === "light") {
            Ve(M.Alert, "errorColor", L(Yn, M.error.light, .6)),
            Ve(M.Alert, "infoColor", L(Yn, M.info.light, .6)),
            Ve(M.Alert, "successColor", L(Yn, M.success.light, .6)),
            Ve(M.Alert, "warningColor", L(Yn, M.warning.light, .6)),
            Ve(M.Alert, "errorFilledBg", B("palette-error-main")),
            Ve(M.Alert, "infoFilledBg", B("palette-info-main")),
            Ve(M.Alert, "successFilledBg", B("palette-success-main")),
            Ve(M.Alert, "warningFilledBg", B("palette-warning-main")),
            Ve(M.Alert, "errorFilledColor", us( () => M.getContrastText(M.error.main))),
            Ve(M.Alert, "infoFilledColor", us( () => M.getContrastText(M.info.main))),
            Ve(M.Alert, "successFilledColor", us( () => M.getContrastText(M.success.main))),
            Ve(M.Alert, "warningFilledColor", us( () => M.getContrastText(M.warning.main))),
            Ve(M.Alert, "errorStandardBg", L(Zn, M.error.light, .9)),
            Ve(M.Alert, "infoStandardBg", L(Zn, M.info.light, .9)),
            Ve(M.Alert, "successStandardBg", L(Zn, M.success.light, .9)),
            Ve(M.Alert, "warningStandardBg", L(Zn, M.warning.light, .9)),
            Ve(M.Alert, "errorIconColor", B("palette-error-main")),
            Ve(M.Alert, "infoIconColor", B("palette-info-main")),
            Ve(M.Alert, "successIconColor", B("palette-success-main")),
            Ve(M.Alert, "warningIconColor", B("palette-warning-main")),
            Ve(M.AppBar, "defaultBg", B("palette-grey-100")),
            Ve(M.Avatar, "defaultBg", B("palette-grey-400")),
            Ve(M.Button, "inheritContainedBg", B("palette-grey-300")),
            Ve(M.Button, "inheritContainedHoverBg", B("palette-grey-A100")),
            Ve(M.Chip, "defaultBorder", B("palette-grey-400")),
            Ve(M.Chip, "defaultAvatarColor", B("palette-grey-700")),
            Ve(M.Chip, "defaultIconColor", B("palette-grey-700")),
            Ve(M.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"),
            Ve(M.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"),
            Ve(M.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"),
            Ve(M.LinearProgress, "primaryBg", L(Zn, M.primary.main, .62)),
            Ve(M.LinearProgress, "secondaryBg", L(Zn, M.secondary.main, .62)),
            Ve(M.LinearProgress, "errorBg", L(Zn, M.error.main, .62)),
            Ve(M.LinearProgress, "infoBg", L(Zn, M.info.main, .62)),
            Ve(M.LinearProgress, "successBg", L(Zn, M.success.main, .62)),
            Ve(M.LinearProgress, "warningBg", L(Zn, M.warning.main, .62)),
            Ve(M.Skeleton, "bg", T ? L(nu, M.text.primary, .11) : `rgba(${B("palette-text-primaryChannel")} / 0.11)`),
            Ve(M.Slider, "primaryTrack", L(Zn, M.primary.main, .62)),
            Ve(M.Slider, "secondaryTrack", L(Zn, M.secondary.main, .62)),
            Ve(M.Slider, "errorTrack", L(Zn, M.error.main, .62)),
            Ve(M.Slider, "infoTrack", L(Zn, M.info.main, .62)),
            Ve(M.Slider, "successTrack", L(Zn, M.success.main, .62)),
            Ve(M.Slider, "warningTrack", L(Zn, M.warning.main, .62));
            const F = T ? L(Yn, M.background.default, .6825) : Pb(M.background.default, .8);
            Ve(M.SnackbarContent, "bg", F),
            Ve(M.SnackbarContent, "color", us( () => T ? j2.text.primary : M.getContrastText(F))),
            Ve(M.SpeedDialAction, "fabHoverBg", Pb(M.background.paper, .15)),
            Ve(M.StepConnector, "border", B("palette-grey-400")),
            Ve(M.StepContent, "border", B("palette-grey-400")),
            Ve(M.Switch, "defaultColor", B("palette-common-white")),
            Ve(M.Switch, "defaultDisabledColor", B("palette-grey-100")),
            Ve(M.Switch, "primaryDisabledColor", L(Zn, M.primary.main, .62)),
            Ve(M.Switch, "secondaryDisabledColor", L(Zn, M.secondary.main, .62)),
            Ve(M.Switch, "errorDisabledColor", L(Zn, M.error.main, .62)),
            Ve(M.Switch, "infoDisabledColor", L(Zn, M.info.main, .62)),
            Ve(M.Switch, "successDisabledColor", L(Zn, M.success.main, .62)),
            Ve(M.Switch, "warningDisabledColor", L(Zn, M.warning.main, .62)),
            Ve(M.TableCell, "border", L(Zn, L(nu, M.divider, 1), .88)),
            Ve(M.Tooltip, "bg", L(nu, M.grey[700], .92))
        }
        if (M.mode === "dark") {
            Ve(M.Alert, "errorColor", L(Zn, M.error.light, .6)),
            Ve(M.Alert, "infoColor", L(Zn, M.info.light, .6)),
            Ve(M.Alert, "successColor", L(Zn, M.success.light, .6)),
            Ve(M.Alert, "warningColor", L(Zn, M.warning.light, .6)),
            Ve(M.Alert, "errorFilledBg", B("palette-error-dark")),
            Ve(M.Alert, "infoFilledBg", B("palette-info-dark")),
            Ve(M.Alert, "successFilledBg", B("palette-success-dark")),
            Ve(M.Alert, "warningFilledBg", B("palette-warning-dark")),
            Ve(M.Alert, "errorFilledColor", us( () => M.getContrastText(M.error.dark))),
            Ve(M.Alert, "infoFilledColor", us( () => M.getContrastText(M.info.dark))),
            Ve(M.Alert, "successFilledColor", us( () => M.getContrastText(M.success.dark))),
            Ve(M.Alert, "warningFilledColor", us( () => M.getContrastText(M.warning.dark))),
            Ve(M.Alert, "errorStandardBg", L(Yn, M.error.light, .9)),
            Ve(M.Alert, "infoStandardBg", L(Yn, M.info.light, .9)),
            Ve(M.Alert, "successStandardBg", L(Yn, M.success.light, .9)),
            Ve(M.Alert, "warningStandardBg", L(Yn, M.warning.light, .9)),
            Ve(M.Alert, "errorIconColor", B("palette-error-main")),
            Ve(M.Alert, "infoIconColor", B("palette-info-main")),
            Ve(M.Alert, "successIconColor", B("palette-success-main")),
            Ve(M.Alert, "warningIconColor", B("palette-warning-main")),
            Ve(M.AppBar, "defaultBg", B("palette-grey-900")),
            Ve(M.AppBar, "darkBg", B("palette-background-paper")),
            Ve(M.AppBar, "darkColor", B("palette-text-primary")),
            Ve(M.Avatar, "defaultBg", B("palette-grey-600")),
            Ve(M.Button, "inheritContainedBg", B("palette-grey-800")),
            Ve(M.Button, "inheritContainedHoverBg", B("palette-grey-700")),
            Ve(M.Chip, "defaultBorder", B("palette-grey-700")),
            Ve(M.Chip, "defaultAvatarColor", B("palette-grey-300")),
            Ve(M.Chip, "defaultIconColor", B("palette-grey-300")),
            Ve(M.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"),
            Ve(M.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"),
            Ve(M.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"),
            Ve(M.LinearProgress, "primaryBg", L(Yn, M.primary.main, .5)),
            Ve(M.LinearProgress, "secondaryBg", L(Yn, M.secondary.main, .5)),
            Ve(M.LinearProgress, "errorBg", L(Yn, M.error.main, .5)),
            Ve(M.LinearProgress, "infoBg", L(Yn, M.info.main, .5)),
            Ve(M.LinearProgress, "successBg", L(Yn, M.success.main, .5)),
            Ve(M.LinearProgress, "warningBg", L(Yn, M.warning.main, .5)),
            Ve(M.Skeleton, "bg", T ? L(nu, M.text.primary, .13) : `rgba(${B("palette-text-primaryChannel")} / 0.13)`),
            Ve(M.Slider, "primaryTrack", L(Yn, M.primary.main, .5)),
            Ve(M.Slider, "secondaryTrack", L(Yn, M.secondary.main, .5)),
            Ve(M.Slider, "errorTrack", L(Yn, M.error.main, .5)),
            Ve(M.Slider, "infoTrack", L(Yn, M.info.main, .5)),
            Ve(M.Slider, "successTrack", L(Yn, M.success.main, .5)),
            Ve(M.Slider, "warningTrack", L(Yn, M.warning.main, .5));
            const F = T ? L(Zn, M.background.default, .985) : Pb(M.background.default, .98);
            Ve(M.SnackbarContent, "bg", F),
            Ve(M.SnackbarContent, "color", us( () => T ? yN.text.primary : M.getContrastText(F))),
            Ve(M.SpeedDialAction, "fabHoverBg", Pb(M.background.paper, .15)),
            Ve(M.StepConnector, "border", B("palette-grey-600")),
            Ve(M.StepContent, "border", B("palette-grey-600")),
            Ve(M.Switch, "defaultColor", B("palette-grey-300")),
            Ve(M.Switch, "defaultDisabledColor", B("palette-grey-600")),
            Ve(M.Switch, "primaryDisabledColor", L(Yn, M.primary.main, .55)),
            Ve(M.Switch, "secondaryDisabledColor", L(Yn, M.secondary.main, .55)),
            Ve(M.Switch, "errorDisabledColor", L(Yn, M.error.main, .55)),
            Ve(M.Switch, "infoDisabledColor", L(Yn, M.info.main, .55)),
            Ve(M.Switch, "successDisabledColor", L(Yn, M.success.main, .55)),
            Ve(M.Switch, "warningDisabledColor", L(Yn, M.warning.main, .55)),
            Ve(M.TableCell, "border", L(Yn, L(nu, M.divider, 1), .68)),
            Ve(M.Tooltip, "bg", L(nu, M.grey[700], .92))
        }
        il(M.background, "default"),
        il(M.background, "paper"),
        il(M.common, "background"),
        il(M.common, "onBackground"),
        il(M, "divider"),
        Object.keys(M).forEach(F => {
            const j = M[F];
            F !== "tonalOffset" && j && typeof j == "object" && (j.main && Ve(M[F], "mainChannel", Qp(Kp(j.main))),
            j.light && Ve(M[F], "lightChannel", Qp(Kp(j.light))),
            j.dark && Ve(M[F], "darkChannel", Qp(Kp(j.dark))),
            j.contrastText && Ve(M[F], "contrastTextChannel", Qp(Kp(j.contrastText))),
            F === "text" && (il(M[F], "primary"),
            il(M[F], "secondary")),
            F === "action" && (j.active && il(M[F], "active"),
            j.selected && il(M[F], "selected")))
        }
        )
    }
    ),
    P = t.reduce( (I, M) => ci(I, M), P);
    const D = {
        prefix: o,
        disableCssColorScheme: i,
        shouldSkipGeneratingVar: s,
        getSelector: sne(P),
        enableContrastVars: a
    }
      , {vars: $, generateThemeVars: z, generateStyleSheets: O} = dte(P, D);
    return P.vars = $,
    Object.entries(P.colorSchemes[P.defaultColorScheme]).forEach( ([I,M]) => {
        P[I] = M
    }
    ),
    P.generateThemeVars = z,
    P.generateStyleSheets = O,
    P.generateSpacing = function() {
        return JF(f.spacing, Ov(this))
    }
    ,
    P.getColorSchemeSelector = fte(c),
    P.spacing = P.generateSpacing(),
    P.shouldSkipGeneratingVar = s,
    P.unstable_sxConfig = {
        ...Ag,
        ...f?.unstable_sxConfig
    },
    P.unstable_sx = function(M) {
        return yc({
            sx: M,
            theme: this
        })
    }
    ,
    P.toRuntimeSource = SN,
    P
}
function d$(e, t, n) {
    e.colorSchemes && n && (e.colorSchemes[t] = {
        ...n !== !0 && n,
        palette: wE({
            ...n === !0 ? {} : n.palette,
            mode: t
        })
    })
}
function qv(e={}, ...t) {
    const {palette: n, cssVariables: r=!1, colorSchemes: i=n ? void 0 : {
        light: !0
    }, defaultColorScheme: o=n?.mode, ...a} = e
      , s = o || "light"
      , c = i?.[s]
      , u = {
        ...i,
        ...n ? {
            [s]: {
                ...typeof c != "boolean" && c,
                palette: n
            }
        } : void 0
    };
    if (r === !1) {
        if (!("colorSchemes"in e))
            return B2(e, ...t);
        let f = n;
        "palette"in e || u[s] && (u[s] !== !0 ? f = u[s].palette : s === "dark" && (f = {
            mode: "dark"
        }));
        const h = B2({
            ...e,
            palette: f
        }, ...t);
        return h.defaultColorScheme = s,
        h.colorSchemes = u,
        h.palette.mode === "light" && (h.colorSchemes.light = {
            ...u.light !== !0 && u.light,
            palette: h.palette
        },
        d$(h, "dark", u.dark)),
        h.palette.mode === "dark" && (h.colorSchemes.dark = {
            ...u.dark !== !0 && u.dark,
            palette: h.palette
        },
        d$(h, "light", u.light)),
        h
    }
    return !n && !("light"in u) && s === "light" && (u.light = !0),
    dne({
        ...a,
        colorSchemes: u,
        defaultColorScheme: s,
        ...typeof r != "boolean" && r
    }, ...t)
}
function fne(e) {
    return String(e).match(/[\d.\-+]*\s*(.*)/)[1] || ""
}
function hne(e) {
    return parseFloat(e)
}
const Wv = qv();
function ko() {
    const e = Pg(Wv);
    return e[xa] || e
}
function hr({props: e, name: t}) {
    return bE({
        props: e,
        name: t,
        defaultTheme: Wv,
        themeId: xa
    })
}
function kE(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as"
}
const ai = e => kE(e) && e !== "classes"
  , ue = oN({
    themeId: xa,
    defaultTheme: Wv,
    rootShouldForwardProp: ai
});
function pne({theme: e, ...t}) {
    const n = xa in e ? e[xa] : void 0;
    return g.jsx(pN, {
        ...t,
        themeId: n ? xa : void 0,
        theme: n || e
    })
}
const Rb = {
    colorSchemeStorageKey: "mui-color-scheme",
    defaultLightColorScheme: "light",
    defaultDarkColorScheme: "dark",
    modeStorageKey: "mui-mode"
}
  , {CssVarsProvider: mne} = ste({
    themeId: xa,
    theme: () => qv({
        cssVariables: !0
    }),
    colorSchemeStorageKey: Rb.colorSchemeStorageKey,
    modeStorageKey: Rb.modeStorageKey,
    defaultColorScheme: {
        light: Rb.defaultLightColorScheme,
        dark: Rb.defaultDarkColorScheme
    },
    resolveTheme: e => {
        const t = {
            ...e,
            typography: xN(e.palette, e.typography)
        };
        return t.unstable_sx = function(r) {
            return yc({
                sx: r,
                theme: this
            })
        }
        ,
        t
    }
})
  , gne = mne;
function yne({theme: e, ...t}) {
    const n = A.useMemo( () => {
        if (typeof e == "function")
            return e;
        const r = xa in e ? e[xa] : e;
        return "colorSchemes"in r ? null : "vars"in r ? e : {
            ...e,
            vars: null
        }
    }
    , [e]);
    return n ? g.jsx(pne, {
        theme: n,
        ...t
    }) : g.jsx(gne, {
        theme: e,
        ...t
    })
}
function F2(...e) {
    return e.reduce( (t, n) => n == null ? t : function(...i) {
        t.apply(this, i),
        n.apply(this, i)
    }
    , () => {}
    )
}
function bne(e) {
    return g.jsx(eN, {
        ...e,
        defaultTheme: Wv,
        themeId: xa
    })
}
function TE(e) {
    return function(n) {
        return g.jsx(bne, {
            styles: typeof e == "function" ? r => e({
                theme: r,
                ...n
            }) : e
        })
    }
}
function xne() {
    return Fv
}
const pt = Jee;
function gt(e) {
    return Zee(e)
}
function vne(e) {
    return rt("MuiSvgIcon", e)
}
ot("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const Sne = e => {
    const {color: t, fontSize: n, classes: r} = e
      , i = {
        root: ["root", t !== "inherit" && `color${Te(t)}`, `fontSize${Te(n)}`]
    };
    return tt(i, vne, r)
}
  , Cne = ue("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.color !== "inherit" && t[`color${Te(n.color)}`], t[`fontSize${Te(n.fontSize)}`]]
    }
})(pt( ({theme: e}) => ({
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: e.transitions?.create?.("fill", {
        duration: (e.vars ?? e).transitions?.duration?.shorter
    }),
    variants: [{
        props: t => !t.hasSvgAsChild,
        style: {
            fill: "currentColor"
        }
    }, {
        props: {
            fontSize: "inherit"
        },
        style: {
            fontSize: "inherit"
        }
    }, {
        props: {
            fontSize: "small"
        },
        style: {
            fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
        }
    }, {
        props: {
            fontSize: "medium"
        },
        style: {
            fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
        }
    }, {
        props: {
            fontSize: "large"
        },
        style: {
            fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
        }
    }, ...Object.entries((e.vars ?? e).palette).filter( ([,t]) => t && t.main).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            color: (e.vars ?? e).palette?.[t]?.main
        }
    })), {
        props: {
            color: "action"
        },
        style: {
            color: (e.vars ?? e).palette?.action?.active
        }
    }, {
        props: {
            color: "disabled"
        },
        style: {
            color: (e.vars ?? e).palette?.action?.disabled
        }
    }, {
        props: {
            color: "inherit"
        },
        style: {
            color: void 0
        }
    }]
})))
  , N2 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiSvgIcon"
    })
      , {children: i, className: o, color: a="inherit", component: s="svg", fontSize: c="medium", htmlColor: u, inheritViewBox: f=!1, titleAccess: h, viewBox: m="0 0 24 24", ...y} = r
      , b = A.isValidElement(i) && i.type === "svg"
      , v = {
        ...r,
        color: a,
        component: s,
        fontSize: c,
        instanceFontSize: t.fontSize,
        inheritViewBox: f,
        viewBox: m,
        hasSvgAsChild: b
    }
      , S = {};
    f || (S.viewBox = m);
    const C = Sne(v);
    return g.jsxs(Cne, {
        as: s,
        className: Ne(C.root, o),
        focusable: "false",
        color: u,
        "aria-hidden": h ? void 0 : !0,
        role: h ? "img" : void 0,
        ref: n,
        ...S,
        ...y,
        ...b && i.props,
        ownerState: v,
        children: [b ? i.props.children : i, h ? g.jsx("title", {
            children: h
        }) : null]
    })
});
N2.muiName = "SvgIcon";
function _t(e, t) {
    function n(r, i) {
        return g.jsx(N2, {
            "data-testid": void 0,
            ref: i,
            ...r,
            children: e
        })
    }
    return n.muiName = N2.muiName,
    A.memo(A.forwardRef(n))
}
function Rg(e, t=166) {
    let n;
    function r(...i) {
        const o = () => {
            e.apply(this, i)
        }
        ;
        clearTimeout(n),
        n = setTimeout(o, t)
    }
    return r.clear = () => {
        clearTimeout(n)
    }
    ,
    r
}
function Kr(e) {
    return e && e.ownerDocument || document
}
function Zo(e) {
    return Kr(e).defaultView || window
}
function U2(e, t) {
    typeof e == "function" ? e(t) : e && (e.current = t)
}
function go(e) {
    const {controlled: t, default: n, name: r, state: i="value"} = e
      , {current: o} = A.useRef(t !== void 0)
      , [a,s] = A.useState(n)
      , c = o ? t : a
      , u = A.useCallback(f => {
        o || s(f)
    }
    , []);
    return [c, u]
}
function ft(e) {
    const t = A.useRef(e);
    return Cr( () => {
        t.current = e
    }
    ),
    A.useRef( (...n) => (0,
    t.current)(...n)).current
}
function Cn(...e) {
    const t = A.useRef(void 0)
      , n = A.useCallback(r => {
        const i = e.map(o => {
            if (o == null)
                return null;
            if (typeof o == "function") {
                const a = o
                  , s = a(r);
                return typeof s == "function" ? s : () => {
                    a(null)
                }
            }
            return o.current = r,
            () => {
                o.current = null
            }
        }
        );
        return () => {
            i.forEach(o => o?.())
        }
    }
    , e);
    return A.useMemo( () => e.every(r => r == null) ? null : r => {
        t.current && (t.current(),
        t.current = void 0),
        r != null && (t.current = n(r))
    }
    , e)
}
function wne(e, t) {
    const n = e.charCodeAt(2);
    return e[0] === "o" && e[1] === "n" && n >= 65 && n <= 90 && typeof t == "function"
}
function _E(e, t) {
    if (!e)
        return t;
    function n(a, s) {
        const c = {};
        return Object.keys(s).forEach(u => {
            wne(u, s[u]) && typeof a[u] == "function" && (c[u] = (...f) => {
                a[u](...f),
                s[u](...f)
            }
            )
        }
        ),
        c
    }
    if (typeof e == "function" || typeof t == "function")
        return a => {
            const s = typeof t == "function" ? t(a) : t
              , c = typeof e == "function" ? e({
                ...a,
                ...s
            }) : e
              , u = Ne(a?.className, s?.className, c?.className)
              , f = n(c, s);
            return {
                ...s,
                ...c,
                ...f,
                ...!!u && {
                    className: u
                },
                ...s?.style && c?.style && {
                    style: {
                        ...s.style,
                        ...c.style
                    }
                },
                ...s?.sx && c?.sx && {
                    sx: [...Array.isArray(s.sx) ? s.sx : [s.sx], ...Array.isArray(c.sx) ? c.sx : [c.sx]]
                }
            }
        }
        ;
    const r = t
      , i = n(e, r)
      , o = Ne(r?.className, e?.className);
    return {
        ...t,
        ...e,
        ...i,
        ...!!o && {
            className: o
        },
        ...r?.style && e?.style && {
            style: {
                ...r.style,
                ...e.style
            }
        },
        ...r?.sx && e?.sx && {
            sx: [...Array.isArray(r.sx) ? r.sx : [r.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
        }
    }
}
function Qt(e, t) {
    if (e == null)
        return {};
    var n = {};
    for (var r in e)
        if ({}.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) !== -1)
                continue;
            n[r] = e[r]
        }
    return n
}
function V2(e, t) {
    return V2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
        return n.__proto__ = r,
        n
    }
    ,
    V2(e, t)
}
function EE(e, t) {
    e.prototype = Object.create(t.prototype),
    e.prototype.constructor = e,
    V2(e, t)
}
function kne(e, t) {
    return e.classList ? !!t && e.classList.contains(t) : (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ") !== -1
}
function Tne(e, t) {
    e.classList ? e.classList.add(t) : kne(e, t) || (typeof e.className == "string" ? e.className = e.className + " " + t : e.setAttribute("class", (e.className && e.className.baseVal || "") + " " + t))
}
function f$(e, t) {
    return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)","g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
}
function _ne(e, t) {
    e.classList ? e.classList.remove(t) : typeof e.className == "string" ? e.className = f$(e.className, t) : e.setAttribute("class", f$(e.className && e.className.baseVal || "", t))
}
const h$ = {
    disabled: !1
}
  , f0 = bt.createContext(null);
var kN = function(t) {
    return t.scrollTop
}
  , Xp = "unmounted"
  , du = "exited"
  , fu = "entering"
  , af = "entered"
  , H2 = "exiting"
  , Xo = (function(e) {
    EE(t, e);
    function t(r, i) {
        var o;
        o = e.call(this, r, i) || this;
        var a = i, s = a && !a.isMounting ? r.enter : r.appear, c;
        return o.appearStatus = null,
        r.in ? s ? (c = du,
        o.appearStatus = fu) : c = af : r.unmountOnExit || r.mountOnEnter ? c = Xp : c = du,
        o.state = {
            status: c
        },
        o.nextCallback = null,
        o
    }
    t.getDerivedStateFromProps = function(i, o) {
        var a = i.in;
        return a && o.status === Xp ? {
            status: du
        } : null
    }
    ;
    var n = t.prototype;
    return n.componentDidMount = function() {
        this.updateStatus(!0, this.appearStatus)
    }
    ,
    n.componentDidUpdate = function(i) {
        var o = null;
        if (i !== this.props) {
            var a = this.state.status;
            this.props.in ? a !== fu && a !== af && (o = fu) : (a === fu || a === af) && (o = H2)
        }
        this.updateStatus(!1, o)
    }
    ,
    n.componentWillUnmount = function() {
        this.cancelNextCallback()
    }
    ,
    n.getTimeouts = function() {
        var i = this.props.timeout, o, a, s;
        return o = a = s = i,
        i != null && typeof i != "number" && (o = i.exit,
        a = i.enter,
        s = i.appear !== void 0 ? i.appear : a),
        {
            exit: o,
            enter: a,
            appear: s
        }
    }
    ,
    n.updateStatus = function(i, o) {
        if (i === void 0 && (i = !1),
        o !== null)
            if (this.cancelNextCallback(),
            o === fu) {
                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                    var a = this.props.nodeRef ? this.props.nodeRef.current : Eb.findDOMNode(this);
                    a && kN(a)
                }
                this.performEnter(i)
            } else
                this.performExit();
        else
            this.props.unmountOnExit && this.state.status === du && this.setState({
                status: Xp
            })
    }
    ,
    n.performEnter = function(i) {
        var o = this
          , a = this.props.enter
          , s = this.context ? this.context.isMounting : i
          , c = this.props.nodeRef ? [s] : [Eb.findDOMNode(this), s]
          , u = c[0]
          , f = c[1]
          , h = this.getTimeouts()
          , m = s ? h.appear : h.enter;
        if (!i && !a || h$.disabled) {
            this.safeSetState({
                status: af
            }, function() {
                o.props.onEntered(u)
            });
            return
        }
        this.props.onEnter(u, f),
        this.safeSetState({
            status: fu
        }, function() {
            o.props.onEntering(u, f),
            o.onTransitionEnd(m, function() {
                o.safeSetState({
                    status: af
                }, function() {
                    o.props.onEntered(u, f)
                })
            })
        })
    }
    ,
    n.performExit = function() {
        var i = this
          , o = this.props.exit
          , a = this.getTimeouts()
          , s = this.props.nodeRef ? void 0 : Eb.findDOMNode(this);
        if (!o || h$.disabled) {
            this.safeSetState({
                status: du
            }, function() {
                i.props.onExited(s)
            });
            return
        }
        this.props.onExit(s),
        this.safeSetState({
            status: H2
        }, function() {
            i.props.onExiting(s),
            i.onTransitionEnd(a.exit, function() {
                i.safeSetState({
                    status: du
                }, function() {
                    i.props.onExited(s)
                })
            })
        })
    }
    ,
    n.cancelNextCallback = function() {
        this.nextCallback !== null && (this.nextCallback.cancel(),
        this.nextCallback = null)
    }
    ,
    n.safeSetState = function(i, o) {
        o = this.setNextCallback(o),
        this.setState(i, o)
    }
    ,
    n.setNextCallback = function(i) {
        var o = this
          , a = !0;
        return this.nextCallback = function(s) {
            a && (a = !1,
            o.nextCallback = null,
            i(s))
        }
        ,
        this.nextCallback.cancel = function() {
            a = !1
        }
        ,
        this.nextCallback
    }
    ,
    n.onTransitionEnd = function(i, o) {
        this.setNextCallback(o);
        var a = this.props.nodeRef ? this.props.nodeRef.current : Eb.findDOMNode(this)
          , s = i == null && !this.props.addEndListener;
        if (!a || s) {
            setTimeout(this.nextCallback, 0);
            return
        }
        if (this.props.addEndListener) {
            var c = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback]
              , u = c[0]
              , f = c[1];
            this.props.addEndListener(u, f)
        }
        i != null && setTimeout(this.nextCallback, i)
    }
    ,
    n.render = function() {
        var i = this.state.status;
        if (i === Xp)
            return null;
        var o = this.props
          , a = o.children;
        o.in,
        o.mountOnEnter,
        o.unmountOnExit,
        o.appear,
        o.enter,
        o.exit,
        o.timeout,
        o.addEndListener,
        o.onEnter,
        o.onEntering,
        o.onEntered,
        o.onExit,
        o.onExiting,
        o.onExited,
        o.nodeRef;
        var s = Qt(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return bt.createElement(f0.Provider, {
            value: null
        }, typeof a == "function" ? a(i, s) : bt.cloneElement(bt.Children.only(a), s))
    }
    ,
    t
}
)(bt.Component);
Xo.contextType = f0;
Xo.propTypes = {};
function Qd() {}
Xo.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: Qd,
    onEntering: Qd,
    onEntered: Qd,
    onExit: Qd,
    onExiting: Qd,
    onExited: Qd
};
Xo.UNMOUNTED = Xp;
Xo.EXITED = du;
Xo.ENTERING = fu;
Xo.ENTERED = af;
Xo.EXITING = H2;
var Ene = function(t, n) {
    return t && n && n.split(" ").forEach(function(r) {
        return Tne(t, r)
    })
}
  , qw = function(t, n) {
    return t && n && n.split(" ").forEach(function(r) {
        return _ne(t, r)
    })
}
  , AE = (function(e) {
    EE(t, e);
    function t() {
        for (var r, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
            o[a] = arguments[a];
        return r = e.call.apply(e, [this].concat(o)) || this,
        r.appliedClasses = {
            appear: {},
            enter: {},
            exit: {}
        },
        r.onEnter = function(s, c) {
            var u = r.resolveArguments(s, c)
              , f = u[0]
              , h = u[1];
            r.removeClasses(f, "exit"),
            r.addClass(f, h ? "appear" : "enter", "base"),
            r.props.onEnter && r.props.onEnter(s, c)
        }
        ,
        r.onEntering = function(s, c) {
            var u = r.resolveArguments(s, c)
              , f = u[0]
              , h = u[1]
              , m = h ? "appear" : "enter";
            r.addClass(f, m, "active"),
            r.props.onEntering && r.props.onEntering(s, c)
        }
        ,
        r.onEntered = function(s, c) {
            var u = r.resolveArguments(s, c)
              , f = u[0]
              , h = u[1]
              , m = h ? "appear" : "enter";
            r.removeClasses(f, m),
            r.addClass(f, m, "done"),
            r.props.onEntered && r.props.onEntered(s, c)
        }
        ,
        r.onExit = function(s) {
            var c = r.resolveArguments(s)
              , u = c[0];
            r.removeClasses(u, "appear"),
            r.removeClasses(u, "enter"),
            r.addClass(u, "exit", "base"),
            r.props.onExit && r.props.onExit(s)
        }
        ,
        r.onExiting = function(s) {
            var c = r.resolveArguments(s)
              , u = c[0];
            r.addClass(u, "exit", "active"),
            r.props.onExiting && r.props.onExiting(s)
        }
        ,
        r.onExited = function(s) {
            var c = r.resolveArguments(s)
              , u = c[0];
            r.removeClasses(u, "exit"),
            r.addClass(u, "exit", "done"),
            r.props.onExited && r.props.onExited(s)
        }
        ,
        r.resolveArguments = function(s, c) {
            return r.props.nodeRef ? [r.props.nodeRef.current, s] : [s, c]
        }
        ,
        r.getClassNames = function(s) {
            var c = r.props.classNames
              , u = typeof c == "string"
              , f = u && c ? c + "-" : ""
              , h = u ? "" + f + s : c[s]
              , m = u ? h + "-active" : c[s + "Active"]
              , y = u ? h + "-done" : c[s + "Done"];
            return {
                baseClassName: h,
                activeClassName: m,
                doneClassName: y
            }
        }
        ,
        r
    }
    var n = t.prototype;
    return n.addClass = function(i, o, a) {
        var s = this.getClassNames(o)[a + "ClassName"]
          , c = this.getClassNames("enter")
          , u = c.doneClassName;
        o === "appear" && a === "done" && u && (s += " " + u),
        a === "active" && i && kN(i),
        s && (this.appliedClasses[o][a] = s,
        Ene(i, s))
    }
    ,
    n.removeClasses = function(i, o) {
        var a = this.appliedClasses[o]
          , s = a.base
          , c = a.active
          , u = a.done;
        this.appliedClasses[o] = {},
        s && qw(i, s),
        c && qw(i, c),
        u && qw(i, u)
    }
    ,
    n.render = function() {
        var i = this.props;
        i.classNames;
        var o = Qt(i, ["classNames"]);
        return bt.createElement(Xo, ge({}, o, {
            onEnter: this.onEnter,
            onEntered: this.onEntered,
            onEntering: this.onEntering,
            onExit: this.onExit,
            onExiting: this.onExiting,
            onExited: this.onExited
        }))
    }
    ,
    t
}
)(bt.Component);
AE.defaultProps = {
    classNames: ""
};
AE.propTypes = {};
function Ane(e) {
    if (e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}
function ME(e, t) {
    var n = function(o) {
        return t && A.isValidElement(o) ? t(o) : o
    }
      , r = Object.create(null);
    return e && A.Children.map(e, function(i) {
        return i
    }).forEach(function(i) {
        r[i.key] = n(i)
    }),
    r
}
function Mne(e, t) {
    e = e || {},
    t = t || {};
    function n(f) {
        return f in t ? t[f] : e[f]
    }
    var r = Object.create(null)
      , i = [];
    for (var o in e)
        o in t ? i.length && (r[o] = i,
        i = []) : i.push(o);
    var a, s = {};
    for (var c in t) {
        if (r[c])
            for (a = 0; a < r[c].length; a++) {
                var u = r[c][a];
                s[r[c][a]] = n(u)
            }
        s[c] = n(c)
    }
    for (a = 0; a < i.length; a++)
        s[i[a]] = n(i[a]);
    return s
}
function Su(e, t, n) {
    return n[t] != null ? n[t] : e.props[t]
}
function Pne(e, t) {
    return ME(e.children, function(n) {
        return A.cloneElement(n, {
            onExited: t.bind(null, n),
            in: !0,
            appear: Su(n, "appear", e),
            enter: Su(n, "enter", e),
            exit: Su(n, "exit", e)
        })
    })
}
function Rne(e, t, n) {
    var r = ME(e.children)
      , i = Mne(t, r);
    return Object.keys(i).forEach(function(o) {
        var a = i[o];
        if (A.isValidElement(a)) {
            var s = o in t
              , c = o in r
              , u = t[o]
              , f = A.isValidElement(u) && !u.props.in;
            c && (!s || f) ? i[o] = A.cloneElement(a, {
                onExited: n.bind(null, a),
                in: !0,
                exit: Su(a, "exit", e),
                enter: Su(a, "enter", e)
            }) : !c && s && !f ? i[o] = A.cloneElement(a, {
                in: !1
            }) : c && s && A.isValidElement(u) && (i[o] = A.cloneElement(a, {
                onExited: n.bind(null, a),
                in: u.props.in,
                exit: Su(a, "exit", e),
                enter: Su(a, "enter", e)
            }))
        }
    }),
    i
}
var Dne = Object.values || function(e) {
    return Object.keys(e).map(function(t) {
        return e[t]
    })
}
  , One = {
    component: "div",
    childFactory: function(t) {
        return t
    }
}
  , Dg = (function(e) {
    EE(t, e);
    function t(r, i) {
        var o;
        o = e.call(this, r, i) || this;
        var a = o.handleExited.bind(Ane(o));
        return o.state = {
            contextValue: {
                isMounting: !0
            },
            handleExited: a,
            firstRender: !0
        },
        o
    }
    var n = t.prototype;
    return n.componentDidMount = function() {
        this.mounted = !0,
        this.setState({
            contextValue: {
                isMounting: !1
            }
        })
    }
    ,
    n.componentWillUnmount = function() {
        this.mounted = !1
    }
    ,
    t.getDerivedStateFromProps = function(i, o) {
        var a = o.children
          , s = o.handleExited
          , c = o.firstRender;
        return {
            children: c ? Pne(i, s) : Rne(i, a, s),
            firstRender: !1
        }
    }
    ,
    n.handleExited = function(i, o) {
        var a = ME(this.props.children);
        i.key in a || (i.props.onExited && i.props.onExited(o),
        this.mounted && this.setState(function(s) {
            var c = ge({}, s.children);
            return delete c[i.key],
            {
                children: c
            }
        }))
    }
    ,
    n.render = function() {
        var i = this.props
          , o = i.component
          , a = i.childFactory
          , s = Qt(i, ["component", "childFactory"])
          , c = this.state.contextValue
          , u = Dne(this.state.children).map(a);
        return delete s.appear,
        delete s.enter,
        delete s.exit,
        o === null ? bt.createElement(f0.Provider, {
            value: c
        }, u) : bt.createElement(f0.Provider, {
            value: c
        }, bt.createElement(o, s, u))
    }
    ,
    t
}
)(bt.Component);
Dg.propTypes = {};
Dg.defaultProps = One;
const p$ = {};
function TN(e, t) {
    const n = A.useRef(p$);
    return n.current === p$ && (n.current = e(t)),
    n
}
const Ine = [];
function $ne(e) {
    A.useEffect(e, Ine)
}
class Gv {
    static create() {
        return new Gv
    }
    currentId = null;
    start(t, n) {
        this.clear(),
        this.currentId = setTimeout( () => {
            this.currentId = null,
            n()
        }
        , t)
    }
    clear = () => {
        this.currentId !== null && (clearTimeout(this.currentId),
        this.currentId = null)
    }
    ;
    disposeEffect = () => this.clear
}
function uc() {
    const e = TN(Gv.create).current;
    return $ne(e.disposeEffect),
    e
}
const PE = e => e.scrollTop;
function xc(e, t) {
    const {timeout: n, easing: r, style: i={}} = e;
    return {
        duration: i.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
        easing: i.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
        delay: i.transitionDelay
    }
}
function Lne(e) {
    return rt("MuiCollapse", e)
}
ot("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const jne = e => {
    const {orientation: t, classes: n} = e
      , r = {
        root: ["root", `${t}`],
        entered: ["entered"],
        hidden: ["hidden"],
        wrapper: ["wrapper", `${t}`],
        wrapperInner: ["wrapperInner", `${t}`]
    };
    return tt(r, Lne, n)
}
  , Bne = ue("div", {
    name: "MuiCollapse",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[n.orientation], n.state === "entered" && t.entered, n.state === "exited" && !n.in && n.collapsedSize === "0px" && t.hidden]
    }
})(pt( ({theme: e}) => ({
    height: 0,
    overflow: "hidden",
    transition: e.transitions.create("height"),
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            height: "auto",
            width: 0,
            transition: e.transitions.create("width")
        }
    }, {
        props: {
            state: "entered"
        },
        style: {
            height: "auto",
            overflow: "visible"
        }
    }, {
        props: {
            state: "entered",
            orientation: "horizontal"
        },
        style: {
            width: "auto"
        }
    }, {
        props: ({ownerState: t}) => t.state === "exited" && !t.in && t.collapsedSize === "0px",
        style: {
            visibility: "hidden"
        }
    }]
})))
  , zne = ue("div", {
    name: "MuiCollapse",
    slot: "Wrapper"
})({
    display: "flex",
    width: "100%",
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            width: "auto",
            height: "100%"
        }
    }]
})
  , Fne = ue("div", {
    name: "MuiCollapse",
    slot: "WrapperInner"
})({
    width: "100%",
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            width: "auto",
            height: "100%"
        }
    }]
})
  , h0 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiCollapse"
    })
      , {addEndListener: i, children: o, className: a, collapsedSize: s="0px", component: c, easing: u, in: f, onEnter: h, onEntered: m, onEntering: y, onExit: b, onExited: v, onExiting: S, orientation: C="vertical", style: w, timeout: k=vN.standard, TransitionComponent: T=Xo, ...E} = r
      , P = {
        ...r,
        orientation: C,
        collapsedSize: s
    }
      , D = jne(P)
      , $ = ko()
      , z = uc()
      , O = A.useRef(null)
      , I = A.useRef()
      , M = typeof s == "number" ? `${s}px` : s
      , B = C === "horizontal"
      , L = B ? "width" : "height"
      , F = A.useRef(null)
      , j = Cn(n, F)
      , N = ee => re => {
        if (ee) {
            const ie = F.current;
            re === void 0 ? ee(ie) : ee(ie, re)
        }
    }
      , H = () => O.current ? O.current[B ? "clientWidth" : "clientHeight"] : 0
      , Z = N( (ee, re) => {
        O.current && B && (O.current.style.position = "absolute"),
        ee.style[L] = M,
        h && h(ee, re)
    }
    )
      , q = N( (ee, re) => {
        const ie = H();
        O.current && B && (O.current.style.position = "");
        const {duration: J, easing: oe} = xc({
            style: w,
            timeout: k,
            easing: u
        }, {
            mode: "enter"
        });
        if (k === "auto") {
            const we = $.transitions.getAutoHeightDuration(ie);
            ee.style.transitionDuration = `${we}ms`,
            I.current = we
        } else
            ee.style.transitionDuration = typeof J == "string" ? J : `${J}ms`;
        ee.style[L] = `${ie}px`,
        ee.style.transitionTimingFunction = oe,
        y && y(ee, re)
    }
    )
      , V = N( (ee, re) => {
        ee.style[L] = "auto",
        m && m(ee, re)
    }
    )
      , Y = N(ee => {
        ee.style[L] = `${H()}px`,
        b && b(ee)
    }
    )
      , W = N(v)
      , te = N(ee => {
        const re = H()
          , {duration: ie, easing: J} = xc({
            style: w,
            timeout: k,
            easing: u
        }, {
            mode: "exit"
        });
        if (k === "auto") {
            const oe = $.transitions.getAutoHeightDuration(re);
            ee.style.transitionDuration = `${oe}ms`,
            I.current = oe
        } else
            ee.style.transitionDuration = typeof ie == "string" ? ie : `${ie}ms`;
        ee.style[L] = M,
        ee.style.transitionTimingFunction = J,
        S && S(ee)
    }
    )
      , K = ee => {
        k === "auto" && z.start(I.current || 0, ee),
        i && i(F.current, ee)
    }
    ;
    return g.jsx(T, {
        in: f,
        onEnter: Z,
        onEntered: V,
        onEntering: q,
        onExit: Y,
        onExited: W,
        onExiting: te,
        addEndListener: K,
        nodeRef: F,
        timeout: k === "auto" ? null : k,
        ...E,
        children: (ee, {ownerState: re, ...ie}) => g.jsx(Bne, {
            as: c,
            className: Ne(D.root, a, {
                entered: D.entered,
                exited: !f && M === "0px" && D.hidden
            }[ee]),
            style: {
                [B ? "minWidth" : "minHeight"]: M,
                ...w
            },
            ref: j,
            ownerState: {
                ...P,
                state: ee
            },
            ...ie,
            children: g.jsx(zne, {
                ownerState: {
                    ...P,
                    state: ee
                },
                className: D.wrapper,
                ref: O,
                children: g.jsx(Fne, {
                    ownerState: {
                        ...P,
                        state: ee
                    },
                    className: D.wrapperInner,
                    children: o
                })
            })
        })
    })
});
h0 && (h0.muiSupportAuto = !0);
function Nne(e) {
    return rt("MuiPaper", e)
}
ot("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const Une = e => {
    const {square: t, elevation: n, variant: r, classes: i} = e
      , o = {
        root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
    };
    return tt(o, Nne, i)
}
  , Vne = ue("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]]
    }
})(pt( ({theme: e}) => ({
    backgroundColor: (e.vars || e).palette.background.paper,
    color: (e.vars || e).palette.text.primary,
    transition: e.transitions.create("box-shadow"),
    variants: [{
        props: ({ownerState: t}) => !t.square,
        style: {
            borderRadius: e.shape.borderRadius
        }
    }, {
        props: {
            variant: "outlined"
        },
        style: {
            border: `1px solid ${(e.vars || e).palette.divider}`
        }
    }, {
        props: {
            variant: "elevation"
        },
        style: {
            boxShadow: "var(--Paper-shadow)",
            backgroundImage: "var(--Paper-overlay)"
        }
    }]
})))
  , yn = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiPaper"
    })
      , i = ko()
      , {className: o, component: a="div", elevation: s=1, square: c=!1, variant: u="elevation", ...f} = r
      , h = {
        ...r,
        component: a,
        elevation: s,
        square: c,
        variant: u
    }
      , m = Une(h);
    return g.jsx(Vne, {
        as: a,
        ownerState: h,
        className: Ne(m.root, o),
        ref: n,
        ...f,
        style: {
            ...u === "elevation" && {
                "--Paper-shadow": (i.vars || i).shadows[s],
                ...i.vars && {
                    "--Paper-overlay": i.vars.overlays?.[s]
                },
                ...!i.vars && i.palette.mode === "dark" && {
                    "--Paper-overlay": `linear-gradient(${Ts("#fff", z2(s))}, ${Ts("#fff", z2(s))})`
                }
            },
            ...f.style
        }
    })
});
function Nf(e) {
    return typeof e == "string"
}
function _N(e, t, n) {
    return e === void 0 || Nf(e) ? t : {
        ...t,
        ownerState: {
            ...t.ownerState,
            ...n
        }
    }
}
function Yv(e, t, n) {
    return typeof e == "function" ? e(t, n) : e
}
function p0(e, t=[]) {
    if (e === void 0)
        return {};
    const n = {};
    return Object.keys(e).filter(r => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach(r => {
        n[r] = e[r]
    }
    ),
    n
}
function m$(e) {
    if (e === void 0)
        return {};
    const t = {};
    return Object.keys(e).filter(n => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach(n => {
        t[n] = e[n]
    }
    ),
    t
}
function EN(e) {
    const {getSlotProps: t, additionalProps: n, externalSlotProps: r, externalForwardedProps: i, className: o} = e;
    if (!t) {
        const y = Ne(n?.className, o, i?.className, r?.className)
          , b = {
            ...n?.style,
            ...i?.style,
            ...r?.style
        }
          , v = {
            ...n,
            ...i,
            ...r
        };
        return y.length > 0 && (v.className = y),
        Object.keys(b).length > 0 && (v.style = b),
        {
            props: v,
            internalRef: void 0
        }
    }
    const a = p0({
        ...i,
        ...r
    })
      , s = m$(r)
      , c = m$(i)
      , u = t(a)
      , f = Ne(u?.className, n?.className, o, i?.className, r?.className)
      , h = {
        ...u?.style,
        ...n?.style,
        ...i?.style,
        ...r?.style
    }
      , m = {
        ...u,
        ...n,
        ...c,
        ...s
    };
    return f.length > 0 && (m.className = f),
    Object.keys(h).length > 0 && (m.style = h),
    {
        props: m,
        internalRef: u.ref
    }
}
function mt(e, t) {
    const {className: n, elementType: r, ownerState: i, externalForwardedProps: o, internalForwardedProps: a, shouldForwardComponentProp: s=!1, ...c} = t
      , {component: u, slots: f={
        [e]: void 0
    }, slotProps: h={
        [e]: void 0
    }, ...m} = o
      , y = f[e] || r
      , b = Yv(h[e], i)
      , {props: {component: v, ...S}, internalRef: C} = EN({
        className: n,
        ...c,
        externalForwardedProps: e === "root" ? m : void 0,
        externalSlotProps: b
    })
      , w = Cn(C, b?.ref, t.ref)
      , k = e === "root" ? v || u : v
      , T = _N(y, {
        ...e === "root" && !u && !f[e] && a,
        ...e !== "root" && !f[e] && a,
        ...S,
        ...k && !s && {
            as: k
        },
        ...k && s && {
            component: k
        },
        ref: w
    }, i);
    return [y, T]
}
const AN = ze.oneOfType([ze.func, ze.object]);
function m0(e) {
    try {
        return e.matches(":focus-visible")
    } catch {}
    return !1
}
class g0 {
    static create() {
        return new g0
    }
    static use() {
        const t = TN(g0.create).current
          , [n,r] = A.useState(!1);
        return t.shouldMount = n,
        t.setShouldMount = r,
        A.useEffect(t.mountEffect, [n]),
        t
    }
    constructor() {
        this.ref = {
            current: null
        },
        this.mounted = null,
        this.didMount = !1,
        this.shouldMount = !1,
        this.setShouldMount = null
    }
    mount() {
        return this.mounted || (this.mounted = qne(),
        this.shouldMount = !0,
        this.setShouldMount(this.shouldMount)),
        this.mounted
    }
    mountEffect = () => {
        this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0,
        this.mounted.resolve())
    }
    ;
    start(...t) {
        this.mount().then( () => this.ref.current?.start(...t))
    }
    stop(...t) {
        this.mount().then( () => this.ref.current?.stop(...t))
    }
    pulsate(...t) {
        this.mount().then( () => this.ref.current?.pulsate(...t))
    }
}
function Hne() {
    return g0.use()
}
function qne() {
    let e, t;
    const n = new Promise( (r, i) => {
        e = r,
        t = i
    }
    );
    return n.resolve = e,
    n.reject = t,
    n
}
function Wne(e) {
    const {className: t, classes: n, pulsate: r=!1, rippleX: i, rippleY: o, rippleSize: a, in: s, onExited: c, timeout: u} = e
      , [f,h] = A.useState(!1)
      , m = Ne(t, n.ripple, n.rippleVisible, r && n.ripplePulsate)
      , y = {
        width: a,
        height: a,
        top: -(a / 2) + o,
        left: -(a / 2) + i
    }
      , b = Ne(n.child, f && n.childLeaving, r && n.childPulsate);
    return !s && !f && h(!0),
    A.useEffect( () => {
        if (!s && c != null) {
            const v = setTimeout(c, u);
            return () => {
                clearTimeout(v)
            }
        }
    }
    , [c, s, u]),
    g.jsx("span", {
        className: m,
        style: y,
        children: g.jsx("span", {
            className: b
        })
    })
}
const ma = ot("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"])
  , q2 = 550
  , Gne = 80
  , Yne = $s`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`
  , Zne = $s`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`
  , Qne = $s`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`
  , Kne = ue("span", {
    name: "MuiTouchRipple",
    slot: "Root"
})({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
})
  , Xne = ue(Wne, {
    name: "MuiTouchRipple",
    slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${ma.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${Yne};
    animation-duration: ${q2}ms;
    animation-timing-function: ${ ({theme: e}) => e.transitions.easing.easeInOut};
  }

  &.${ma.ripplePulsate} {
    animation-duration: ${ ({theme: e}) => e.transitions.duration.shorter}ms;
  }

  & .${ma.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${ma.childLeaving} {
    opacity: 0;
    animation-name: ${Zne};
    animation-duration: ${q2}ms;
    animation-timing-function: ${ ({theme: e}) => e.transitions.easing.easeInOut};
  }

  & .${ma.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${Qne};
    animation-duration: 2500ms;
    animation-timing-function: ${ ({theme: e}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`
  , Jne = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTouchRipple"
    })
      , {center: i=!1, classes: o={}, className: a, ...s} = r
      , [c,u] = A.useState([])
      , f = A.useRef(0)
      , h = A.useRef(null);
    A.useEffect( () => {
        h.current && (h.current(),
        h.current = null)
    }
    , [c]);
    const m = A.useRef(!1)
      , y = uc()
      , b = A.useRef(null)
      , v = A.useRef(null)
      , S = A.useCallback(T => {
        const {pulsate: E, rippleX: P, rippleY: D, rippleSize: $, cb: z} = T;
        u(O => [...O, g.jsx(Xne, {
            classes: {
                ripple: Ne(o.ripple, ma.ripple),
                rippleVisible: Ne(o.rippleVisible, ma.rippleVisible),
                ripplePulsate: Ne(o.ripplePulsate, ma.ripplePulsate),
                child: Ne(o.child, ma.child),
                childLeaving: Ne(o.childLeaving, ma.childLeaving),
                childPulsate: Ne(o.childPulsate, ma.childPulsate)
            },
            timeout: q2,
            pulsate: E,
            rippleX: P,
            rippleY: D,
            rippleSize: $
        }, f.current)]),
        f.current += 1,
        h.current = z
    }
    , [o])
      , C = A.useCallback( (T={}, E={}, P= () => {}
    ) => {
        const {pulsate: D=!1, center: $=i || E.pulsate, fakeElement: z=!1} = E;
        if (T?.type === "mousedown" && m.current) {
            m.current = !1;
            return
        }
        T?.type === "touchstart" && (m.current = !0);
        const O = z ? null : v.current
          , I = O ? O.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
        };
        let M, B, L;
        if ($ || T === void 0 || T.clientX === 0 && T.clientY === 0 || !T.clientX && !T.touches)
            M = Math.round(I.width / 2),
            B = Math.round(I.height / 2);
        else {
            const {clientX: F, clientY: j} = T.touches && T.touches.length > 0 ? T.touches[0] : T;
            M = Math.round(F - I.left),
            B = Math.round(j - I.top)
        }
        if ($)
            L = Math.sqrt((2 * I.width ** 2 + I.height ** 2) / 3),
            L % 2 === 0 && (L += 1);
        else {
            const F = Math.max(Math.abs((O ? O.clientWidth : 0) - M), M) * 2 + 2
              , j = Math.max(Math.abs((O ? O.clientHeight : 0) - B), B) * 2 + 2;
            L = Math.sqrt(F ** 2 + j ** 2)
        }
        T?.touches ? b.current === null && (b.current = () => {
            S({
                pulsate: D,
                rippleX: M,
                rippleY: B,
                rippleSize: L,
                cb: P
            })
        }
        ,
        y.start(Gne, () => {
            b.current && (b.current(),
            b.current = null)
        }
        )) : S({
            pulsate: D,
            rippleX: M,
            rippleY: B,
            rippleSize: L,
            cb: P
        })
    }
    , [i, S, y])
      , w = A.useCallback( () => {
        C({}, {
            pulsate: !0
        })
    }
    , [C])
      , k = A.useCallback( (T, E) => {
        if (y.clear(),
        T?.type === "touchend" && b.current) {
            b.current(),
            b.current = null,
            y.start(0, () => {
                k(T, E)
            }
            );
            return
        }
        b.current = null,
        u(P => P.length > 0 ? P.slice(1) : P),
        h.current = E
    }
    , [y]);
    return A.useImperativeHandle(n, () => ({
        pulsate: w,
        start: C,
        stop: k
    }), [w, C, k]),
    g.jsx(Kne, {
        className: Ne(ma.root, o.root, a),
        ref: v,
        ...s,
        children: g.jsx(Dg, {
            component: null,
            exit: !0,
            children: c
        })
    })
});
function ere(e) {
    return rt("MuiButtonBase", e)
}
const tre = ot("MuiButtonBase", ["root", "disabled", "focusVisible"])
  , nre = e => {
    const {disabled: t, focusVisible: n, focusVisibleClassName: r, classes: i} = e
      , a = tt({
        root: ["root", t && "disabled", n && "focusVisible"]
    }, ere, i);
    return n && r && (a.root += ` ${r}`),
    a
}
  , rre = ue("button", {
    name: "MuiButtonBase",
    slot: "Root"
})({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": {
        borderStyle: "none"
    },
    [`&.${tre.disabled}`]: {
        pointerEvents: "none",
        cursor: "default"
    },
    "@media print": {
        colorAdjust: "exact"
    }
})
  , Ka = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiButtonBase"
    })
      , {action: i, centerRipple: o=!1, children: a, className: s, component: c="button", disabled: u=!1, disableRipple: f=!1, disableTouchRipple: h=!1, focusRipple: m=!1, focusVisibleClassName: y, LinkComponent: b="a", onBlur: v, onClick: S, onContextMenu: C, onDragLeave: w, onFocus: k, onFocusVisible: T, onKeyDown: E, onKeyUp: P, onMouseDown: D, onMouseLeave: $, onMouseUp: z, onTouchEnd: O, onTouchMove: I, onTouchStart: M, tabIndex: B=0, TouchRippleProps: L, touchRippleRef: F, type: j, ...N} = r
      , H = A.useRef(null)
      , Z = Hne()
      , q = Cn(Z.ref, F)
      , [V,Y] = A.useState(!1);
    u && V && Y(!1),
    A.useImperativeHandle(i, () => ({
        focusVisible: () => {
            Y(!0),
            H.current.focus()
        }
    }), []);
    const W = Z.shouldMount && !f && !u;
    A.useEffect( () => {
        V && m && !f && Z.pulsate()
    }
    , [f, m, V, Z]);
    const te = ol(Z, "start", D, h)
      , K = ol(Z, "stop", C, h)
      , ee = ol(Z, "stop", w, h)
      , re = ol(Z, "stop", z, h)
      , ie = ol(Z, "stop", fe => {
        V && fe.preventDefault(),
        $ && $(fe)
    }
    , h)
      , J = ol(Z, "start", M, h)
      , oe = ol(Z, "stop", O, h)
      , we = ol(Z, "stop", I, h)
      , xe = ol(Z, "stop", fe => {
        m0(fe.target) || Y(!1),
        v && v(fe)
    }
    , !1)
      , se = ft(fe => {
        H.current || (H.current = fe.currentTarget),
        m0(fe.target) && (Y(!0),
        T && T(fe)),
        k && k(fe)
    }
    )
      , de = () => {
        const fe = H.current;
        return c && c !== "button" && !(fe.tagName === "A" && fe.href)
    }
      , Se = ft(fe => {
        m && !fe.repeat && V && fe.key === " " && Z.stop(fe, () => {
            Z.start(fe)
        }
        ),
        fe.target === fe.currentTarget && de() && fe.key === " " && fe.preventDefault(),
        E && E(fe),
        fe.target === fe.currentTarget && de() && fe.key === "Enter" && !u && (fe.preventDefault(),
        S && S(fe))
    }
    )
      , Ce = ft(fe => {
        m && fe.key === " " && V && !fe.defaultPrevented && Z.stop(fe, () => {
            Z.pulsate(fe)
        }
        ),
        P && P(fe),
        S && fe.target === fe.currentTarget && de() && fe.key === " " && !fe.defaultPrevented && S(fe)
    }
    );
    let Ye = c;
    Ye === "button" && (N.href || N.to) && (Ye = b);
    const ye = {};
    Ye === "button" ? (ye.type = j === void 0 ? "button" : j,
    ye.disabled = u) : (!N.href && !N.to && (ye.role = "button"),
    u && (ye["aria-disabled"] = u));
    const Ke = Cn(n, H)
      , X = {
        ...r,
        centerRipple: o,
        component: c,
        disabled: u,
        disableRipple: f,
        disableTouchRipple: h,
        focusRipple: m,
        tabIndex: B,
        focusVisible: V
    }
      , ce = nre(X);
    return g.jsxs(rre, {
        as: Ye,
        className: Ne(ce.root, s),
        ownerState: X,
        onBlur: xe,
        onClick: S,
        onContextMenu: K,
        onFocus: se,
        onKeyDown: Se,
        onKeyUp: Ce,
        onMouseDown: te,
        onMouseLeave: ie,
        onMouseUp: re,
        onDragLeave: ee,
        onTouchEnd: oe,
        onTouchMove: we,
        onTouchStart: J,
        ref: Ke,
        tabIndex: u ? -1 : B,
        type: j,
        ...ye,
        ...N,
        children: [a, W ? g.jsx(Jne, {
            ref: q,
            center: o,
            ...L
        }) : null]
    })
});
function ol(e, t, n, r=!1) {
    return ft(i => (n && n(i),
    r || e[t](i),
    !0))
}
function ire(e) {
    return typeof e.main == "string"
}
function ore(e, t=[]) {
    if (!ire(e))
        return !1;
    for (const n of t)
        if (!e.hasOwnProperty(n) || typeof e[n] != "string")
            return !1;
    return !0
}
function Qn(e=[]) {
    return ([,t]) => t && ore(t, e)
}
function are(e) {
    return rt("MuiAlert", e)
}
const g$ = ot("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
function sre(e) {
    return rt("MuiCircularProgress", e)
}
ot("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const Oa = 44
  , W2 = $s`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`
  , G2 = $s`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`
  , lre = typeof W2 != "string" ? Ac`
        animation: ${W2} 1.4s linear infinite;
      ` : null
  , cre = typeof G2 != "string" ? Ac`
        animation: ${G2} 1.4s ease-in-out infinite;
      ` : null
  , ure = e => {
    const {classes: t, variant: n, color: r, disableShrink: i} = e
      , o = {
        root: ["root", n, `color${Te(r)}`],
        svg: ["svg"],
        track: ["track"],
        circle: ["circle", `circle${Te(n)}`, i && "circleDisableShrink"]
    };
    return tt(o, sre, t)
}
  , dre = ue("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[n.variant], t[`color${Te(n.color)}`]]
    }
})(pt( ({theme: e}) => ({
    display: "inline-block",
    variants: [{
        props: {
            variant: "determinate"
        },
        style: {
            transition: e.transitions.create("transform")
        }
    }, {
        props: {
            variant: "indeterminate"
        },
        style: lre || {
            animation: `${W2} 1.4s linear infinite`
        }
    }, ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            color: (e.vars || e).palette[t].main
        }
    }))]
})))
  , fre = ue("svg", {
    name: "MuiCircularProgress",
    slot: "Svg"
})({
    display: "block"
})
  , hre = ue("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.circle, t[`circle${Te(n.variant)}`], n.disableShrink && t.circleDisableShrink]
    }
})(pt( ({theme: e}) => ({
    stroke: "currentColor",
    variants: [{
        props: {
            variant: "determinate"
        },
        style: {
            transition: e.transitions.create("stroke-dashoffset")
        }
    }, {
        props: {
            variant: "indeterminate"
        },
        style: {
            strokeDasharray: "80px, 200px",
            strokeDashoffset: 0
        }
    }, {
        props: ({ownerState: t}) => t.variant === "indeterminate" && !t.disableShrink,
        style: cre || {
            animation: `${G2} 1.4s ease-in-out infinite`
        }
    }]
})))
  , pre = ue("circle", {
    name: "MuiCircularProgress",
    slot: "Track"
})(pt( ({theme: e}) => ({
    stroke: "currentColor",
    opacity: (e.vars || e).palette.action.activatedOpacity
})))
  , Jr = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiCircularProgress"
    })
      , {className: i, color: o="primary", disableShrink: a=!1, enableTrackSlot: s=!1, size: c=40, style: u, thickness: f=3.6, value: h=0, variant: m="indeterminate", ...y} = r
      , b = {
        ...r,
        color: o,
        disableShrink: a,
        size: c,
        thickness: f,
        value: h,
        variant: m,
        enableTrackSlot: s
    }
      , v = ure(b)
      , S = {}
      , C = {}
      , w = {};
    if (m === "determinate") {
        const k = 2 * Math.PI * ((Oa - f) / 2);
        S.strokeDasharray = k.toFixed(3),
        w["aria-valuenow"] = Math.round(h),
        S.strokeDashoffset = `${((100 - h) / 100 * k).toFixed(3)}px`,
        C.transform = "rotate(-90deg)"
    }
    return g.jsx(dre, {
        className: Ne(v.root, i),
        style: {
            width: c,
            height: c,
            ...C,
            ...u
        },
        ownerState: b,
        ref: n,
        role: "progressbar",
        ...w,
        ...y,
        children: g.jsxs(fre, {
            className: v.svg,
            ownerState: b,
            viewBox: `${Oa / 2} ${Oa / 2} ${Oa} ${Oa}`,
            children: [s ? g.jsx(pre, {
                className: v.track,
                ownerState: b,
                cx: Oa,
                cy: Oa,
                r: (Oa - f) / 2,
                fill: "none",
                strokeWidth: f,
                "aria-hidden": "true"
            }) : null, g.jsx(hre, {
                className: v.circle,
                style: S,
                ownerState: b,
                cx: Oa,
                cy: Oa,
                r: (Oa - f) / 2,
                fill: "none",
                strokeWidth: f
            })]
        })
    })
});
function mre(e) {
    return rt("MuiIconButton", e)
}
const y$ = ot("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"])
  , gre = e => {
    const {classes: t, disabled: n, color: r, edge: i, size: o, loading: a} = e
      , s = {
        root: ["root", a && "loading", n && "disabled", r !== "default" && `color${Te(r)}`, i && `edge${Te(i)}`, `size${Te(o)}`],
        loadingIndicator: ["loadingIndicator"],
        loadingWrapper: ["loadingWrapper"]
    };
    return tt(s, mre, t)
}
  , yre = ue(Ka, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.loading && t.loading, n.color !== "default" && t[`color${Te(n.color)}`], n.edge && t[`edge${Te(n.edge)}`], t[`size${Te(n.size)}`]]
    }
})(pt( ({theme: e}) => ({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: e.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    color: (e.vars || e).palette.action.active,
    transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shortest
    }),
    variants: [{
        props: t => !t.disableRipple,
        style: {
            "--IconButton-hoverBg": e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity),
            "&:hover": {
                backgroundColor: "var(--IconButton-hoverBg)",
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        }
    }, {
        props: {
            edge: "start"
        },
        style: {
            marginLeft: -12
        }
    }, {
        props: {
            edge: "start",
            size: "small"
        },
        style: {
            marginLeft: -3
        }
    }, {
        props: {
            edge: "end"
        },
        style: {
            marginRight: -12
        }
    }, {
        props: {
            edge: "end",
            size: "small"
        },
        style: {
            marginRight: -3
        }
    }]
})), pt( ({theme: e}) => ({
    variants: [{
        props: {
            color: "inherit"
        },
        style: {
            color: "inherit"
        }
    }, ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            color: (e.vars || e).palette[t].main
        }
    })), ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            "--IconButton-hoverBg": e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
        }
    })), {
        props: {
            size: "small"
        },
        style: {
            padding: 5,
            fontSize: e.typography.pxToRem(18)
        }
    }, {
        props: {
            size: "large"
        },
        style: {
            padding: 12,
            fontSize: e.typography.pxToRem(28)
        }
    }],
    [`&.${y$.disabled}`]: {
        backgroundColor: "transparent",
        color: (e.vars || e).palette.action.disabled
    },
    [`&.${y$.loading}`]: {
        color: "transparent"
    }
})))
  , bre = ue("span", {
    name: "MuiIconButton",
    slot: "LoadingIndicator"
})( ({theme: e}) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    color: (e.vars || e).palette.action.disabled,
    variants: [{
        props: {
            loading: !0
        },
        style: {
            display: "flex"
        }
    }]
}))
  , In = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiIconButton"
    })
      , {edge: i=!1, children: o, className: a, color: s="default", disabled: c=!1, disableFocusRipple: u=!1, size: f="medium", id: h, loading: m=null, loadingIndicator: y, ...b} = r
      , v = Gi(h)
      , S = y ?? g.jsx(Jr, {
        "aria-labelledby": v,
        color: "inherit",
        size: 16
    })
      , C = {
        ...r,
        edge: i,
        color: s,
        disabled: c,
        disableFocusRipple: u,
        loading: m,
        loadingIndicator: S,
        size: f
    }
      , w = gre(C);
    return g.jsxs(yre, {
        id: m ? v : h,
        className: Ne(w.root, a),
        centerRipple: !0,
        focusRipple: !u,
        disabled: c || m,
        ref: n,
        ...b,
        ownerState: C,
        children: [typeof m == "boolean" && g.jsx("span", {
            className: w.loadingWrapper,
            style: {
                display: "contents"
            },
            children: g.jsx(bre, {
                className: w.loadingIndicator,
                ownerState: C,
                children: m && S
            })
        }), o]
    })
})
  , xre = _t(g.jsx("path", {
    d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}))
  , vre = _t(g.jsx("path", {
    d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}))
  , Sre = _t(g.jsx("path", {
    d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}))
  , Cre = _t(g.jsx("path", {
    d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}))
  , MN = _t(g.jsx("path", {
    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}))
  , wre = e => {
    const {variant: t, color: n, severity: r, classes: i} = e
      , o = {
        root: ["root", `color${Te(n || r)}`, `${t}${Te(n || r)}`, `${t}`],
        icon: ["icon"],
        message: ["message"],
        action: ["action"]
    };
    return tt(o, are, i)
}
  , kre = ue(yn, {
    name: "MuiAlert",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[n.variant], t[`${n.variant}${Te(n.color || n.severity)}`]]
    }
})(pt( ({theme: e}) => {
    const t = e.palette.mode === "light" ? e.darken : e.lighten
      , n = e.palette.mode === "light" ? e.lighten : e.darken;
    return {
        ...e.typography.body2,
        backgroundColor: "transparent",
        display: "flex",
        padding: "6px 16px",
        variants: [...Object.entries(e.palette).filter(Qn(["light"])).map( ([r]) => ({
            props: {
                colorSeverity: r,
                variant: "standard"
            },
            style: {
                color: e.vars ? e.vars.palette.Alert[`${r}Color`] : t(e.palette[r].light, .6),
                backgroundColor: e.vars ? e.vars.palette.Alert[`${r}StandardBg`] : n(e.palette[r].light, .9),
                [`& .${g$.icon}`]: e.vars ? {
                    color: e.vars.palette.Alert[`${r}IconColor`]
                } : {
                    color: e.palette[r].main
                }
            }
        })), ...Object.entries(e.palette).filter(Qn(["light"])).map( ([r]) => ({
            props: {
                colorSeverity: r,
                variant: "outlined"
            },
            style: {
                color: e.vars ? e.vars.palette.Alert[`${r}Color`] : t(e.palette[r].light, .6),
                border: `1px solid ${(e.vars || e).palette[r].light}`,
                [`& .${g$.icon}`]: e.vars ? {
                    color: e.vars.palette.Alert[`${r}IconColor`]
                } : {
                    color: e.palette[r].main
                }
            }
        })), ...Object.entries(e.palette).filter(Qn(["dark"])).map( ([r]) => ({
            props: {
                colorSeverity: r,
                variant: "filled"
            },
            style: {
                fontWeight: e.typography.fontWeightMedium,
                ...e.vars ? {
                    color: e.vars.palette.Alert[`${r}FilledColor`],
                    backgroundColor: e.vars.palette.Alert[`${r}FilledBg`]
                } : {
                    backgroundColor: e.palette.mode === "dark" ? e.palette[r].dark : e.palette[r].main,
                    color: e.palette.getContrastText(e.palette[r].main)
                }
            }
        }))]
    }
}
))
  , Tre = ue("div", {
    name: "MuiAlert",
    slot: "Icon"
})({
    marginRight: 12,
    padding: "7px 0",
    display: "flex",
    fontSize: 22,
    opacity: .9
})
  , _re = ue("div", {
    name: "MuiAlert",
    slot: "Message"
})({
    padding: "8px 0",
    minWidth: 0,
    overflow: "auto"
})
  , Ere = ue("div", {
    name: "MuiAlert",
    slot: "Action"
})({
    display: "flex",
    alignItems: "flex-start",
    padding: "4px 0 0 16px",
    marginLeft: "auto",
    marginRight: -8
})
  , b$ = {
    success: g.jsx(xre, {
        fontSize: "inherit"
    }),
    warning: g.jsx(vre, {
        fontSize: "inherit"
    }),
    error: g.jsx(Sre, {
        fontSize: "inherit"
    }),
    info: g.jsx(Cre, {
        fontSize: "inherit"
    })
}
  , Mc = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiAlert"
    })
      , {action: i, children: o, className: a, closeText: s="Close", color: c, components: u={}, componentsProps: f={}, icon: h, iconMapping: m=b$, onClose: y, role: b="alert", severity: v="success", slotProps: S={}, slots: C={}, variant: w="standard", ...k} = r
      , T = {
        ...r,
        color: c,
        severity: v,
        variant: w,
        colorSeverity: c || v
    }
      , E = wre(T)
      , P = {
        slots: {
            closeButton: u.CloseButton,
            closeIcon: u.CloseIcon,
            ...C
        },
        slotProps: {
            ...f,
            ...S
        }
    }
      , [D,$] = mt("root", {
        ref: n,
        shouldForwardComponentProp: !0,
        className: Ne(E.root, a),
        elementType: kre,
        externalForwardedProps: {
            ...P,
            ...k
        },
        ownerState: T,
        additionalProps: {
            role: b,
            elevation: 0
        }
    })
      , [z,O] = mt("icon", {
        className: E.icon,
        elementType: Tre,
        externalForwardedProps: P,
        ownerState: T
    })
      , [I,M] = mt("message", {
        className: E.message,
        elementType: _re,
        externalForwardedProps: P,
        ownerState: T
    })
      , [B,L] = mt("action", {
        className: E.action,
        elementType: Ere,
        externalForwardedProps: P,
        ownerState: T
    })
      , [F,j] = mt("closeButton", {
        elementType: In,
        externalForwardedProps: P,
        ownerState: T
    })
      , [N,H] = mt("closeIcon", {
        elementType: MN,
        externalForwardedProps: P,
        ownerState: T
    });
    return g.jsxs(D, {
        ...$,
        children: [h !== !1 ? g.jsx(z, {
            ...O,
            children: h || m[v] || b$[v]
        }) : null, g.jsx(I, {
            ...M,
            children: o
        }), i != null ? g.jsx(B, {
            ...L,
            children: i
        }) : null, i == null && y ? g.jsx(B, {
            ...L,
            children: g.jsx(F, {
                size: "small",
                "aria-label": s,
                title: s,
                color: "inherit",
                onClick: y,
                ...j,
                children: g.jsx(N, {
                    fontSize: "small",
                    ...H
                })
            })
        }) : null]
    })
});
function Are(e) {
    return rt("MuiTypography", e)
}
const x$ = ot("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"])
  , Mre = {
    primary: !0,
    secondary: !0,
    error: !0,
    info: !0,
    success: !0,
    warning: !0,
    textPrimary: !0,
    textSecondary: !0,
    textDisabled: !0
}
  , Pre = xne()
  , Rre = e => {
    const {align: t, gutterBottom: n, noWrap: r, paragraph: i, variant: o, classes: a} = e
      , s = {
        root: ["root", o, e.align !== "inherit" && `align${Te(t)}`, n && "gutterBottom", r && "noWrap", i && "paragraph"]
    };
    return tt(s, Are, a)
}
  , Dre = ue("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${Te(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph]
    }
})(pt( ({theme: e}) => ({
    margin: 0,
    variants: [{
        props: {
            variant: "inherit"
        },
        style: {
            font: "inherit",
            lineHeight: "inherit",
            letterSpacing: "inherit"
        }
    }, ...Object.entries(e.typography).filter( ([t,n]) => t !== "inherit" && n && typeof n == "object").map( ([t,n]) => ({
        props: {
            variant: t
        },
        style: n
    })), ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            color: (e.vars || e).palette[t].main
        }
    })), ...Object.entries(e.palette?.text || {}).filter( ([,t]) => typeof t == "string").map( ([t]) => ({
        props: {
            color: `text${Te(t)}`
        },
        style: {
            color: (e.vars || e).palette.text[t]
        }
    })), {
        props: ({ownerState: t}) => t.align !== "inherit",
        style: {
            textAlign: "var(--Typography-textAlign)"
        }
    }, {
        props: ({ownerState: t}) => t.noWrap,
        style: {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
        }
    }, {
        props: ({ownerState: t}) => t.gutterBottom,
        style: {
            marginBottom: "0.35em"
        }
    }, {
        props: ({ownerState: t}) => t.paragraph,
        style: {
            marginBottom: 16
        }
    }]
})))
  , v$ = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
}
  , Ae = A.forwardRef(function(t, n) {
    const {color: r, ...i} = gt({
        props: t,
        name: "MuiTypography"
    })
      , o = !Mre[r]
      , a = Pre({
        ...i,
        ...o && {
            color: r
        }
    })
      , {align: s="inherit", className: c, component: u, gutterBottom: f=!1, noWrap: h=!1, paragraph: m=!1, variant: y="body1", variantMapping: b=v$, ...v} = a
      , S = {
        ...a,
        align: s,
        color: r,
        className: c,
        component: u,
        gutterBottom: f,
        noWrap: h,
        paragraph: m,
        variant: y,
        variantMapping: b
    }
      , C = u || (m ? "p" : b[y] || v$[y]) || "span"
      , w = Rre(S);
    return g.jsx(Dre, {
        as: C,
        ref: n,
        className: Ne(w.root, c),
        ...v,
        ownerState: S,
        style: {
            ...s !== "inherit" && {
                "--Typography-textAlign": s
            },
            ...v.style
        }
    })
});
function Ore(e) {
    return rt("MuiAppBar", e)
}
ot("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent", "colorError", "colorInfo", "colorSuccess", "colorWarning"]);
const Ire = e => {
    const {color: t, position: n, classes: r} = e
      , i = {
        root: ["root", `color${Te(t)}`, `position${Te(n)}`]
    };
    return tt(i, Ore, r)
}
  , S$ = (e, t) => e ? `${e?.replace(")", "")}, ${t})` : t
  , $re = ue(yn, {
    name: "MuiAppBar",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[`position${Te(n.position)}`], t[`color${Te(n.color)}`]]
    }
})(pt( ({theme: e}) => ({
    display: "flex",
    flexDirection: "column",
    width: "100%",
    boxSizing: "border-box",
    flexShrink: 0,
    variants: [{
        props: {
            position: "fixed"
        },
        style: {
            position: "fixed",
            zIndex: (e.vars || e).zIndex.appBar,
            top: 0,
            left: "auto",
            right: 0,
            "@media print": {
                position: "absolute"
            }
        }
    }, {
        props: {
            position: "absolute"
        },
        style: {
            position: "absolute",
            zIndex: (e.vars || e).zIndex.appBar,
            top: 0,
            left: "auto",
            right: 0
        }
    }, {
        props: {
            position: "sticky"
        },
        style: {
            position: "sticky",
            zIndex: (e.vars || e).zIndex.appBar,
            top: 0,
            left: "auto",
            right: 0
        }
    }, {
        props: {
            position: "static"
        },
        style: {
            position: "static"
        }
    }, {
        props: {
            position: "relative"
        },
        style: {
            position: "relative"
        }
    }, {
        props: {
            color: "inherit"
        },
        style: {
            "--AppBar-color": "inherit"
        }
    }, {
        props: {
            color: "default"
        },
        style: {
            "--AppBar-background": e.vars ? e.vars.palette.AppBar.defaultBg : e.palette.grey[100],
            "--AppBar-color": e.vars ? e.vars.palette.text.primary : e.palette.getContrastText(e.palette.grey[100]),
            ...e.applyStyles("dark", {
                "--AppBar-background": e.vars ? e.vars.palette.AppBar.defaultBg : e.palette.grey[900],
                "--AppBar-color": e.vars ? e.vars.palette.text.primary : e.palette.getContrastText(e.palette.grey[900])
            })
        }
    }, ...Object.entries(e.palette).filter(Qn(["contrastText"])).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            "--AppBar-background": (e.vars ?? e).palette[t].main,
            "--AppBar-color": (e.vars ?? e).palette[t].contrastText
        }
    })), {
        props: t => t.enableColorOnDark === !0 && !["inherit", "transparent"].includes(t.color),
        style: {
            backgroundColor: "var(--AppBar-background)",
            color: "var(--AppBar-color)"
        }
    }, {
        props: t => t.enableColorOnDark === !1 && !["inherit", "transparent"].includes(t.color),
        style: {
            backgroundColor: "var(--AppBar-background)",
            color: "var(--AppBar-color)",
            ...e.applyStyles("dark", {
                backgroundColor: e.vars ? S$(e.vars.palette.AppBar.darkBg, "var(--AppBar-background)") : null,
                color: e.vars ? S$(e.vars.palette.AppBar.darkColor, "var(--AppBar-color)") : null
            })
        }
    }, {
        props: {
            color: "transparent"
        },
        style: {
            "--AppBar-background": "transparent",
            "--AppBar-color": "inherit",
            backgroundColor: "var(--AppBar-background)",
            color: "var(--AppBar-color)",
            ...e.applyStyles("dark", {
                backgroundImage: "none"
            })
        }
    }]
})))
  , PN = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiAppBar"
    })
      , {className: i, color: o="primary", enableColorOnDark: a=!1, position: s="fixed", ...c} = r
      , u = {
        ...r,
        color: o,
        position: s,
        enableColorOnDark: a
    }
      , f = Ire(u);
    return g.jsx($re, {
        square: !0,
        component: "header",
        ownerState: u,
        elevation: 4,
        className: Ne(f.root, i, s === "fixed" && "mui-fixed"),
        ref: n,
        ...c
    })
});
function RE(e) {
    const t = A.useRef({});
    return A.useEffect( () => {
        t.current = e
    }
    ),
    t.current
}
function C$({array1: e, array2: t, parser: n=r => r}) {
    return e && t && e.length === t.length && e.every( (r, i) => n(r) === n(t[i]))
}
function w$(e) {
    return e.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
}
function Lre(e={}) {
    const {ignoreAccents: t=!0, ignoreCase: n=!0, limit: r, matchFrom: i="any", stringify: o, trim: a=!1} = e;
    return (s, {inputValue: c, getOptionLabel: u}) => {
        let f = a ? c.trim() : c;
        n && (f = f.toLowerCase()),
        t && (f = w$(f));
        const h = f ? s.filter(m => {
            let y = (o || u)(m);
            return n && (y = y.toLowerCase()),
            t && (y = w$(y)),
            i === "start" ? y.startsWith(f) : y.includes(f)
        }
        ) : s;
        return typeof r == "number" ? h.slice(0, r) : h
    }
}
const jre = Lre()
  , k$ = 5
  , Bre = e => e.current !== null && e.current.parentElement?.contains(document.activeElement)
  , zre = [];
function T$(e, t, n, r) {
    if (t || e == null || r)
        return "";
    const i = n(e);
    return typeof i == "string" ? i : ""
}
function Fre(e) {
    const {unstable_isActiveElementInListbox: t=Bre, unstable_classNamePrefix: n="Mui", autoComplete: r=!1, autoHighlight: i=!1, autoSelect: o=!1, blurOnSelect: a=!1, clearOnBlur: s=!e.freeSolo, clearOnEscape: c=!1, componentName: u="useAutocomplete", defaultValue: f=e.multiple ? zre : null, disableClearable: h=!1, disableCloseOnSelect: m=!1, disabled: y, disabledItemsFocusable: b=!1, disableListWrap: v=!1, filterOptions: S=jre, filterSelectedOptions: C=!1, freeSolo: w=!1, getOptionDisabled: k, getOptionKey: T, getOptionLabel: E=Fe => Fe.label ?? Fe, groupBy: P, handleHomeEndKeys: D=!e.freeSolo, id: $, includeInputInList: z=!1, inputValue: O, isOptionEqualToValue: I= (Fe, me) => Fe === me, multiple: M=!1, onChange: B, onClose: L, onHighlightChange: F, onInputChange: j, onOpen: N, open: H, openOnFocus: Z=!1, options: q, readOnly: V=!1, renderValue: Y, selectOnFocus: W=!e.freeSolo, value: te} = e
      , K = Gi($);
    let ee = E;
    ee = Fe => {
        const me = E(Fe);
        return typeof me != "string" ? String(me) : me
    }
    ;
    const re = A.useRef(!1)
      , ie = A.useRef(!0)
      , J = A.useRef(null)
      , oe = A.useRef(null)
      , [we,xe] = A.useState(null)
      , [se,de] = A.useState(-1)
      , Se = i ? 0 : -1
      , Ce = A.useRef(Se)
      , Ye = A.useRef(T$(f ?? te, M, ee)).current
      , [ye,Ke] = go({
        controlled: te,
        default: f,
        name: u
    })
      , [X,ce] = go({
        controlled: O,
        default: Ye,
        name: u,
        state: "inputValue"
    })
      , [fe,Xe] = A.useState(!1)
      , Oe = A.useCallback( (Fe, me, ne) => {
        if (!(M ? ye.length < me.length : me !== null) && !s)
            return;
        const Ze = T$(me, M, ee, Y);
        X !== Ze && (ce(Ze),
        j && j(Fe, Ze, ne))
    }
    , [ee, X, M, j, ce, s, ye, Y])
      , [Re,le] = go({
        controlled: H,
        default: !1,
        name: u,
        state: "open"
    })
      , [ke,He] = A.useState(!0)
      , st = !M && ye != null && X === ee(ye)
      , lt = Re && !V
      , et = lt ? S(q.filter(Fe => !(C && (M ? ye : [ye]).some(me => me !== null && I(Fe, me)))), {
        inputValue: st && ke ? "" : X,
        getOptionLabel: ee
    }) : []
      , Ht = RE({
        filteredOptions: et,
        value: ye,
        inputValue: X
    });
    A.useEffect( () => {
        const Fe = ye !== Ht.value;
        fe && !Fe || w && !Fe || Oe(null, ye, "reset")
    }
    , [ye, Oe, fe, Ht.value, w]);
    const Ft = Re && et.length > 0 && !V
      , Pt = ft(Fe => {
        if (Fe === -1)
            J.current.focus();
        else {
            const me = Y ? "data-item-index" : "data-tag-index";
            we.querySelector(`[${me}="${Fe}"]`).focus()
        }
    }
    );
    A.useEffect( () => {
        M && se > ye.length - 1 && (de(-1),
        Pt(-1))
    }
    , [ye, M, se, Pt]);
    function nt(Fe, me) {
        if (!oe.current || Fe < 0 || Fe >= et.length)
            return -1;
        let ne = Fe;
        for (; ; ) {
            const De = oe.current.querySelector(`[data-option-index="${ne}"]`)
              , Ze = b ? !1 : !De || De.disabled || De.getAttribute("aria-disabled") === "true";
            if (De && De.hasAttribute("tabindex") && !Ze)
                return ne;
            if (me === "next" ? ne = (ne + 1) % et.length : ne = (ne - 1 + et.length) % et.length,
            ne === Fe)
                return -1
        }
    }
    const ut = ft( ({event: Fe, index: me, reason: ne}) => {
        if (Ce.current = me,
        me === -1 ? J.current.removeAttribute("aria-activedescendant") : J.current.setAttribute("aria-activedescendant", `${K}-option-${me}`),
        F && ["mouse", "keyboard", "touch"].includes(ne) && F(Fe, me === -1 ? null : et[me], ne),
        !oe.current)
            return;
        const De = oe.current.querySelector(`[role="option"].${n}-focused`);
        De && (De.classList.remove(`${n}-focused`),
        De.classList.remove(`${n}-focusVisible`));
        let Ze = oe.current;
        if (oe.current.getAttribute("role") !== "listbox" && (Ze = oe.current.parentElement.querySelector('[role="listbox"]')),
        !Ze)
            return;
        if (me === -1) {
            Ze.scrollTop = 0;
            return
        }
        const Wt = oe.current.querySelector(`[data-option-index="${me}"]`);
        if (Wt && (Wt.classList.add(`${n}-focused`),
        ne === "keyboard" && Wt.classList.add(`${n}-focusVisible`),
        Ze.scrollHeight > Ze.clientHeight && ne !== "mouse" && ne !== "touch")) {
            const Zt = Wt
              , Nt = Ze.clientHeight + Ze.scrollTop
              , _r = Zt.offsetTop + Zt.offsetHeight;
            _r > Nt ? Ze.scrollTop = _r - Ze.clientHeight : Zt.offsetTop - Zt.offsetHeight * (P ? 1.3 : 0) < Ze.scrollTop && (Ze.scrollTop = Zt.offsetTop - Zt.offsetHeight * (P ? 1.3 : 0))
        }
    }
    )
      , Lt = ft( ({event: Fe, diff: me, direction: ne="next", reason: De}) => {
        if (!lt)
            return;
        const Wt = nt(( () => {
            const Zt = et.length - 1;
            if (me === "reset")
                return Se;
            if (me === "start")
                return 0;
            if (me === "end")
                return Zt;
            const Nt = Ce.current + me;
            return Nt < 0 ? Nt === -1 && z ? -1 : v && Ce.current !== -1 || Math.abs(me) > 1 ? 0 : Zt : Nt > Zt ? Nt === Zt + 1 && z ? -1 : v || Math.abs(me) > 1 ? Zt : 0 : Nt
        }
        )(), ne);
        if (ut({
            index: Wt,
            reason: De,
            event: Fe
        }),
        r && me !== "reset")
            if (Wt === -1)
                J.current.value = X;
            else {
                const Zt = ee(et[Wt]);
                J.current.value = Zt,
                Zt.toLowerCase().indexOf(X.toLowerCase()) === 0 && X.length > 0 && J.current.setSelectionRange(X.length, Zt.length)
            }
    }
    )
      , tn = !C$({
        array1: Ht.filteredOptions,
        array2: et,
        parser: ee
    })
      , Xt = () => {
        const Fe = (me, ne) => {
            const De = me ? ee(me) : ""
              , Ze = ne ? ee(ne) : "";
            return De === Ze
        }
        ;
        if (Ce.current !== -1 && !C$({
            array1: Ht.filteredOptions,
            array2: et,
            parser: ee
        }) && Ht.inputValue === X && (M ? ye.length === Ht.value.length && Ht.value.every( (me, ne) => ee(ye[ne]) === ee(me)) : Fe(Ht.value, ye))) {
            const me = Ht.filteredOptions[Ce.current];
            if (me)
                return et.findIndex(ne => ee(ne) === ee(me))
        }
        return -1
    }
      , Mn = A.useCallback( () => {
        if (!lt)
            return;
        const Fe = Xt();
        if (Fe !== -1) {
            Ce.current = Fe;
            return
        }
        const me = M ? ye[0] : ye;
        if (et.length === 0 || me == null) {
            Lt({
                diff: "reset"
            });
            return
        }
        if (oe.current) {
            if (me != null) {
                const ne = et[Ce.current];
                if (M && ne && ye.findIndex(Ze => I(ne, Ze)) !== -1)
                    return;
                const De = et.findIndex(Ze => I(Ze, me));
                De === -1 ? Lt({
                    diff: "reset"
                }) : ut({
                    index: De
                });
                return
            }
            if (Ce.current >= et.length - 1) {
                ut({
                    index: et.length - 1
                });
                return
            }
            ut({
                index: Ce.current
            })
        }
    }
    , [et.length, M ? !1 : ye, C, Lt, ut, lt, X, M])
      , Pn = ft(Fe => {
        U2(oe, Fe),
        Fe && Mn()
    }
    );
    A.useEffect( () => {
        (tn || lt) && Mn()
    }
    , [Mn, tn, lt]);
    const wn = Fe => {
        Re || (le(!0),
        He(!0),
        N && N(Fe))
    }
      , Kn = (Fe, me) => {
        Re && (le(!1),
        L && L(Fe, me))
    }
      , vr = (Fe, me, ne, De) => {
        if (M) {
            if (ye.length === me.length && ye.every( (Ze, Wt) => Ze === me[Wt]))
                return
        } else if (ye === me)
            return;
        B && B(Fe, me, ne, De),
        Ke(me)
    }
      , mr = A.useRef(!1)
      , kn = (Fe, me, ne="selectOption", De="options") => {
        let Ze = ne
          , Wt = me;
        if (M) {
            Wt = Array.isArray(ye) ? ye.slice() : [];
            const Zt = Wt.findIndex(Nt => I(me, Nt));
            Zt === -1 ? Wt.push(me) : De !== "freeSolo" && (Wt.splice(Zt, 1),
            Ze = "removeOption")
        }
        Oe(Fe, Wt, Ze),
        vr(Fe, Wt, Ze, {
            option: me
        }),
        !m && (!Fe || !Fe.ctrlKey && !Fe.metaKey) && Kn(Fe, Ze),
        (a === !0 || a === "touch" && mr.current || a === "mouse" && !mr.current) && J.current.blur()
    }
    ;
    function At(Fe, me) {
        if (Fe === -1)
            return -1;
        let ne = Fe;
        for (; ; ) {
            if (me === "next" && ne === ye.length || me === "previous" && ne === -1)
                return -1;
            const De = Y ? "data-item-index" : "data-tag-index"
              , Ze = we.querySelector(`[${De}="${ne}"]`);
            if (!Ze || !Ze.hasAttribute("tabindex") || Ze.disabled || Ze.getAttribute("aria-disabled") === "true")
                ne += me === "next" ? 1 : -1;
            else
                return ne
        }
    }
    const nr = (Fe, me) => {
        if (!M)
            return;
        X === "" && Kn(Fe, "toggleInput");
        let ne = se;
        se === -1 ? X === "" && me === "previous" && (ne = ye.length - 1) : (ne += me === "next" ? 1 : -1,
        ne < 0 && (ne = 0),
        ne === ye.length && (ne = -1)),
        ne = At(ne, me),
        de(ne),
        Pt(ne)
    }
      , he = Fe => {
        re.current = !0,
        ce(""),
        j && j(Fe, "", "clear"),
        vr(Fe, M ? [] : null, "clear")
    }
      , Le = Fe => me => {
        if (Fe.onKeyDown && Fe.onKeyDown(me),
        !me.defaultMuiPrevented && (se !== -1 && !["ArrowLeft", "ArrowRight"].includes(me.key) && (de(-1),
        Pt(-1)),
        me.which !== 229))
            switch (me.key) {
            case "Home":
                lt && D && (me.preventDefault(),
                Lt({
                    diff: "start",
                    direction: "next",
                    reason: "keyboard",
                    event: me
                }));
                break;
            case "End":
                lt && D && (me.preventDefault(),
                Lt({
                    diff: "end",
                    direction: "previous",
                    reason: "keyboard",
                    event: me
                }));
                break;
            case "PageUp":
                me.preventDefault(),
                Lt({
                    diff: -k$,
                    direction: "previous",
                    reason: "keyboard",
                    event: me
                }),
                wn(me);
                break;
            case "PageDown":
                me.preventDefault(),
                Lt({
                    diff: k$,
                    direction: "next",
                    reason: "keyboard",
                    event: me
                }),
                wn(me);
                break;
            case "ArrowDown":
                me.preventDefault(),
                Lt({
                    diff: 1,
                    direction: "next",
                    reason: "keyboard",
                    event: me
                }),
                wn(me);
                break;
            case "ArrowUp":
                me.preventDefault(),
                Lt({
                    diff: -1,
                    direction: "previous",
                    reason: "keyboard",
                    event: me
                }),
                wn(me);
                break;
            case "ArrowLeft":
                !M && Y ? Pt(0) : nr(me, "previous");
                break;
            case "ArrowRight":
                !M && Y ? Pt(-1) : nr(me, "next");
                break;
            case "Enter":
                if (Ce.current !== -1 && lt) {
                    const ne = et[Ce.current]
                      , De = k ? k(ne) : !1;
                    if (me.preventDefault(),
                    De)
                        return;
                    kn(me, ne, "selectOption"),
                    r && J.current.setSelectionRange(J.current.value.length, J.current.value.length)
                } else
                    w && X !== "" && st === !1 && (M && me.preventDefault(),
                    kn(me, X, "createOption", "freeSolo"));
                break;
            case "Escape":
                lt ? (me.preventDefault(),
                me.stopPropagation(),
                Kn(me, "escape")) : c && (X !== "" || M && ye.length > 0 || Y) && (me.preventDefault(),
                me.stopPropagation(),
                he(me));
                break;
            case "Backspace":
                if (M && !V && X === "" && ye.length > 0) {
                    const ne = se === -1 ? ye.length - 1 : se
                      , De = ye.slice();
                    De.splice(ne, 1),
                    vr(me, De, "removeOption", {
                        option: ye[ne]
                    })
                }
                !M && Y && !V && (Ke(null),
                Pt(-1));
                break;
            case "Delete":
                if (M && !V && X === "" && ye.length > 0 && se !== -1) {
                    const ne = se
                      , De = ye.slice();
                    De.splice(ne, 1),
                    vr(me, De, "removeOption", {
                        option: ye[ne]
                    })
                }
                !M && Y && !V && (Ke(null),
                Pt(-1));
                break
            }
    }
      , it = Fe => {
        Xe(!0),
        Z && !re.current && wn(Fe)
    }
      , Je = Fe => {
        if (t(oe)) {
            J.current.focus();
            return
        }
        Xe(!1),
        ie.current = !0,
        re.current = !1,
        o && Ce.current !== -1 && lt ? kn(Fe, et[Ce.current], "blur") : o && w && X !== "" ? kn(Fe, X, "blur", "freeSolo") : s && Oe(Fe, ye, "blur"),
        Kn(Fe, "blur")
    }
      , Jt = Fe => {
        const me = Fe.target.value;
        X !== me && (ce(me),
        He(!1),
        j && j(Fe, me, "input")),
        me === "" ? !h && !M && vr(Fe, null, "clear") : wn(Fe)
    }
      , qt = Fe => {
        const me = Number(Fe.currentTarget.getAttribute("data-option-index"));
        Ce.current !== me && ut({
            event: Fe,
            index: me,
            reason: "mouse"
        })
    }
      , dn = Fe => {
        ut({
            event: Fe,
            index: Number(Fe.currentTarget.getAttribute("data-option-index")),
            reason: "touch"
        }),
        mr.current = !0
    }
      , Ir = Fe => {
        const me = Number(Fe.currentTarget.getAttribute("data-option-index"));
        kn(Fe, et[me], "selectOption"),
        mr.current = !1
    }
      , Ki = Fe => me => {
        const ne = ye.slice();
        ne.splice(Fe, 1),
        vr(me, ne, "removeOption", {
            option: ye[Fe]
        })
    }
      , Tr = Fe => {
        vr(Fe, null, "removeOption", {
            option: ye
        })
    }
      , ln = Fe => {
        Re ? Kn(Fe, "toggleInput") : wn(Fe)
    }
      , en = Fe => {
        Fe.currentTarget.contains(Fe.target) && Fe.target.getAttribute("id") !== K && Fe.preventDefault()
    }
      , si = Fe => {
        Fe.currentTarget.contains(Fe.target) && (J.current.focus(),
        W && ie.current && J.current.selectionEnd - J.current.selectionStart === 0 && J.current.select(),
        ie.current = !1)
    }
      , is = Fe => {
        !y && (X === "" || !Re) && ln(Fe)
    }
    ;
    let os = w && X.length > 0;
    os = os || (M ? ye.length > 0 : ye !== null);
    let zs = et;
    return P && (zs = et.reduce( (Fe, me, ne) => {
        const De = P(me);
        return Fe.length > 0 && Fe[Fe.length - 1].group === De ? Fe[Fe.length - 1].options.push(me) : Fe.push({
            key: ne,
            index: ne,
            group: De,
            options: [me]
        }),
        Fe
    }
    , [])),
    y && fe && Je(),
    {
        getRootProps: (Fe={}) => ({
            ...Fe,
            onKeyDown: Le(Fe),
            onMouseDown: en,
            onClick: si
        }),
        getInputLabelProps: () => ({
            id: `${K}-label`,
            htmlFor: K
        }),
        getInputProps: () => ({
            id: K,
            value: X,
            onBlur: Je,
            onFocus: it,
            onChange: Jt,
            onMouseDown: is,
            "aria-activedescendant": lt ? "" : null,
            "aria-autocomplete": r ? "both" : "list",
            "aria-controls": Ft ? `${K}-listbox` : void 0,
            "aria-expanded": Ft,
            autoComplete: "off",
            ref: J,
            autoCapitalize: "none",
            spellCheck: "false",
            role: "combobox",
            disabled: y
        }),
        getClearProps: () => ({
            tabIndex: -1,
            type: "button",
            onClick: he
        }),
        getItemProps: ({index: Fe=0}={}) => ({
            ...M && {
                key: Fe
            },
            ...Y ? {
                "data-item-index": Fe
            } : {
                "data-tag-index": Fe
            },
            tabIndex: -1,
            ...!V && {
                onDelete: M ? Ki(Fe) : Tr
            }
        }),
        getPopupIndicatorProps: () => ({
            tabIndex: -1,
            type: "button",
            onClick: ln
        }),
        getTagProps: ({index: Fe}) => ({
            key: Fe,
            "data-tag-index": Fe,
            tabIndex: -1,
            ...!V && {
                onDelete: Ki(Fe)
            }
        }),
        getListboxProps: () => ({
            role: "listbox",
            id: `${K}-listbox`,
            "aria-labelledby": `${K}-label`,
            ref: Pn,
            onMouseDown: Fe => {
                Fe.preventDefault()
            }
        }),
        getOptionProps: ({index: Fe, option: me}) => {
            const ne = (M ? ye : [ye]).some(Ze => Ze != null && I(me, Ze))
              , De = k ? k(me) : !1;
            return {
                key: T?.(me) ?? ee(me),
                tabIndex: -1,
                role: "option",
                id: `${K}-option-${Fe}`,
                onMouseMove: qt,
                onClick: Ir,
                onTouchStart: dn,
                "data-option-index": Fe,
                "aria-disabled": De,
                "aria-selected": ne
            }
        }
        ,
        id: K,
        inputValue: X,
        value: ye,
        dirty: os,
        expanded: lt && we,
        popupOpen: lt,
        focused: fe || se !== -1,
        anchorEl: we,
        setAnchorEl: xe,
        focusedItem: se,
        focusedTag: se,
        groupedOptions: zs
    }
}
var yo = "top"
  , Sa = "bottom"
  , Ca = "right"
  , bo = "left"
  , DE = "auto"
  , Og = [yo, Sa, Ca, bo]
  , Uf = "start"
  , Hm = "end"
  , Nre = "clippingParents"
  , RN = "viewport"
  , bp = "popper"
  , Ure = "reference"
  , _$ = Og.reduce(function(e, t) {
    return e.concat([t + "-" + Uf, t + "-" + Hm])
}, [])
  , DN = [].concat(Og, [DE]).reduce(function(e, t) {
    return e.concat([t, t + "-" + Uf, t + "-" + Hm])
}, [])
  , Vre = "beforeRead"
  , Hre = "read"
  , qre = "afterRead"
  , Wre = "beforeMain"
  , Gre = "main"
  , Yre = "afterMain"
  , Zre = "beforeWrite"
  , Qre = "write"
  , Kre = "afterWrite"
  , Xre = [Vre, Hre, qre, Wre, Gre, Yre, Zre, Qre, Kre];
function _s(e) {
    return e ? (e.nodeName || "").toLowerCase() : null
}
function Qo(e) {
    if (e == null)
        return window;
    if (e.toString() !== "[object Window]") {
        var t = e.ownerDocument;
        return t && t.defaultView || window
    }
    return e
}
function Bu(e) {
    var t = Qo(e).Element;
    return e instanceof t || e instanceof Element
}
function va(e) {
    var t = Qo(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement
}
function OE(e) {
    if (typeof ShadowRoot > "u")
        return !1;
    var t = Qo(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot
}
function Jre(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function(n) {
        var r = t.styles[n] || {}
          , i = t.attributes[n] || {}
          , o = t.elements[n];
        !va(o) || !_s(o) || (Object.assign(o.style, r),
        Object.keys(i).forEach(function(a) {
            var s = i[a];
            s === !1 ? o.removeAttribute(a) : o.setAttribute(a, s === !0 ? "" : s)
        }))
    })
}
function eie(e) {
    var t = e.state
      , n = {
        popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    return Object.assign(t.elements.popper.style, n.popper),
    t.styles = n,
    t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
    function() {
        Object.keys(t.elements).forEach(function(r) {
            var i = t.elements[r]
              , o = t.attributes[r] || {}
              , a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r])
              , s = a.reduce(function(c, u) {
                return c[u] = "",
                c
            }, {});
            !va(i) || !_s(i) || (Object.assign(i.style, s),
            Object.keys(o).forEach(function(c) {
                i.removeAttribute(c)
            }))
        })
    }
}
const tie = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: Jre,
    effect: eie,
    requires: ["computeStyles"]
};
function Cs(e) {
    return e.split("-")[0]
}
var Mu = Math.max
  , y0 = Math.min
  , Vf = Math.round;
function Y2() {
    var e = navigator.userAgentData;
    return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
        return t.brand + "/" + t.version
    }).join(" ") : navigator.userAgent
}
function ON() {
    return !/^((?!chrome|android).)*safari/i.test(Y2())
}
function Hf(e, t, n) {
    t === void 0 && (t = !1),
    n === void 0 && (n = !1);
    var r = e.getBoundingClientRect()
      , i = 1
      , o = 1;
    t && va(e) && (i = e.offsetWidth > 0 && Vf(r.width) / e.offsetWidth || 1,
    o = e.offsetHeight > 0 && Vf(r.height) / e.offsetHeight || 1);
    var a = Bu(e) ? Qo(e) : window
      , s = a.visualViewport
      , c = !ON() && n
      , u = (r.left + (c && s ? s.offsetLeft : 0)) / i
      , f = (r.top + (c && s ? s.offsetTop : 0)) / o
      , h = r.width / i
      , m = r.height / o;
    return {
        width: h,
        height: m,
        top: f,
        right: u + h,
        bottom: f + m,
        left: u,
        x: u,
        y: f
    }
}
function IE(e) {
    var t = Hf(e)
      , n = e.offsetWidth
      , r = e.offsetHeight;
    return Math.abs(t.width - n) <= 1 && (n = t.width),
    Math.abs(t.height - r) <= 1 && (r = t.height),
    {
        x: e.offsetLeft,
        y: e.offsetTop,
        width: n,
        height: r
    }
}
function IN(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t))
        return !0;
    if (n && OE(n)) {
        var r = t;
        do {
            if (r && e.isSameNode(r))
                return !0;
            r = r.parentNode || r.host
        } while (r)
    }
    return !1
}
function wl(e) {
    return Qo(e).getComputedStyle(e)
}
function nie(e) {
    return ["table", "td", "th"].indexOf(_s(e)) >= 0
}
function Pc(e) {
    return ((Bu(e) ? e.ownerDocument : e.document) || window.document).documentElement
}
function Zv(e) {
    return _s(e) === "html" ? e : e.assignedSlot || e.parentNode || (OE(e) ? e.host : null) || Pc(e)
}
function E$(e) {
    return !va(e) || wl(e).position === "fixed" ? null : e.offsetParent
}
function rie(e) {
    var t = /firefox/i.test(Y2())
      , n = /Trident/i.test(Y2());
    if (n && va(e)) {
        var r = wl(e);
        if (r.position === "fixed")
            return null
    }
    var i = Zv(e);
    for (OE(i) && (i = i.host); va(i) && ["html", "body"].indexOf(_s(i)) < 0; ) {
        var o = wl(i);
        if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
            return i;
        i = i.parentNode
    }
    return null
}
function Ig(e) {
    for (var t = Qo(e), n = E$(e); n && nie(n) && wl(n).position === "static"; )
        n = E$(n);
    return n && (_s(n) === "html" || _s(n) === "body" && wl(n).position === "static") ? t : n || rie(e) || t
}
function $E(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function hm(e, t, n) {
    return Mu(e, y0(t, n))
}
function iie(e, t, n) {
    var r = hm(e, t, n);
    return r > n ? n : r
}
function $N() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function LN(e) {
    return Object.assign({}, $N(), e)
}
function jN(e, t) {
    return t.reduce(function(n, r) {
        return n[r] = e,
        n
    }, {})
}
var oie = function(t, n) {
    return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
        placement: n.placement
    })) : t,
    LN(typeof t != "number" ? t : jN(t, Og))
};
function aie(e) {
    var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, a = n.modifiersData.popperOffsets, s = Cs(n.placement), c = $E(s), u = [bo, Ca].indexOf(s) >= 0, f = u ? "height" : "width";
    if (!(!o || !a)) {
        var h = oie(i.padding, n)
          , m = IE(o)
          , y = c === "y" ? yo : bo
          , b = c === "y" ? Sa : Ca
          , v = n.rects.reference[f] + n.rects.reference[c] - a[c] - n.rects.popper[f]
          , S = a[c] - n.rects.reference[c]
          , C = Ig(o)
          , w = C ? c === "y" ? C.clientHeight || 0 : C.clientWidth || 0 : 0
          , k = v / 2 - S / 2
          , T = h[y]
          , E = w - m[f] - h[b]
          , P = w / 2 - m[f] / 2 + k
          , D = hm(T, P, E)
          , $ = c;
        n.modifiersData[r] = (t = {},
        t[$] = D,
        t.centerOffset = D - P,
        t)
    }
}
function sie(e) {
    var t = e.state
      , n = e.options
      , r = n.element
      , i = r === void 0 ? "[data-popper-arrow]" : r;
    i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i),
    !i) || IN(t.elements.popper, i) && (t.elements.arrow = i))
}
const lie = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: aie,
    effect: sie,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function qf(e) {
    return e.split("-")[1]
}
var cie = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function uie(e, t) {
    var n = e.x
      , r = e.y
      , i = t.devicePixelRatio || 1;
    return {
        x: Vf(n * i) / i || 0,
        y: Vf(r * i) / i || 0
    }
}
function A$(e) {
    var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, a = e.offsets, s = e.position, c = e.gpuAcceleration, u = e.adaptive, f = e.roundOffsets, h = e.isFixed, m = a.x, y = m === void 0 ? 0 : m, b = a.y, v = b === void 0 ? 0 : b, S = typeof f == "function" ? f({
        x: y,
        y: v
    }) : {
        x: y,
        y: v
    };
    y = S.x,
    v = S.y;
    var C = a.hasOwnProperty("x")
      , w = a.hasOwnProperty("y")
      , k = bo
      , T = yo
      , E = window;
    if (u) {
        var P = Ig(n)
          , D = "clientHeight"
          , $ = "clientWidth";
        if (P === Qo(n) && (P = Pc(n),
        wl(P).position !== "static" && s === "absolute" && (D = "scrollHeight",
        $ = "scrollWidth")),
        P = P,
        i === yo || (i === bo || i === Ca) && o === Hm) {
            T = Sa;
            var z = h && P === E && E.visualViewport ? E.visualViewport.height : P[D];
            v -= z - r.height,
            v *= c ? 1 : -1
        }
        if (i === bo || (i === yo || i === Sa) && o === Hm) {
            k = Ca;
            var O = h && P === E && E.visualViewport ? E.visualViewport.width : P[$];
            y -= O - r.width,
            y *= c ? 1 : -1
        }
    }
    var I = Object.assign({
        position: s
    }, u && cie)
      , M = f === !0 ? uie({
        x: y,
        y: v
    }, Qo(n)) : {
        x: y,
        y: v
    };
    if (y = M.x,
    v = M.y,
    c) {
        var B;
        return Object.assign({}, I, (B = {},
        B[T] = w ? "0" : "",
        B[k] = C ? "0" : "",
        B.transform = (E.devicePixelRatio || 1) <= 1 ? "translate(" + y + "px, " + v + "px)" : "translate3d(" + y + "px, " + v + "px, 0)",
        B))
    }
    return Object.assign({}, I, (t = {},
    t[T] = w ? v + "px" : "",
    t[k] = C ? y + "px" : "",
    t.transform = "",
    t))
}
function die(e) {
    var t = e.state
      , n = e.options
      , r = n.gpuAcceleration
      , i = r === void 0 ? !0 : r
      , o = n.adaptive
      , a = o === void 0 ? !0 : o
      , s = n.roundOffsets
      , c = s === void 0 ? !0 : s
      , u = {
        placement: Cs(t.placement),
        variation: qf(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: i,
        isFixed: t.options.strategy === "fixed"
    };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, A$(Object.assign({}, u, {
        offsets: t.modifiersData.popperOffsets,
        position: t.options.strategy,
        adaptive: a,
        roundOffsets: c
    })))),
    t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, A$(Object.assign({}, u, {
        offsets: t.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: c
    })))),
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
    })
}
const fie = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: die,
    data: {}
};
var Db = {
    passive: !0
};
function hie(e) {
    var t = e.state
      , n = e.instance
      , r = e.options
      , i = r.scroll
      , o = i === void 0 ? !0 : i
      , a = r.resize
      , s = a === void 0 ? !0 : a
      , c = Qo(t.elements.popper)
      , u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return o && u.forEach(function(f) {
        f.addEventListener("scroll", n.update, Db)
    }),
    s && c.addEventListener("resize", n.update, Db),
    function() {
        o && u.forEach(function(f) {
            f.removeEventListener("scroll", n.update, Db)
        }),
        s && c.removeEventListener("resize", n.update, Db)
    }
}
const pie = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect: hie,
    data: {}
};
var mie = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function Ax(e) {
    return e.replace(/left|right|bottom|top/g, function(t) {
        return mie[t]
    })
}
var gie = {
    start: "end",
    end: "start"
};
function M$(e) {
    return e.replace(/start|end/g, function(t) {
        return gie[t]
    })
}
function LE(e) {
    var t = Qo(e)
      , n = t.pageXOffset
      , r = t.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}
function jE(e) {
    return Hf(Pc(e)).left + LE(e).scrollLeft
}
function yie(e, t) {
    var n = Qo(e)
      , r = Pc(e)
      , i = n.visualViewport
      , o = r.clientWidth
      , a = r.clientHeight
      , s = 0
      , c = 0;
    if (i) {
        o = i.width,
        a = i.height;
        var u = ON();
        (u || !u && t === "fixed") && (s = i.offsetLeft,
        c = i.offsetTop)
    }
    return {
        width: o,
        height: a,
        x: s + jE(e),
        y: c
    }
}
function bie(e) {
    var t, n = Pc(e), r = LE(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, o = Mu(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = Mu(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + jE(e), c = -r.scrollTop;
    return wl(i || n).direction === "rtl" && (s += Mu(n.clientWidth, i ? i.clientWidth : 0) - o),
    {
        width: o,
        height: a,
        x: s,
        y: c
    }
}
function BE(e) {
    var t = wl(e)
      , n = t.overflow
      , r = t.overflowX
      , i = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r)
}
function BN(e) {
    return ["html", "body", "#document"].indexOf(_s(e)) >= 0 ? e.ownerDocument.body : va(e) && BE(e) ? e : BN(Zv(e))
}
function pm(e, t) {
    var n;
    t === void 0 && (t = []);
    var r = BN(e)
      , i = r === ((n = e.ownerDocument) == null ? void 0 : n.body)
      , o = Qo(r)
      , a = i ? [o].concat(o.visualViewport || [], BE(r) ? r : []) : r
      , s = t.concat(a);
    return i ? s : s.concat(pm(Zv(a)))
}
function Z2(e) {
    return Object.assign({}, e, {
        left: e.x,
        top: e.y,
        right: e.x + e.width,
        bottom: e.y + e.height
    })
}
function xie(e, t) {
    var n = Hf(e, !1, t === "fixed");
    return n.top = n.top + e.clientTop,
    n.left = n.left + e.clientLeft,
    n.bottom = n.top + e.clientHeight,
    n.right = n.left + e.clientWidth,
    n.width = e.clientWidth,
    n.height = e.clientHeight,
    n.x = n.left,
    n.y = n.top,
    n
}
function P$(e, t, n) {
    return t === RN ? Z2(yie(e, n)) : Bu(t) ? xie(t, n) : Z2(bie(Pc(e)))
}
function vie(e) {
    var t = pm(Zv(e))
      , n = ["absolute", "fixed"].indexOf(wl(e).position) >= 0
      , r = n && va(e) ? Ig(e) : e;
    return Bu(r) ? t.filter(function(i) {
        return Bu(i) && IN(i, r) && _s(i) !== "body"
    }) : []
}
function Sie(e, t, n, r) {
    var i = t === "clippingParents" ? vie(e) : [].concat(t)
      , o = [].concat(i, [n])
      , a = o[0]
      , s = o.reduce(function(c, u) {
        var f = P$(e, u, r);
        return c.top = Mu(f.top, c.top),
        c.right = y0(f.right, c.right),
        c.bottom = y0(f.bottom, c.bottom),
        c.left = Mu(f.left, c.left),
        c
    }, P$(e, a, r));
    return s.width = s.right - s.left,
    s.height = s.bottom - s.top,
    s.x = s.left,
    s.y = s.top,
    s
}
function zN(e) {
    var t = e.reference, n = e.element, r = e.placement, i = r ? Cs(r) : null, o = r ? qf(r) : null, a = t.x + t.width / 2 - n.width / 2, s = t.y + t.height / 2 - n.height / 2, c;
    switch (i) {
    case yo:
        c = {
            x: a,
            y: t.y - n.height
        };
        break;
    case Sa:
        c = {
            x: a,
            y: t.y + t.height
        };
        break;
    case Ca:
        c = {
            x: t.x + t.width,
            y: s
        };
        break;
    case bo:
        c = {
            x: t.x - n.width,
            y: s
        };
        break;
    default:
        c = {
            x: t.x,
            y: t.y
        }
    }
    var u = i ? $E(i) : null;
    if (u != null) {
        var f = u === "y" ? "height" : "width";
        switch (o) {
        case Uf:
            c[u] = c[u] - (t[f] / 2 - n[f] / 2);
            break;
        case Hm:
            c[u] = c[u] + (t[f] / 2 - n[f] / 2);
            break
        }
    }
    return c
}
function qm(e, t) {
    t === void 0 && (t = {});
    var n = t
      , r = n.placement
      , i = r === void 0 ? e.placement : r
      , o = n.strategy
      , a = o === void 0 ? e.strategy : o
      , s = n.boundary
      , c = s === void 0 ? Nre : s
      , u = n.rootBoundary
      , f = u === void 0 ? RN : u
      , h = n.elementContext
      , m = h === void 0 ? bp : h
      , y = n.altBoundary
      , b = y === void 0 ? !1 : y
      , v = n.padding
      , S = v === void 0 ? 0 : v
      , C = LN(typeof S != "number" ? S : jN(S, Og))
      , w = m === bp ? Ure : bp
      , k = e.rects.popper
      , T = e.elements[b ? w : m]
      , E = Sie(Bu(T) ? T : T.contextElement || Pc(e.elements.popper), c, f, a)
      , P = Hf(e.elements.reference)
      , D = zN({
        reference: P,
        element: k,
        placement: i
    })
      , $ = Z2(Object.assign({}, k, D))
      , z = m === bp ? $ : P
      , O = {
        top: E.top - z.top + C.top,
        bottom: z.bottom - E.bottom + C.bottom,
        left: E.left - z.left + C.left,
        right: z.right - E.right + C.right
    }
      , I = e.modifiersData.offset;
    if (m === bp && I) {
        var M = I[i];
        Object.keys(O).forEach(function(B) {
            var L = [Ca, Sa].indexOf(B) >= 0 ? 1 : -1
              , F = [yo, Sa].indexOf(B) >= 0 ? "y" : "x";
            O[B] += M[F] * L
        })
    }
    return O
}
function Cie(e, t) {
    t === void 0 && (t = {});
    var n = t
      , r = n.placement
      , i = n.boundary
      , o = n.rootBoundary
      , a = n.padding
      , s = n.flipVariations
      , c = n.allowedAutoPlacements
      , u = c === void 0 ? DN : c
      , f = qf(r)
      , h = f ? s ? _$ : _$.filter(function(b) {
        return qf(b) === f
    }) : Og
      , m = h.filter(function(b) {
        return u.indexOf(b) >= 0
    });
    m.length === 0 && (m = h);
    var y = m.reduce(function(b, v) {
        return b[v] = qm(e, {
            placement: v,
            boundary: i,
            rootBoundary: o,
            padding: a
        })[Cs(v)],
        b
    }, {});
    return Object.keys(y).sort(function(b, v) {
        return y[b] - y[v]
    })
}
function wie(e) {
    if (Cs(e) === DE)
        return [];
    var t = Ax(e);
    return [M$(e), t, M$(t)]
}
function kie(e) {
    var t = e.state
      , n = e.options
      , r = e.name;
    if (!t.modifiersData[r]._skip) {
        for (var i = n.mainAxis, o = i === void 0 ? !0 : i, a = n.altAxis, s = a === void 0 ? !0 : a, c = n.fallbackPlacements, u = n.padding, f = n.boundary, h = n.rootBoundary, m = n.altBoundary, y = n.flipVariations, b = y === void 0 ? !0 : y, v = n.allowedAutoPlacements, S = t.options.placement, C = Cs(S), w = C === S, k = c || (w || !b ? [Ax(S)] : wie(S)), T = [S].concat(k).reduce(function(te, K) {
            return te.concat(Cs(K) === DE ? Cie(t, {
                placement: K,
                boundary: f,
                rootBoundary: h,
                padding: u,
                flipVariations: b,
                allowedAutoPlacements: v
            }) : K)
        }, []), E = t.rects.reference, P = t.rects.popper, D = new Map, $ = !0, z = T[0], O = 0; O < T.length; O++) {
            var I = T[O]
              , M = Cs(I)
              , B = qf(I) === Uf
              , L = [yo, Sa].indexOf(M) >= 0
              , F = L ? "width" : "height"
              , j = qm(t, {
                placement: I,
                boundary: f,
                rootBoundary: h,
                altBoundary: m,
                padding: u
            })
              , N = L ? B ? Ca : bo : B ? Sa : yo;
            E[F] > P[F] && (N = Ax(N));
            var H = Ax(N)
              , Z = [];
            if (o && Z.push(j[M] <= 0),
            s && Z.push(j[N] <= 0, j[H] <= 0),
            Z.every(function(te) {
                return te
            })) {
                z = I,
                $ = !1;
                break
            }
            D.set(I, Z)
        }
        if ($)
            for (var q = b ? 3 : 1, V = function(K) {
                var ee = T.find(function(re) {
                    var ie = D.get(re);
                    if (ie)
                        return ie.slice(0, K).every(function(J) {
                            return J
                        })
                });
                if (ee)
                    return z = ee,
                    "break"
            }, Y = q; Y > 0; Y--) {
                var W = V(Y);
                if (W === "break")
                    break
            }
        t.placement !== z && (t.modifiersData[r]._skip = !0,
        t.placement = z,
        t.reset = !0)
    }
}
const Tie = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: kie,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function R$(e, t, n) {
    return n === void 0 && (n = {
        x: 0,
        y: 0
    }),
    {
        top: e.top - t.height - n.y,
        right: e.right - t.width + n.x,
        bottom: e.bottom - t.height + n.y,
        left: e.left - t.width - n.x
    }
}
function D$(e) {
    return [yo, Ca, Sa, bo].some(function(t) {
        return e[t] >= 0
    })
}
function _ie(e) {
    var t = e.state
      , n = e.name
      , r = t.rects.reference
      , i = t.rects.popper
      , o = t.modifiersData.preventOverflow
      , a = qm(t, {
        elementContext: "reference"
    })
      , s = qm(t, {
        altBoundary: !0
    })
      , c = R$(a, r)
      , u = R$(s, i, o)
      , f = D$(c)
      , h = D$(u);
    t.modifiersData[n] = {
        referenceClippingOffsets: c,
        popperEscapeOffsets: u,
        isReferenceHidden: f,
        hasPopperEscaped: h
    },
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": f,
        "data-popper-escaped": h
    })
}
const Eie = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: _ie
};
function Aie(e, t, n) {
    var r = Cs(e)
      , i = [bo, yo].indexOf(r) >= 0 ? -1 : 1
      , o = typeof n == "function" ? n(Object.assign({}, t, {
        placement: e
    })) : n
      , a = o[0]
      , s = o[1];
    return a = a || 0,
    s = (s || 0) * i,
    [bo, Ca].indexOf(r) >= 0 ? {
        x: s,
        y: a
    } : {
        x: a,
        y: s
    }
}
function Mie(e) {
    var t = e.state
      , n = e.options
      , r = e.name
      , i = n.offset
      , o = i === void 0 ? [0, 0] : i
      , a = DN.reduce(function(f, h) {
        return f[h] = Aie(h, t.rects, o),
        f
    }, {})
      , s = a[t.placement]
      , c = s.x
      , u = s.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c,
    t.modifiersData.popperOffsets.y += u),
    t.modifiersData[r] = a
}
const Pie = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: Mie
};
function Rie(e) {
    var t = e.state
      , n = e.name;
    t.modifiersData[n] = zN({
        reference: t.rects.reference,
        element: t.rects.popper,
        placement: t.placement
    })
}
const Die = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: Rie,
    data: {}
};
function Oie(e) {
    return e === "x" ? "y" : "x"
}
function Iie(e) {
    var t = e.state
      , n = e.options
      , r = e.name
      , i = n.mainAxis
      , o = i === void 0 ? !0 : i
      , a = n.altAxis
      , s = a === void 0 ? !1 : a
      , c = n.boundary
      , u = n.rootBoundary
      , f = n.altBoundary
      , h = n.padding
      , m = n.tether
      , y = m === void 0 ? !0 : m
      , b = n.tetherOffset
      , v = b === void 0 ? 0 : b
      , S = qm(t, {
        boundary: c,
        rootBoundary: u,
        padding: h,
        altBoundary: f
    })
      , C = Cs(t.placement)
      , w = qf(t.placement)
      , k = !w
      , T = $E(C)
      , E = Oie(T)
      , P = t.modifiersData.popperOffsets
      , D = t.rects.reference
      , $ = t.rects.popper
      , z = typeof v == "function" ? v(Object.assign({}, t.rects, {
        placement: t.placement
    })) : v
      , O = typeof z == "number" ? {
        mainAxis: z,
        altAxis: z
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, z)
      , I = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null
      , M = {
        x: 0,
        y: 0
    };
    if (P) {
        if (o) {
            var B, L = T === "y" ? yo : bo, F = T === "y" ? Sa : Ca, j = T === "y" ? "height" : "width", N = P[T], H = N + S[L], Z = N - S[F], q = y ? -$[j] / 2 : 0, V = w === Uf ? D[j] : $[j], Y = w === Uf ? -$[j] : -D[j], W = t.elements.arrow, te = y && W ? IE(W) : {
                width: 0,
                height: 0
            }, K = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : $N(), ee = K[L], re = K[F], ie = hm(0, D[j], te[j]), J = k ? D[j] / 2 - q - ie - ee - O.mainAxis : V - ie - ee - O.mainAxis, oe = k ? -D[j] / 2 + q + ie + re + O.mainAxis : Y + ie + re + O.mainAxis, we = t.elements.arrow && Ig(t.elements.arrow), xe = we ? T === "y" ? we.clientTop || 0 : we.clientLeft || 0 : 0, se = (B = I?.[T]) != null ? B : 0, de = N + J - se - xe, Se = N + oe - se, Ce = hm(y ? y0(H, de) : H, N, y ? Mu(Z, Se) : Z);
            P[T] = Ce,
            M[T] = Ce - N
        }
        if (s) {
            var Ye, ye = T === "x" ? yo : bo, Ke = T === "x" ? Sa : Ca, X = P[E], ce = E === "y" ? "height" : "width", fe = X + S[ye], Xe = X - S[Ke], Oe = [yo, bo].indexOf(C) !== -1, Re = (Ye = I?.[E]) != null ? Ye : 0, le = Oe ? fe : X - D[ce] - $[ce] - Re + O.altAxis, ke = Oe ? X + D[ce] + $[ce] - Re - O.altAxis : Xe, He = y && Oe ? iie(le, X, ke) : hm(y ? le : fe, X, y ? ke : Xe);
            P[E] = He,
            M[E] = He - X
        }
        t.modifiersData[r] = M
    }
}
const $ie = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: Iie,
    requiresIfExists: ["offset"]
};
function Lie(e) {
    return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    }
}
function jie(e) {
    return e === Qo(e) || !va(e) ? LE(e) : Lie(e)
}
function Bie(e) {
    var t = e.getBoundingClientRect()
      , n = Vf(t.width) / e.offsetWidth || 1
      , r = Vf(t.height) / e.offsetHeight || 1;
    return n !== 1 || r !== 1
}
function zie(e, t, n) {
    n === void 0 && (n = !1);
    var r = va(t)
      , i = va(t) && Bie(t)
      , o = Pc(t)
      , a = Hf(e, i, n)
      , s = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , c = {
        x: 0,
        y: 0
    };
    return (r || !r && !n) && ((_s(t) !== "body" || BE(o)) && (s = jie(t)),
    va(t) ? (c = Hf(t, !0),
    c.x += t.clientLeft,
    c.y += t.clientTop) : o && (c.x = jE(o))),
    {
        x: a.left + s.scrollLeft - c.x,
        y: a.top + s.scrollTop - c.y,
        width: a.width,
        height: a.height
    }
}
function Fie(e) {
    var t = new Map
      , n = new Set
      , r = [];
    e.forEach(function(o) {
        t.set(o.name, o)
    });
    function i(o) {
        n.add(o.name);
        var a = [].concat(o.requires || [], o.requiresIfExists || []);
        a.forEach(function(s) {
            if (!n.has(s)) {
                var c = t.get(s);
                c && i(c)
            }
        }),
        r.push(o)
    }
    return e.forEach(function(o) {
        n.has(o.name) || i(o)
    }),
    r
}
function Nie(e) {
    var t = Fie(e);
    return Xre.reduce(function(n, r) {
        return n.concat(t.filter(function(i) {
            return i.phase === r
        }))
    }, [])
}
function Uie(e) {
    var t;
    return function() {
        return t || (t = new Promise(function(n) {
            Promise.resolve().then(function() {
                t = void 0,
                n(e())
            })
        }
        )),
        t
    }
}
function Vie(e) {
    var t = e.reduce(function(n, r) {
        var i = n[r.name];
        return n[r.name] = i ? Object.assign({}, i, r, {
            options: Object.assign({}, i.options, r.options),
            data: Object.assign({}, i.data, r.data)
        }) : r,
        n
    }, {});
    return Object.keys(t).map(function(n) {
        return t[n]
    })
}
var O$ = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function I$() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return !t.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}
function Hie(e) {
    e === void 0 && (e = {});
    var t = e
      , n = t.defaultModifiers
      , r = n === void 0 ? [] : n
      , i = t.defaultOptions
      , o = i === void 0 ? O$ : i;
    return function(s, c, u) {
        u === void 0 && (u = o);
        var f = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, O$, o),
            modifiersData: {},
            elements: {
                reference: s,
                popper: c
            },
            attributes: {},
            styles: {}
        }
          , h = []
          , m = !1
          , y = {
            state: f,
            setOptions: function(C) {
                var w = typeof C == "function" ? C(f.options) : C;
                v(),
                f.options = Object.assign({}, o, f.options, w),
                f.scrollParents = {
                    reference: Bu(s) ? pm(s) : s.contextElement ? pm(s.contextElement) : [],
                    popper: pm(c)
                };
                var k = Nie(Vie([].concat(r, f.options.modifiers)));
                return f.orderedModifiers = k.filter(function(T) {
                    return T.enabled
                }),
                b(),
                y.update()
            },
            forceUpdate: function() {
                if (!m) {
                    var C = f.elements
                      , w = C.reference
                      , k = C.popper;
                    if (I$(w, k)) {
                        f.rects = {
                            reference: zie(w, Ig(k), f.options.strategy === "fixed"),
                            popper: IE(k)
                        },
                        f.reset = !1,
                        f.placement = f.options.placement,
                        f.orderedModifiers.forEach(function(O) {
                            return f.modifiersData[O.name] = Object.assign({}, O.data)
                        });
                        for (var T = 0; T < f.orderedModifiers.length; T++) {
                            if (f.reset === !0) {
                                f.reset = !1,
                                T = -1;
                                continue
                            }
                            var E = f.orderedModifiers[T]
                              , P = E.fn
                              , D = E.options
                              , $ = D === void 0 ? {} : D
                              , z = E.name;
                            typeof P == "function" && (f = P({
                                state: f,
                                options: $,
                                name: z,
                                instance: y
                            }) || f)
                        }
                    }
                }
            },
            update: Uie(function() {
                return new Promise(function(S) {
                    y.forceUpdate(),
                    S(f)
                }
                )
            }),
            destroy: function() {
                v(),
                m = !0
            }
        };
        if (!I$(s, c))
            return y;
        y.setOptions(u).then(function(S) {
            !m && u.onFirstUpdate && u.onFirstUpdate(S)
        });
        function b() {
            f.orderedModifiers.forEach(function(S) {
                var C = S.name
                  , w = S.options
                  , k = w === void 0 ? {} : w
                  , T = S.effect;
                if (typeof T == "function") {
                    var E = T({
                        state: f,
                        name: C,
                        instance: y,
                        options: k
                    })
                      , P = function() {};
                    h.push(E || P)
                }
            })
        }
        function v() {
            h.forEach(function(S) {
                return S()
            }),
            h = []
        }
        return y
    }
}
var qie = [pie, Die, fie, tie, Pie, Tie, $ie, lie, Eie]
  , Wie = Hie({
    defaultModifiers: qie
});
function _n(e) {
    const {elementType: t, externalSlotProps: n, ownerState: r, skipResolvingSlotProps: i=!1, ...o} = e
      , a = i ? {} : Yv(n, r)
      , {props: s, internalRef: c} = EN({
        ...o,
        externalSlotProps: a
    })
      , u = Cn(c, a?.ref, e.additionalProps?.ref);
    return _N(t, {
        ...s,
        ref: u
    }, r)
}
function Rc(e) {
    return parseInt(A.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null
}
function Gie(e) {
    return typeof e == "function" ? e() : e
}
const FN = A.forwardRef(function(t, n) {
    const {children: r, container: i, disablePortal: o=!1} = t
      , [a,s] = A.useState(null)
      , c = Cn(A.isValidElement(r) ? Rc(r) : null, n);
    if (Cr( () => {
        o || s(Gie(i) || document.body)
    }
    , [i, o]),
    Cr( () => {
        if (a && !o)
            return U2(n, a),
            () => {
                U2(n, null)
            }
    }
    , [n, a, o]),
    o) {
        if (A.isValidElement(r)) {
            const u = {
                ref: c
            };
            return A.cloneElement(r, u)
        }
        return r
    }
    return a && yF.createPortal(r, a)
});
function Yie(e) {
    return rt("MuiPopper", e)
}
ot("MuiPopper", ["root"]);
function Zie(e, t) {
    if (t === "ltr")
        return e;
    switch (e) {
    case "bottom-end":
        return "bottom-start";
    case "bottom-start":
        return "bottom-end";
    case "top-end":
        return "top-start";
    case "top-start":
        return "top-end";
    default:
        return e
    }
}
function Q2(e) {
    return typeof e == "function" ? e() : e
}
function Qie(e) {
    return e.nodeType !== void 0
}
const Kie = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, Yie, t)
}
  , Xie = {}
  , Jie = A.forwardRef(function(t, n) {
    const {anchorEl: r, children: i, direction: o, disablePortal: a, modifiers: s, open: c, placement: u, popperOptions: f, popperRef: h, slotProps: m={}, slots: y={}, TransitionProps: b, ownerState: v, ...S} = t
      , C = A.useRef(null)
      , w = Cn(C, n)
      , k = A.useRef(null)
      , T = Cn(k, h)
      , E = A.useRef(T);
    Cr( () => {
        E.current = T
    }
    , [T]),
    A.useImperativeHandle(h, () => k.current, []);
    const P = Zie(u, o)
      , [D,$] = A.useState(P)
      , [z,O] = A.useState(Q2(r));
    A.useEffect( () => {
        k.current && k.current.forceUpdate()
    }
    ),
    A.useEffect( () => {
        r && O(Q2(r))
    }
    , [r]),
    Cr( () => {
        if (!z || !c)
            return;
        const F = H => {
            $(H.placement)
        }
        ;
        let j = [{
            name: "preventOverflow",
            options: {
                altBoundary: a
            }
        }, {
            name: "flip",
            options: {
                altBoundary: a
            }
        }, {
            name: "onUpdate",
            enabled: !0,
            phase: "afterWrite",
            fn: ({state: H}) => {
                F(H)
            }
        }];
        s != null && (j = j.concat(s)),
        f && f.modifiers != null && (j = j.concat(f.modifiers));
        const N = Wie(z, C.current, {
            placement: P,
            ...f,
            modifiers: j
        });
        return E.current(N),
        () => {
            N.destroy(),
            E.current(null)
        }
    }
    , [z, a, s, c, f, P]);
    const I = {
        placement: D
    };
    b !== null && (I.TransitionProps = b);
    const M = Kie(t)
      , B = y.root ?? "div"
      , L = _n({
        elementType: B,
        externalSlotProps: m.root,
        externalForwardedProps: S,
        additionalProps: {
            role: "tooltip",
            ref: w
        },
        ownerState: t,
        className: M.root
    });
    return g.jsx(B, {
        ...L,
        children: typeof i == "function" ? i(I) : i
    })
})
  , eoe = A.forwardRef(function(t, n) {
    const {anchorEl: r, children: i, container: o, direction: a="ltr", disablePortal: s=!1, keepMounted: c=!1, modifiers: u, open: f, placement: h="bottom", popperOptions: m=Xie, popperRef: y, style: b, transition: v=!1, slotProps: S={}, slots: C={}, ...w} = t
      , [k,T] = A.useState(!0)
      , E = () => {
        T(!1)
    }
      , P = () => {
        T(!0)
    }
    ;
    if (!c && !f && (!v || k))
        return null;
    let D;
    if (o)
        D = o;
    else if (r) {
        const O = Q2(r);
        D = O && Qie(O) ? Kr(O).body : Kr(null).body
    }
    const $ = !f && c && (!v || k) ? "none" : void 0
      , z = v ? {
        in: f,
        onEnter: E,
        onExited: P
    } : void 0;
    return g.jsx(FN, {
        disablePortal: s,
        container: D,
        children: g.jsx(Jie, {
            anchorEl: r,
            direction: a,
            disablePortal: s,
            modifiers: u,
            ref: n,
            open: v ? !k : f,
            placement: h,
            popperOptions: m,
            popperRef: y,
            slotProps: S,
            slots: C,
            ...w,
            style: {
                position: "fixed",
                top: 0,
                left: 0,
                display: $,
                ...b
            },
            TransitionProps: z,
            children: i
        })
    })
})
  , toe = ue(eoe, {
    name: "MuiPopper",
    slot: "Root"
})({})
  , $g = A.forwardRef(function(t, n) {
    const r = Si()
      , i = gt({
        props: t,
        name: "MuiPopper"
    })
      , {anchorEl: o, component: a, components: s, componentsProps: c, container: u, disablePortal: f, keepMounted: h, modifiers: m, open: y, placement: b, popperOptions: v, popperRef: S, transition: C, slots: w, slotProps: k, ...T} = i
      , E = w?.root ?? s?.Root
      , P = {
        anchorEl: o,
        container: u,
        disablePortal: f,
        keepMounted: h,
        modifiers: m,
        open: y,
        placement: b,
        popperOptions: v,
        popperRef: S,
        transition: C,
        ...T
    };
    return g.jsx(toe, {
        as: a,
        direction: r ? "rtl" : "ltr",
        slots: {
            root: E
        },
        slotProps: k ?? c,
        ...P,
        ref: n
    })
});
function noe(e) {
    return rt("MuiListSubheader", e)
}
ot("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const roe = e => {
    const {classes: t, color: n, disableGutters: r, inset: i, disableSticky: o} = e
      , a = {
        root: ["root", n !== "default" && `color${Te(n)}`, !r && "gutters", i && "inset", !o && "sticky"]
    };
    return tt(a, noe, t)
}
  , ioe = ue("li", {
    name: "MuiListSubheader",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.color !== "default" && t[`color${Te(n.color)}`], !n.disableGutters && t.gutters, n.inset && t.inset, !n.disableSticky && t.sticky]
    }
})(pt( ({theme: e}) => ({
    boxSizing: "border-box",
    lineHeight: "48px",
    listStyle: "none",
    color: (e.vars || e).palette.text.secondary,
    fontFamily: e.typography.fontFamily,
    fontWeight: e.typography.fontWeightMedium,
    fontSize: e.typography.pxToRem(14),
    variants: [{
        props: {
            color: "primary"
        },
        style: {
            color: (e.vars || e).palette.primary.main
        }
    }, {
        props: {
            color: "inherit"
        },
        style: {
            color: "inherit"
        }
    }, {
        props: ({ownerState: t}) => !t.disableGutters,
        style: {
            paddingLeft: 16,
            paddingRight: 16
        }
    }, {
        props: ({ownerState: t}) => t.inset,
        style: {
            paddingLeft: 72
        }
    }, {
        props: ({ownerState: t}) => !t.disableSticky,
        style: {
            position: "sticky",
            top: 0,
            zIndex: 1,
            backgroundColor: (e.vars || e).palette.background.paper
        }
    }]
})))
  , K2 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiListSubheader"
    })
      , {className: i, color: o="default", component: a="li", disableGutters: s=!1, disableSticky: c=!1, inset: u=!1, ...f} = r
      , h = {
        ...r,
        color: o,
        component: a,
        disableGutters: s,
        disableSticky: c,
        inset: u
    }
      , m = roe(h);
    return g.jsx(ioe, {
        as: a,
        className: Ne(m.root, i),
        ref: n,
        ownerState: h,
        ...f
    })
});
K2 && (K2.muiSkipListHighlight = !0);
const ooe = _t(g.jsx("path", {
    d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}));
function aoe(e) {
    return rt("MuiChip", e)
}
const pn = ot("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorDefault", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"])
  , soe = e => {
    const {classes: t, disabled: n, size: r, color: i, iconColor: o, onDelete: a, clickable: s, variant: c} = e
      , u = {
        root: ["root", c, n && "disabled", `size${Te(r)}`, `color${Te(i)}`, s && "clickable", s && `clickableColor${Te(i)}`, a && "deletable", a && `deletableColor${Te(i)}`, `${c}${Te(i)}`],
        label: ["label", `label${Te(r)}`],
        avatar: ["avatar", `avatar${Te(r)}`, `avatarColor${Te(i)}`],
        icon: ["icon", `icon${Te(r)}`, `iconColor${Te(o)}`],
        deleteIcon: ["deleteIcon", `deleteIcon${Te(r)}`, `deleteIconColor${Te(i)}`, `deleteIcon${Te(c)}Color${Te(i)}`]
    };
    return tt(u, aoe, t)
}
  , loe = ue("div", {
    name: "MuiChip",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e
          , {color: r, iconColor: i, clickable: o, onDelete: a, size: s, variant: c} = n;
        return [{
            [`& .${pn.avatar}`]: t.avatar
        }, {
            [`& .${pn.avatar}`]: t[`avatar${Te(s)}`]
        }, {
            [`& .${pn.avatar}`]: t[`avatarColor${Te(r)}`]
        }, {
            [`& .${pn.icon}`]: t.icon
        }, {
            [`& .${pn.icon}`]: t[`icon${Te(s)}`]
        }, {
            [`& .${pn.icon}`]: t[`iconColor${Te(i)}`]
        }, {
            [`& .${pn.deleteIcon}`]: t.deleteIcon
        }, {
            [`& .${pn.deleteIcon}`]: t[`deleteIcon${Te(s)}`]
        }, {
            [`& .${pn.deleteIcon}`]: t[`deleteIconColor${Te(r)}`]
        }, {
            [`& .${pn.deleteIcon}`]: t[`deleteIcon${Te(c)}Color${Te(r)}`]
        }, t.root, t[`size${Te(s)}`], t[`color${Te(r)}`], o && t.clickable, o && r !== "default" && t[`clickableColor${Te(r)})`], a && t.deletable, a && r !== "default" && t[`deletableColor${Te(r)}`], t[c], t[`${c}${Te(r)}`]]
    }
})(pt( ({theme: e}) => {
    const t = e.palette.mode === "light" ? e.palette.grey[700] : e.palette.grey[300];
    return {
        maxWidth: "100%",
        fontFamily: e.typography.fontFamily,
        fontSize: e.typography.pxToRem(13),
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        height: 32,
        lineHeight: 1.5,
        color: (e.vars || e).palette.text.primary,
        backgroundColor: (e.vars || e).palette.action.selected,
        borderRadius: 32 / 2,
        whiteSpace: "nowrap",
        transition: e.transitions.create(["background-color", "box-shadow"]),
        cursor: "unset",
        outline: 0,
        textDecoration: "none",
        border: 0,
        padding: 0,
        verticalAlign: "middle",
        boxSizing: "border-box",
        [`&.${pn.disabled}`]: {
            opacity: (e.vars || e).palette.action.disabledOpacity,
            pointerEvents: "none"
        },
        [`& .${pn.avatar}`]: {
            marginLeft: 5,
            marginRight: -6,
            width: 24,
            height: 24,
            color: e.vars ? e.vars.palette.Chip.defaultAvatarColor : t,
            fontSize: e.typography.pxToRem(12)
        },
        [`& .${pn.avatarColorPrimary}`]: {
            color: (e.vars || e).palette.primary.contrastText,
            backgroundColor: (e.vars || e).palette.primary.dark
        },
        [`& .${pn.avatarColorSecondary}`]: {
            color: (e.vars || e).palette.secondary.contrastText,
            backgroundColor: (e.vars || e).palette.secondary.dark
        },
        [`& .${pn.avatarSmall}`]: {
            marginLeft: 4,
            marginRight: -4,
            width: 18,
            height: 18,
            fontSize: e.typography.pxToRem(10)
        },
        [`& .${pn.icon}`]: {
            marginLeft: 5,
            marginRight: -6
        },
        [`& .${pn.deleteIcon}`]: {
            WebkitTapHighlightColor: "transparent",
            color: e.alpha((e.vars || e).palette.text.primary, .26),
            fontSize: 22,
            cursor: "pointer",
            margin: "0 5px 0 -6px",
            "&:hover": {
                color: e.alpha((e.vars || e).palette.text.primary, .4)
            }
        },
        variants: [{
            props: {
                size: "small"
            },
            style: {
                height: 24,
                [`& .${pn.icon}`]: {
                    fontSize: 18,
                    marginLeft: 4,
                    marginRight: -4
                },
                [`& .${pn.deleteIcon}`]: {
                    fontSize: 16,
                    marginRight: 4,
                    marginLeft: -4
                }
            }
        }, ...Object.entries(e.palette).filter(Qn(["contrastText"])).map( ([n]) => ({
            props: {
                color: n
            },
            style: {
                backgroundColor: (e.vars || e).palette[n].main,
                color: (e.vars || e).palette[n].contrastText,
                [`& .${pn.deleteIcon}`]: {
                    color: e.alpha((e.vars || e).palette[n].contrastText, .7),
                    "&:hover, &:active": {
                        color: (e.vars || e).palette[n].contrastText
                    }
                }
            }
        })), {
            props: n => n.iconColor === n.color,
            style: {
                [`& .${pn.icon}`]: {
                    color: e.vars ? e.vars.palette.Chip.defaultIconColor : t
                }
            }
        }, {
            props: n => n.iconColor === n.color && n.color !== "default",
            style: {
                [`& .${pn.icon}`]: {
                    color: "inherit"
                }
            }
        }, {
            props: {
                onDelete: !0
            },
            style: {
                [`&.${pn.focusVisible}`]: {
                    backgroundColor: e.alpha((e.vars || e).palette.action.selected, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
                }
            }
        }, ...Object.entries(e.palette).filter(Qn(["dark"])).map( ([n]) => ({
            props: {
                color: n,
                onDelete: !0
            },
            style: {
                [`&.${pn.focusVisible}`]: {
                    background: (e.vars || e).palette[n].dark
                }
            }
        })), {
            props: {
                clickable: !0
            },
            style: {
                userSelect: "none",
                WebkitTapHighlightColor: "transparent",
                cursor: "pointer",
                "&:hover": {
                    backgroundColor: e.alpha((e.vars || e).palette.action.selected, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`)
                },
                [`&.${pn.focusVisible}`]: {
                    backgroundColor: e.alpha((e.vars || e).palette.action.selected, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
                },
                "&:active": {
                    boxShadow: (e.vars || e).shadows[1]
                }
            }
        }, ...Object.entries(e.palette).filter(Qn(["dark"])).map( ([n]) => ({
            props: {
                color: n,
                clickable: !0
            },
            style: {
                [`&:hover, &.${pn.focusVisible}`]: {
                    backgroundColor: (e.vars || e).palette[n].dark
                }
            }
        })), {
            props: {
                variant: "outlined"
            },
            style: {
                backgroundColor: "transparent",
                border: e.vars ? `1px solid ${e.vars.palette.Chip.defaultBorder}` : `1px solid ${e.palette.mode === "light" ? e.palette.grey[400] : e.palette.grey[700]}`,
                [`&.${pn.clickable}:hover`]: {
                    backgroundColor: (e.vars || e).palette.action.hover
                },
                [`&.${pn.focusVisible}`]: {
                    backgroundColor: (e.vars || e).palette.action.focus
                },
                [`& .${pn.avatar}`]: {
                    marginLeft: 4
                },
                [`& .${pn.avatarSmall}`]: {
                    marginLeft: 2
                },
                [`& .${pn.icon}`]: {
                    marginLeft: 4
                },
                [`& .${pn.iconSmall}`]: {
                    marginLeft: 2
                },
                [`& .${pn.deleteIcon}`]: {
                    marginRight: 5
                },
                [`& .${pn.deleteIconSmall}`]: {
                    marginRight: 3
                }
            }
        }, ...Object.entries(e.palette).filter(Qn()).map( ([n]) => ({
            props: {
                variant: "outlined",
                color: n
            },
            style: {
                color: (e.vars || e).palette[n].main,
                border: `1px solid ${e.alpha((e.vars || e).palette[n].main, .7)}`,
                [`&.${pn.clickable}:hover`]: {
                    backgroundColor: e.alpha((e.vars || e).palette[n].main, (e.vars || e).palette.action.hoverOpacity)
                },
                [`&.${pn.focusVisible}`]: {
                    backgroundColor: e.alpha((e.vars || e).palette[n].main, (e.vars || e).palette.action.focusOpacity)
                },
                [`& .${pn.deleteIcon}`]: {
                    color: e.alpha((e.vars || e).palette[n].main, .7),
                    "&:hover, &:active": {
                        color: (e.vars || e).palette[n].main
                    }
                }
            }
        }))]
    }
}
))
  , coe = ue("span", {
    name: "MuiChip",
    slot: "Label",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e
          , {size: r} = n;
        return [t.label, t[`label${Te(r)}`]]
    }
})({
    overflow: "hidden",
    textOverflow: "ellipsis",
    paddingLeft: 12,
    paddingRight: 12,
    whiteSpace: "nowrap",
    variants: [{
        props: {
            variant: "outlined"
        },
        style: {
            paddingLeft: 11,
            paddingRight: 11
        }
    }, {
        props: {
            size: "small"
        },
        style: {
            paddingLeft: 8,
            paddingRight: 8
        }
    }, {
        props: {
            size: "small",
            variant: "outlined"
        },
        style: {
            paddingLeft: 7,
            paddingRight: 7
        }
    }]
});
function $$(e) {
    return e.key === "Backspace" || e.key === "Delete"
}
const zE = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiChip"
    })
      , {avatar: i, className: o, clickable: a, color: s="default", component: c, deleteIcon: u, disabled: f=!1, icon: h, label: m, onClick: y, onDelete: b, onKeyDown: v, onKeyUp: S, size: C="medium", variant: w="filled", tabIndex: k, skipFocusWhenDisabled: T=!1, slots: E={}, slotProps: P={}, ...D} = r
      , $ = A.useRef(null)
      , z = Cn($, n)
      , O = ee => {
        ee.stopPropagation(),
        b && b(ee)
    }
      , I = ee => {
        ee.currentTarget === ee.target && $$(ee) && ee.preventDefault(),
        v && v(ee)
    }
      , M = ee => {
        ee.currentTarget === ee.target && b && $$(ee) && b(ee),
        S && S(ee)
    }
      , B = a !== !1 && y ? !0 : a
      , L = B || b ? Ka : c || "div"
      , F = {
        ...r,
        component: L,
        disabled: f,
        size: C,
        color: s,
        iconColor: A.isValidElement(h) && h.props.color || s,
        onDelete: !!b,
        clickable: B,
        variant: w
    }
      , j = soe(F)
      , N = L === Ka ? {
        component: c || "div",
        focusVisibleClassName: j.focusVisible,
        ...b && {
            disableRipple: !0
        }
    } : {};
    let H = null;
    b && (H = u && A.isValidElement(u) ? A.cloneElement(u, {
        className: Ne(u.props.className, j.deleteIcon),
        onClick: O
    }) : g.jsx(ooe, {
        className: j.deleteIcon,
        onClick: O
    }));
    let Z = null;
    i && A.isValidElement(i) && (Z = A.cloneElement(i, {
        className: Ne(j.avatar, i.props.className)
    }));
    let q = null;
    h && A.isValidElement(h) && (q = A.cloneElement(h, {
        className: Ne(j.icon, h.props.className)
    }));
    const V = {
        slots: E,
        slotProps: P
    }
      , [Y,W] = mt("root", {
        elementType: loe,
        externalForwardedProps: {
            ...V,
            ...D
        },
        ownerState: F,
        shouldForwardComponentProp: !0,
        ref: z,
        className: Ne(j.root, o),
        additionalProps: {
            disabled: B && f ? !0 : void 0,
            tabIndex: T && f ? -1 : k,
            ...N
        },
        getSlotProps: ee => ({
            ...ee,
            onClick: re => {
                ee.onClick?.(re),
                y?.(re)
            }
            ,
            onKeyDown: re => {
                ee.onKeyDown?.(re),
                I(re)
            }
            ,
            onKeyUp: re => {
                ee.onKeyUp?.(re),
                M(re)
            }
        })
    })
      , [te,K] = mt("label", {
        elementType: coe,
        externalForwardedProps: V,
        ownerState: F,
        className: j.label
    });
    return g.jsxs(Y, {
        as: L,
        ...W,
        children: [Z || q, g.jsx(te, {
            ...K,
            children: m
        }), H]
    })
});
function Ob(e) {
    return parseInt(e, 10) || 0
}
const uoe = {
    shadow: {
        visibility: "hidden",
        position: "absolute",
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        transform: "translateZ(0)"
    }
};
function doe(e) {
    for (const t in e)
        return !1;
    return !0
}
function L$(e) {
    return doe(e) || e.outerHeightStyle === 0 && !e.overflowing
}
const foe = A.forwardRef(function(t, n) {
    const {onChange: r, maxRows: i, minRows: o=1, style: a, value: s, ...c} = t
      , {current: u} = A.useRef(s != null)
      , f = A.useRef(null)
      , h = Cn(n, f)
      , m = A.useRef(null)
      , y = A.useRef(null)
      , b = A.useCallback( () => {
        const k = f.current
          , T = y.current;
        if (!k || !T)
            return;
        const P = Zo(k).getComputedStyle(k);
        if (P.width === "0px")
            return {
                outerHeightStyle: 0,
                overflowing: !1
            };
        T.style.width = P.width,
        T.value = k.value || t.placeholder || "x",
        T.value.slice(-1) === `
` && (T.value += " ");
        const D = P.boxSizing
          , $ = Ob(P.paddingBottom) + Ob(P.paddingTop)
          , z = Ob(P.borderBottomWidth) + Ob(P.borderTopWidth)
          , O = T.scrollHeight;
        T.value = "x";
        const I = T.scrollHeight;
        let M = O;
        o && (M = Math.max(Number(o) * I, M)),
        i && (M = Math.min(Number(i) * I, M)),
        M = Math.max(M, I);
        const B = M + (D === "border-box" ? $ + z : 0)
          , L = Math.abs(M - O) <= 1;
        return {
            outerHeightStyle: B,
            overflowing: L
        }
    }
    , [i, o, t.placeholder])
      , v = ft( () => {
        const k = f.current
          , T = b();
        if (!k || !T || L$(T))
            return !1;
        const E = T.outerHeightStyle;
        return m.current != null && m.current !== E
    }
    )
      , S = A.useCallback( () => {
        const k = f.current
          , T = b();
        if (!k || !T || L$(T))
            return;
        const E = T.outerHeightStyle;
        m.current !== E && (m.current = E,
        k.style.height = `${E}px`),
        k.style.overflow = T.overflowing ? "hidden" : ""
    }
    , [b])
      , C = A.useRef(-1);
    Cr( () => {
        const k = Rg(S)
          , T = f?.current;
        if (!T)
            return;
        const E = Zo(T);
        E.addEventListener("resize", k);
        let P;
        return typeof ResizeObserver < "u" && (P = new ResizeObserver( () => {
            v() && (P.unobserve(T),
            cancelAnimationFrame(C.current),
            S(),
            C.current = requestAnimationFrame( () => {
                P.observe(T)
            }
            ))
        }
        ),
        P.observe(T)),
        () => {
            k.clear(),
            cancelAnimationFrame(C.current),
            E.removeEventListener("resize", k),
            P && P.disconnect()
        }
    }
    , [b, S, v]),
    Cr( () => {
        S()
    }
    );
    const w = k => {
        u || S();
        const T = k.target
          , E = T.value.length
          , P = T.value.endsWith(`
`)
          , D = T.selectionStart === E;
        P && D && T.setSelectionRange(E, E),
        r && r(k)
    }
    ;
    return g.jsxs(A.Fragment, {
        children: [g.jsx("textarea", {
            value: s,
            onChange: w,
            ref: h,
            rows: o,
            style: a,
            ...c
        }), g.jsx("textarea", {
            "aria-hidden": !0,
            className: t.className,
            readOnly: !0,
            ref: y,
            tabIndex: -1,
            style: {
                ...uoe.shadow,
                ...a,
                paddingTop: 0,
                paddingBottom: 0
            }
        })]
    })
});
function nd({props: e, states: t, muiFormControl: n}) {
    return t.reduce( (r, i) => (r[i] = e[i],
    n && typeof e[i] > "u" && (r[i] = n[i]),
    r), {})
}
const Qv = A.createContext(void 0);
function To() {
    return A.useContext(Qv)
}
function j$(e) {
    return e != null && !(Array.isArray(e) && e.length === 0)
}
function b0(e, t=!1) {
    return e && (j$(e.value) && e.value !== "" || t && j$(e.defaultValue) && e.defaultValue !== "")
}
function hoe(e) {
    return e.startAdornment
}
function poe(e) {
    return rt("MuiInputBase", e)
}
const Fo = ot("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var B$;
const Kv = (e, t) => {
    const {ownerState: n} = e;
    return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${Te(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel]
}
  , Xv = (e, t) => {
    const {ownerState: n} = e;
    return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel]
}
  , moe = e => {
    const {classes: t, color: n, disabled: r, error: i, endAdornment: o, focused: a, formControl: s, fullWidth: c, hiddenLabel: u, multiline: f, readOnly: h, size: m, startAdornment: y, type: b} = e
      , v = {
        root: ["root", `color${Te(n)}`, r && "disabled", i && "error", c && "fullWidth", a && "focused", s && "formControl", m && m !== "medium" && `size${Te(m)}`, f && "multiline", y && "adornedStart", o && "adornedEnd", u && "hiddenLabel", h && "readOnly"],
        input: ["input", r && "disabled", b === "search" && "inputTypeSearch", f && "inputMultiline", m === "small" && "inputSizeSmall", u && "inputHiddenLabel", y && "inputAdornedStart", o && "inputAdornedEnd", h && "readOnly"]
    };
    return tt(v, poe, t)
}
  , Jv = ue("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: Kv
})(pt( ({theme: e}) => ({
    ...e.typography.body1,
    color: (e.vars || e).palette.text.primary,
    lineHeight: "1.4375em",
    boxSizing: "border-box",
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${Fo.disabled}`]: {
        color: (e.vars || e).palette.text.disabled,
        cursor: "default"
    },
    variants: [{
        props: ({ownerState: t}) => t.multiline,
        style: {
            padding: "4px 0 5px"
        }
    }, {
        props: ({ownerState: t, size: n}) => t.multiline && n === "small",
        style: {
            paddingTop: 1
        }
    }, {
        props: ({ownerState: t}) => t.fullWidth,
        style: {
            width: "100%"
        }
    }]
})))
  , e1 = ue("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: Xv
})(pt( ({theme: e}) => {
    const t = e.palette.mode === "light"
      , n = {
        color: "currentColor",
        ...e.vars ? {
            opacity: e.vars.opacity.inputPlaceholder
        } : {
            opacity: t ? .42 : .5
        },
        transition: e.transitions.create("opacity", {
            duration: e.transitions.duration.shorter
        })
    }
      , r = {
        opacity: "0 !important"
    }
      , i = e.vars ? {
        opacity: e.vars.opacity.inputPlaceholder
    } : {
        opacity: t ? .42 : .5
    };
    return {
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        "&::-webkit-input-placeholder": n,
        "&::-moz-placeholder": n,
        "&::-ms-input-placeholder": n,
        "&:focus": {
            outline: 0
        },
        "&:invalid": {
            boxShadow: "none"
        },
        "&::-webkit-search-decoration": {
            WebkitAppearance: "none"
        },
        [`label[data-shrink=false] + .${Fo.formControl} &`]: {
            "&::-webkit-input-placeholder": r,
            "&::-moz-placeholder": r,
            "&::-ms-input-placeholder": r,
            "&:focus::-webkit-input-placeholder": i,
            "&:focus::-moz-placeholder": i,
            "&:focus::-ms-input-placeholder": i
        },
        [`&.${Fo.disabled}`]: {
            opacity: 1,
            WebkitTextFillColor: (e.vars || e).palette.text.disabled
        },
        variants: [{
            props: ({ownerState: o}) => !o.disableInjectingGlobalStyles,
            style: {
                animationName: "mui-auto-fill-cancel",
                animationDuration: "10ms",
                "&:-webkit-autofill": {
                    animationDuration: "5000s",
                    animationName: "mui-auto-fill"
                }
            }
        }, {
            props: {
                size: "small"
            },
            style: {
                paddingTop: 1
            }
        }, {
            props: ({ownerState: o}) => o.multiline,
            style: {
                height: "auto",
                resize: "none",
                padding: 0,
                paddingTop: 0
            }
        }, {
            props: {
                type: "search"
            },
            style: {
                MozAppearance: "textfield"
            }
        }]
    }
}
))
  , z$ = TE({
    "@keyframes mui-auto-fill": {
        from: {
            display: "block"
        }
    },
    "@keyframes mui-auto-fill-cancel": {
        from: {
            display: "block"
        }
    }
})
  , Lg = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiInputBase"
    })
      , {"aria-describedby": i, autoComplete: o, autoFocus: a, className: s, color: c, components: u={}, componentsProps: f={}, defaultValue: h, disabled: m, disableInjectingGlobalStyles: y, endAdornment: b, error: v, fullWidth: S=!1, id: C, inputComponent: w="input", inputProps: k={}, inputRef: T, margin: E, maxRows: P, minRows: D, multiline: $=!1, name: z, onBlur: O, onChange: I, onClick: M, onFocus: B, onKeyDown: L, onKeyUp: F, placeholder: j, readOnly: N, renderSuffix: H, rows: Z, size: q, slotProps: V={}, slots: Y={}, startAdornment: W, type: te="text", value: K, ...ee} = r
      , re = k.value != null ? k.value : K
      , {current: ie} = A.useRef(re != null)
      , J = A.useRef()
      , oe = A.useCallback(et => {}
    , [])
      , we = Cn(J, T, k.ref, oe)
      , [xe,se] = A.useState(!1)
      , de = To()
      , Se = nd({
        props: r,
        muiFormControl: de,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
    });
    Se.focused = de ? de.focused : xe,
    A.useEffect( () => {
        !de && m && xe && (se(!1),
        O && O())
    }
    , [de, m, xe, O]);
    const Ce = de && de.onFilled
      , Ye = de && de.onEmpty
      , ye = A.useCallback(et => {
        b0(et) ? Ce && Ce() : Ye && Ye()
    }
    , [Ce, Ye]);
    Cr( () => {
        ie && ye({
            value: re
        })
    }
    , [re, ye, ie]);
    const Ke = et => {
        B && B(et),
        k.onFocus && k.onFocus(et),
        de && de.onFocus ? de.onFocus(et) : se(!0)
    }
      , X = et => {
        O && O(et),
        k.onBlur && k.onBlur(et),
        de && de.onBlur ? de.onBlur(et) : se(!1)
    }
      , ce = (et, ...Ht) => {
        if (!ie) {
            const Ft = et.target || J.current;
            if (Ft == null)
                throw new Error(Cl(1));
            ye({
                value: Ft.value
            })
        }
        k.onChange && k.onChange(et, ...Ht),
        I && I(et, ...Ht)
    }
    ;
    A.useEffect( () => {
        ye(J.current)
    }
    , []);
    const fe = et => {
        J.current && et.currentTarget === et.target && J.current.focus(),
        M && M(et)
    }
    ;
    let Xe = w
      , Oe = k;
    $ && Xe === "input" && (Z ? Oe = {
        type: void 0,
        minRows: Z,
        maxRows: Z,
        ...Oe
    } : Oe = {
        type: void 0,
        maxRows: P,
        minRows: D,
        ...Oe
    },
    Xe = foe);
    const Re = et => {
        ye(et.animationName === "mui-auto-fill-cancel" ? J.current : {
            value: "x"
        })
    }
    ;
    A.useEffect( () => {
        de && de.setAdornedStart(!!W)
    }
    , [de, W]);
    const le = {
        ...r,
        color: Se.color || "primary",
        disabled: Se.disabled,
        endAdornment: b,
        error: Se.error,
        focused: Se.focused,
        formControl: de,
        fullWidth: S,
        hiddenLabel: Se.hiddenLabel,
        multiline: $,
        size: Se.size,
        startAdornment: W,
        type: te
    }
      , ke = moe(le)
      , He = Y.root || u.Root || Jv
      , st = V.root || f.root || {}
      , lt = Y.input || u.Input || e1;
    return Oe = {
        ...Oe,
        ...V.input ?? f.input
    },
    g.jsxs(A.Fragment, {
        children: [!y && typeof z$ == "function" && (B$ || (B$ = g.jsx(z$, {}))), g.jsxs(He, {
            ...st,
            ref: n,
            onClick: fe,
            ...ee,
            ...!Nf(He) && {
                ownerState: {
                    ...le,
                    ...st.ownerState
                }
            },
            className: Ne(ke.root, st.className, s, N && "MuiInputBase-readOnly"),
            children: [W, g.jsx(Qv.Provider, {
                value: null,
                children: g.jsx(lt, {
                    "aria-invalid": Se.error,
                    "aria-describedby": i,
                    autoComplete: o,
                    autoFocus: a,
                    defaultValue: h,
                    disabled: Se.disabled,
                    id: C,
                    onAnimationStart: Re,
                    name: z,
                    placeholder: j,
                    readOnly: N,
                    required: Se.required,
                    rows: Z,
                    value: re,
                    onKeyDown: L,
                    onKeyUp: F,
                    type: te,
                    ...Oe,
                    ...!Nf(lt) && {
                        as: Xe,
                        ownerState: {
                            ...le,
                            ...Oe.ownerState
                        }
                    },
                    ref: we,
                    className: Ne(ke.input, Oe.className, N && "MuiInputBase-readOnly"),
                    onBlur: X,
                    onChange: ce,
                    onFocus: Ke
                })
            }), b, H ? H({
                ...Se,
                startAdornment: W
            }) : null]
        })]
    })
});
function goe(e) {
    return rt("MuiInput", e)
}
const ac = {
    ...Fo,
    ...ot("MuiInput", ["root", "underline", "input"])
};
function yoe(e) {
    return rt("MuiOutlinedInput", e)
}
const fa = {
    ...Fo,
    ...ot("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
function boe(e) {
    return rt("MuiFilledInput", e)
}
const No = {
    ...Fo,
    ...ot("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}
  , NN = _t(g.jsx("path", {
    d: "M7 10l5 5 5-5z"
}));
function xoe(e) {
    return rt("MuiAutocomplete", e)
}
const cn = ot("MuiAutocomplete", ["root", "expanded", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
var F$, N$;
const voe = e => {
    const {classes: t, disablePortal: n, expanded: r, focused: i, fullWidth: o, hasClearIcon: a, hasPopupIcon: s, inputFocused: c, popupOpen: u, size: f} = e
      , h = {
        root: ["root", r && "expanded", i && "focused", o && "fullWidth", a && "hasClearIcon", s && "hasPopupIcon"],
        inputRoot: ["inputRoot"],
        input: ["input", c && "inputFocused"],
        tag: ["tag", `tagSize${Te(f)}`],
        endAdornment: ["endAdornment"],
        clearIndicator: ["clearIndicator"],
        popupIndicator: ["popupIndicator", u && "popupIndicatorOpen"],
        popper: ["popper", n && "popperDisablePortal"],
        paper: ["paper"],
        listbox: ["listbox"],
        loading: ["loading"],
        noOptions: ["noOptions"],
        option: ["option"],
        groupLabel: ["groupLabel"],
        groupUl: ["groupUl"]
    };
    return tt(h, xoe, t)
}
  , Soe = ue("div", {
    name: "MuiAutocomplete",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e
          , {fullWidth: r, hasClearIcon: i, hasPopupIcon: o, inputFocused: a, size: s} = n;
        return [{
            [`& .${cn.tag}`]: t.tag
        }, {
            [`& .${cn.tag}`]: t[`tagSize${Te(s)}`]
        }, {
            [`& .${cn.inputRoot}`]: t.inputRoot
        }, {
            [`& .${cn.input}`]: t.input
        }, {
            [`& .${cn.input}`]: a && t.inputFocused
        }, t.root, r && t.fullWidth, o && t.hasPopupIcon, i && t.hasClearIcon]
    }
})({
    [`&.${cn.focused} .${cn.clearIndicator}`]: {
        visibility: "visible"
    },
    "@media (pointer: fine)": {
        [`&:hover .${cn.clearIndicator}`]: {
            visibility: "visible"
        }
    },
    [`& .${cn.tag}`]: {
        margin: 3,
        maxWidth: "calc(100% - 6px)"
    },
    [`& .${cn.inputRoot}`]: {
        [`.${cn.hasPopupIcon}&, .${cn.hasClearIcon}&`]: {
            paddingRight: 30
        },
        [`.${cn.hasPopupIcon}.${cn.hasClearIcon}&`]: {
            paddingRight: 56
        },
        [`& .${cn.input}`]: {
            width: 0,
            minWidth: 30
        }
    },
    [`& .${ac.root}`]: {
        paddingBottom: 1,
        "& .MuiInput-input": {
            padding: "4px 4px 4px 0px"
        }
    },
    [`& .${ac.root}.${Fo.sizeSmall}`]: {
        [`& .${ac.input}`]: {
            padding: "2px 4px 3px 0"
        }
    },
    [`& .${fa.root}`]: {
        padding: 9,
        [`.${cn.hasPopupIcon}&, .${cn.hasClearIcon}&`]: {
            paddingRight: 39
        },
        [`.${cn.hasPopupIcon}.${cn.hasClearIcon}&`]: {
            paddingRight: 65
        },
        [`& .${cn.input}`]: {
            padding: "7.5px 4px 7.5px 5px"
        },
        [`& .${cn.endAdornment}`]: {
            right: 9
        }
    },
    [`& .${fa.root}.${Fo.sizeSmall}`]: {
        paddingTop: 6,
        paddingBottom: 6,
        paddingLeft: 6,
        [`& .${cn.input}`]: {
            padding: "2.5px 4px 2.5px 8px"
        }
    },
    [`& .${No.root}`]: {
        paddingTop: 19,
        paddingLeft: 8,
        [`.${cn.hasPopupIcon}&, .${cn.hasClearIcon}&`]: {
            paddingRight: 39
        },
        [`.${cn.hasPopupIcon}.${cn.hasClearIcon}&`]: {
            paddingRight: 65
        },
        [`& .${No.input}`]: {
            padding: "7px 4px"
        },
        [`& .${cn.endAdornment}`]: {
            right: 9
        }
    },
    [`& .${No.root}.${Fo.sizeSmall}`]: {
        paddingBottom: 1,
        [`& .${No.input}`]: {
            padding: "2.5px 4px"
        }
    },
    [`& .${Fo.hiddenLabel}`]: {
        paddingTop: 8
    },
    [`& .${No.root}.${Fo.hiddenLabel}`]: {
        paddingTop: 0,
        paddingBottom: 0,
        [`& .${cn.input}`]: {
            paddingTop: 16,
            paddingBottom: 17
        }
    },
    [`& .${No.root}.${Fo.hiddenLabel}.${Fo.sizeSmall}`]: {
        [`& .${cn.input}`]: {
            paddingTop: 8,
            paddingBottom: 9
        }
    },
    [`& .${cn.input}`]: {
        flexGrow: 1,
        textOverflow: "ellipsis",
        opacity: 0
    },
    variants: [{
        props: {
            fullWidth: !0
        },
        style: {
            width: "100%"
        }
    }, {
        props: {
            size: "small"
        },
        style: {
            [`& .${cn.tag}`]: {
                margin: 2,
                maxWidth: "calc(100% - 4px)"
            }
        }
    }, {
        props: {
            inputFocused: !0
        },
        style: {
            [`& .${cn.input}`]: {
                opacity: 1
            }
        }
    }, {
        props: {
            multiple: !0
        },
        style: {
            [`& .${cn.inputRoot}`]: {
                flexWrap: "wrap"
            }
        }
    }]
})
  , Coe = ue("div", {
    name: "MuiAutocomplete",
    slot: "EndAdornment"
})({
    position: "absolute",
    right: 0,
    top: "50%",
    transform: "translate(0, -50%)"
})
  , woe = ue(In, {
    name: "MuiAutocomplete",
    slot: "ClearIndicator"
})({
    marginRight: -2,
    padding: 4,
    visibility: "hidden"
})
  , koe = ue(In, {
    name: "MuiAutocomplete",
    slot: "PopupIndicator",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.popupIndicator, n.popupOpen && t.popupIndicatorOpen]
    }
})({
    padding: 2,
    marginRight: -2,
    variants: [{
        props: {
            popupOpen: !0
        },
        style: {
            transform: "rotate(180deg)"
        }
    }]
})
  , Toe = ue($g, {
    name: "MuiAutocomplete",
    slot: "Popper",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [{
            [`& .${cn.option}`]: t.option
        }, t.popper, n.disablePortal && t.popperDisablePortal]
    }
})(pt( ({theme: e}) => ({
    zIndex: (e.vars || e).zIndex.modal,
    variants: [{
        props: {
            disablePortal: !0
        },
        style: {
            position: "absolute"
        }
    }]
})))
  , _oe = ue(yn, {
    name: "MuiAutocomplete",
    slot: "Paper"
})(pt( ({theme: e}) => ({
    ...e.typography.body1,
    overflow: "auto"
})))
  , Eoe = ue("div", {
    name: "MuiAutocomplete",
    slot: "Loading"
})(pt( ({theme: e}) => ({
    color: (e.vars || e).palette.text.secondary,
    padding: "14px 16px"
})))
  , Aoe = ue("div", {
    name: "MuiAutocomplete",
    slot: "NoOptions"
})(pt( ({theme: e}) => ({
    color: (e.vars || e).palette.text.secondary,
    padding: "14px 16px"
})))
  , Moe = ue("ul", {
    name: "MuiAutocomplete",
    slot: "Listbox"
})(pt( ({theme: e}) => ({
    listStyle: "none",
    margin: 0,
    padding: "8px 0",
    maxHeight: "40vh",
    overflow: "auto",
    position: "relative",
    [`& .${cn.option}`]: {
        minHeight: 48,
        display: "flex",
        overflow: "hidden",
        justifyContent: "flex-start",
        alignItems: "center",
        cursor: "pointer",
        paddingTop: 6,
        boxSizing: "border-box",
        outline: "0",
        WebkitTapHighlightColor: "transparent",
        paddingBottom: 6,
        paddingLeft: 16,
        paddingRight: 16,
        [e.breakpoints.up("sm")]: {
            minHeight: "auto"
        },
        [`&.${cn.focused}`]: {
            backgroundColor: (e.vars || e).palette.action.hover,
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        },
        '&[aria-disabled="true"]': {
            opacity: (e.vars || e).palette.action.disabledOpacity,
            pointerEvents: "none"
        },
        [`&.${cn.focusVisible}`]: {
            backgroundColor: (e.vars || e).palette.action.focus
        },
        '&[aria-selected="true"]': {
            backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
            [`&.${cn.focused}`]: {
                backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
                "@media (hover: none)": {
                    backgroundColor: (e.vars || e).palette.action.selected
                }
            },
            [`&.${cn.focusVisible}`]: {
                backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
            }
        }
    }
})))
  , Poe = ue(K2, {
    name: "MuiAutocomplete",
    slot: "GroupLabel"
})(pt( ({theme: e}) => ({
    backgroundColor: (e.vars || e).palette.background.paper,
    top: -8
})))
  , Roe = ue("ul", {
    name: "MuiAutocomplete",
    slot: "GroupUl"
})({
    padding: 0,
    [`& .${cn.option}`]: {
        paddingLeft: 24
    }
})
  , co = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiAutocomplete"
    })
      , {autoComplete: i=!1, autoHighlight: o=!1, autoSelect: a=!1, blurOnSelect: s=!1, ChipProps: c, className: u, clearIcon: f=F$ || (F$ = g.jsx(MN, {
        fontSize: "small"
    })), clearOnBlur: h=!r.freeSolo, clearOnEscape: m=!1, clearText: y="Clear", closeText: b="Close", componentsProps: v, defaultValue: S=r.multiple ? [] : null, disableClearable: C=!1, disableCloseOnSelect: w=!1, disabled: k=!1, disabledItemsFocusable: T=!1, disableListWrap: E=!1, disablePortal: P=!1, filterOptions: D, filterSelectedOptions: $=!1, forcePopupIcon: z="auto", freeSolo: O=!1, fullWidth: I=!1, getLimitTagsText: M=Bt => `+${Bt}`, getOptionDisabled: B, getOptionKey: L, getOptionLabel: F, isOptionEqualToValue: j, groupBy: N, handleHomeEndKeys: H=!r.freeSolo, id: Z, includeInputInList: q=!1, inputValue: V, limitTags: Y=-1, ListboxComponent: W, ListboxProps: te, loading: K=!1, loadingText: ee="Loading", multiple: re=!1, noOptionsText: ie="No options", onChange: J, onClose: oe, onHighlightChange: we, onInputChange: xe, onOpen: se, open: de, openOnFocus: Se=!1, openText: Ce="Open", options: Ye, PaperComponent: ye, PopperComponent: Ke, popupIcon: X=N$ || (N$ = g.jsx(NN, {})), readOnly: ce=!1, renderGroup: fe, renderInput: Xe, renderOption: Oe, renderTags: Re, renderValue: le, selectOnFocus: ke=!r.freeSolo, size: He="medium", slots: st={}, slotProps: lt={}, value: et, ...Ht} = r
      , {getRootProps: Ft, getInputProps: Pt, getInputLabelProps: nt, getPopupIndicatorProps: ut, getClearProps: Lt, getItemProps: tn, getListboxProps: Xt, getOptionProps: Mn, value: Pn, dirty: wn, expanded: Kn, id: vr, popupOpen: mr, focused: kn, focusedItem: At, anchorEl: nr, setAnchorEl: he, inputValue: Le, groupedOptions: it} = Fre({
        ...r,
        componentName: "Autocomplete"
    })
      , Je = !C && !k && wn && !ce
      , Jt = (!O || z === !0) && z !== !1
      , {onMouseDown: qt} = Pt()
      , {ref: dn, ...Ir} = Xt()
      , Tr = F || (Bt => Bt.label ?? Bt)
      , ln = {
        ...r,
        disablePortal: P,
        expanded: Kn,
        focused: kn,
        fullWidth: I,
        getOptionLabel: Tr,
        hasClearIcon: Je,
        hasPopupIcon: Jt,
        inputFocused: At === -1,
        popupOpen: mr,
        size: He
    }
      , en = voe(ln)
      , si = {
        slots: {
            paper: ye,
            popper: Ke,
            ...st
        },
        slotProps: {
            chip: c,
            listbox: te,
            ...v,
            ...lt
        }
    }
      , [is,os] = mt("listbox", {
        elementType: Moe,
        externalForwardedProps: si,
        ownerState: ln,
        className: en.listbox,
        additionalProps: Ir,
        ref: dn
    })
      , [zs,Fe] = mt("paper", {
        elementType: yn,
        externalForwardedProps: si,
        ownerState: ln,
        className: en.paper
    })
      , [me,ne] = mt("popper", {
        elementType: $g,
        externalForwardedProps: si,
        ownerState: ln,
        className: en.popper,
        additionalProps: {
            disablePortal: P,
            style: {
                width: nr ? nr.clientWidth : null
            },
            role: "presentation",
            anchorEl: nr,
            open: mr
        }
    });
    let De;
    const Ze = Bt => ({
        className: en.tag,
        disabled: k,
        ...tn(Bt)
    });
    if (re ? Pn.length > 0 && (Re ? De = Re(Pn, Ze, ln) : le ? De = le(Pn, Ze, ln) : De = Pn.map( (Bt, Xi) => {
        const {key: Ji, ...zc} = Ze({
            index: Xi
        });
        return g.jsx(zE, {
            label: Tr(Bt),
            size: He,
            ...zc,
            ...si.slotProps.chip
        }, Ji)
    }
    )) : le && Pn != null && (De = le(Pn, Ze, ln)),
    Y > -1 && Array.isArray(De)) {
        const Bt = De.length - Y;
        !kn && Bt > 0 && (De = De.splice(0, Y),
        De.push(g.jsx("span", {
            className: en.tag,
            children: M(Bt)
        }, De.length)))
    }
    const Zt = fe || (Bt => g.jsxs("li", {
        children: [g.jsx(Poe, {
            className: en.groupLabel,
            ownerState: ln,
            component: "div",
            children: Bt.group
        }), g.jsx(Roe, {
            className: en.groupUl,
            ownerState: ln,
            children: Bt.children
        })]
    }, Bt.key))
      , _r = Oe || ( (Bt, Xi) => {
        const {key: Ji, ...zc} = Bt;
        return g.jsx("li", {
            ...zc,
            children: Tr(Xi)
        }, Ji)
    }
    )
      , Ii = (Bt, Xi) => {
        const Ji = Mn({
            option: Bt,
            index: Xi
        });
        return _r({
            ...Ji,
            className: en.option
        }, Bt, {
            selected: Ji["aria-selected"],
            index: Xi,
            inputValue: Le
        }, ln)
    }
      , ui = si.slotProps.clearIndicator
      , Mo = si.slotProps.popupIndicator;
    return g.jsxs(A.Fragment, {
        children: [g.jsx(Soe, {
            ref: n,
            className: Ne(en.root, u),
            ownerState: ln,
            ...Ft(Ht),
            children: Xe({
                id: vr,
                disabled: k,
                fullWidth: !0,
                size: He === "small" ? "small" : void 0,
                InputLabelProps: nt(),
                InputProps: {
                    ref: he,
                    className: en.inputRoot,
                    startAdornment: De,
                    onMouseDown: Bt => {
                        Bt.target === Bt.currentTarget && qt(Bt)
                    }
                    ,
                    ...(Je || Jt) && {
                        endAdornment: g.jsxs(Coe, {
                            className: en.endAdornment,
                            ownerState: ln,
                            children: [Je ? g.jsx(woe, {
                                ...Lt(),
                                "aria-label": y,
                                title: y,
                                ownerState: ln,
                                ...ui,
                                className: Ne(en.clearIndicator, ui?.className),
                                children: f
                            }) : null, Jt ? g.jsx(koe, {
                                ...ut(),
                                disabled: k,
                                "aria-label": mr ? b : Ce,
                                title: mr ? b : Ce,
                                ownerState: ln,
                                ...Mo,
                                className: Ne(en.popupIndicator, Mo?.className),
                                children: X
                            }) : null]
                        })
                    }
                },
                inputProps: {
                    className: en.input,
                    disabled: k,
                    readOnly: ce,
                    ...Pt()
                }
            })
        }), nr ? g.jsx(Toe, {
            as: me,
            ...ne,
            children: g.jsxs(_oe, {
                as: zs,
                ...Fe,
                children: [K && it.length === 0 ? g.jsx(Eoe, {
                    className: en.loading,
                    ownerState: ln,
                    children: ee
                }) : null, it.length === 0 && !O && !K ? g.jsx(Aoe, {
                    className: en.noOptions,
                    ownerState: ln,
                    role: "presentation",
                    onMouseDown: Bt => {
                        Bt.preventDefault()
                    }
                    ,
                    children: ie
                }) : null, it.length > 0 ? g.jsx(is, {
                    as: W,
                    ...os,
                    children: it.map( (Bt, Xi) => N ? Zt({
                        key: Bt.key,
                        group: Bt.group,
                        children: Bt.options.map( (Ji, zc) => Ii(Ji, Bt.index + zc))
                    }) : Ii(Bt, Xi))
                }) : null]
            })
        }) : null]
    })
})
  , Doe = _t(g.jsx("path", {
    d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}));
function Ooe(e) {
    return rt("MuiAvatar", e)
}
ot("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const Ioe = e => {
    const {classes: t, variant: n, colorDefault: r} = e;
    return tt({
        root: ["root", n, r && "colorDefault"],
        img: ["img"],
        fallback: ["fallback"]
    }, Ooe, t)
}
  , $oe = ue("div", {
    name: "MuiAvatar",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[n.variant], n.colorDefault && t.colorDefault]
    }
})(pt( ({theme: e}) => ({
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    width: 40,
    height: 40,
    fontFamily: e.typography.fontFamily,
    fontSize: e.typography.pxToRem(20),
    lineHeight: 1,
    borderRadius: "50%",
    overflow: "hidden",
    userSelect: "none",
    variants: [{
        props: {
            variant: "rounded"
        },
        style: {
            borderRadius: (e.vars || e).shape.borderRadius
        }
    }, {
        props: {
            variant: "square"
        },
        style: {
            borderRadius: 0
        }
    }, {
        props: {
            colorDefault: !0
        },
        style: {
            color: (e.vars || e).palette.background.default,
            ...e.vars ? {
                backgroundColor: e.vars.palette.Avatar.defaultBg
            } : {
                backgroundColor: e.palette.grey[400],
                ...e.applyStyles("dark", {
                    backgroundColor: e.palette.grey[600]
                })
            }
        }
    }]
})))
  , Loe = ue("img", {
    name: "MuiAvatar",
    slot: "Img"
})({
    width: "100%",
    height: "100%",
    textAlign: "center",
    objectFit: "cover",
    color: "transparent",
    textIndent: 1e4
})
  , joe = ue(Doe, {
    name: "MuiAvatar",
    slot: "Fallback"
})({
    width: "75%",
    height: "75%"
});
function Boe({crossOrigin: e, referrerPolicy: t, src: n, srcSet: r}) {
    const [i,o] = A.useState(!1);
    return A.useEffect( () => {
        if (!n && !r)
            return;
        o(!1);
        let a = !0;
        const s = new Image;
        return s.onload = () => {
            a && o("loaded")
        }
        ,
        s.onerror = () => {
            a && o("error")
        }
        ,
        s.crossOrigin = e,
        s.referrerPolicy = t,
        s.src = n,
        r && (s.srcset = r),
        () => {
            a = !1
        }
    }
    , [e, t, n, r]),
    i
}
const zu = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiAvatar"
    })
      , {alt: i, children: o, className: a, component: s="div", slots: c={}, slotProps: u={}, imgProps: f, sizes: h, src: m, srcSet: y, variant: b="circular", ...v} = r;
    let S = null;
    const C = {
        ...r,
        component: s,
        variant: b
    }
      , w = Boe({
        ...f,
        ...typeof u.img == "function" ? u.img(C) : u.img,
        src: m,
        srcSet: y
    })
      , k = m || y
      , T = k && w !== "error";
    C.colorDefault = !T,
    delete C.ownerState;
    const E = Ioe(C)
      , [P,D] = mt("root", {
        ref: n,
        className: Ne(E.root, a),
        elementType: $oe,
        externalForwardedProps: {
            slots: c,
            slotProps: u,
            component: s,
            ...v
        },
        ownerState: C
    })
      , [$,z] = mt("img", {
        className: E.img,
        elementType: Loe,
        externalForwardedProps: {
            slots: c,
            slotProps: {
                img: {
                    ...f,
                    ...u.img
                }
            }
        },
        additionalProps: {
            alt: i,
            src: m,
            srcSet: y,
            sizes: h
        },
        ownerState: C
    })
      , [O,I] = mt("fallback", {
        className: E.fallback,
        elementType: joe,
        externalForwardedProps: {
            slots: c,
            slotProps: u
        },
        shouldForwardComponentProp: !0,
        ownerState: C
    });
    return T ? S = g.jsx($, {
        ...z
    }) : o || o === 0 ? S = o : k && i ? S = i[0] : S = g.jsx(O, {
        ...I
    }),
    g.jsx(P, {
        ...D,
        children: S
    })
})
  , zoe = {
    entering: {
        opacity: 1
    },
    entered: {
        opacity: 1
    }
}
  , vc = A.forwardRef(function(t, n) {
    const r = ko()
      , i = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen
    }
      , {addEndListener: o, appear: a=!0, children: s, easing: c, in: u, onEnter: f, onEntered: h, onEntering: m, onExit: y, onExited: b, onExiting: v, style: S, timeout: C=i, TransitionComponent: w=Xo, ...k} = t
      , T = A.useRef(null)
      , E = Cn(T, Rc(s), n)
      , P = L => F => {
        if (L) {
            const j = T.current;
            F === void 0 ? L(j) : L(j, F)
        }
    }
      , D = P(m)
      , $ = P( (L, F) => {
        PE(L);
        const j = xc({
            style: S,
            timeout: C,
            easing: c
        }, {
            mode: "enter"
        });
        L.style.webkitTransition = r.transitions.create("opacity", j),
        L.style.transition = r.transitions.create("opacity", j),
        f && f(L, F)
    }
    )
      , z = P(h)
      , O = P(v)
      , I = P(L => {
        const F = xc({
            style: S,
            timeout: C,
            easing: c
        }, {
            mode: "exit"
        });
        L.style.webkitTransition = r.transitions.create("opacity", F),
        L.style.transition = r.transitions.create("opacity", F),
        y && y(L)
    }
    )
      , M = P(b)
      , B = L => {
        o && o(T.current, L)
    }
    ;
    return g.jsx(w, {
        appear: a,
        in: u,
        nodeRef: T,
        onEnter: $,
        onEntered: z,
        onEntering: D,
        onExit: I,
        onExited: M,
        onExiting: O,
        addEndListener: B,
        timeout: C,
        ...k,
        children: (L, {ownerState: F, ...j}) => A.cloneElement(s, {
            style: {
                opacity: 0,
                visibility: L === "exited" && !u ? "hidden" : void 0,
                ...zoe[L],
                ...S,
                ...s.props.style
            },
            ref: E,
            ...j
        })
    })
});
function Foe(e) {
    return rt("MuiBackdrop", e)
}
ot("MuiBackdrop", ["root", "invisible"]);
const Noe = e => {
    const {classes: t, invisible: n} = e;
    return tt({
        root: ["root", n && "invisible"]
    }, Foe, t)
}
  , Uoe = ue("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.invisible && t.invisible]
    }
})({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent",
    variants: [{
        props: {
            invisible: !0
        },
        style: {
            backgroundColor: "transparent"
        }
    }]
})
  , jg = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiBackdrop"
    })
      , {children: i, className: o, component: a="div", invisible: s=!1, open: c, components: u={}, componentsProps: f={}, slotProps: h={}, slots: m={}, TransitionComponent: y, transitionDuration: b, ...v} = r
      , S = {
        ...r,
        component: a,
        invisible: s
    }
      , C = Noe(S)
      , w = {
        transition: y,
        root: u.Root,
        ...m
    }
      , k = {
        ...f,
        ...h
    }
      , T = {
        component: a,
        slots: w,
        slotProps: k
    }
      , [E,P] = mt("root", {
        elementType: Uoe,
        externalForwardedProps: T,
        className: Ne(C.root, o),
        ownerState: S
    })
      , [D,$] = mt("transition", {
        elementType: vc,
        externalForwardedProps: T,
        ownerState: S
    });
    return g.jsx(D, {
        in: c,
        timeout: b,
        ...v,
        ...$,
        children: g.jsx(E, {
            "aria-hidden": !0,
            ...P,
            classes: C,
            ref: n,
            children: i
        })
    })
});
function Voe(e) {
    const {badgeContent: t, invisible: n=!1, max: r=99, showZero: i=!1} = e
      , o = RE({
        badgeContent: t,
        max: r
    });
    let a = n;
    n === !1 && t === 0 && !i && (a = !0);
    const {badgeContent: s, max: c=r} = a ? o : e
      , u = s && Number(s) > c ? `${c}+` : s;
    return {
        badgeContent: s,
        invisible: a,
        max: c,
        displayValue: u
    }
}
function Hoe(e) {
    return rt("MuiBadge", e)
}
const tc = ot("MuiBadge", ["root", "badge", "dot", "standard", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft", "invisible", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "overlapRectangular", "overlapCircular", "anchorOriginTopLeftCircular", "anchorOriginTopLeftRectangular", "anchorOriginTopRightCircular", "anchorOriginTopRightRectangular", "anchorOriginBottomLeftCircular", "anchorOriginBottomLeftRectangular", "anchorOriginBottomRightCircular", "anchorOriginBottomRightRectangular"])
  , Ww = 10
  , Gw = 4
  , qoe = e => {
    const {color: t, anchorOrigin: n, invisible: r, overlap: i, variant: o, classes: a={}} = e
      , s = {
        root: ["root"],
        badge: ["badge", o, r && "invisible", `anchorOrigin${Te(n.vertical)}${Te(n.horizontal)}`, `anchorOrigin${Te(n.vertical)}${Te(n.horizontal)}${Te(i)}`, `overlap${Te(i)}`, t !== "default" && `color${Te(t)}`]
    };
    return tt(s, Hoe, a)
}
  , Woe = ue("span", {
    name: "MuiBadge",
    slot: "Root"
})({
    position: "relative",
    display: "inline-flex",
    verticalAlign: "middle",
    flexShrink: 0
})
  , Goe = ue("span", {
    name: "MuiBadge",
    slot: "Badge",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.badge, t[n.variant], t[`anchorOrigin${Te(n.anchorOrigin.vertical)}${Te(n.anchorOrigin.horizontal)}${Te(n.overlap)}`], n.color !== "default" && t[`color${Te(n.color)}`], n.invisible && t.invisible]
    }
})(pt( ({theme: e}) => ({
    display: "flex",
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    alignContent: "center",
    alignItems: "center",
    position: "absolute",
    boxSizing: "border-box",
    fontFamily: e.typography.fontFamily,
    fontWeight: e.typography.fontWeightMedium,
    fontSize: e.typography.pxToRem(12),
    minWidth: Ww * 2,
    lineHeight: 1,
    padding: "0 6px",
    height: Ww * 2,
    borderRadius: Ww,
    zIndex: 1,
    transition: e.transitions.create("transform", {
        easing: e.transitions.easing.easeInOut,
        duration: e.transitions.duration.enteringScreen
    }),
    variants: [...Object.entries(e.palette).filter(Qn(["contrastText"])).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            backgroundColor: (e.vars || e).palette[t].main,
            color: (e.vars || e).palette[t].contrastText
        }
    })), {
        props: {
            variant: "dot"
        },
        style: {
            borderRadius: Gw,
            height: Gw * 2,
            minWidth: Gw * 2,
            padding: 0
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "top" && t.anchorOrigin.horizontal === "right" && t.overlap === "rectangular",
        style: {
            top: 0,
            right: 0,
            transform: "scale(1) translate(50%, -50%)",
            transformOrigin: "100% 0%",
            [`&.${tc.invisible}`]: {
                transform: "scale(0) translate(50%, -50%)"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "bottom" && t.anchorOrigin.horizontal === "right" && t.overlap === "rectangular",
        style: {
            bottom: 0,
            right: 0,
            transform: "scale(1) translate(50%, 50%)",
            transformOrigin: "100% 100%",
            [`&.${tc.invisible}`]: {
                transform: "scale(0) translate(50%, 50%)"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "top" && t.anchorOrigin.horizontal === "left" && t.overlap === "rectangular",
        style: {
            top: 0,
            left: 0,
            transform: "scale(1) translate(-50%, -50%)",
            transformOrigin: "0% 0%",
            [`&.${tc.invisible}`]: {
                transform: "scale(0) translate(-50%, -50%)"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "bottom" && t.anchorOrigin.horizontal === "left" && t.overlap === "rectangular",
        style: {
            bottom: 0,
            left: 0,
            transform: "scale(1) translate(-50%, 50%)",
            transformOrigin: "0% 100%",
            [`&.${tc.invisible}`]: {
                transform: "scale(0) translate(-50%, 50%)"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "top" && t.anchorOrigin.horizontal === "right" && t.overlap === "circular",
        style: {
            top: "14%",
            right: "14%",
            transform: "scale(1) translate(50%, -50%)",
            transformOrigin: "100% 0%",
            [`&.${tc.invisible}`]: {
                transform: "scale(0) translate(50%, -50%)"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "bottom" && t.anchorOrigin.horizontal === "right" && t.overlap === "circular",
        style: {
            bottom: "14%",
            right: "14%",
            transform: "scale(1) translate(50%, 50%)",
            transformOrigin: "100% 100%",
            [`&.${tc.invisible}`]: {
                transform: "scale(0) translate(50%, 50%)"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "top" && t.anchorOrigin.horizontal === "left" && t.overlap === "circular",
        style: {
            top: "14%",
            left: "14%",
            transform: "scale(1) translate(-50%, -50%)",
            transformOrigin: "0% 0%",
            [`&.${tc.invisible}`]: {
                transform: "scale(0) translate(-50%, -50%)"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "bottom" && t.anchorOrigin.horizontal === "left" && t.overlap === "circular",
        style: {
            bottom: "14%",
            left: "14%",
            transform: "scale(1) translate(-50%, 50%)",
            transformOrigin: "0% 100%",
            [`&.${tc.invisible}`]: {
                transform: "scale(0) translate(-50%, 50%)"
            }
        }
    }, {
        props: {
            invisible: !0
        },
        style: {
            transition: e.transitions.create("transform", {
                easing: e.transitions.easing.easeInOut,
                duration: e.transitions.duration.leavingScreen
            })
        }
    }]
})));
function U$(e) {
    return {
        vertical: e?.vertical ?? "top",
        horizontal: e?.horizontal ?? "right"
    }
}
const UN = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiBadge"
    })
      , {anchorOrigin: i, className: o, classes: a, component: s, components: c={}, componentsProps: u={}, children: f, overlap: h="rectangular", color: m="default", invisible: y=!1, max: b=99, badgeContent: v, slots: S, slotProps: C, showZero: w=!1, variant: k="standard", ...T} = r
      , {badgeContent: E, invisible: P, max: D, displayValue: $} = Voe({
        max: b,
        invisible: y,
        badgeContent: v,
        showZero: w
    })
      , z = RE({
        anchorOrigin: U$(i),
        color: m,
        overlap: h,
        variant: k,
        badgeContent: v
    })
      , O = P || E == null && k !== "dot"
      , {color: I=m, overlap: M=h, anchorOrigin: B, variant: L=k} = O ? z : r
      , F = U$(B)
      , j = L !== "dot" ? $ : void 0
      , N = {
        ...r,
        badgeContent: E,
        invisible: O,
        max: D,
        displayValue: j,
        showZero: w,
        anchorOrigin: F,
        color: I,
        overlap: M,
        variant: L
    }
      , H = qoe(N)
      , Z = {
        slots: {
            root: S?.root ?? c.Root,
            badge: S?.badge ?? c.Badge
        },
        slotProps: {
            root: C?.root ?? u.root,
            badge: C?.badge ?? u.badge
        }
    }
      , [q,V] = mt("root", {
        elementType: Woe,
        externalForwardedProps: {
            ...Z,
            ...T
        },
        ownerState: N,
        className: Ne(H.root, o),
        ref: n,
        additionalProps: {
            as: s
        }
    })
      , [Y,W] = mt("badge", {
        elementType: Goe,
        externalForwardedProps: Z,
        ownerState: N,
        className: H.badge
    });
    return g.jsxs(q, {
        ...V,
        children: [f, g.jsx(Y, {
            ...W,
            children: j
        })]
    })
})
  , Yoe = ot("MuiBox", ["root"])
  , Zoe = qv()
  , Be = _ee({
    themeId: xa,
    defaultTheme: Zoe,
    defaultClassName: Yoe.root,
    generateClassName: tN.generate
});
function Qoe(e) {
    return rt("MuiButton", e)
}
const ru = ot("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"])
  , VN = A.createContext({})
  , HN = A.createContext(void 0)
  , Koe = e => {
    const {color: t, disableElevation: n, fullWidth: r, size: i, variant: o, loading: a, loadingPosition: s, classes: c} = e
      , u = {
        root: ["root", a && "loading", o, `${o}${Te(t)}`, `size${Te(i)}`, `${o}Size${Te(i)}`, `color${Te(t)}`, n && "disableElevation", r && "fullWidth", a && `loadingPosition${Te(s)}`],
        startIcon: ["icon", "startIcon", `iconSize${Te(i)}`],
        endIcon: ["icon", "endIcon", `iconSize${Te(i)}`],
        loadingIndicator: ["loadingIndicator"],
        loadingWrapper: ["loadingWrapper"]
    }
      , f = tt(u, Qoe, c);
    return {
        ...c,
        ...f
    }
}
  , qN = [{
    props: {
        size: "small"
    },
    style: {
        "& > *:nth-of-type(1)": {
            fontSize: 18
        }
    }
}, {
    props: {
        size: "medium"
    },
    style: {
        "& > *:nth-of-type(1)": {
            fontSize: 20
        }
    }
}, {
    props: {
        size: "large"
    },
    style: {
        "& > *:nth-of-type(1)": {
            fontSize: 22
        }
    }
}]
  , Xoe = ue(Ka, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[n.variant], t[`${n.variant}${Te(n.color)}`], t[`size${Te(n.size)}`], t[`${n.variant}Size${Te(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth, n.loading && t.loading]
    }
})(pt( ({theme: e}) => {
    const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800]
      , n = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
    return {
        ...e.typography.button,
        minWidth: 64,
        padding: "6px 16px",
        border: 0,
        borderRadius: (e.vars || e).shape.borderRadius,
        transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
            duration: e.transitions.duration.short
        }),
        "&:hover": {
            textDecoration: "none"
        },
        [`&.${ru.disabled}`]: {
            color: (e.vars || e).palette.action.disabled
        },
        variants: [{
            props: {
                variant: "contained"
            },
            style: {
                color: "var(--variant-containedColor)",
                backgroundColor: "var(--variant-containedBg)",
                boxShadow: (e.vars || e).shadows[2],
                "&:hover": {
                    boxShadow: (e.vars || e).shadows[4],
                    "@media (hover: none)": {
                        boxShadow: (e.vars || e).shadows[2]
                    }
                },
                "&:active": {
                    boxShadow: (e.vars || e).shadows[8]
                },
                [`&.${ru.focusVisible}`]: {
                    boxShadow: (e.vars || e).shadows[6]
                },
                [`&.${ru.disabled}`]: {
                    color: (e.vars || e).palette.action.disabled,
                    boxShadow: (e.vars || e).shadows[0],
                    backgroundColor: (e.vars || e).palette.action.disabledBackground
                }
            }
        }, {
            props: {
                variant: "outlined"
            },
            style: {
                padding: "5px 15px",
                border: "1px solid currentColor",
                borderColor: "var(--variant-outlinedBorder, currentColor)",
                backgroundColor: "var(--variant-outlinedBg)",
                color: "var(--variant-outlinedColor)",
                [`&.${ru.disabled}`]: {
                    border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
                }
            }
        }, {
            props: {
                variant: "text"
            },
            style: {
                padding: "6px 8px",
                color: "var(--variant-textColor)",
                backgroundColor: "var(--variant-textBg)"
            }
        }, ...Object.entries(e.palette).filter(Qn()).map( ([r]) => ({
            props: {
                color: r
            },
            style: {
                "--variant-textColor": (e.vars || e).palette[r].main,
                "--variant-outlinedColor": (e.vars || e).palette[r].main,
                "--variant-outlinedBorder": e.alpha((e.vars || e).palette[r].main, .5),
                "--variant-containedColor": (e.vars || e).palette[r].contrastText,
                "--variant-containedBg": (e.vars || e).palette[r].main,
                "@media (hover: hover)": {
                    "&:hover": {
                        "--variant-containedBg": (e.vars || e).palette[r].dark,
                        "--variant-textBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity),
                        "--variant-outlinedBorder": (e.vars || e).palette[r].main,
                        "--variant-outlinedBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity)
                    }
                }
            }
        })), {
            props: {
                color: "inherit"
            },
            style: {
                color: "inherit",
                borderColor: "currentColor",
                "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
                "@media (hover: hover)": {
                    "&:hover": {
                        "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n,
                        "--variant-textBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity),
                        "--variant-outlinedBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity)
                    }
                }
            }
        }, {
            props: {
                size: "small",
                variant: "text"
            },
            style: {
                padding: "4px 5px",
                fontSize: e.typography.pxToRem(13)
            }
        }, {
            props: {
                size: "large",
                variant: "text"
            },
            style: {
                padding: "8px 11px",
                fontSize: e.typography.pxToRem(15)
            }
        }, {
            props: {
                size: "small",
                variant: "outlined"
            },
            style: {
                padding: "3px 9px",
                fontSize: e.typography.pxToRem(13)
            }
        }, {
            props: {
                size: "large",
                variant: "outlined"
            },
            style: {
                padding: "7px 21px",
                fontSize: e.typography.pxToRem(15)
            }
        }, {
            props: {
                size: "small",
                variant: "contained"
            },
            style: {
                padding: "4px 10px",
                fontSize: e.typography.pxToRem(13)
            }
        }, {
            props: {
                size: "large",
                variant: "contained"
            },
            style: {
                padding: "8px 22px",
                fontSize: e.typography.pxToRem(15)
            }
        }, {
            props: {
                disableElevation: !0
            },
            style: {
                boxShadow: "none",
                "&:hover": {
                    boxShadow: "none"
                },
                [`&.${ru.focusVisible}`]: {
                    boxShadow: "none"
                },
                "&:active": {
                    boxShadow: "none"
                },
                [`&.${ru.disabled}`]: {
                    boxShadow: "none"
                }
            }
        }, {
            props: {
                fullWidth: !0
            },
            style: {
                width: "100%"
            }
        }, {
            props: {
                loadingPosition: "center"
            },
            style: {
                transition: e.transitions.create(["background-color", "box-shadow", "border-color"], {
                    duration: e.transitions.duration.short
                }),
                [`&.${ru.loading}`]: {
                    color: "transparent"
                }
            }
        }]
    }
}
))
  , Joe = ue("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.startIcon, n.loading && t.startIconLoadingStart, t[`iconSize${Te(n.size)}`]]
    }
})( ({theme: e}) => ({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4,
    variants: [{
        props: {
            size: "small"
        },
        style: {
            marginLeft: -2
        }
    }, {
        props: {
            loadingPosition: "start",
            loading: !0
        },
        style: {
            transition: e.transitions.create(["opacity"], {
                duration: e.transitions.duration.short
            }),
            opacity: 0
        }
    }, {
        props: {
            loadingPosition: "start",
            loading: !0,
            fullWidth: !0
        },
        style: {
            marginRight: -8
        }
    }, ...qN]
}))
  , eae = ue("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.endIcon, n.loading && t.endIconLoadingEnd, t[`iconSize${Te(n.size)}`]]
    }
})( ({theme: e}) => ({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8,
    variants: [{
        props: {
            size: "small"
        },
        style: {
            marginRight: -2
        }
    }, {
        props: {
            loadingPosition: "end",
            loading: !0
        },
        style: {
            transition: e.transitions.create(["opacity"], {
                duration: e.transitions.duration.short
            }),
            opacity: 0
        }
    }, {
        props: {
            loadingPosition: "end",
            loading: !0,
            fullWidth: !0
        },
        style: {
            marginLeft: -8
        }
    }, ...qN]
}))
  , tae = ue("span", {
    name: "MuiButton",
    slot: "LoadingIndicator"
})( ({theme: e}) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    variants: [{
        props: {
            loading: !0
        },
        style: {
            display: "flex"
        }
    }, {
        props: {
            loadingPosition: "start"
        },
        style: {
            left: 14
        }
    }, {
        props: {
            loadingPosition: "start",
            size: "small"
        },
        style: {
            left: 10
        }
    }, {
        props: {
            variant: "text",
            loadingPosition: "start"
        },
        style: {
            left: 6
        }
    }, {
        props: {
            loadingPosition: "center"
        },
        style: {
            left: "50%",
            transform: "translate(-50%)",
            color: (e.vars || e).palette.action.disabled
        }
    }, {
        props: {
            loadingPosition: "end"
        },
        style: {
            right: 14
        }
    }, {
        props: {
            loadingPosition: "end",
            size: "small"
        },
        style: {
            right: 10
        }
    }, {
        props: {
            variant: "text",
            loadingPosition: "end"
        },
        style: {
            right: 6
        }
    }, {
        props: {
            loadingPosition: "start",
            fullWidth: !0
        },
        style: {
            position: "relative",
            left: -10
        }
    }, {
        props: {
            loadingPosition: "end",
            fullWidth: !0
        },
        style: {
            position: "relative",
            right: -10
        }
    }]
}))
  , V$ = ue("span", {
    name: "MuiButton",
    slot: "LoadingIconPlaceholder"
})({
    display: "inline-block",
    width: "1em",
    height: "1em"
})
  , Mt = A.forwardRef(function(t, n) {
    const r = A.useContext(VN)
      , i = A.useContext(HN)
      , o = Vm(r, t)
      , a = gt({
        props: o,
        name: "MuiButton"
    })
      , {children: s, color: c="primary", component: u="button", className: f, disabled: h=!1, disableElevation: m=!1, disableFocusRipple: y=!1, endIcon: b, focusVisibleClassName: v, fullWidth: S=!1, id: C, loading: w=null, loadingIndicator: k, loadingPosition: T="center", size: E="medium", startIcon: P, type: D, variant: $="text", ...z} = a
      , O = Gi(C)
      , I = k ?? g.jsx(Jr, {
        "aria-labelledby": O,
        color: "inherit",
        size: 16
    })
      , M = {
        ...a,
        color: c,
        component: u,
        disabled: h,
        disableElevation: m,
        disableFocusRipple: y,
        fullWidth: S,
        loading: w,
        loadingIndicator: I,
        loadingPosition: T,
        size: E,
        type: D,
        variant: $
    }
      , B = Koe(M)
      , L = (P || w && T === "start") && g.jsx(Joe, {
        className: B.startIcon,
        ownerState: M,
        children: P || g.jsx(V$, {
            className: B.loadingIconPlaceholder,
            ownerState: M
        })
    })
      , F = (b || w && T === "end") && g.jsx(eae, {
        className: B.endIcon,
        ownerState: M,
        children: b || g.jsx(V$, {
            className: B.loadingIconPlaceholder,
            ownerState: M
        })
    })
      , j = i || ""
      , N = typeof w == "boolean" ? g.jsx("span", {
        className: B.loadingWrapper,
        style: {
            display: "contents"
        },
        children: w && g.jsx(tae, {
            className: B.loadingIndicator,
            ownerState: M,
            children: I
        })
    }) : null;
    return g.jsxs(Xoe, {
        ownerState: M,
        className: Ne(r.className, B.root, f, j),
        component: u,
        disabled: h || w,
        focusRipple: !y,
        focusVisibleClassName: Ne(B.focusVisible, v),
        ref: n,
        type: D,
        id: w ? O : C,
        ...z,
        classes: B,
        children: [L, T !== "end" && N, s, T === "end" && N, F]
    })
});
function nae(e) {
    return A.Children.toArray(e).filter(t => A.isValidElement(t))
}
function rae(e) {
    return rt("MuiButtonGroup", e)
}
const sn = ot("MuiButtonGroup", ["root", "contained", "outlined", "text", "disableElevation", "disabled", "firstButton", "fullWidth", "horizontal", "vertical", "colorPrimary", "colorSecondary", "grouped", "groupedHorizontal", "groupedVertical", "groupedText", "groupedTextHorizontal", "groupedTextVertical", "groupedTextPrimary", "groupedTextSecondary", "groupedOutlined", "groupedOutlinedHorizontal", "groupedOutlinedVertical", "groupedOutlinedPrimary", "groupedOutlinedSecondary", "groupedContained", "groupedContainedHorizontal", "groupedContainedVertical", "groupedContainedPrimary", "groupedContainedSecondary", "lastButton", "middleButton"])
  , iae = (e, t) => {
    const {ownerState: n} = e;
    return [{
        [`& .${sn.grouped}`]: t.grouped
    }, {
        [`& .${sn.grouped}`]: t[`grouped${Te(n.orientation)}`]
    }, {
        [`& .${sn.grouped}`]: t[`grouped${Te(n.variant)}`]
    }, {
        [`& .${sn.grouped}`]: t[`grouped${Te(n.variant)}${Te(n.orientation)}`]
    }, {
        [`& .${sn.grouped}`]: t[`grouped${Te(n.variant)}${Te(n.color)}`]
    }, {
        [`& .${sn.firstButton}`]: t.firstButton
    }, {
        [`& .${sn.lastButton}`]: t.lastButton
    }, {
        [`& .${sn.middleButton}`]: t.middleButton
    }, t.root, t[n.variant], n.disableElevation === !0 && t.disableElevation, n.fullWidth && t.fullWidth, n.orientation === "vertical" && t.vertical]
}
  , oae = e => {
    const {classes: t, color: n, disabled: r, disableElevation: i, fullWidth: o, orientation: a, variant: s} = e
      , c = {
        root: ["root", s, a, o && "fullWidth", i && "disableElevation", `color${Te(n)}`],
        grouped: ["grouped", `grouped${Te(a)}`, `grouped${Te(s)}`, `grouped${Te(s)}${Te(a)}`, `grouped${Te(s)}${Te(n)}`, r && "disabled"],
        firstButton: ["firstButton"],
        lastButton: ["lastButton"],
        middleButton: ["middleButton"]
    };
    return tt(c, rae, t)
}
  , aae = ue("div", {
    name: "MuiButtonGroup",
    slot: "Root",
    overridesResolver: iae
})(pt( ({theme: e}) => ({
    display: "inline-flex",
    borderRadius: (e.vars || e).shape.borderRadius,
    variants: [{
        props: {
            variant: "contained"
        },
        style: {
            boxShadow: (e.vars || e).shadows[2]
        }
    }, {
        props: {
            disableElevation: !0
        },
        style: {
            boxShadow: "none"
        }
    }, {
        props: {
            fullWidth: !0
        },
        style: {
            width: "100%"
        }
    }, {
        props: {
            orientation: "vertical"
        },
        style: {
            flexDirection: "column",
            [`& .${sn.lastButton},& .${sn.middleButton}`]: {
                borderTopRightRadius: 0,
                borderTopLeftRadius: 0
            },
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderBottomRightRadius: 0,
                borderBottomLeftRadius: 0
            }
        }
    }, {
        props: {
            orientation: "horizontal"
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderTopRightRadius: 0,
                borderBottomRightRadius: 0
            },
            [`& .${sn.lastButton},& .${sn.middleButton}`]: {
                borderTopLeftRadius: 0,
                borderBottomLeftRadius: 0
            }
        }
    }, {
        props: {
            variant: "text",
            orientation: "horizontal"
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderRight: e.vars ? `1px solid ${e.alpha(e.vars.palette.common.onBackground, .23)}` : `1px solid ${e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
                [`&.${sn.disabled}`]: {
                    borderRight: `1px solid ${(e.vars || e).palette.action.disabled}`
                }
            }
        }
    }, {
        props: {
            variant: "text",
            orientation: "vertical"
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderBottom: e.vars ? `1px solid ${e.alpha(e.vars.palette.common.onBackground, .23)}` : `1px solid ${e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
                [`&.${sn.disabled}`]: {
                    borderBottom: `1px solid ${(e.vars || e).palette.action.disabled}`
                }
            }
        }
    }, ...Object.entries(e.palette).filter(Qn()).flatMap( ([t]) => [{
        props: {
            variant: "text",
            color: t
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderColor: e.alpha((e.vars || e).palette[t].main, .5)
            }
        }
    }]), {
        props: {
            variant: "outlined",
            orientation: "horizontal"
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderRightColor: "transparent",
                "&:hover": {
                    borderRightColor: "currentColor"
                }
            },
            [`& .${sn.lastButton},& .${sn.middleButton}`]: {
                marginLeft: -1
            }
        }
    }, {
        props: {
            variant: "outlined",
            orientation: "vertical"
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderBottomColor: "transparent",
                "&:hover": {
                    borderBottomColor: "currentColor"
                }
            },
            [`& .${sn.lastButton},& .${sn.middleButton}`]: {
                marginTop: -1
            }
        }
    }, {
        props: {
            variant: "contained",
            orientation: "horizontal"
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderRight: `1px solid ${(e.vars || e).palette.grey[400]}`,
                [`&.${sn.disabled}`]: {
                    borderRight: `1px solid ${(e.vars || e).palette.action.disabled}`
                }
            }
        }
    }, {
        props: {
            variant: "contained",
            orientation: "vertical"
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderBottom: `1px solid ${(e.vars || e).palette.grey[400]}`,
                [`&.${sn.disabled}`]: {
                    borderBottom: `1px solid ${(e.vars || e).palette.action.disabled}`
                }
            }
        }
    }, ...Object.entries(e.palette).filter(Qn(["dark"])).map( ([t]) => ({
        props: {
            variant: "contained",
            color: t
        },
        style: {
            [`& .${sn.firstButton},& .${sn.middleButton}`]: {
                borderColor: (e.vars || e).palette[t].dark
            }
        }
    }))],
    [`& .${sn.grouped}`]: {
        minWidth: 40,
        boxShadow: "none",
        props: {
            variant: "contained"
        },
        style: {
            "&:hover": {
                boxShadow: "none"
            }
        }
    }
})))
  , sae = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiButtonGroup"
    })
      , {children: i, className: o, color: a="primary", component: s="div", disabled: c=!1, disableElevation: u=!1, disableFocusRipple: f=!1, disableRipple: h=!1, fullWidth: m=!1, orientation: y="horizontal", size: b="medium", variant: v="outlined", ...S} = r
      , C = {
        ...r,
        color: a,
        component: s,
        disabled: c,
        disableElevation: u,
        disableFocusRipple: f,
        disableRipple: h,
        fullWidth: m,
        orientation: y,
        size: b,
        variant: v
    }
      , w = oae(C)
      , k = A.useMemo( () => ({
        className: w.grouped,
        color: a,
        disabled: c,
        disableElevation: u,
        disableFocusRipple: f,
        disableRipple: h,
        fullWidth: m,
        size: b,
        variant: v
    }), [a, c, u, f, h, m, b, v, w.grouped])
      , T = nae(i)
      , E = T.length
      , P = D => {
        const $ = D === 0
          , z = D === E - 1;
        return $ && z ? "" : $ ? w.firstButton : z ? w.lastButton : w.middleButton
    }
    ;
    return g.jsx(aae, {
        as: s,
        role: "group",
        className: Ne(w.root, o),
        ref: n,
        ownerState: C,
        ...S,
        children: g.jsx(VN.Provider, {
            value: k,
            children: T.map( (D, $) => g.jsx(HN.Provider, {
                value: P($),
                children: D
            }, $))
        })
    })
});
function lae(e) {
    return rt("MuiCard", e)
}
ot("MuiCard", ["root"]);
const cae = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, lae, t)
}
  , uae = ue(yn, {
    name: "MuiCard",
    slot: "Root"
})({
    overflow: "hidden"
})
  , X2 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiCard"
    })
      , {className: i, raised: o=!1, ...a} = r
      , s = {
        ...r,
        raised: o
    }
      , c = cae(s);
    return g.jsx(uae, {
        className: Ne(c.root, i),
        elevation: o ? 8 : void 0,
        ref: n,
        ownerState: s,
        ...a
    })
});
function dae(e) {
    return rt("MuiCardContent", e)
}
ot("MuiCardContent", ["root"]);
const fae = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, dae, t)
}
  , hae = ue("div", {
    name: "MuiCardContent",
    slot: "Root"
})({
    padding: 16,
    "&:last-child": {
        paddingBottom: 24
    }
})
  , J2 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiCardContent"
    })
      , {className: i, component: o="div", ...a} = r
      , s = {
        ...r,
        component: o
    }
      , c = fae(s);
    return g.jsx(hae, {
        as: o,
        className: Ne(c.root, i),
        ownerState: s,
        ref: n,
        ...a
    })
});
function pae(e) {
    return rt("PrivateSwitchBase", e)
}
ot("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const mae = e => {
    const {classes: t, checked: n, disabled: r, edge: i} = e
      , o = {
        root: ["root", n && "checked", r && "disabled", i && `edge${Te(i)}`],
        input: ["input"]
    };
    return tt(o, pae, t)
}
  , gae = ue(Ka, {
    name: "MuiSwitchBase"
})({
    padding: 9,
    borderRadius: "50%",
    variants: [{
        props: {
            edge: "start",
            size: "small"
        },
        style: {
            marginLeft: -3
        }
    }, {
        props: ({edge: e, ownerState: t}) => e === "start" && t.size !== "small",
        style: {
            marginLeft: -12
        }
    }, {
        props: {
            edge: "end",
            size: "small"
        },
        style: {
            marginRight: -3
        }
    }, {
        props: ({edge: e, ownerState: t}) => e === "end" && t.size !== "small",
        style: {
            marginRight: -12
        }
    }]
})
  , yae = ue("input", {
    name: "MuiSwitchBase",
    shouldForwardProp: ai
})({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
})
  , WN = A.forwardRef(function(t, n) {
    const {autoFocus: r, checked: i, checkedIcon: o, defaultChecked: a, disabled: s, disableFocusRipple: c=!1, edge: u=!1, icon: f, id: h, inputProps: m, inputRef: y, name: b, onBlur: v, onChange: S, onFocus: C, readOnly: w, required: k=!1, tabIndex: T, type: E, value: P, slots: D={}, slotProps: $={}, ...z} = t
      , [O,I] = go({
        controlled: i,
        default: !!a,
        name: "SwitchBase",
        state: "checked"
    })
      , M = To()
      , B = K => {
        C && C(K),
        M && M.onFocus && M.onFocus(K)
    }
      , L = K => {
        v && v(K),
        M && M.onBlur && M.onBlur(K)
    }
      , F = K => {
        if (K.nativeEvent.defaultPrevented)
            return;
        const ee = K.target.checked;
        I(ee),
        S && S(K, ee)
    }
    ;
    let j = s;
    M && typeof j > "u" && (j = M.disabled);
    const N = E === "checkbox" || E === "radio"
      , H = {
        ...t,
        checked: O,
        disabled: j,
        disableFocusRipple: c,
        edge: u
    }
      , Z = mae(H)
      , q = {
        slots: D,
        slotProps: {
            input: m,
            ...$
        }
    }
      , [V,Y] = mt("root", {
        ref: n,
        elementType: gae,
        className: Z.root,
        shouldForwardComponentProp: !0,
        externalForwardedProps: {
            ...q,
            component: "span",
            ...z
        },
        getSlotProps: K => ({
            ...K,
            onFocus: ee => {
                K.onFocus?.(ee),
                B(ee)
            }
            ,
            onBlur: ee => {
                K.onBlur?.(ee),
                L(ee)
            }
        }),
        ownerState: H,
        additionalProps: {
            centerRipple: !0,
            focusRipple: !c,
            disabled: j,
            role: void 0,
            tabIndex: null
        }
    })
      , [W,te] = mt("input", {
        ref: y,
        elementType: yae,
        className: Z.input,
        externalForwardedProps: q,
        getSlotProps: K => ({
            ...K,
            onChange: ee => {
                K.onChange?.(ee),
                F(ee)
            }
        }),
        ownerState: H,
        additionalProps: {
            autoFocus: r,
            checked: i,
            defaultChecked: a,
            disabled: j,
            id: N ? h : void 0,
            name: b,
            readOnly: w,
            required: k,
            tabIndex: T,
            type: E,
            ...E === "checkbox" && P === void 0 ? {} : {
                value: P
            }
        }
    });
    return g.jsxs(V, {
        ...Y,
        children: [g.jsx(W, {
            ...te
        }), O ? o : f]
    })
})
  , bae = _t(g.jsx("path", {
    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}))
  , xae = _t(g.jsx("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}))
  , vae = _t(g.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}));
function Sae(e) {
    return rt("MuiCheckbox", e)
}
const Yw = ot("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"])
  , Cae = e => {
    const {classes: t, indeterminate: n, color: r, size: i} = e
      , o = {
        root: ["root", n && "indeterminate", `color${Te(r)}`, `size${Te(i)}`]
    }
      , a = tt(o, Sae, t);
    return {
        ...t,
        ...a
    }
}
  , wae = ue(WN, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiCheckbox",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.indeterminate && t.indeterminate, t[`size${Te(n.size)}`], n.color !== "default" && t[`color${Te(n.color)}`]]
    }
})(pt( ({theme: e}) => ({
    color: (e.vars || e).palette.text.secondary,
    variants: [{
        props: {
            color: "default",
            disableRipple: !1
        },
        style: {
            "&:hover": {
                backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
            }
        }
    }, ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t,
            disableRipple: !1
        },
        style: {
            "&:hover": {
                backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
            }
        }
    })), ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            [`&.${Yw.checked}, &.${Yw.indeterminate}`]: {
                color: (e.vars || e).palette[t].main
            },
            [`&.${Yw.disabled}`]: {
                color: (e.vars || e).palette.action.disabled
            }
        }
    })), {
        props: {
            disableRipple: !1
        },
        style: {
            "&:hover": {
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        }
    }]
})))
  , kae = g.jsx(xae, {})
  , Tae = g.jsx(bae, {})
  , _ae = g.jsx(vae, {})
  , Eae = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiCheckbox"
    })
      , {checkedIcon: i=kae, color: o="primary", icon: a=Tae, indeterminate: s=!1, indeterminateIcon: c=_ae, inputProps: u, size: f="medium", disableRipple: h=!1, className: m, slots: y={}, slotProps: b={}, ...v} = r
      , S = s ? c : a
      , C = s ? c : i
      , w = {
        ...r,
        disableRipple: h,
        color: o,
        indeterminate: s,
        size: f
    }
      , k = Cae(w)
      , T = b.input ?? u
      , [E,P] = mt("root", {
        ref: n,
        elementType: wae,
        className: Ne(k.root, m),
        shouldForwardComponentProp: !0,
        externalForwardedProps: {
            slots: y,
            slotProps: b,
            ...v
        },
        ownerState: w,
        additionalProps: {
            type: "checkbox",
            icon: A.cloneElement(S, {
                fontSize: S.props.fontSize ?? f
            }),
            checkedIcon: A.cloneElement(C, {
                fontSize: C.props.fontSize ?? f
            }),
            disableRipple: h,
            slots: y,
            slotProps: {
                input: _E(typeof T == "function" ? T(w) : T, {
                    "data-indeterminate": s
                })
            }
        }
    });
    return g.jsx(E, {
        ...P,
        classes: k
    })
});
function H$(e) {
    return e.substring(2).toLowerCase()
}
function Aae(e, t) {
    return t.documentElement.clientWidth < e.clientX || t.documentElement.clientHeight < e.clientY
}
function Mae(e) {
    const {children: t, disableReactTree: n=!1, mouseEvent: r="onClick", onClickAway: i, touchEvent: o="onTouchEnd"} = e
      , a = A.useRef(!1)
      , s = A.useRef(null)
      , c = A.useRef(!1)
      , u = A.useRef(!1);
    A.useEffect( () => (setTimeout( () => {
        c.current = !0
    }
    , 0),
    () => {
        c.current = !1
    }
    ), []);
    const f = Cn(Rc(t), s)
      , h = ft(b => {
        const v = u.current;
        u.current = !1;
        const S = Kr(s.current);
        if (!c.current || !s.current || "clientX"in b && Aae(b, S))
            return;
        if (a.current) {
            a.current = !1;
            return
        }
        let C;
        b.composedPath ? C = b.composedPath().includes(s.current) : C = !S.documentElement.contains(b.target) || s.current.contains(b.target),
        !C && (n || !v) && i(b)
    }
    )
      , m = b => v => {
        u.current = !0;
        const S = t.props[b];
        S && S(v)
    }
      , y = {
        ref: f
    };
    return o !== !1 && (y[o] = m(o)),
    A.useEffect( () => {
        if (o !== !1) {
            const b = H$(o)
              , v = Kr(s.current)
              , S = () => {
                a.current = !0
            }
            ;
            return v.addEventListener(b, h),
            v.addEventListener("touchmove", S),
            () => {
                v.removeEventListener(b, h),
                v.removeEventListener("touchmove", S)
            }
        }
    }
    , [h, o]),
    r !== !1 && (y[r] = m(r)),
    A.useEffect( () => {
        if (r !== !1) {
            const b = H$(r)
              , v = Kr(s.current);
            return v.addEventListener(b, h),
            () => {
                v.removeEventListener(b, h)
            }
        }
    }
    , [h, r]),
    A.cloneElement(t, y)
}
const eT = typeof TE({}) == "function"
  , Pae = (e, t) => ({
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale",
    boxSizing: "border-box",
    WebkitTextSizeAdjust: "100%",
    ...t && !e.vars && {
        colorScheme: e.palette.mode
    }
})
  , Rae = e => ({
    color: (e.vars || e).palette.text.primary,
    ...e.typography.body1,
    backgroundColor: (e.vars || e).palette.background.default,
    "@media print": {
        backgroundColor: (e.vars || e).palette.common.white
    }
})
  , GN = (e, t=!1) => {
    const n = {};
    t && e.colorSchemes && typeof e.getColorSchemeSelector == "function" && Object.entries(e.colorSchemes).forEach( ([o,a]) => {
        const s = e.getColorSchemeSelector(o);
        s.startsWith("@") ? n[s] = {
            ":root": {
                colorScheme: a.palette?.mode
            }
        } : n[s.replace(/\s*&/, "")] = {
            colorScheme: a.palette?.mode
        }
    }
    );
    let r = {
        html: Pae(e, t),
        "*, *::before, *::after": {
            boxSizing: "inherit"
        },
        "strong, b": {
            fontWeight: e.typography.fontWeightBold
        },
        body: {
            margin: 0,
            ...Rae(e),
            "&::backdrop": {
                backgroundColor: (e.vars || e).palette.background.default
            }
        },
        ...n
    };
    const i = e.components?.MuiCssBaseline?.styleOverrides;
    return i && (r = [r, i]),
    r
}
  , Mx = "mui-ecs"
  , Dae = e => {
    const t = GN(e, !1)
      , n = Array.isArray(t) ? t[0] : t;
    return !e.vars && n && (n.html[`:root:has(${Mx})`] = {
        colorScheme: e.palette.mode
    }),
    e.colorSchemes && Object.entries(e.colorSchemes).forEach( ([r,i]) => {
        const o = e.getColorSchemeSelector(r);
        o.startsWith("@") ? n[o] = {
            [`:root:not(:has(.${Mx}))`]: {
                colorScheme: i.palette?.mode
            }
        } : n[o.replace(/\s*&/, "")] = {
            [`&:not(:has(.${Mx}))`]: {
                colorScheme: i.palette?.mode
            }
        }
    }
    ),
    t
}
  , Oae = TE(eT ? ({theme: e, enableColorScheme: t}) => GN(e, t) : ({theme: e}) => Dae(e));
function Iae(e) {
    const t = gt({
        props: e,
        name: "MuiCssBaseline"
    })
      , {children: n, enableColorScheme: r=!1} = t;
    return g.jsxs(A.Fragment, {
        children: [eT && g.jsx(Oae, {
            enableColorScheme: r
        }), !eT && !r && g.jsx("span", {
            className: Mx,
            style: {
                display: "none"
            }
        }), n]
    })
}
function YN(e=window) {
    const t = e.document.documentElement.clientWidth;
    return e.innerWidth - t
}
function $ae(e) {
    const t = Kr(e);
    return t.body === e ? Zo(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight
}
function mm(e, t) {
    t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden")
}
function q$(e) {
    return parseInt(Zo(e).getComputedStyle(e).paddingRight, 10) || 0
}
function Lae(e) {
    const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName)
      , r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
    return n || r
}
function W$(e, t, n, r, i) {
    const o = [t, n, ...r];
    [].forEach.call(e.children, a => {
        const s = !o.includes(a)
          , c = !Lae(a);
        s && c && mm(a, i)
    }
    )
}
function Zw(e, t) {
    let n = -1;
    return e.some( (r, i) => t(r) ? (n = i,
    !0) : !1),
    n
}
function jae(e, t) {
    const n = []
      , r = e.container;
    if (!t.disableScrollLock) {
        if ($ae(r)) {
            const a = YN(Zo(r));
            n.push({
                value: r.style.paddingRight,
                property: "padding-right",
                el: r
            }),
            r.style.paddingRight = `${q$(r) + a}px`;
            const s = Kr(r).querySelectorAll(".mui-fixed");
            [].forEach.call(s, c => {
                n.push({
                    value: c.style.paddingRight,
                    property: "padding-right",
                    el: c
                }),
                c.style.paddingRight = `${q$(c) + a}px`
            }
            )
        }
        let o;
        if (r.parentNode instanceof DocumentFragment)
            o = Kr(r).body;
        else {
            const a = r.parentElement
              , s = Zo(r);
            o = a?.nodeName === "HTML" && s.getComputedStyle(a).overflowY === "scroll" ? a : r
        }
        n.push({
            value: o.style.overflow,
            property: "overflow",
            el: o
        }, {
            value: o.style.overflowX,
            property: "overflow-x",
            el: o
        }, {
            value: o.style.overflowY,
            property: "overflow-y",
            el: o
        }),
        o.style.overflow = "hidden"
    }
    return () => {
        n.forEach( ({value: o, el: a, property: s}) => {
            o ? a.style.setProperty(s, o) : a.style.removeProperty(s)
        }
        )
    }
}
function Bae(e) {
    const t = [];
    return [].forEach.call(e.children, n => {
        n.getAttribute("aria-hidden") === "true" && t.push(n)
    }
    ),
    t
}
class zae {
    constructor() {
        this.modals = [],
        this.containers = []
    }
    add(t, n) {
        let r = this.modals.indexOf(t);
        if (r !== -1)
            return r;
        r = this.modals.length,
        this.modals.push(t),
        t.modalRef && mm(t.modalRef, !1);
        const i = Bae(n);
        W$(n, t.mount, t.modalRef, i, !0);
        const o = Zw(this.containers, a => a.container === n);
        return o !== -1 ? (this.containers[o].modals.push(t),
        r) : (this.containers.push({
            modals: [t],
            container: n,
            restore: null,
            hiddenSiblings: i
        }),
        r)
    }
    mount(t, n) {
        const r = Zw(this.containers, o => o.modals.includes(t))
          , i = this.containers[r];
        i.restore || (i.restore = jae(i, n))
    }
    remove(t, n=!0) {
        const r = this.modals.indexOf(t);
        if (r === -1)
            return r;
        const i = Zw(this.containers, a => a.modals.includes(t))
          , o = this.containers[i];
        if (o.modals.splice(o.modals.indexOf(t), 1),
        this.modals.splice(r, 1),
        o.modals.length === 0)
            o.restore && o.restore(),
            t.modalRef && mm(t.modalRef, n),
            W$(o.container, t.mount, t.modalRef, o.hiddenSiblings, !1),
            this.containers.splice(i, 1);
        else {
            const a = o.modals[o.modals.length - 1];
            a.modalRef && mm(a.modalRef, !1)
        }
        return r
    }
    isTopModal(t) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === t
    }
}
const Fae = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function Nae(e) {
    const t = parseInt(e.getAttribute("tabindex") || "", 10);
    return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t
}
function Uae(e) {
    if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
        return !1;
    const t = r => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
    let n = t(`[name="${e.name}"]:checked`);
    return n || (n = t(`[name="${e.name}"]`)),
    n !== e
}
function Vae(e) {
    return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || Uae(e))
}
function Hae(e) {
    const t = []
      , n = [];
    return Array.from(e.querySelectorAll(Fae)).forEach( (r, i) => {
        const o = Nae(r);
        o === -1 || !Vae(r) || (o === 0 ? t.push(r) : n.push({
            documentOrder: i,
            tabIndex: o,
            node: r
        }))
    }
    ),
    n.sort( (r, i) => r.tabIndex === i.tabIndex ? r.documentOrder - i.documentOrder : r.tabIndex - i.tabIndex).map(r => r.node).concat(t)
}
function qae() {
    return !0
}
function ZN(e) {
    const {children: t, disableAutoFocus: n=!1, disableEnforceFocus: r=!1, disableRestoreFocus: i=!1, getTabbable: o=Hae, isEnabled: a=qae, open: s} = e
      , c = A.useRef(!1)
      , u = A.useRef(null)
      , f = A.useRef(null)
      , h = A.useRef(null)
      , m = A.useRef(null)
      , y = A.useRef(!1)
      , b = A.useRef(null)
      , v = Cn(Rc(t), b)
      , S = A.useRef(null);
    A.useEffect( () => {
        !s || !b.current || (y.current = !n)
    }
    , [n, s]),
    A.useEffect( () => {
        if (!s || !b.current)
            return;
        const k = Kr(b.current);
        return b.current.contains(k.activeElement) || (b.current.hasAttribute("tabIndex") || b.current.setAttribute("tabIndex", "-1"),
        y.current && b.current.focus()),
        () => {
            i || (h.current && h.current.focus && (c.current = !0,
            h.current.focus()),
            h.current = null)
        }
    }
    , [s]),
    A.useEffect( () => {
        if (!s || !b.current)
            return;
        const k = Kr(b.current)
          , T = D => {
            S.current = D,
            !(r || !a() || D.key !== "Tab") && k.activeElement === b.current && D.shiftKey && (c.current = !0,
            f.current && f.current.focus())
        }
          , E = () => {
            const D = b.current;
            if (D === null)
                return;
            if (!k.hasFocus() || !a() || c.current) {
                c.current = !1;
                return
            }
            if (D.contains(k.activeElement) || r && k.activeElement !== u.current && k.activeElement !== f.current)
                return;
            if (k.activeElement !== m.current)
                m.current = null;
            else if (m.current !== null)
                return;
            if (!y.current)
                return;
            let $ = [];
            if ((k.activeElement === u.current || k.activeElement === f.current) && ($ = o(b.current)),
            $.length > 0) {
                const z = !!(S.current?.shiftKey && S.current?.key === "Tab")
                  , O = $[0]
                  , I = $[$.length - 1];
                typeof O != "string" && typeof I != "string" && (z ? I.focus() : O.focus())
            } else
                D.focus()
        }
        ;
        k.addEventListener("focusin", E),
        k.addEventListener("keydown", T, !0);
        const P = setInterval( () => {
            k.activeElement && k.activeElement.tagName === "BODY" && E()
        }
        , 50);
        return () => {
            clearInterval(P),
            k.removeEventListener("focusin", E),
            k.removeEventListener("keydown", T, !0)
        }
    }
    , [n, r, i, a, s, o]);
    const C = k => {
        h.current === null && (h.current = k.relatedTarget),
        y.current = !0,
        m.current = k.target;
        const T = t.props.onFocus;
        T && T(k)
    }
      , w = k => {
        h.current === null && (h.current = k.relatedTarget),
        y.current = !0
    }
    ;
    return g.jsxs(A.Fragment, {
        children: [g.jsx("div", {
            tabIndex: s ? 0 : -1,
            onFocus: w,
            ref: u,
            "data-testid": "sentinelStart"
        }), A.cloneElement(t, {
            ref: v,
            onFocus: C
        }), g.jsx("div", {
            tabIndex: s ? 0 : -1,
            onFocus: w,
            ref: f,
            "data-testid": "sentinelEnd"
        })]
    })
}
function Wae(e) {
    return typeof e == "function" ? e() : e
}
function Gae(e) {
    return e ? e.props.hasOwnProperty("in") : !1
}
const G$ = () => {}
  , Ib = new zae;
function Yae(e) {
    const {container: t, disableEscapeKeyDown: n=!1, disableScrollLock: r=!1, closeAfterTransition: i=!1, onTransitionEnter: o, onTransitionExited: a, children: s, onClose: c, open: u, rootRef: f} = e
      , h = A.useRef({})
      , m = A.useRef(null)
      , y = A.useRef(null)
      , b = Cn(y, f)
      , [v,S] = A.useState(!u)
      , C = Gae(s);
    let w = !0;
    (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (w = !1);
    const k = () => Kr(m.current)
      , T = () => (h.current.modalRef = y.current,
    h.current.mount = m.current,
    h.current)
      , E = () => {
        Ib.mount(T(), {
            disableScrollLock: r
        }),
        y.current && (y.current.scrollTop = 0)
    }
      , P = ft( () => {
        const F = Wae(t) || k().body;
        Ib.add(T(), F),
        y.current && E()
    }
    )
      , D = () => Ib.isTopModal(T())
      , $ = ft(F => {
        m.current = F,
        F && (u && D() ? E() : y.current && mm(y.current, w))
    }
    )
      , z = A.useCallback( () => {
        Ib.remove(T(), w)
    }
    , [w]);
    A.useEffect( () => () => {
        z()
    }
    , [z]),
    A.useEffect( () => {
        u ? P() : (!C || !i) && z()
    }
    , [u, z, C, i, P]);
    const O = F => j => {
        F.onKeyDown?.(j),
        !(j.key !== "Escape" || j.which === 229 || !D()) && (n || (j.stopPropagation(),
        c && c(j, "escapeKeyDown")))
    }
      , I = F => j => {
        F.onClick?.(j),
        j.target === j.currentTarget && c && c(j, "backdropClick")
    }
    ;
    return {
        getRootProps: (F={}) => {
            const j = p0(e);
            delete j.onTransitionEnter,
            delete j.onTransitionExited;
            const N = {
                ...j,
                ...F
            };
            return {
                role: "presentation",
                ...N,
                onKeyDown: O(N),
                ref: b
            }
        }
        ,
        getBackdropProps: (F={}) => {
            const j = F;
            return {
                "aria-hidden": !0,
                ...j,
                onClick: I(j),
                open: u
            }
        }
        ,
        getTransitionProps: () => {
            const F = () => {
                S(!1),
                o && o()
            }
              , j = () => {
                S(!0),
                a && a(),
                i && z()
            }
            ;
            return {
                onEnter: F2(F, s?.props.onEnter ?? G$),
                onExited: F2(j, s?.props.onExited ?? G$)
            }
        }
        ,
        rootRef: b,
        portalRef: $,
        isTopModal: D,
        exited: v,
        hasTransition: C
    }
}
function Zae(e) {
    return rt("MuiModal", e)
}
ot("MuiModal", ["root", "hidden", "backdrop"]);
const Qae = e => {
    const {open: t, exited: n, classes: r} = e;
    return tt({
        root: ["root", !t && n && "hidden"],
        backdrop: ["backdrop"]
    }, Zae, r)
}
  , Kae = ue("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, !n.open && n.exited && t.hidden]
    }
})(pt( ({theme: e}) => ({
    position: "fixed",
    zIndex: (e.vars || e).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    variants: [{
        props: ({ownerState: t}) => !t.open && t.exited,
        style: {
            visibility: "hidden"
        }
    }]
})))
  , Xae = ue(jg, {
    name: "MuiModal",
    slot: "Backdrop"
})({
    zIndex: -1
})
  , FE = A.forwardRef(function(t, n) {
    const r = gt({
        name: "MuiModal",
        props: t
    })
      , {BackdropComponent: i=Xae, BackdropProps: o, classes: a, className: s, closeAfterTransition: c=!1, children: u, container: f, component: h, components: m={}, componentsProps: y={}, disableAutoFocus: b=!1, disableEnforceFocus: v=!1, disableEscapeKeyDown: S=!1, disablePortal: C=!1, disableRestoreFocus: w=!1, disableScrollLock: k=!1, hideBackdrop: T=!1, keepMounted: E=!1, onClose: P, onTransitionEnter: D, onTransitionExited: $, open: z, slotProps: O={}, slots: I={}, theme: M, ...B} = r
      , L = {
        ...r,
        closeAfterTransition: c,
        disableAutoFocus: b,
        disableEnforceFocus: v,
        disableEscapeKeyDown: S,
        disablePortal: C,
        disableRestoreFocus: w,
        disableScrollLock: k,
        hideBackdrop: T,
        keepMounted: E
    }
      , {getRootProps: F, getBackdropProps: j, getTransitionProps: N, portalRef: H, isTopModal: Z, exited: q, hasTransition: V} = Yae({
        ...L,
        rootRef: n
    })
      , Y = {
        ...L,
        exited: q
    }
      , W = Qae(Y)
      , te = {};
    if (u.props.tabIndex === void 0 && (te.tabIndex = "-1"),
    V) {
        const {onEnter: oe, onExited: we} = N();
        te.onEnter = oe,
        te.onExited = we
    }
    const K = {
        slots: {
            root: m.Root,
            backdrop: m.Backdrop,
            ...I
        },
        slotProps: {
            ...y,
            ...O
        }
    }
      , [ee,re] = mt("root", {
        ref: n,
        elementType: Kae,
        externalForwardedProps: {
            ...K,
            ...B,
            component: h
        },
        getSlotProps: F,
        ownerState: Y,
        className: Ne(s, W?.root, !Y.open && Y.exited && W?.hidden)
    })
      , [ie,J] = mt("backdrop", {
        ref: o?.ref,
        elementType: i,
        externalForwardedProps: K,
        shouldForwardComponentProp: !0,
        additionalProps: o,
        getSlotProps: oe => j({
            ...oe,
            onClick: we => {
                oe?.onClick && oe.onClick(we)
            }
        }),
        className: Ne(o?.className, W?.backdrop),
        ownerState: Y
    });
    return !E && !z && (!V || q) ? null : g.jsx(FN, {
        ref: H,
        container: f,
        disablePortal: C,
        children: g.jsxs(ee, {
            ...re,
            children: [!T && i ? g.jsx(ie, {
                ...J
            }) : null, g.jsx(ZN, {
                disableEnforceFocus: v,
                disableAutoFocus: b,
                disableRestoreFocus: w,
                isEnabled: Z,
                open: z,
                children: A.cloneElement(u, te)
            })]
        })
    })
});
function Jae(e) {
    return rt("MuiDialog", e)
}
const gm = ot("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"])
  , QN = A.createContext({})
  , ese = ue(jg, {
    name: "MuiDialog",
    slot: "Backdrop",
    overrides: (e, t) => t.backdrop
})({
    zIndex: -1
})
  , tse = e => {
    const {classes: t, scroll: n, maxWidth: r, fullWidth: i, fullScreen: o} = e
      , a = {
        root: ["root"],
        container: ["container", `scroll${Te(n)}`],
        paper: ["paper", `paperScroll${Te(n)}`, `paperWidth${Te(String(r))}`, i && "paperFullWidth", o && "paperFullScreen"]
    };
    return tt(a, Jae, t)
}
  , nse = ue(FE, {
    name: "MuiDialog",
    slot: "Root"
})({
    "@media print": {
        position: "absolute !important"
    }
})
  , rse = ue("div", {
    name: "MuiDialog",
    slot: "Container",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.container, t[`scroll${Te(n.scroll)}`]]
    }
})({
    height: "100%",
    "@media print": {
        height: "auto"
    },
    outline: 0,
    variants: [{
        props: {
            scroll: "paper"
        },
        style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
        }
    }, {
        props: {
            scroll: "body"
        },
        style: {
            overflowY: "auto",
            overflowX: "hidden",
            textAlign: "center",
            "&::after": {
                content: '""',
                display: "inline-block",
                verticalAlign: "middle",
                height: "100%",
                width: "0"
            }
        }
    }]
})
  , ise = ue(yn, {
    name: "MuiDialog",
    slot: "Paper",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.paper, t[`scrollPaper${Te(n.scroll)}`], t[`paperWidth${Te(String(n.maxWidth))}`], n.fullWidth && t.paperFullWidth, n.fullScreen && t.paperFullScreen]
    }
})(pt( ({theme: e}) => ({
    margin: 32,
    position: "relative",
    overflowY: "auto",
    "@media print": {
        overflowY: "visible",
        boxShadow: "none"
    },
    variants: [{
        props: {
            scroll: "paper"
        },
        style: {
            display: "flex",
            flexDirection: "column",
            maxHeight: "calc(100% - 64px)"
        }
    }, {
        props: {
            scroll: "body"
        },
        style: {
            display: "inline-block",
            verticalAlign: "middle",
            textAlign: "initial"
        }
    }, {
        props: ({ownerState: t}) => !t.maxWidth,
        style: {
            maxWidth: "calc(100% - 64px)"
        }
    }, {
        props: {
            maxWidth: "xs"
        },
        style: {
            maxWidth: e.breakpoints.unit === "px" ? Math.max(e.breakpoints.values.xs, 444) : `max(${e.breakpoints.values.xs}${e.breakpoints.unit}, 444px)`,
            [`&.${gm.paperScrollBody}`]: {
                [e.breakpoints.down(Math.max(e.breakpoints.values.xs, 444) + 64)]: {
                    maxWidth: "calc(100% - 64px)"
                }
            }
        }
    }, ...Object.keys(e.breakpoints.values).filter(t => t !== "xs").map(t => ({
        props: {
            maxWidth: t
        },
        style: {
            maxWidth: `${e.breakpoints.values[t]}${e.breakpoints.unit}`,
            [`&.${gm.paperScrollBody}`]: {
                [e.breakpoints.down(e.breakpoints.values[t] + 64)]: {
                    maxWidth: "calc(100% - 64px)"
                }
            }
        }
    })), {
        props: ({ownerState: t}) => t.fullWidth,
        style: {
            width: "calc(100% - 64px)"
        }
    }, {
        props: ({ownerState: t}) => t.fullScreen,
        style: {
            margin: 0,
            width: "100%",
            maxWidth: "100%",
            height: "100%",
            maxHeight: "none",
            borderRadius: 0,
            [`&.${gm.paperScrollBody}`]: {
                margin: 0,
                maxWidth: "100%"
            }
        }
    }]
})))
  , sc = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiDialog"
    })
      , i = ko()
      , o = {
        enter: i.transitions.duration.enteringScreen,
        exit: i.transitions.duration.leavingScreen
    }
      , {"aria-describedby": a, "aria-labelledby": s, "aria-modal": c=!0, BackdropComponent: u, BackdropProps: f, children: h, className: m, disableEscapeKeyDown: y=!1, fullScreen: b=!1, fullWidth: v=!1, maxWidth: S="sm", onClick: C, onClose: w, open: k, PaperComponent: T=yn, PaperProps: E={}, scroll: P="paper", slots: D={}, slotProps: $={}, TransitionComponent: z=vc, transitionDuration: O=o, TransitionProps: I, ...M} = r
      , B = {
        ...r,
        disableEscapeKeyDown: y,
        fullScreen: b,
        fullWidth: v,
        maxWidth: S,
        scroll: P
    }
      , L = tse(B)
      , F = A.useRef()
      , j = se => {
        F.current = se.target === se.currentTarget
    }
      , N = se => {
        C && C(se),
        F.current && (F.current = null,
        w && w(se, "backdropClick"))
    }
      , H = Gi(s)
      , Z = A.useMemo( () => ({
        titleId: H
    }), [H])
      , q = {
        transition: z,
        ...D
    }
      , V = {
        transition: I,
        paper: E,
        backdrop: f,
        ...$
    }
      , Y = {
        slots: q,
        slotProps: V
    }
      , [W,te] = mt("root", {
        elementType: nse,
        shouldForwardComponentProp: !0,
        externalForwardedProps: Y,
        ownerState: B,
        className: Ne(L.root, m),
        ref: n
    })
      , [K,ee] = mt("backdrop", {
        elementType: ese,
        shouldForwardComponentProp: !0,
        externalForwardedProps: Y,
        ownerState: B
    })
      , [re,ie] = mt("paper", {
        elementType: ise,
        shouldForwardComponentProp: !0,
        externalForwardedProps: Y,
        ownerState: B,
        className: Ne(L.paper, E.className)
    })
      , [J,oe] = mt("container", {
        elementType: rse,
        externalForwardedProps: Y,
        ownerState: B,
        className: L.container
    })
      , [we,xe] = mt("transition", {
        elementType: vc,
        externalForwardedProps: Y,
        ownerState: B,
        additionalProps: {
            appear: !0,
            in: k,
            timeout: O,
            role: "presentation"
        }
    });
    return g.jsx(W, {
        closeAfterTransition: !0,
        slots: {
            backdrop: K
        },
        slotProps: {
            backdrop: {
                transitionDuration: O,
                as: u,
                ...ee
            }
        },
        disableEscapeKeyDown: y,
        onClose: w,
        open: k,
        onClick: N,
        ...te,
        ...M,
        children: g.jsx(we, {
            ...xe,
            children: g.jsx(J, {
                onMouseDown: j,
                ...oe,
                children: g.jsx(re, {
                    as: T,
                    elevation: 24,
                    role: "dialog",
                    "aria-describedby": a,
                    "aria-labelledby": H,
                    "aria-modal": c,
                    ...ie,
                    children: g.jsx(QN.Provider, {
                        value: Z,
                        children: h
                    })
                })
            })
        })
    })
});
function ose(e) {
    return rt("MuiDialogActions", e)
}
ot("MuiDialogActions", ["root", "spacing"]);
const ase = e => {
    const {classes: t, disableSpacing: n} = e;
    return tt({
        root: ["root", !n && "spacing"]
    }, ose, t)
}
  , sse = ue("div", {
    name: "MuiDialogActions",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, !n.disableSpacing && t.spacing]
    }
})({
    display: "flex",
    alignItems: "center",
    padding: 8,
    justifyContent: "flex-end",
    flex: "0 0 auto",
    variants: [{
        props: ({ownerState: e}) => !e.disableSpacing,
        style: {
            "& > :not(style) ~ :not(style)": {
                marginLeft: 8
            }
        }
    }]
})
  , lc = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiDialogActions"
    })
      , {className: i, disableSpacing: o=!1, ...a} = r
      , s = {
        ...r,
        disableSpacing: o
    }
      , c = ase(s);
    return g.jsx(sse, {
        className: Ne(c.root, i),
        ownerState: s,
        ref: n,
        ...a
    })
});
function lse(e) {
    return rt("MuiDialogContent", e)
}
ot("MuiDialogContent", ["root", "dividers"]);
function cse(e) {
    return rt("MuiDialogTitle", e)
}
const use = ot("MuiDialogTitle", ["root"])
  , dse = e => {
    const {classes: t, dividers: n} = e;
    return tt({
        root: ["root", n && "dividers"]
    }, lse, t)
}
  , fse = ue("div", {
    name: "MuiDialogContent",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.dividers && t.dividers]
    }
})(pt( ({theme: e}) => ({
    flex: "1 1 auto",
    WebkitOverflowScrolling: "touch",
    overflowY: "auto",
    padding: "20px 24px",
    variants: [{
        props: ({ownerState: t}) => t.dividers,
        style: {
            padding: "16px 24px",
            borderTop: `1px solid ${(e.vars || e).palette.divider}`,
            borderBottom: `1px solid ${(e.vars || e).palette.divider}`
        }
    }, {
        props: ({ownerState: t}) => !t.dividers,
        style: {
            [`.${use.root} + &`]: {
                paddingTop: 0
            }
        }
    }]
})))
  , cc = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiDialogContent"
    })
      , {className: i, dividers: o=!1, ...a} = r
      , s = {
        ...r,
        dividers: o
    }
      , c = dse(s);
    return g.jsx(fse, {
        className: Ne(c.root, i),
        ownerState: s,
        ref: n,
        ...a
    })
});
function hse(e) {
    return rt("MuiDialogContentText", e)
}
ot("MuiDialogContentText", ["root"]);
const pse = e => {
    const {classes: t} = e
      , r = tt({
        root: ["root"]
    }, hse, t);
    return {
        ...t,
        ...r
    }
}
  , mse = ue(Ae, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiDialogContentText",
    slot: "Root"
})({})
  , Px = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiDialogContentText"
    })
      , {children: i, className: o, ...a} = r
      , s = pse(a);
    return g.jsx(mse, {
        component: "p",
        variant: "body1",
        color: "textSecondary",
        ref: n,
        ownerState: a,
        className: Ne(s.root, o),
        ...r,
        classes: s
    })
})
  , gse = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, cse, t)
}
  , yse = ue(Ae, {
    name: "MuiDialogTitle",
    slot: "Root"
})({
    padding: "16px 24px",
    flex: "0 0 auto"
})
  , yu = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiDialogTitle"
    })
      , {className: i, id: o, ...a} = r
      , s = r
      , c = gse(s)
      , {titleId: u=o} = A.useContext(QN);
    return g.jsx(yse, {
        component: "h2",
        className: Ne(c.root, i),
        ownerState: s,
        ref: n,
        variant: "h6",
        id: o ?? u,
        ...a
    })
});
function bse(e) {
    return rt("MuiDivider", e)
}
const Y$ = ot("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"])
  , xse = e => {
    const {absolute: t, children: n, classes: r, flexItem: i, light: o, orientation: a, textAlign: s, variant: c} = e;
    return tt({
        root: ["root", t && "absolute", c, o && "light", a === "vertical" && "vertical", i && "flexItem", n && "withChildren", n && a === "vertical" && "withChildrenVertical", s === "right" && a !== "vertical" && "textAlignRight", s === "left" && a !== "vertical" && "textAlignLeft"],
        wrapper: ["wrapper", a === "vertical" && "wrapperVertical"]
    }, bse, r)
}
  , vse = ue("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft]
    }
})(pt( ({theme: e}) => ({
    margin: 0,
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (e.vars || e).palette.divider,
    borderBottomWidth: "thin",
    variants: [{
        props: {
            absolute: !0
        },
        style: {
            position: "absolute",
            bottom: 0,
            left: 0,
            width: "100%"
        }
    }, {
        props: {
            light: !0
        },
        style: {
            borderColor: e.alpha((e.vars || e).palette.divider, .08)
        }
    }, {
        props: {
            variant: "inset"
        },
        style: {
            marginLeft: 72
        }
    }, {
        props: {
            variant: "middle",
            orientation: "horizontal"
        },
        style: {
            marginLeft: e.spacing(2),
            marginRight: e.spacing(2)
        }
    }, {
        props: {
            variant: "middle",
            orientation: "vertical"
        },
        style: {
            marginTop: e.spacing(1),
            marginBottom: e.spacing(1)
        }
    }, {
        props: {
            orientation: "vertical"
        },
        style: {
            height: "100%",
            borderBottomWidth: 0,
            borderRightWidth: "thin"
        }
    }, {
        props: {
            flexItem: !0
        },
        style: {
            alignSelf: "stretch",
            height: "auto"
        }
    }, {
        props: ({ownerState: t}) => !!t.children,
        style: {
            display: "flex",
            textAlign: "center",
            border: 0,
            borderTopStyle: "solid",
            borderLeftStyle: "solid",
            "&::before, &::after": {
                content: '""',
                alignSelf: "center"
            }
        }
    }, {
        props: ({ownerState: t}) => t.children && t.orientation !== "vertical",
        style: {
            "&::before, &::after": {
                width: "100%",
                borderTop: `thin solid ${(e.vars || e).palette.divider}`,
                borderTopStyle: "inherit"
            }
        }
    }, {
        props: ({ownerState: t}) => t.orientation === "vertical" && t.children,
        style: {
            flexDirection: "column",
            "&::before, &::after": {
                height: "100%",
                borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
                borderLeftStyle: "inherit"
            }
        }
    }, {
        props: ({ownerState: t}) => t.textAlign === "right" && t.orientation !== "vertical",
        style: {
            "&::before": {
                width: "90%"
            },
            "&::after": {
                width: "10%"
            }
        }
    }, {
        props: ({ownerState: t}) => t.textAlign === "left" && t.orientation !== "vertical",
        style: {
            "&::before": {
                width: "10%"
            },
            "&::after": {
                width: "90%"
            }
        }
    }]
})))
  , Sse = ue("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical]
    }
})(pt( ({theme: e}) => ({
    display: "inline-block",
    paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
    paddingRight: `calc(${e.spacing(1)} * 1.2)`,
    whiteSpace: "nowrap",
    variants: [{
        props: {
            orientation: "vertical"
        },
        style: {
            paddingTop: `calc(${e.spacing(1)} * 1.2)`,
            paddingBottom: `calc(${e.spacing(1)} * 1.2)`
        }
    }]
})))
  , Wm = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiDivider"
    })
      , {absolute: i=!1, children: o, className: a, orientation: s="horizontal", component: c=o || s === "vertical" ? "div" : "hr", flexItem: u=!1, light: f=!1, role: h=c !== "hr" ? "separator" : void 0, textAlign: m="center", variant: y="fullWidth", ...b} = r
      , v = {
        ...r,
        absolute: i,
        component: c,
        flexItem: u,
        light: f,
        orientation: s,
        role: h,
        textAlign: m,
        variant: y
    }
      , S = xse(v);
    return g.jsx(vse, {
        as: c,
        className: Ne(S.root, a),
        role: h,
        ref: n,
        ownerState: v,
        "aria-orientation": h === "separator" && (c !== "hr" || s === "vertical") ? s : void 0,
        ...b,
        children: o ? g.jsx(Sse, {
            className: S.wrapper,
            ownerState: v,
            children: o
        }) : null
    })
});
Wm && (Wm.muiSkipListHighlight = !0);
function Cse(e, t, n) {
    const r = t.getBoundingClientRect()
      , i = n && n.getBoundingClientRect()
      , o = Zo(t);
    let a;
    if (t.fakeTransform)
        a = t.fakeTransform;
    else {
        const u = o.getComputedStyle(t);
        a = u.getPropertyValue("-webkit-transform") || u.getPropertyValue("transform")
    }
    let s = 0
      , c = 0;
    if (a && a !== "none" && typeof a == "string") {
        const u = a.split("(")[1].split(")")[0].split(",");
        s = parseInt(u[4], 10),
        c = parseInt(u[5], 10)
    }
    return e === "left" ? i ? `translateX(${i.right + s - r.left}px)` : `translateX(${o.innerWidth + s - r.left}px)` : e === "right" ? i ? `translateX(-${r.right - i.left - s}px)` : `translateX(-${r.left + r.width - s}px)` : e === "up" ? i ? `translateY(${i.bottom + c - r.top}px)` : `translateY(${o.innerHeight + c - r.top}px)` : i ? `translateY(-${r.top - i.top + r.height - c}px)` : `translateY(-${r.top + r.height - c}px)`
}
function wse(e) {
    return typeof e == "function" ? e() : e
}
function $b(e, t, n) {
    const r = wse(n)
      , i = Cse(e, t, r);
    i && (t.style.webkitTransform = i,
    t.style.transform = i)
}
const kse = A.forwardRef(function(t, n) {
    const r = ko()
      , i = {
        enter: r.transitions.easing.easeOut,
        exit: r.transitions.easing.sharp
    }
      , o = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen
    }
      , {addEndListener: a, appear: s=!0, children: c, container: u, direction: f="down", easing: h=i, in: m, onEnter: y, onEntered: b, onEntering: v, onExit: S, onExited: C, onExiting: w, style: k, timeout: T=o, TransitionComponent: E=Xo, ...P} = t
      , D = A.useRef(null)
      , $ = Cn(Rc(c), D, n)
      , z = H => Z => {
        H && (Z === void 0 ? H(D.current) : H(D.current, Z))
    }
      , O = z( (H, Z) => {
        $b(f, H, u),
        PE(H),
        y && y(H, Z)
    }
    )
      , I = z( (H, Z) => {
        const q = xc({
            timeout: T,
            style: k,
            easing: h
        }, {
            mode: "enter"
        });
        H.style.webkitTransition = r.transitions.create("-webkit-transform", {
            ...q
        }),
        H.style.transition = r.transitions.create("transform", {
            ...q
        }),
        H.style.webkitTransform = "none",
        H.style.transform = "none",
        v && v(H, Z)
    }
    )
      , M = z(b)
      , B = z(w)
      , L = z(H => {
        const Z = xc({
            timeout: T,
            style: k,
            easing: h
        }, {
            mode: "exit"
        });
        H.style.webkitTransition = r.transitions.create("-webkit-transform", Z),
        H.style.transition = r.transitions.create("transform", Z),
        $b(f, H, u),
        S && S(H)
    }
    )
      , F = z(H => {
        H.style.webkitTransition = "",
        H.style.transition = "",
        C && C(H)
    }
    )
      , j = H => {
        a && a(D.current, H)
    }
      , N = A.useCallback( () => {
        D.current && $b(f, D.current, u)
    }
    , [f, u]);
    return A.useEffect( () => {
        if (m || f === "down" || f === "right")
            return;
        const H = Rg( () => {
            D.current && $b(f, D.current, u)
        }
        )
          , Z = Zo(D.current);
        return Z.addEventListener("resize", H),
        () => {
            H.clear(),
            Z.removeEventListener("resize", H)
        }
    }
    , [f, m, u]),
    A.useEffect( () => {
        m || N()
    }
    , [m, N]),
    g.jsx(E, {
        nodeRef: D,
        onEnter: O,
        onEntered: M,
        onEntering: I,
        onExit: L,
        onExited: F,
        onExiting: B,
        addEndListener: j,
        appear: s,
        in: m,
        timeout: T,
        ...P,
        children: (H, {ownerState: Z, ...q}) => A.cloneElement(c, {
            ref: $,
            style: {
                visibility: H === "exited" && !m ? "hidden" : void 0,
                ...k,
                ...c.props.style
            },
            ...q
        })
    })
});
function Tse(e) {
    return rt("MuiDrawer", e)
}
ot("MuiDrawer", ["root", "docked", "paper", "anchorLeft", "anchorRight", "anchorTop", "anchorBottom", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const KN = (e, t) => {
    const {ownerState: n} = e;
    return [t.root, (n.variant === "permanent" || n.variant === "persistent") && t.docked, t.modal]
}
  , _se = e => {
    const {classes: t, anchor: n, variant: r} = e
      , i = {
        root: ["root", `anchor${Te(n)}`],
        docked: [(r === "permanent" || r === "persistent") && "docked"],
        modal: ["modal"],
        paper: ["paper", `paperAnchor${Te(n)}`, r !== "temporary" && `paperAnchorDocked${Te(n)}`]
    };
    return tt(i, Tse, t)
}
  , Ese = ue(FE, {
    name: "MuiDrawer",
    slot: "Root",
    overridesResolver: KN
})(pt( ({theme: e}) => ({
    zIndex: (e.vars || e).zIndex.drawer
})))
  , Ase = ue("div", {
    shouldForwardProp: ai,
    name: "MuiDrawer",
    slot: "Docked",
    skipVariantsResolver: !1,
    overridesResolver: KN
})({
    flex: "0 0 auto"
})
  , Mse = ue(yn, {
    name: "MuiDrawer",
    slot: "Paper",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.paper, t[`paperAnchor${Te(n.anchor)}`], n.variant !== "temporary" && t[`paperAnchorDocked${Te(n.anchor)}`]]
    }
})(pt( ({theme: e}) => ({
    overflowY: "auto",
    display: "flex",
    flexDirection: "column",
    height: "100%",
    flex: "1 0 auto",
    zIndex: (e.vars || e).zIndex.drawer,
    WebkitOverflowScrolling: "touch",
    position: "fixed",
    top: 0,
    outline: 0,
    variants: [{
        props: {
            anchor: "left"
        },
        style: {
            left: 0
        }
    }, {
        props: {
            anchor: "top"
        },
        style: {
            top: 0,
            left: 0,
            right: 0,
            height: "auto",
            maxHeight: "100%"
        }
    }, {
        props: {
            anchor: "right"
        },
        style: {
            right: 0
        }
    }, {
        props: {
            anchor: "bottom"
        },
        style: {
            top: "auto",
            left: 0,
            bottom: 0,
            right: 0,
            height: "auto",
            maxHeight: "100%"
        }
    }, {
        props: ({ownerState: t}) => t.anchor === "left" && t.variant !== "temporary",
        style: {
            borderRight: `1px solid ${(e.vars || e).palette.divider}`
        }
    }, {
        props: ({ownerState: t}) => t.anchor === "top" && t.variant !== "temporary",
        style: {
            borderBottom: `1px solid ${(e.vars || e).palette.divider}`
        }
    }, {
        props: ({ownerState: t}) => t.anchor === "right" && t.variant !== "temporary",
        style: {
            borderLeft: `1px solid ${(e.vars || e).palette.divider}`
        }
    }, {
        props: ({ownerState: t}) => t.anchor === "bottom" && t.variant !== "temporary",
        style: {
            borderTop: `1px solid ${(e.vars || e).palette.divider}`
        }
    }]
})))
  , XN = {
    left: "right",
    right: "left",
    top: "down",
    bottom: "up"
};
function Pse(e) {
    return ["left", "right"].includes(e)
}
function Rse({direction: e}, t) {
    return e === "rtl" && Pse(t) ? XN[t] : t
}
const JN = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiDrawer"
    })
      , i = ko()
      , o = Si()
      , a = {
        enter: i.transitions.duration.enteringScreen,
        exit: i.transitions.duration.leavingScreen
    }
      , {anchor: s="left", BackdropProps: c, children: u, className: f, elevation: h=16, hideBackdrop: m=!1, ModalProps: {BackdropProps: y, ...b}={}, onClose: v, open: S=!1, PaperProps: C={}, SlideProps: w, TransitionComponent: k, transitionDuration: T=a, variant: E="temporary", slots: P={}, slotProps: D={}, ...$} = r
      , z = A.useRef(!1);
    A.useEffect( () => {
        z.current = !0
    }
    , []);
    const O = Rse({
        direction: o ? "rtl" : "ltr"
    }, s)
      , M = {
        ...r,
        anchor: s,
        elevation: h,
        open: S,
        variant: E,
        ...$
    }
      , B = _se(M)
      , L = {
        slots: {
            transition: k,
            ...P
        },
        slotProps: {
            paper: C,
            transition: w,
            ...D,
            backdrop: _E(D.backdrop || {
                ...c,
                ...y
            }, {
                transitionDuration: T
            })
        }
    }
      , [F,j] = mt("root", {
        ref: n,
        elementType: Ese,
        className: Ne(B.root, B.modal, f),
        shouldForwardComponentProp: !0,
        ownerState: M,
        externalForwardedProps: {
            ...L,
            ...$,
            ...b
        },
        additionalProps: {
            open: S,
            onClose: v,
            hideBackdrop: m,
            slots: {
                backdrop: L.slots.backdrop
            },
            slotProps: {
                backdrop: L.slotProps.backdrop
            }
        }
    })
      , [N,H] = mt("paper", {
        elementType: Mse,
        shouldForwardComponentProp: !0,
        className: Ne(B.paper, C.className),
        ownerState: M,
        externalForwardedProps: L,
        additionalProps: {
            elevation: E === "temporary" ? h : 0,
            square: !0,
            ...E === "temporary" && {
                role: "dialog",
                "aria-modal": "true"
            }
        }
    })
      , [Z,q] = mt("docked", {
        elementType: Ase,
        ref: n,
        className: Ne(B.root, B.docked, f),
        ownerState: M,
        externalForwardedProps: L,
        additionalProps: $
    })
      , [V,Y] = mt("transition", {
        elementType: kse,
        ownerState: M,
        externalForwardedProps: L,
        additionalProps: {
            in: S,
            direction: XN[O],
            timeout: T,
            appear: z.current
        }
    })
      , W = g.jsx(N, {
        ...H,
        children: u
    });
    if (E === "permanent")
        return g.jsx(Z, {
            ...q,
            children: W
        });
    const te = g.jsx(V, {
        ...Y,
        children: W
    });
    return E === "persistent" ? g.jsx(Z, {
        ...q,
        children: te
    }) : g.jsx(F, {
        ...j,
        children: te
    })
})
  , Dse = e => {
    const {classes: t, disableUnderline: n, startAdornment: r, endAdornment: i, size: o, hiddenLabel: a, multiline: s} = e
      , c = {
        root: ["root", !n && "underline", r && "adornedStart", i && "adornedEnd", o === "small" && `size${Te(o)}`, a && "hiddenLabel", s && "multiline"],
        input: ["input"]
    }
      , u = tt(c, boe, t);
    return {
        ...t,
        ...u
    }
}
  , Ose = ue(Jv, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [...Kv(e, t), !n.disableUnderline && t.underline]
    }
})(pt( ({theme: e}) => {
    const t = e.palette.mode === "light"
      , n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)"
      , r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)"
      , i = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)"
      , o = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return {
        position: "relative",
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
        borderTopLeftRadius: (e.vars || e).shape.borderRadius,
        borderTopRightRadius: (e.vars || e).shape.borderRadius,
        transition: e.transitions.create("background-color", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
        }),
        "&:hover": {
            backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : i,
            "@media (hover: none)": {
                backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
            }
        },
        [`&.${No.focused}`]: {
            backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
        },
        [`&.${No.disabled}`]: {
            backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : o
        },
        variants: [{
            props: ({ownerState: a}) => !a.disableUnderline,
            style: {
                "&::after": {
                    left: 0,
                    bottom: 0,
                    content: '""',
                    position: "absolute",
                    right: 0,
                    transform: "scaleX(0)",
                    transition: e.transitions.create("transform", {
                        duration: e.transitions.duration.shorter,
                        easing: e.transitions.easing.easeOut
                    }),
                    pointerEvents: "none"
                },
                [`&.${No.focused}:after`]: {
                    transform: "scaleX(1) translateX(0)"
                },
                [`&.${No.error}`]: {
                    "&::before, &::after": {
                        borderBottomColor: (e.vars || e).palette.error.main
                    }
                },
                "&::before": {
                    borderBottom: `1px solid ${e.vars ? e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline) : n}`,
                    left: 0,
                    bottom: 0,
                    content: '"\\00a0"',
                    position: "absolute",
                    right: 0,
                    transition: e.transitions.create("border-bottom-color", {
                        duration: e.transitions.duration.shorter
                    }),
                    pointerEvents: "none"
                },
                [`&:hover:not(.${No.disabled}, .${No.error}):before`]: {
                    borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
                },
                [`&.${No.disabled}:before`]: {
                    borderBottomStyle: "dotted"
                }
            }
        }, ...Object.entries(e.palette).filter(Qn()).map( ([a]) => ({
            props: {
                disableUnderline: !1,
                color: a
            },
            style: {
                "&::after": {
                    borderBottom: `2px solid ${(e.vars || e).palette[a]?.main}`
                }
            }
        })), {
            props: ({ownerState: a}) => a.startAdornment,
            style: {
                paddingLeft: 12
            }
        }, {
            props: ({ownerState: a}) => a.endAdornment,
            style: {
                paddingRight: 12
            }
        }, {
            props: ({ownerState: a}) => a.multiline,
            style: {
                padding: "25px 12px 8px"
            }
        }, {
            props: ({ownerState: a, size: s}) => a.multiline && s === "small",
            style: {
                paddingTop: 21,
                paddingBottom: 4
            }
        }, {
            props: ({ownerState: a}) => a.multiline && a.hiddenLabel,
            style: {
                paddingTop: 16,
                paddingBottom: 17
            }
        }, {
            props: ({ownerState: a}) => a.multiline && a.hiddenLabel && a.size === "small",
            style: {
                paddingTop: 8,
                paddingBottom: 9
            }
        }]
    }
}
))
  , Ise = ue(e1, {
    name: "MuiFilledInput",
    slot: "Input",
    overridesResolver: Xv
})(pt( ({theme: e}) => ({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12,
    ...!e.vars && {
        "&:-webkit-autofill": {
            WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
            WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
            caretColor: e.palette.mode === "light" ? null : "#fff",
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit"
        }
    },
    ...e.vars && {
        "&:-webkit-autofill": {
            borderTopLeftRadius: "inherit",
            borderTopRightRadius: "inherit"
        },
        [e.getColorSchemeSelector("dark")]: {
            "&:-webkit-autofill": {
                WebkitBoxShadow: "0 0 0 100px #266798 inset",
                WebkitTextFillColor: "#fff",
                caretColor: "#fff"
            }
        }
    },
    variants: [{
        props: {
            size: "small"
        },
        style: {
            paddingTop: 21,
            paddingBottom: 4
        }
    }, {
        props: ({ownerState: t}) => t.hiddenLabel,
        style: {
            paddingTop: 16,
            paddingBottom: 17
        }
    }, {
        props: ({ownerState: t}) => t.startAdornment,
        style: {
            paddingLeft: 0
        }
    }, {
        props: ({ownerState: t}) => t.endAdornment,
        style: {
            paddingRight: 0
        }
    }, {
        props: ({ownerState: t}) => t.hiddenLabel && t.size === "small",
        style: {
            paddingTop: 8,
            paddingBottom: 9
        }
    }, {
        props: ({ownerState: t}) => t.multiline,
        style: {
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0
        }
    }]
})))
  , NE = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiFilledInput"
    })
      , {disableUnderline: i=!1, components: o={}, componentsProps: a, fullWidth: s=!1, hiddenLabel: c, inputComponent: u="input", multiline: f=!1, slotProps: h, slots: m={}, type: y="text", ...b} = r
      , v = {
        ...r,
        disableUnderline: i,
        fullWidth: s,
        inputComponent: u,
        multiline: f,
        type: y
    }
      , S = Dse(r)
      , C = {
        root: {
            ownerState: v
        },
        input: {
            ownerState: v
        }
    }
      , w = h ?? a ? ci(C, h ?? a) : C
      , k = m.root ?? o.Root ?? Ose
      , T = m.input ?? o.Input ?? Ise;
    return g.jsx(Lg, {
        slots: {
            root: k,
            input: T
        },
        slotProps: w,
        fullWidth: s,
        inputComponent: u,
        multiline: f,
        ref: n,
        type: y,
        ...b,
        classes: S
    })
});
NE.muiName = "Input";
function $se(e) {
    return rt("MuiFormControl", e)
}
ot("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const Lse = e => {
    const {classes: t, margin: n, fullWidth: r} = e
      , i = {
        root: ["root", n !== "none" && `margin${Te(n)}`, r && "fullWidth"]
    };
    return tt(i, $se, t)
}
  , jse = ue("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[`margin${Te(n.margin)}`], n.fullWidth && t.fullWidth]
    }
})({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top",
    variants: [{
        props: {
            margin: "normal"
        },
        style: {
            marginTop: 16,
            marginBottom: 8
        }
    }, {
        props: {
            margin: "dense"
        },
        style: {
            marginTop: 8,
            marginBottom: 4
        }
    }, {
        props: {
            fullWidth: !0
        },
        style: {
            width: "100%"
        }
    }]
})
  , x0 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiFormControl"
    })
      , {children: i, className: o, color: a="primary", component: s="div", disabled: c=!1, error: u=!1, focused: f, fullWidth: h=!1, hiddenLabel: m=!1, margin: y="none", required: b=!1, size: v="medium", variant: S="outlined", ...C} = r
      , w = {
        ...r,
        color: a,
        component: s,
        disabled: c,
        error: u,
        fullWidth: h,
        hiddenLabel: m,
        margin: y,
        required: b,
        size: v,
        variant: S
    }
      , k = Lse(w)
      , [T,E] = A.useState( () => {
        let F = !1;
        return i && A.Children.forEach(i, j => {
            if (!fm(j, ["Input", "Select"]))
                return;
            const N = fm(j, ["Select"]) ? j.props.input : j;
            N && hoe(N.props) && (F = !0)
        }
        ),
        F
    }
    )
      , [P,D] = A.useState( () => {
        let F = !1;
        return i && A.Children.forEach(i, j => {
            fm(j, ["Input", "Select"]) && (b0(j.props, !0) || b0(j.props.inputProps, !0)) && (F = !0)
        }
        ),
        F
    }
    )
      , [$,z] = A.useState(!1);
    c && $ && z(!1);
    const O = f !== void 0 && !c ? f : $;
    let I;
    A.useRef(!1);
    const M = A.useCallback( () => {
        D(!0)
    }
    , [])
      , B = A.useCallback( () => {
        D(!1)
    }
    , [])
      , L = A.useMemo( () => ({
        adornedStart: T,
        setAdornedStart: E,
        color: a,
        disabled: c,
        error: u,
        filled: P,
        focused: O,
        fullWidth: h,
        hiddenLabel: m,
        size: v,
        onBlur: () => {
            z(!1)
        }
        ,
        onFocus: () => {
            z(!0)
        }
        ,
        onEmpty: B,
        onFilled: M,
        registerEffect: I,
        required: b,
        variant: S
    }), [T, a, c, u, P, O, h, m, I, B, M, b, v, S]);
    return g.jsx(Qv.Provider, {
        value: L,
        children: g.jsx(jse, {
            as: s,
            ownerState: w,
            className: Ne(k.root, o),
            ref: n,
            ...C,
            children: i
        })
    })
});
function Bse(e) {
    return rt("MuiFormControlLabel", e)
}
const Jp = ot("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"])
  , zse = e => {
    const {classes: t, disabled: n, labelPlacement: r, error: i, required: o} = e
      , a = {
        root: ["root", n && "disabled", `labelPlacement${Te(r)}`, i && "error", o && "required"],
        label: ["label", n && "disabled"],
        asterisk: ["asterisk", i && "error"]
    };
    return tt(a, Bse, t)
}
  , Fse = ue("label", {
    name: "MuiFormControlLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [{
            [`& .${Jp.label}`]: t.label
        }, t.root, t[`labelPlacement${Te(n.labelPlacement)}`]]
    }
})(pt( ({theme: e}) => ({
    display: "inline-flex",
    alignItems: "center",
    cursor: "pointer",
    verticalAlign: "middle",
    WebkitTapHighlightColor: "transparent",
    marginLeft: -11,
    marginRight: 16,
    [`&.${Jp.disabled}`]: {
        cursor: "default"
    },
    [`& .${Jp.label}`]: {
        [`&.${Jp.disabled}`]: {
            color: (e.vars || e).palette.text.disabled
        }
    },
    variants: [{
        props: {
            labelPlacement: "start"
        },
        style: {
            flexDirection: "row-reverse",
            marginRight: -11
        }
    }, {
        props: {
            labelPlacement: "top"
        },
        style: {
            flexDirection: "column-reverse"
        }
    }, {
        props: {
            labelPlacement: "bottom"
        },
        style: {
            flexDirection: "column"
        }
    }, {
        props: ({labelPlacement: t}) => t === "start" || t === "top" || t === "bottom",
        style: {
            marginLeft: 16
        }
    }]
})))
  , Nse = ue("span", {
    name: "MuiFormControlLabel",
    slot: "Asterisk"
})(pt( ({theme: e}) => ({
    [`&.${Jp.error}`]: {
        color: (e.vars || e).palette.error.main
    }
})))
  , Use = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiFormControlLabel"
    })
      , {checked: i, className: o, componentsProps: a={}, control: s, disabled: c, disableTypography: u, inputRef: f, label: h, labelPlacement: m="end", name: y, onChange: b, required: v, slots: S={}, slotProps: C={}, value: w, ...k} = r
      , T = To()
      , E = c ?? s.props.disabled ?? T?.disabled
      , P = v ?? s.props.required
      , D = {
        disabled: E,
        required: P
    };
    ["checked", "name", "onChange", "value", "inputRef"].forEach(F => {
        typeof s.props[F] > "u" && typeof r[F] < "u" && (D[F] = r[F])
    }
    );
    const $ = nd({
        props: r,
        muiFormControl: T,
        states: ["error"]
    })
      , z = {
        ...r,
        disabled: E,
        labelPlacement: m,
        required: P,
        error: $.error
    }
      , O = zse(z)
      , I = {
        slots: S,
        slotProps: {
            ...a,
            ...C
        }
    }
      , [M,B] = mt("typography", {
        elementType: Ae,
        externalForwardedProps: I,
        ownerState: z
    });
    let L = h;
    return L != null && L.type !== Ae && !u && (L = g.jsx(M, {
        component: "span",
        ...B,
        className: Ne(O.label, B?.className),
        children: L
    })),
    g.jsxs(Fse, {
        className: Ne(O.root, o),
        ownerState: z,
        ref: n,
        ...k,
        children: [A.cloneElement(s, D), P ? g.jsxs("div", {
            children: [L, g.jsxs(Nse, {
                ownerState: z,
                "aria-hidden": !0,
                className: O.asterisk,
                children: ["", "*"]
            })]
        }) : L]
    })
});
function Vse(e) {
    return rt("MuiFormHelperText", e)
}
const Z$ = ot("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var Q$;
const Hse = e => {
    const {classes: t, contained: n, size: r, disabled: i, error: o, filled: a, focused: s, required: c} = e
      , u = {
        root: ["root", i && "disabled", o && "error", r && `size${Te(r)}`, n && "contained", s && "focused", a && "filled", c && "required"]
    };
    return tt(u, Vse, t)
}
  , qse = ue("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.size && t[`size${Te(n.size)}`], n.contained && t.contained, n.filled && t.filled]
    }
})(pt( ({theme: e}) => ({
    color: (e.vars || e).palette.text.secondary,
    ...e.typography.caption,
    textAlign: "left",
    marginTop: 3,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    [`&.${Z$.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
    },
    [`&.${Z$.error}`]: {
        color: (e.vars || e).palette.error.main
    },
    variants: [{
        props: {
            size: "small"
        },
        style: {
            marginTop: 4
        }
    }, {
        props: ({ownerState: t}) => t.contained,
        style: {
            marginLeft: 14,
            marginRight: 14
        }
    }]
})))
  , e3 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiFormHelperText"
    })
      , {children: i, className: o, component: a="p", disabled: s, error: c, filled: u, focused: f, margin: h, required: m, variant: y, ...b} = r
      , v = To()
      , S = nd({
        props: r,
        muiFormControl: v,
        states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
    })
      , C = {
        ...r,
        component: a,
        contained: S.variant === "filled" || S.variant === "outlined",
        variant: S.variant,
        size: S.size,
        disabled: S.disabled,
        error: S.error,
        filled: S.filled,
        focused: S.focused,
        required: S.required
    };
    delete C.ownerState;
    const w = Hse(C);
    return g.jsx(qse, {
        as: a,
        className: Ne(w.root, o),
        ref: n,
        ...b,
        ownerState: C,
        children: i === " " ? Q$ || (Q$ = g.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: ""
        })) : i
    })
});
function Wse(e) {
    return rt("MuiFormLabel", e)
}
const ym = ot("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"])
  , Gse = e => {
    const {classes: t, color: n, focused: r, disabled: i, error: o, filled: a, required: s} = e
      , c = {
        root: ["root", `color${Te(n)}`, i && "disabled", o && "error", a && "filled", r && "focused", s && "required"],
        asterisk: ["asterisk", o && "error"]
    };
    return tt(c, Wse, t)
}
  , Yse = ue("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled]
    }
})(pt( ({theme: e}) => ({
    color: (e.vars || e).palette.text.secondary,
    ...e.typography.body1,
    lineHeight: "1.4375em",
    padding: 0,
    position: "relative",
    variants: [...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            [`&.${ym.focused}`]: {
                color: (e.vars || e).palette[t].main
            }
        }
    })), {
        props: {},
        style: {
            [`&.${ym.disabled}`]: {
                color: (e.vars || e).palette.text.disabled
            },
            [`&.${ym.error}`]: {
                color: (e.vars || e).palette.error.main
            }
        }
    }]
})))
  , Zse = ue("span", {
    name: "MuiFormLabel",
    slot: "Asterisk"
})(pt( ({theme: e}) => ({
    [`&.${ym.error}`]: {
        color: (e.vars || e).palette.error.main
    }
})))
  , Qse = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiFormLabel"
    })
      , {children: i, className: o, color: a, component: s="label", disabled: c, error: u, filled: f, focused: h, required: m, ...y} = r
      , b = To()
      , v = nd({
        props: r,
        muiFormControl: b,
        states: ["color", "required", "focused", "disabled", "error", "filled"]
    })
      , S = {
        ...r,
        color: v.color || "primary",
        component: s,
        disabled: v.disabled,
        error: v.error,
        filled: v.filled,
        focused: v.focused,
        required: v.required
    }
      , C = Gse(S);
    return g.jsxs(Yse, {
        as: s,
        ownerState: S,
        className: Ne(C.root, o),
        ref: n,
        ...y,
        children: [i, v.required && g.jsxs(Zse, {
            ownerState: S,
            "aria-hidden": !0,
            className: C.asterisk,
            children: ["", "*"]
        })]
    })
})
  , je = Ate({
    createStyledComponent: ue("div", {
        name: "MuiGrid",
        slot: "Root",
        overridesResolver: (e, t) => {
            const {ownerState: n} = e;
            return [t.root, n.container && t.container]
        }
    }),
    componentName: "MuiGrid",
    useThemeProps: e => gt({
        props: e,
        name: "MuiGrid"
    }),
    useTheme: ko
});
function tT(e) {
    return `scale(${e}, ${e ** 2})`
}
const Kse = {
    entering: {
        opacity: 1,
        transform: tT(1)
    },
    entered: {
        opacity: 1,
        transform: "none"
    }
}
  , Qw = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent)
  , Wf = A.forwardRef(function(t, n) {
    const {addEndListener: r, appear: i=!0, children: o, easing: a, in: s, onEnter: c, onEntered: u, onEntering: f, onExit: h, onExited: m, onExiting: y, style: b, timeout: v="auto", TransitionComponent: S=Xo, ...C} = t
      , w = uc()
      , k = A.useRef()
      , T = ko()
      , E = A.useRef(null)
      , P = Cn(E, Rc(o), n)
      , D = F => j => {
        if (F) {
            const N = E.current;
            j === void 0 ? F(N) : F(N, j)
        }
    }
      , $ = D(f)
      , z = D( (F, j) => {
        PE(F);
        const {duration: N, delay: H, easing: Z} = xc({
            style: b,
            timeout: v,
            easing: a
        }, {
            mode: "enter"
        });
        let q;
        v === "auto" ? (q = T.transitions.getAutoHeightDuration(F.clientHeight),
        k.current = q) : q = N,
        F.style.transition = [T.transitions.create("opacity", {
            duration: q,
            delay: H
        }), T.transitions.create("transform", {
            duration: Qw ? q : q * .666,
            delay: H,
            easing: Z
        })].join(","),
        c && c(F, j)
    }
    )
      , O = D(u)
      , I = D(y)
      , M = D(F => {
        const {duration: j, delay: N, easing: H} = xc({
            style: b,
            timeout: v,
            easing: a
        }, {
            mode: "exit"
        });
        let Z;
        v === "auto" ? (Z = T.transitions.getAutoHeightDuration(F.clientHeight),
        k.current = Z) : Z = j,
        F.style.transition = [T.transitions.create("opacity", {
            duration: Z,
            delay: N
        }), T.transitions.create("transform", {
            duration: Qw ? Z : Z * .666,
            delay: Qw ? N : N || Z * .333,
            easing: H
        })].join(","),
        F.style.opacity = 0,
        F.style.transform = tT(.75),
        h && h(F)
    }
    )
      , B = D(m)
      , L = F => {
        v === "auto" && w.start(k.current || 0, F),
        r && r(E.current, F)
    }
    ;
    return g.jsx(S, {
        appear: i,
        in: s,
        nodeRef: E,
        onEnter: z,
        onEntered: O,
        onEntering: $,
        onExit: M,
        onExited: B,
        onExiting: I,
        addEndListener: L,
        timeout: v === "auto" ? null : v,
        ...C,
        children: (F, {ownerState: j, ...N}) => A.cloneElement(o, {
            style: {
                opacity: 0,
                transform: tT(.75),
                visibility: F === "exited" && !s ? "hidden" : void 0,
                ...Kse[F],
                ...b,
                ...o.props.style
            },
            ref: P,
            ...N
        })
    })
});
Wf && (Wf.muiSupportAuto = !0);
const Xse = e => {
    const {classes: t, disableUnderline: n} = e
      , i = tt({
        root: ["root", !n && "underline"],
        input: ["input"]
    }, goe, t);
    return {
        ...t,
        ...i
    }
}
  , Jse = ue(Jv, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [...Kv(e, t), !n.disableUnderline && t.underline]
    }
})(pt( ({theme: e}) => {
    let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    return e.vars && (n = e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline)),
    {
        position: "relative",
        variants: [{
            props: ({ownerState: r}) => r.formControl,
            style: {
                "label + &": {
                    marginTop: 16
                }
            }
        }, {
            props: ({ownerState: r}) => !r.disableUnderline,
            style: {
                "&::after": {
                    left: 0,
                    bottom: 0,
                    content: '""',
                    position: "absolute",
                    right: 0,
                    transform: "scaleX(0)",
                    transition: e.transitions.create("transform", {
                        duration: e.transitions.duration.shorter,
                        easing: e.transitions.easing.easeOut
                    }),
                    pointerEvents: "none"
                },
                [`&.${ac.focused}:after`]: {
                    transform: "scaleX(1) translateX(0)"
                },
                [`&.${ac.error}`]: {
                    "&::before, &::after": {
                        borderBottomColor: (e.vars || e).palette.error.main
                    }
                },
                "&::before": {
                    borderBottom: `1px solid ${n}`,
                    left: 0,
                    bottom: 0,
                    content: '"\\00a0"',
                    position: "absolute",
                    right: 0,
                    transition: e.transitions.create("border-bottom-color", {
                        duration: e.transitions.duration.shorter
                    }),
                    pointerEvents: "none"
                },
                [`&:hover:not(.${ac.disabled}, .${ac.error}):before`]: {
                    borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
                    "@media (hover: none)": {
                        borderBottom: `1px solid ${n}`
                    }
                },
                [`&.${ac.disabled}:before`]: {
                    borderBottomStyle: "dotted"
                }
            }
        }, ...Object.entries(e.palette).filter(Qn()).map( ([r]) => ({
            props: {
                color: r,
                disableUnderline: !1
            },
            style: {
                "&::after": {
                    borderBottom: `2px solid ${(e.vars || e).palette[r].main}`
                }
            }
        }))]
    }
}
))
  , ele = ue(e1, {
    name: "MuiInput",
    slot: "Input",
    overridesResolver: Xv
})({})
  , UE = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiInput"
    })
      , {disableUnderline: i=!1, components: o={}, componentsProps: a, fullWidth: s=!1, inputComponent: c="input", multiline: u=!1, slotProps: f, slots: h={}, type: m="text", ...y} = r
      , b = Xse(r)
      , S = {
        root: {
            ownerState: {
                disableUnderline: i
            }
        }
    }
      , C = f ?? a ? ci(f ?? a, S) : S
      , w = h.root ?? o.Root ?? Jse
      , k = h.input ?? o.Input ?? ele;
    return g.jsx(Lg, {
        slots: {
            root: w,
            input: k
        },
        slotProps: C,
        fullWidth: s,
        inputComponent: c,
        multiline: u,
        ref: n,
        type: m,
        ...y,
        classes: b
    })
});
UE.muiName = "Input";
function tle(e) {
    return rt("MuiInputAdornment", e)
}
const K$ = ot("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
var X$;
const nle = (e, t) => {
    const {ownerState: n} = e;
    return [t.root, t[`position${Te(n.position)}`], n.disablePointerEvents === !0 && t.disablePointerEvents, t[n.variant]]
}
  , rle = e => {
    const {classes: t, disablePointerEvents: n, hiddenLabel: r, position: i, size: o, variant: a} = e
      , s = {
        root: ["root", n && "disablePointerEvents", i && `position${Te(i)}`, a, r && "hiddenLabel", o && `size${Te(o)}`]
    };
    return tt(s, tle, t)
}
  , ile = ue("div", {
    name: "MuiInputAdornment",
    slot: "Root",
    overridesResolver: nle
})(pt( ({theme: e}) => ({
    display: "flex",
    maxHeight: "2em",
    alignItems: "center",
    whiteSpace: "nowrap",
    color: (e.vars || e).palette.action.active,
    variants: [{
        props: {
            variant: "filled"
        },
        style: {
            [`&.${K$.positionStart}&:not(.${K$.hiddenLabel})`]: {
                marginTop: 16
            }
        }
    }, {
        props: {
            position: "start"
        },
        style: {
            marginRight: 8
        }
    }, {
        props: {
            position: "end"
        },
        style: {
            marginLeft: 8
        }
    }, {
        props: {
            disablePointerEvents: !0
        },
        style: {
            pointerEvents: "none"
        }
    }]
})))
  , v0 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiInputAdornment"
    })
      , {children: i, className: o, component: a="div", disablePointerEvents: s=!1, disableTypography: c=!1, position: u, variant: f, ...h} = r
      , m = To() || {};
    let y = f;
    f && m.variant,
    m && !y && (y = m.variant);
    const b = {
        ...r,
        hiddenLabel: m.hiddenLabel,
        size: m.size,
        disablePointerEvents: s,
        position: u,
        variant: y
    }
      , v = rle(b);
    return g.jsx(Qv.Provider, {
        value: null,
        children: g.jsx(ile, {
            as: a,
            ownerState: b,
            className: Ne(v.root, o),
            ref: n,
            ...h,
            children: typeof i == "string" && !c ? g.jsx(Ae, {
                color: "textSecondary",
                children: i
            }) : g.jsxs(A.Fragment, {
                children: [u === "start" ? X$ || (X$ = g.jsx("span", {
                    className: "notranslate",
                    "aria-hidden": !0,
                    children: ""
                })) : null, i]
            })
        })
    })
});
function ole(e) {
    return rt("MuiInputLabel", e)
}
ot("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const ale = e => {
    const {classes: t, formControl: n, size: r, shrink: i, disableAnimation: o, variant: a, required: s} = e
      , c = {
        root: ["root", n && "formControl", !o && "animated", i && "shrink", r && r !== "medium" && `size${Te(r)}`, a],
        asterisk: [s && "asterisk"]
    }
      , u = tt(c, ole, t);
    return {
        ...t,
        ...u
    }
}
  , sle = ue(Qse, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [{
            [`& .${ym.asterisk}`]: t.asterisk
        }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]]
    }
})(pt( ({theme: e}) => ({
    display: "block",
    transformOrigin: "top left",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    maxWidth: "100%",
    variants: [{
        props: ({ownerState: t}) => t.formControl,
        style: {
            position: "absolute",
            left: 0,
            top: 0,
            transform: "translate(0, 20px) scale(1)"
        }
    }, {
        props: {
            size: "small"
        },
        style: {
            transform: "translate(0, 17px) scale(1)"
        }
    }, {
        props: ({ownerState: t}) => t.shrink,
        style: {
            transform: "translate(0, -1.5px) scale(0.75)",
            transformOrigin: "top left",
            maxWidth: "133%"
        }
    }, {
        props: ({ownerState: t}) => !t.disableAnimation,
        style: {
            transition: e.transitions.create(["color", "transform", "max-width"], {
                duration: e.transitions.duration.shorter,
                easing: e.transitions.easing.easeOut
            })
        }
    }, {
        props: {
            variant: "filled"
        },
        style: {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(12px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)"
        }
    }, {
        props: {
            variant: "filled",
            size: "small"
        },
        style: {
            transform: "translate(12px, 13px) scale(1)"
        }
    }, {
        props: ({variant: t, ownerState: n}) => t === "filled" && n.shrink,
        style: {
            userSelect: "none",
            pointerEvents: "auto",
            transform: "translate(12px, 7px) scale(0.75)",
            maxWidth: "calc(133% - 24px)"
        }
    }, {
        props: ({variant: t, ownerState: n, size: r}) => t === "filled" && n.shrink && r === "small",
        style: {
            transform: "translate(12px, 4px) scale(0.75)"
        }
    }, {
        props: {
            variant: "outlined"
        },
        style: {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(14px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)"
        }
    }, {
        props: {
            variant: "outlined",
            size: "small"
        },
        style: {
            transform: "translate(14px, 9px) scale(1)"
        }
    }, {
        props: ({variant: t, ownerState: n}) => t === "outlined" && n.shrink,
        style: {
            userSelect: "none",
            pointerEvents: "auto",
            maxWidth: "calc(133% - 32px)",
            transform: "translate(14px, -9px) scale(0.75)"
        }
    }]
})))
  , S0 = A.forwardRef(function(t, n) {
    const r = gt({
        name: "MuiInputLabel",
        props: t
    })
      , {disableAnimation: i=!1, margin: o, shrink: a, variant: s, className: c, ...u} = r
      , f = To();
    let h = a;
    typeof h > "u" && f && (h = f.filled || f.focused || f.adornedStart);
    const m = nd({
        props: r,
        muiFormControl: f,
        states: ["size", "variant", "required", "focused"]
    })
      , y = {
        ...r,
        disableAnimation: i,
        formControl: f,
        shrink: h,
        size: m.size,
        variant: m.variant,
        required: m.required,
        focused: m.focused
    }
      , b = ale(y);
    return g.jsx(sle, {
        "data-shrink": h,
        ref: n,
        className: Ne(b.root, c),
        ...u,
        ownerState: y,
        classes: b
    })
});
function lle(e) {
    return rt("MuiLinearProgress", e)
}
ot("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "bar1", "bar2", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
const nT = 4
  , rT = $s`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`
  , cle = typeof rT != "string" ? Ac`
        animation: ${rT} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
      ` : null
  , iT = $s`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`
  , ule = typeof iT != "string" ? Ac`
        animation: ${iT} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
      ` : null
  , oT = $s`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`
  , dle = typeof oT != "string" ? Ac`
        animation: ${oT} 3s infinite linear;
      ` : null
  , fle = e => {
    const {classes: t, variant: n, color: r} = e
      , i = {
        root: ["root", `color${Te(r)}`, n],
        dashed: ["dashed", `dashedColor${Te(r)}`],
        bar1: ["bar", "bar1", `barColor${Te(r)}`, (n === "indeterminate" || n === "query") && "bar1Indeterminate", n === "determinate" && "bar1Determinate", n === "buffer" && "bar1Buffer"],
        bar2: ["bar", "bar2", n !== "buffer" && `barColor${Te(r)}`, n === "buffer" && `color${Te(r)}`, (n === "indeterminate" || n === "query") && "bar2Indeterminate", n === "buffer" && "bar2Buffer"]
    };
    return tt(i, lle, t)
}
  , VE = (e, t) => e.vars ? e.vars.palette.LinearProgress[`${t}Bg`] : e.palette.mode === "light" ? e.lighten(e.palette[t].main, .62) : e.darken(e.palette[t].main, .5)
  , hle = ue("span", {
    name: "MuiLinearProgress",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[`color${Te(n.color)}`], t[n.variant]]
    }
})(pt( ({theme: e}) => ({
    position: "relative",
    overflow: "hidden",
    display: "block",
    height: 4,
    zIndex: 0,
    "@media print": {
        colorAdjust: "exact"
    },
    variants: [...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            backgroundColor: VE(e, t)
        }
    })), {
        props: ({ownerState: t}) => t.color === "inherit" && t.variant !== "buffer",
        style: {
            "&::before": {
                content: '""',
                position: "absolute",
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                backgroundColor: "currentColor",
                opacity: .3
            }
        }
    }, {
        props: {
            variant: "buffer"
        },
        style: {
            backgroundColor: "transparent"
        }
    }, {
        props: {
            variant: "query"
        },
        style: {
            transform: "rotate(180deg)"
        }
    }]
})))
  , ple = ue("span", {
    name: "MuiLinearProgress",
    slot: "Dashed",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.dashed, t[`dashedColor${Te(n.color)}`]]
    }
})(pt( ({theme: e}) => ({
    position: "absolute",
    marginTop: 0,
    height: "100%",
    width: "100%",
    backgroundSize: "10px 10px",
    backgroundPosition: "0 -23px",
    variants: [{
        props: {
            color: "inherit"
        },
        style: {
            opacity: .3,
            backgroundImage: "radial-gradient(currentColor 0%, currentColor 16%, transparent 42%)"
        }
    }, ...Object.entries(e.palette).filter(Qn()).map( ([t]) => {
        const n = VE(e, t);
        return {
            props: {
                color: t
            },
            style: {
                backgroundImage: `radial-gradient(${n} 0%, ${n} 16%, transparent 42%)`
            }
        }
    }
    )]
})), dle || {
    animation: `${oT} 3s infinite linear`
})
  , mle = ue("span", {
    name: "MuiLinearProgress",
    slot: "Bar1",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.bar, t.bar1, t[`barColor${Te(n.color)}`], (n.variant === "indeterminate" || n.variant === "query") && t.bar1Indeterminate, n.variant === "determinate" && t.bar1Determinate, n.variant === "buffer" && t.bar1Buffer]
    }
})(pt( ({theme: e}) => ({
    width: "100%",
    position: "absolute",
    left: 0,
    bottom: 0,
    top: 0,
    transition: "transform 0.2s linear",
    transformOrigin: "left",
    variants: [{
        props: {
            color: "inherit"
        },
        style: {
            backgroundColor: "currentColor"
        }
    }, ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            backgroundColor: (e.vars || e).palette[t].main
        }
    })), {
        props: {
            variant: "determinate"
        },
        style: {
            transition: `transform .${nT}s linear`
        }
    }, {
        props: {
            variant: "buffer"
        },
        style: {
            zIndex: 1,
            transition: `transform .${nT}s linear`
        }
    }, {
        props: ({ownerState: t}) => t.variant === "indeterminate" || t.variant === "query",
        style: {
            width: "auto"
        }
    }, {
        props: ({ownerState: t}) => t.variant === "indeterminate" || t.variant === "query",
        style: cle || {
            animation: `${rT} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite`
        }
    }]
})))
  , gle = ue("span", {
    name: "MuiLinearProgress",
    slot: "Bar2",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.bar, t.bar2, t[`barColor${Te(n.color)}`], (n.variant === "indeterminate" || n.variant === "query") && t.bar2Indeterminate, n.variant === "buffer" && t.bar2Buffer]
    }
})(pt( ({theme: e}) => ({
    width: "100%",
    position: "absolute",
    left: 0,
    bottom: 0,
    top: 0,
    transition: "transform 0.2s linear",
    transformOrigin: "left",
    variants: [...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            "--LinearProgressBar2-barColor": (e.vars || e).palette[t].main
        }
    })), {
        props: ({ownerState: t}) => t.variant !== "buffer" && t.color !== "inherit",
        style: {
            backgroundColor: "var(--LinearProgressBar2-barColor, currentColor)"
        }
    }, {
        props: ({ownerState: t}) => t.variant !== "buffer" && t.color === "inherit",
        style: {
            backgroundColor: "currentColor"
        }
    }, {
        props: {
            color: "inherit"
        },
        style: {
            opacity: .3
        }
    }, ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t,
            variant: "buffer"
        },
        style: {
            backgroundColor: VE(e, t),
            transition: `transform .${nT}s linear`
        }
    })), {
        props: ({ownerState: t}) => t.variant === "indeterminate" || t.variant === "query",
        style: {
            width: "auto"
        }
    }, {
        props: ({ownerState: t}) => t.variant === "indeterminate" || t.variant === "query",
        style: ule || {
            animation: `${iT} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite`
        }
    }]
})))
  , yle = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiLinearProgress"
    })
      , {className: i, color: o="primary", value: a, valueBuffer: s, variant: c="indeterminate", ...u} = r
      , f = {
        ...r,
        color: o,
        variant: c
    }
      , h = fle(f)
      , m = Si()
      , y = {}
      , b = {
        bar1: {},
        bar2: {}
    };
    if ((c === "determinate" || c === "buffer") && a !== void 0) {
        y["aria-valuenow"] = Math.round(a),
        y["aria-valuemin"] = 0,
        y["aria-valuemax"] = 100;
        let v = a - 100;
        m && (v = -v),
        b.bar1.transform = `translateX(${v}%)`
    }
    if (c === "buffer" && s !== void 0) {
        let v = (s || 0) - 100;
        m && (v = -v),
        b.bar2.transform = `translateX(${v}%)`
    }
    return g.jsxs(hle, {
        className: Ne(h.root, i),
        ownerState: f,
        role: "progressbar",
        ...y,
        ref: n,
        ...u,
        children: [c === "buffer" ? g.jsx(ple, {
            className: h.dashed,
            ownerState: f
        }) : null, g.jsx(mle, {
            className: h.bar1,
            ownerState: f,
            style: b.bar1
        }), c === "determinate" ? null : g.jsx(gle, {
            className: h.bar2,
            ownerState: f,
            style: b.bar2
        })]
    })
})
  , Wa = A.createContext({});
function ble(e) {
    return rt("MuiList", e)
}
ot("MuiList", ["root", "padding", "dense", "subheader"]);
const xle = e => {
    const {classes: t, disablePadding: n, dense: r, subheader: i} = e;
    return tt({
        root: ["root", !n && "padding", r && "dense", i && "subheader"]
    }, ble, t)
}
  , vle = ue("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader]
    }
})({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative",
    variants: [{
        props: ({ownerState: e}) => !e.disablePadding,
        style: {
            paddingTop: 8,
            paddingBottom: 8
        }
    }, {
        props: ({ownerState: e}) => e.subheader,
        style: {
            paddingTop: 0
        }
    }]
})
  , Fu = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiList"
    })
      , {children: i, className: o, component: a="ul", dense: s=!1, disablePadding: c=!1, subheader: u, ...f} = r
      , h = A.useMemo( () => ({
        dense: s
    }), [s])
      , m = {
        ...r,
        component: a,
        dense: s,
        disablePadding: c
    }
      , y = xle(m);
    return g.jsx(Wa.Provider, {
        value: h,
        children: g.jsxs(vle, {
            as: a,
            className: Ne(y.root, o),
            ref: n,
            ownerState: m,
            ...f,
            children: [u, i]
        })
    })
});
function Sle(e) {
    return rt("MuiListItem", e)
}
ot("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
function Cle(e) {
    return rt("MuiListItemButton", e)
}
const sf = ot("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"])
  , wle = (e, t) => {
    const {ownerState: n} = e;
    return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters]
}
  , kle = e => {
    const {alignItems: t, classes: n, dense: r, disabled: i, disableGutters: o, divider: a, selected: s} = e
      , u = tt({
        root: ["root", r && "dense", !o && "gutters", a && "divider", i && "disabled", t === "flex-start" && "alignItemsFlexStart", s && "selected"]
    }, Cle, n);
    return {
        ...n,
        ...u
    }
}
  , Tle = ue(Ka, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiListItemButton",
    slot: "Root",
    overridesResolver: wle
})(pt( ({theme: e}) => ({
    display: "flex",
    flexGrow: 1,
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minWidth: 0,
    boxSizing: "border-box",
    textAlign: "left",
    paddingTop: 8,
    paddingBottom: 8,
    transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shortest
    }),
    "&:hover": {
        textDecoration: "none",
        backgroundColor: (e.vars || e).palette.action.hover,
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    },
    [`&.${sf.selected}`]: {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
        [`&.${sf.focusVisible}`]: {
            backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
        }
    },
    [`&.${sf.selected}:hover`]: {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
        "@media (hover: none)": {
            backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
        }
    },
    [`&.${sf.focusVisible}`]: {
        backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${sf.disabled}`]: {
        opacity: (e.vars || e).palette.action.disabledOpacity
    },
    variants: [{
        props: ({ownerState: t}) => t.divider,
        style: {
            borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
            backgroundClip: "padding-box"
        }
    }, {
        props: {
            alignItems: "flex-start"
        },
        style: {
            alignItems: "flex-start"
        }
    }, {
        props: ({ownerState: t}) => !t.disableGutters,
        style: {
            paddingLeft: 16,
            paddingRight: 16
        }
    }, {
        props: ({ownerState: t}) => t.dense,
        style: {
            paddingTop: 4,
            paddingBottom: 4
        }
    }]
})))
  , bm = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiListItemButton"
    })
      , {alignItems: i="center", autoFocus: o=!1, component: a="div", children: s, dense: c=!1, disableGutters: u=!1, divider: f=!1, focusVisibleClassName: h, selected: m=!1, className: y, ...b} = r
      , v = A.useContext(Wa)
      , S = A.useMemo( () => ({
        dense: c || v.dense || !1,
        alignItems: i,
        disableGutters: u
    }), [i, v.dense, c, u])
      , C = A.useRef(null);
    Cr( () => {
        o && C.current && C.current.focus()
    }
    , [o]);
    const w = {
        ...r,
        alignItems: i,
        dense: S.dense,
        disableGutters: u,
        divider: f,
        selected: m
    }
      , k = kle(w)
      , T = Cn(C, n);
    return g.jsx(Wa.Provider, {
        value: S,
        children: g.jsx(Tle, {
            ref: T,
            href: b.href || b.to,
            component: (b.href || b.to) && a === "div" ? "button" : a,
            focusVisibleClassName: Ne(k.focusVisible, h),
            ownerState: w,
            className: Ne(k.root, y),
            ...b,
            classes: k,
            children: s
        })
    })
});
function _le(e) {
    return rt("MuiListItemSecondaryAction", e)
}
ot("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const Ele = e => {
    const {disableGutters: t, classes: n} = e;
    return tt({
        root: ["root", t && "disableGutters"]
    }, _le, n)
}
  , Ale = ue("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.disableGutters && t.disableGutters]
    }
})({
    position: "absolute",
    right: 16,
    top: "50%",
    transform: "translateY(-50%)",
    variants: [{
        props: ({ownerState: e}) => e.disableGutters,
        style: {
            right: 0
        }
    }]
})
  , t3 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiListItemSecondaryAction"
    })
      , {className: i, ...o} = r
      , a = A.useContext(Wa)
      , s = {
        ...r,
        disableGutters: a.disableGutters
    }
      , c = Ele(s);
    return g.jsx(Ale, {
        className: Ne(c.root, i),
        ownerState: s,
        ref: n,
        ...o
    })
});
t3.muiName = "ListItemSecondaryAction";
const Mle = (e, t) => {
    const {ownerState: n} = e;
    return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters, !n.disablePadding && t.padding, n.hasSecondaryAction && t.secondaryAction]
}
  , Ple = e => {
    const {alignItems: t, classes: n, dense: r, disableGutters: i, disablePadding: o, divider: a, hasSecondaryAction: s} = e;
    return tt({
        root: ["root", r && "dense", !i && "gutters", !o && "padding", a && "divider", t === "flex-start" && "alignItemsFlexStart", s && "secondaryAction"],
        container: ["container"]
    }, Sle, n)
}
  , Rle = ue("div", {
    name: "MuiListItem",
    slot: "Root",
    overridesResolver: Mle
})(pt( ({theme: e}) => ({
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "left",
    variants: [{
        props: ({ownerState: t}) => !t.disablePadding,
        style: {
            paddingTop: 8,
            paddingBottom: 8
        }
    }, {
        props: ({ownerState: t}) => !t.disablePadding && t.dense,
        style: {
            paddingTop: 4,
            paddingBottom: 4
        }
    }, {
        props: ({ownerState: t}) => !t.disablePadding && !t.disableGutters,
        style: {
            paddingLeft: 16,
            paddingRight: 16
        }
    }, {
        props: ({ownerState: t}) => !t.disablePadding && !!t.secondaryAction,
        style: {
            paddingRight: 48
        }
    }, {
        props: ({ownerState: t}) => !!t.secondaryAction,
        style: {
            [`& > .${sf.root}`]: {
                paddingRight: 48
            }
        }
    }, {
        props: {
            alignItems: "flex-start"
        },
        style: {
            alignItems: "flex-start"
        }
    }, {
        props: ({ownerState: t}) => t.divider,
        style: {
            borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
            backgroundClip: "padding-box"
        }
    }, {
        props: ({ownerState: t}) => t.button,
        style: {
            transition: e.transitions.create("background-color", {
                duration: e.transitions.duration.shortest
            }),
            "&:hover": {
                textDecoration: "none",
                backgroundColor: (e.vars || e).palette.action.hover,
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        }
    }, {
        props: ({ownerState: t}) => t.hasSecondaryAction,
        style: {
            paddingRight: 48
        }
    }]
})))
  , Dle = ue("li", {
    name: "MuiListItem",
    slot: "Container"
})({
    position: "relative"
})
  , HE = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiListItem"
    })
      , {alignItems: i="center", children: o, className: a, component: s, components: c={}, componentsProps: u={}, ContainerComponent: f="li", ContainerProps: {className: h, ...m}={}, dense: y=!1, disableGutters: b=!1, disablePadding: v=!1, divider: S=!1, secondaryAction: C, slotProps: w={}, slots: k={}, ...T} = r
      , E = A.useContext(Wa)
      , P = A.useMemo( () => ({
        dense: y || E.dense || !1,
        alignItems: i,
        disableGutters: b
    }), [i, E.dense, y, b])
      , D = A.useRef(null)
      , $ = A.Children.toArray(o)
      , z = $.length && fm($[$.length - 1], ["ListItemSecondaryAction"])
      , O = {
        ...r,
        alignItems: i,
        dense: P.dense,
        disableGutters: b,
        disablePadding: v,
        divider: S,
        hasSecondaryAction: z
    }
      , I = Ple(O)
      , M = Cn(D, n)
      , B = k.root || c.Root || Rle
      , L = w.root || u.root || {}
      , F = {
        className: Ne(I.root, L.className, a),
        ...T
    };
    let j = s || "li";
    return z ? (j = !F.component && !s ? "div" : j,
    f === "li" && (j === "li" ? j = "div" : F.component === "li" && (F.component = "div")),
    g.jsx(Wa.Provider, {
        value: P,
        children: g.jsxs(Dle, {
            as: f,
            className: Ne(I.container, h),
            ref: M,
            ownerState: O,
            ...m,
            children: [g.jsx(B, {
                ...L,
                ...!Nf(B) && {
                    as: j,
                    ownerState: {
                        ...O,
                        ...L.ownerState
                    }
                },
                ...F,
                children: $
            }), $.pop()]
        })
    })) : g.jsx(Wa.Provider, {
        value: P,
        children: g.jsxs(B, {
            ...L,
            as: j,
            ref: M,
            ...!Nf(B) && {
                ownerState: {
                    ...O,
                    ...L.ownerState
                }
            },
            ...F,
            children: [$, C && g.jsx(t3, {
                children: C
            })]
        })
    })
});
function Ole(e) {
    return rt("MuiListItemIcon", e)
}
const J$ = ot("MuiListItemIcon", ["root", "alignItemsFlexStart"])
  , Ile = e => {
    const {alignItems: t, classes: n} = e;
    return tt({
        root: ["root", t === "flex-start" && "alignItemsFlexStart"]
    }, Ole, n)
}
  , $le = ue("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart]
    }
})(pt( ({theme: e}) => ({
    minWidth: 56,
    color: (e.vars || e).palette.action.active,
    flexShrink: 0,
    display: "inline-flex",
    variants: [{
        props: {
            alignItems: "flex-start"
        },
        style: {
            marginTop: 8
        }
    }]
})))
  , ha = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiListItemIcon"
    })
      , {className: i, ...o} = r
      , a = A.useContext(Wa)
      , s = {
        ...r,
        alignItems: a.alignItems
    }
      , c = Ile(s);
    return g.jsx($le, {
        className: Ne(c.root, i),
        ownerState: s,
        ref: n,
        ...o
    })
});
function Lle(e) {
    return rt("MuiListItemText", e)
}
const ff = ot("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"])
  , jle = e => {
    const {classes: t, inset: n, primary: r, secondary: i, dense: o} = e;
    return tt({
        root: ["root", n && "inset", o && "dense", r && i && "multiline"],
        primary: ["primary"],
        secondary: ["secondary"]
    }, Lle, t)
}
  , Ble = ue("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [{
            [`& .${ff.primary}`]: t.primary
        }, {
            [`& .${ff.secondary}`]: t.secondary
        }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense]
    }
})({
    flex: "1 1 auto",
    minWidth: 0,
    marginTop: 4,
    marginBottom: 4,
    [`.${x$.root}:where(& .${ff.primary})`]: {
        display: "block"
    },
    [`.${x$.root}:where(& .${ff.secondary})`]: {
        display: "block"
    },
    variants: [{
        props: ({ownerState: e}) => e.primary && e.secondary,
        style: {
            marginTop: 6,
            marginBottom: 6
        }
    }, {
        props: ({ownerState: e}) => e.inset,
        style: {
            paddingLeft: 56
        }
    }]
})
  , zo = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiListItemText"
    })
      , {children: i, className: o, disableTypography: a=!1, inset: s=!1, primary: c, primaryTypographyProps: u, secondary: f, secondaryTypographyProps: h, slots: m={}, slotProps: y={}, ...b} = r
      , {dense: v} = A.useContext(Wa);
    let S = c ?? i
      , C = f;
    const w = {
        ...r,
        disableTypography: a,
        inset: s,
        primary: !!S,
        secondary: !!C,
        dense: v
    }
      , k = jle(w)
      , T = {
        slots: m,
        slotProps: {
            primary: u,
            secondary: h,
            ...y
        }
    }
      , [E,P] = mt("root", {
        className: Ne(k.root, o),
        elementType: Ble,
        externalForwardedProps: {
            ...T,
            ...b
        },
        ownerState: w,
        ref: n
    })
      , [D,$] = mt("primary", {
        className: k.primary,
        elementType: Ae,
        externalForwardedProps: T,
        ownerState: w
    })
      , [z,O] = mt("secondary", {
        className: k.secondary,
        elementType: Ae,
        externalForwardedProps: T,
        ownerState: w
    });
    return S != null && S.type !== Ae && !a && (S = g.jsx(D, {
        variant: v ? "body2" : "body1",
        component: $?.variant ? void 0 : "span",
        ...$,
        children: S
    })),
    C != null && C.type !== Ae && !a && (C = g.jsx(z, {
        variant: "body2",
        color: "textSecondary",
        ...O,
        children: C
    })),
    g.jsxs(E, {
        ...P,
        children: [S, C]
    })
});
function Kw(e, t, n) {
    return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild
}
function eL(e, t, n) {
    return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild
}
function n3(e, t) {
    if (t === void 0)
        return !0;
    let n = e.innerText;
    return n === void 0 && (n = e.textContent),
    n = n.trim().toLowerCase(),
    n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""))
}
function xp(e, t, n, r, i, o) {
    let a = !1
      , s = i(e, t, t ? n : !1);
    for (; s; ) {
        if (s === e.firstChild) {
            if (a)
                return !1;
            a = !0
        }
        const c = r ? !1 : s.disabled || s.getAttribute("aria-disabled") === "true";
        if (!s.hasAttribute("tabindex") || !n3(s, o) || c)
            s = i(e, s, n);
        else
            return s.focus(),
            !0
    }
    return !1
}
const zle = A.forwardRef(function(t, n) {
    const {actions: r, autoFocus: i=!1, autoFocusItem: o=!1, children: a, className: s, disabledItemsFocusable: c=!1, disableListWrap: u=!1, onKeyDown: f, variant: h="selectedMenu", ...m} = t
      , y = A.useRef(null)
      , b = A.useRef({
        keys: [],
        repeating: !0,
        previousKeyMatched: !0,
        lastTime: null
    });
    Cr( () => {
        i && y.current.focus()
    }
    , [i]),
    A.useImperativeHandle(r, () => ({
        adjustStyleForScrollbar: (k, {direction: T}) => {
            const E = !y.current.style.width;
            if (k.clientHeight < y.current.clientHeight && E) {
                const P = `${YN(Zo(k))}px`;
                y.current.style[T === "rtl" ? "paddingLeft" : "paddingRight"] = P,
                y.current.style.width = `calc(100% + ${P})`
            }
            return y.current
        }
    }), []);
    const v = k => {
        const T = y.current
          , E = k.key;
        if (k.ctrlKey || k.metaKey || k.altKey) {
            f && f(k);
            return
        }
        const D = Kr(T).activeElement;
        if (E === "ArrowDown")
            k.preventDefault(),
            xp(T, D, u, c, Kw);
        else if (E === "ArrowUp")
            k.preventDefault(),
            xp(T, D, u, c, eL);
        else if (E === "Home")
            k.preventDefault(),
            xp(T, null, u, c, Kw);
        else if (E === "End")
            k.preventDefault(),
            xp(T, null, u, c, eL);
        else if (E.length === 1) {
            const $ = b.current
              , z = E.toLowerCase()
              , O = performance.now();
            $.keys.length > 0 && (O - $.lastTime > 500 ? ($.keys = [],
            $.repeating = !0,
            $.previousKeyMatched = !0) : $.repeating && z !== $.keys[0] && ($.repeating = !1)),
            $.lastTime = O,
            $.keys.push(z);
            const I = D && !$.repeating && n3(D, $);
            $.previousKeyMatched && (I || xp(T, D, !1, c, Kw, $)) ? k.preventDefault() : $.previousKeyMatched = !1
        }
        f && f(k)
    }
      , S = Cn(y, n);
    let C = -1;
    A.Children.forEach(a, (k, T) => {
        if (!A.isValidElement(k)) {
            C === T && (C += 1,
            C >= a.length && (C = -1));
            return
        }
        k.props.disabled || (h === "selectedMenu" && k.props.selected || C === -1) && (C = T),
        C === T && (k.props.disabled || k.props.muiSkipListHighlight || k.type.muiSkipListHighlight) && (C += 1,
        C >= a.length && (C = -1))
    }
    );
    const w = A.Children.map(a, (k, T) => {
        if (T === C) {
            const E = {};
            return o && (E.autoFocus = !0),
            k.props.tabIndex === void 0 && h === "selectedMenu" && (E.tabIndex = 0),
            A.cloneElement(k, E)
        }
        return k
    }
    );
    return g.jsx(Fu, {
        role: "menu",
        ref: S,
        className: s,
        onKeyDown: v,
        tabIndex: i ? 0 : -1,
        ...m,
        children: w
    })
});
function Fle(e) {
    return rt("MuiPopover", e)
}
ot("MuiPopover", ["root", "paper"]);
function tL(e, t) {
    let n = 0;
    return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height),
    n
}
function nL(e, t) {
    let n = 0;
    return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width),
    n
}
function rL(e) {
    return [e.horizontal, e.vertical].map(t => typeof t == "number" ? `${t}px` : t).join(" ")
}
function Lb(e) {
    return typeof e == "function" ? e() : e
}
const Nle = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        paper: ["paper"]
    }, Fle, t)
}
  , Ule = ue(FE, {
    name: "MuiPopover",
    slot: "Root"
})({})
  , r3 = ue(yn, {
    name: "MuiPopover",
    slot: "Paper"
})({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    outline: 0
})
  , Vle = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiPopover"
    })
      , {action: i, anchorEl: o, anchorOrigin: a={
        vertical: "top",
        horizontal: "left"
    }, anchorPosition: s, anchorReference: c="anchorEl", children: u, className: f, container: h, elevation: m=8, marginThreshold: y=16, open: b, PaperProps: v={}, slots: S={}, slotProps: C={}, transformOrigin: w={
        vertical: "top",
        horizontal: "left"
    }, TransitionComponent: k, transitionDuration: T="auto", TransitionProps: E={}, disableScrollLock: P=!1, ...D} = r
      , $ = A.useRef()
      , z = {
        ...r,
        anchorOrigin: a,
        anchorReference: c,
        elevation: m,
        marginThreshold: y,
        transformOrigin: w,
        TransitionComponent: k,
        transitionDuration: T,
        TransitionProps: E
    }
      , O = Nle(z)
      , I = A.useCallback( () => {
        if (c === "anchorPosition")
            return s;
        const oe = Lb(o)
          , xe = (oe && oe.nodeType === 1 ? oe : Kr($.current).body).getBoundingClientRect();
        return {
            top: xe.top + tL(xe, a.vertical),
            left: xe.left + nL(xe, a.horizontal)
        }
    }
    , [o, a.horizontal, a.vertical, s, c])
      , M = A.useCallback(oe => ({
        vertical: tL(oe, w.vertical),
        horizontal: nL(oe, w.horizontal)
    }), [w.horizontal, w.vertical])
      , B = A.useCallback(oe => {
        const we = {
            width: oe.offsetWidth,
            height: oe.offsetHeight
        }
          , xe = M(we);
        if (c === "none")
            return {
                top: null,
                left: null,
                transformOrigin: rL(xe)
            };
        const se = I();
        let de = se.top - xe.vertical
          , Se = se.left - xe.horizontal;
        const Ce = de + we.height
          , Ye = Se + we.width
          , ye = Zo(Lb(o))
          , Ke = ye.innerHeight - y
          , X = ye.innerWidth - y;
        if (y !== null && de < y) {
            const ce = de - y;
            de -= ce,
            xe.vertical += ce
        } else if (y !== null && Ce > Ke) {
            const ce = Ce - Ke;
            de -= ce,
            xe.vertical += ce
        }
        if (y !== null && Se < y) {
            const ce = Se - y;
            Se -= ce,
            xe.horizontal += ce
        } else if (Ye > X) {
            const ce = Ye - X;
            Se -= ce,
            xe.horizontal += ce
        }
        return {
            top: `${Math.round(de)}px`,
            left: `${Math.round(Se)}px`,
            transformOrigin: rL(xe)
        }
    }
    , [o, c, I, M, y])
      , [L,F] = A.useState(b)
      , j = A.useCallback( () => {
        const oe = $.current;
        if (!oe)
            return;
        const we = B(oe);
        we.top !== null && oe.style.setProperty("top", we.top),
        we.left !== null && (oe.style.left = we.left),
        oe.style.transformOrigin = we.transformOrigin,
        F(!0)
    }
    , [B]);
    A.useEffect( () => (P && window.addEventListener("scroll", j),
    () => window.removeEventListener("scroll", j)), [o, P, j]);
    const N = () => {
        j()
    }
      , H = () => {
        F(!1)
    }
    ;
    A.useEffect( () => {
        b && j()
    }
    ),
    A.useImperativeHandle(i, () => b ? {
        updatePosition: () => {
            j()
        }
    } : null, [b, j]),
    A.useEffect( () => {
        if (!b)
            return;
        const oe = Rg( () => {
            j()
        }
        )
          , we = Zo(Lb(o));
        return we.addEventListener("resize", oe),
        () => {
            oe.clear(),
            we.removeEventListener("resize", oe)
        }
    }
    , [o, b, j]);
    let Z = T;
    const q = {
        slots: {
            transition: k,
            ...S
        },
        slotProps: {
            transition: E,
            paper: v,
            ...C
        }
    }
      , [V,Y] = mt("transition", {
        elementType: Wf,
        externalForwardedProps: q,
        ownerState: z,
        getSlotProps: oe => ({
            ...oe,
            onEntering: (we, xe) => {
                oe.onEntering?.(we, xe),
                N()
            }
            ,
            onExited: we => {
                oe.onExited?.(we),
                H()
            }
        }),
        additionalProps: {
            appear: !0,
            in: b
        }
    });
    T === "auto" && !V.muiSupportAuto && (Z = void 0);
    const W = h || (o ? Kr(Lb(o)).body : void 0)
      , [te,{slots: K, slotProps: ee, ...re}] = mt("root", {
        ref: n,
        elementType: Ule,
        externalForwardedProps: {
            ...q,
            ...D
        },
        shouldForwardComponentProp: !0,
        additionalProps: {
            slots: {
                backdrop: S.backdrop
            },
            slotProps: {
                backdrop: _E(typeof C.backdrop == "function" ? C.backdrop(z) : C.backdrop, {
                    invisible: !0
                })
            },
            container: W,
            open: b
        },
        ownerState: z,
        className: Ne(O.root, f)
    })
      , [ie,J] = mt("paper", {
        ref: $,
        className: O.paper,
        elementType: r3,
        externalForwardedProps: q,
        shouldForwardComponentProp: !0,
        additionalProps: {
            elevation: m,
            style: L ? void 0 : {
                opacity: 0
            }
        },
        ownerState: z
    });
    return g.jsx(te, {
        ...re,
        ...!Nf(te) && {
            slots: K,
            slotProps: ee,
            disableScrollLock: P
        },
        children: g.jsx(V, {
            ...Y,
            timeout: Z,
            children: g.jsx(ie, {
                ...J,
                children: u
            })
        })
    })
});
function Hle(e) {
    return rt("MuiMenu", e)
}
ot("MuiMenu", ["root", "paper", "list"]);
const qle = {
    vertical: "top",
    horizontal: "right"
}
  , Wle = {
    vertical: "top",
    horizontal: "left"
}
  , Gle = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        paper: ["paper"],
        list: ["list"]
    }, Hle, t)
}
  , Yle = ue(Vle, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiMenu",
    slot: "Root"
})({})
  , Zle = ue(r3, {
    name: "MuiMenu",
    slot: "Paper"
})({
    maxHeight: "calc(100% - 96px)",
    WebkitOverflowScrolling: "touch"
})
  , Qle = ue(zle, {
    name: "MuiMenu",
    slot: "List"
})({
    outline: 0
})
  , vf = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiMenu"
    })
      , {autoFocus: i=!0, children: o, className: a, disableAutoFocusItem: s=!1, MenuListProps: c={}, onClose: u, open: f, PaperProps: h={}, PopoverClasses: m, transitionDuration: y="auto", TransitionProps: {onEntering: b, ...v}={}, variant: S="selectedMenu", slots: C={}, slotProps: w={}, ...k} = r
      , T = Si()
      , E = {
        ...r,
        autoFocus: i,
        disableAutoFocusItem: s,
        MenuListProps: c,
        onEntering: b,
        PaperProps: h,
        transitionDuration: y,
        TransitionProps: v,
        variant: S
    }
      , P = Gle(E)
      , D = i && !s && f
      , $ = A.useRef(null)
      , z = (Z, q) => {
        $.current && $.current.adjustStyleForScrollbar(Z, {
            direction: T ? "rtl" : "ltr"
        }),
        b && b(Z, q)
    }
      , O = Z => {
        Z.key === "Tab" && (Z.preventDefault(),
        u && u(Z, "tabKeyDown"))
    }
    ;
    let I = -1;
    A.Children.map(o, (Z, q) => {
        A.isValidElement(Z) && (Z.props.disabled || (S === "selectedMenu" && Z.props.selected || I === -1) && (I = q))
    }
    );
    const M = {
        slots: C,
        slotProps: {
            list: c,
            transition: v,
            paper: h,
            ...w
        }
    }
      , B = _n({
        elementType: C.root,
        externalSlotProps: w.root,
        ownerState: E,
        className: [P.root, a]
    })
      , [L,F] = mt("paper", {
        className: P.paper,
        elementType: Zle,
        externalForwardedProps: M,
        shouldForwardComponentProp: !0,
        ownerState: E
    })
      , [j,N] = mt("list", {
        className: Ne(P.list, c.className),
        elementType: Qle,
        shouldForwardComponentProp: !0,
        externalForwardedProps: M,
        getSlotProps: Z => ({
            ...Z,
            onKeyDown: q => {
                O(q),
                Z.onKeyDown?.(q)
            }
        }),
        ownerState: E
    })
      , H = typeof M.slotProps.transition == "function" ? M.slotProps.transition(E) : M.slotProps.transition;
    return g.jsx(Yle, {
        onClose: u,
        anchorOrigin: {
            vertical: "bottom",
            horizontal: T ? "right" : "left"
        },
        transformOrigin: T ? qle : Wle,
        slots: {
            root: C.root,
            paper: L,
            backdrop: C.backdrop,
            ...C.transition && {
                transition: C.transition
            }
        },
        slotProps: {
            root: B,
            paper: F,
            backdrop: typeof w.backdrop == "function" ? w.backdrop(E) : w.backdrop,
            transition: {
                ...H,
                onEntering: (...Z) => {
                    z(...Z),
                    H?.onEntering?.(...Z)
                }
            }
        },
        open: f,
        ref: n,
        transitionDuration: y,
        ownerState: E,
        ...k,
        classes: m,
        children: g.jsx(j, {
            actions: $,
            autoFocus: i && (I === -1 || s),
            autoFocusItem: D,
            variant: S,
            ...N,
            children: o
        })
    })
});
function Kle(e) {
    return rt("MuiMenuItem", e)
}
const vp = ot("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"])
  , Xle = (e, t) => {
    const {ownerState: n} = e;
    return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters]
}
  , Jle = e => {
    const {disabled: t, dense: n, divider: r, disableGutters: i, selected: o, classes: a} = e
      , c = tt({
        root: ["root", n && "dense", t && "disabled", !i && "gutters", r && "divider", o && "selected"]
    }, Kle, a);
    return {
        ...a,
        ...c
    }
}
  , ece = ue(Ka, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: Xle
})(pt( ({theme: e}) => ({
    ...e.typography.body1,
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: "border-box",
    whiteSpace: "nowrap",
    "&:hover": {
        textDecoration: "none",
        backgroundColor: (e.vars || e).palette.action.hover,
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    },
    [`&.${vp.selected}`]: {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
        [`&.${vp.focusVisible}`]: {
            backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
        }
    },
    [`&.${vp.selected}:hover`]: {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
        "@media (hover: none)": {
            backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
        }
    },
    [`&.${vp.focusVisible}`]: {
        backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${vp.disabled}`]: {
        opacity: (e.vars || e).palette.action.disabledOpacity
    },
    [`& + .${Y$.root}`]: {
        marginTop: e.spacing(1),
        marginBottom: e.spacing(1)
    },
    [`& + .${Y$.inset}`]: {
        marginLeft: 52
    },
    [`& .${ff.root}`]: {
        marginTop: 0,
        marginBottom: 0
    },
    [`& .${ff.inset}`]: {
        paddingLeft: 36
    },
    [`& .${J$.root}`]: {
        minWidth: 36
    },
    variants: [{
        props: ({ownerState: t}) => !t.disableGutters,
        style: {
            paddingLeft: 16,
            paddingRight: 16
        }
    }, {
        props: ({ownerState: t}) => t.divider,
        style: {
            borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
            backgroundClip: "padding-box"
        }
    }, {
        props: ({ownerState: t}) => !t.dense,
        style: {
            [e.breakpoints.up("sm")]: {
                minHeight: "auto"
            }
        }
    }, {
        props: ({ownerState: t}) => t.dense,
        style: {
            minHeight: 32,
            paddingTop: 4,
            paddingBottom: 4,
            ...e.typography.body2,
            [`& .${J$.root} svg`]: {
                fontSize: "1.25rem"
            }
        }
    }]
})))
  , Yr = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiMenuItem"
    })
      , {autoFocus: i=!1, component: o="li", dense: a=!1, divider: s=!1, disableGutters: c=!1, focusVisibleClassName: u, role: f="menuitem", tabIndex: h, className: m, ...y} = r
      , b = A.useContext(Wa)
      , v = A.useMemo( () => ({
        dense: a || b.dense || !1,
        disableGutters: c
    }), [b.dense, a, c])
      , S = A.useRef(null);
    Cr( () => {
        i && S.current && S.current.focus()
    }
    , [i]);
    const C = {
        ...r,
        dense: v.dense,
        divider: s,
        disableGutters: c
    }
      , w = Jle(r)
      , k = Cn(S, n);
    let T;
    return r.disabled || (T = h !== void 0 ? h : -1),
    g.jsx(Wa.Provider, {
        value: v,
        children: g.jsx(ece, {
            ref: k,
            role: f,
            tabIndex: T,
            component: o,
            focusVisibleClassName: Ne(w.focusVisible, u),
            className: Ne(w.root, m),
            ...y,
            ownerState: C,
            classes: w
        })
    })
});
function tce(e) {
    return rt("MuiMobileStepper", e)
}
ot("MuiMobileStepper", ["root", "positionBottom", "positionTop", "positionStatic", "dots", "dot", "dotActive", "progress"]);
const nce = e => {
    const {classes: t, position: n} = e
      , r = {
        root: ["root", `position${Te(n)}`],
        dots: ["dots"],
        dot: ["dot"],
        dotActive: ["dotActive"],
        progress: ["progress"]
    };
    return tt(r, tce, t)
}
  , rce = ue(yn, {
    name: "MuiMobileStepper",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[`position${Te(n.position)}`]]
    }
})(pt( ({theme: e}) => ({
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    background: (e.vars || e).palette.background.default,
    padding: 8,
    variants: [{
        props: ({position: t}) => t === "top" || t === "bottom",
        style: {
            position: "fixed",
            left: 0,
            right: 0,
            zIndex: (e.vars || e).zIndex.mobileStepper
        }
    }, {
        props: {
            position: "top"
        },
        style: {
            top: 0
        }
    }, {
        props: {
            position: "bottom"
        },
        style: {
            bottom: 0
        }
    }]
})))
  , ice = ue("div", {
    name: "MuiMobileStepper",
    slot: "Dots"
})({
    variants: [{
        props: {
            variant: "dots"
        },
        style: {
            display: "flex",
            flexDirection: "row"
        }
    }]
})
  , oce = ue("div", {
    name: "MuiMobileStepper",
    slot: "Dot",
    shouldForwardProp: e => kE(e) && e !== "dotActive",
    overridesResolver: (e, t) => {
        const {dotActive: n} = e;
        return [t.dot, n && t.dotActive]
    }
})(pt( ({theme: e}) => ({
    variants: [{
        props: {
            variant: "dots"
        },
        style: {
            transition: e.transitions.create("background-color", {
                duration: e.transitions.duration.shortest
            }),
            backgroundColor: (e.vars || e).palette.action.disabled,
            borderRadius: "50%",
            width: 8,
            height: 8,
            margin: "0 2px"
        }
    }, {
        props: {
            variant: "dots",
            dotActive: !0
        },
        style: {
            backgroundColor: (e.vars || e).palette.primary.main
        }
    }]
})))
  , ace = ue(yle, {
    name: "MuiMobileStepper",
    slot: "Progress"
})({
    variants: [{
        props: {
            variant: "progress"
        },
        style: {
            width: "50%"
        }
    }]
})
  , sce = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiMobileStepper"
    })
      , {activeStep: i=0, backButton: o, className: a, LinearProgressProps: s, nextButton: c, position: u="bottom", steps: f, variant: h="dots", slots: m={}, slotProps: y={}, ...b} = r
      , v = {
        ...r,
        activeStep: i,
        position: u,
        variant: h
    };
    let S;
    h === "progress" && (f === 1 ? S = 100 : S = Math.ceil(i / (f - 1) * 100));
    const C = nce(v)
      , w = {
        slots: m,
        slotProps: {
            progress: s,
            ...y
        }
    }
      , [k,T] = mt("root", {
        ref: n,
        elementType: rce,
        shouldForwardComponentProp: !0,
        className: Ne(C.root, a),
        externalForwardedProps: {
            ...w,
            ...b
        },
        ownerState: v,
        additionalProps: {
            square: !0,
            elevation: 0
        }
    })
      , [E,P] = mt("dots", {
        className: C.dots,
        elementType: ice,
        externalForwardedProps: w,
        ownerState: v
    })
      , [D,$] = mt("dot", {
        elementType: oce,
        externalForwardedProps: w,
        ownerState: v
    })
      , [z,O] = mt("progress", {
        className: C.progress,
        elementType: ace,
        shouldForwardComponentProp: !0,
        externalForwardedProps: w,
        ownerState: v,
        additionalProps: {
            value: S,
            variant: "determinate"
        }
    });
    return g.jsxs(k, {
        ...T,
        children: [o, h === "text" && g.jsxs(A.Fragment, {
            children: [i + 1, " / ", f]
        }), h === "dots" && g.jsx(E, {
            ...P,
            children: [...new Array(f)].map( (I, M) => g.jsx(D, {
                ...$,
                className: Ne(C.dot, $.className, M === i && C.dotActive),
                dotActive: M === i
            }, M))
        }), h === "progress" && g.jsx(z, {
            ...O
        }), c]
    })
});
function lce(e) {
    return rt("MuiNativeSelect", e)
}
const qE = ot("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"])
  , cce = e => {
    const {classes: t, variant: n, disabled: r, multiple: i, open: o, error: a} = e
      , s = {
        select: ["select", n, r && "disabled", i && "multiple", a && "error"],
        icon: ["icon", `icon${Te(n)}`, o && "iconOpen", r && "disabled"]
    };
    return tt(s, lce, t)
}
  , i3 = ue("select", {
    name: "MuiNativeSelect"
})( ({theme: e}) => ({
    MozAppearance: "none",
    WebkitAppearance: "none",
    userSelect: "none",
    borderRadius: 0,
    cursor: "pointer",
    "&:focus": {
        borderRadius: 0
    },
    [`&.${qE.disabled}`]: {
        cursor: "default"
    },
    "&[multiple]": {
        height: "auto"
    },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
        backgroundColor: (e.vars || e).palette.background.paper
    },
    variants: [{
        props: ({ownerState: t}) => t.variant !== "filled" && t.variant !== "outlined",
        style: {
            "&&&": {
                paddingRight: 24,
                minWidth: 16
            }
        }
    }, {
        props: {
            variant: "filled"
        },
        style: {
            "&&&": {
                paddingRight: 32
            }
        }
    }, {
        props: {
            variant: "outlined"
        },
        style: {
            borderRadius: (e.vars || e).shape.borderRadius,
            "&:focus": {
                borderRadius: (e.vars || e).shape.borderRadius
            },
            "&&&": {
                paddingRight: 32
            }
        }
    }]
}))
  , uce = ue(i3, {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: ai,
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.select, t[n.variant], n.error && t.error, {
            [`&.${qE.multiple}`]: t.multiple
        }]
    }
})({})
  , o3 = ue("svg", {
    name: "MuiNativeSelect"
})( ({theme: e}) => ({
    position: "absolute",
    right: 0,
    top: "calc(50% - .5em)",
    pointerEvents: "none",
    color: (e.vars || e).palette.action.active,
    [`&.${qE.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
    },
    variants: [{
        props: ({ownerState: t}) => t.open,
        style: {
            transform: "rotate(180deg)"
        }
    }, {
        props: {
            variant: "filled"
        },
        style: {
            right: 7
        }
    }, {
        props: {
            variant: "outlined"
        },
        style: {
            right: 7
        }
    }]
}))
  , dce = ue(o3, {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.icon, n.variant && t[`icon${Te(n.variant)}`], n.open && t.iconOpen]
    }
})({})
  , fce = A.forwardRef(function(t, n) {
    const {className: r, disabled: i, error: o, IconComponent: a, inputRef: s, variant: c="standard", ...u} = t
      , f = {
        ...t,
        disabled: i,
        variant: c,
        error: o
    }
      , h = cce(f);
    return g.jsxs(A.Fragment, {
        children: [g.jsx(uce, {
            ownerState: f,
            className: Ne(h.select, r),
            disabled: i,
            ref: s || n,
            ...u
        }), t.multiple ? null : g.jsx(dce, {
            as: a,
            ownerState: f,
            className: h.icon
        })]
    })
});
var iL;
const hce = ue("fieldset", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: ai
})({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%"
})
  , pce = ue("legend", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: ai
})(pt( ({theme: e}) => ({
    float: "unset",
    width: "auto",
    overflow: "hidden",
    variants: [{
        props: ({ownerState: t}) => !t.withLabel,
        style: {
            padding: 0,
            lineHeight: "11px",
            transition: e.transitions.create("width", {
                duration: 150,
                easing: e.transitions.easing.easeOut
            })
        }
    }, {
        props: ({ownerState: t}) => t.withLabel,
        style: {
            display: "block",
            padding: 0,
            height: 11,
            fontSize: "0.75em",
            visibility: "hidden",
            maxWidth: .01,
            transition: e.transitions.create("max-width", {
                duration: 50,
                easing: e.transitions.easing.easeOut
            }),
            whiteSpace: "nowrap",
            "& > span": {
                paddingLeft: 5,
                paddingRight: 5,
                display: "inline-block",
                opacity: 0,
                visibility: "visible"
            }
        }
    }, {
        props: ({ownerState: t}) => t.withLabel && t.notched,
        style: {
            maxWidth: "100%",
            transition: e.transitions.create("max-width", {
                duration: 100,
                easing: e.transitions.easing.easeOut,
                delay: 50
            })
        }
    }]
})));
function mce(e) {
    const {children: t, classes: n, className: r, label: i, notched: o, ...a} = e
      , s = i != null && i !== ""
      , c = {
        ...e,
        notched: o,
        withLabel: s
    };
    return g.jsx(hce, {
        "aria-hidden": !0,
        className: r,
        ownerState: c,
        ...a,
        children: g.jsx(pce, {
            ownerState: c,
            children: s ? g.jsx("span", {
                children: i
            }) : iL || (iL = g.jsx("span", {
                className: "notranslate",
                "aria-hidden": !0,
                children: ""
            }))
        })
    })
}
const gce = e => {
    const {classes: t} = e
      , r = tt({
        root: ["root"],
        notchedOutline: ["notchedOutline"],
        input: ["input"]
    }, yoe, t);
    return {
        ...t,
        ...r
    }
}
  , yce = ue(Jv, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: Kv
})(pt( ({theme: e}) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
        position: "relative",
        borderRadius: (e.vars || e).shape.borderRadius,
        [`&:hover .${fa.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.text.primary
        },
        "@media (hover: none)": {
            [`&:hover .${fa.notchedOutline}`]: {
                borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, .23) : t
            }
        },
        [`&.${fa.focused} .${fa.notchedOutline}`]: {
            borderWidth: 2
        },
        variants: [...Object.entries(e.palette).filter(Qn()).map( ([n]) => ({
            props: {
                color: n
            },
            style: {
                [`&.${fa.focused} .${fa.notchedOutline}`]: {
                    borderColor: (e.vars || e).palette[n].main
                }
            }
        })), {
            props: {},
            style: {
                [`&.${fa.error} .${fa.notchedOutline}`]: {
                    borderColor: (e.vars || e).palette.error.main
                },
                [`&.${fa.disabled} .${fa.notchedOutline}`]: {
                    borderColor: (e.vars || e).palette.action.disabled
                }
            }
        }, {
            props: ({ownerState: n}) => n.startAdornment,
            style: {
                paddingLeft: 14
            }
        }, {
            props: ({ownerState: n}) => n.endAdornment,
            style: {
                paddingRight: 14
            }
        }, {
            props: ({ownerState: n}) => n.multiline,
            style: {
                padding: "16.5px 14px"
            }
        }, {
            props: ({ownerState: n, size: r}) => n.multiline && r === "small",
            style: {
                padding: "8.5px 14px"
            }
        }]
    }
}
))
  , bce = ue(mce, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline"
})(pt( ({theme: e}) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
        borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, .23) : t
    }
}
))
  , xce = ue(e1, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: Xv
})(pt( ({theme: e}) => ({
    padding: "16.5px 14px",
    ...!e.vars && {
        "&:-webkit-autofill": {
            WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
            WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
            caretColor: e.palette.mode === "light" ? null : "#fff",
            borderRadius: "inherit"
        }
    },
    ...e.vars && {
        "&:-webkit-autofill": {
            borderRadius: "inherit"
        },
        [e.getColorSchemeSelector("dark")]: {
            "&:-webkit-autofill": {
                WebkitBoxShadow: "0 0 0 100px #266798 inset",
                WebkitTextFillColor: "#fff",
                caretColor: "#fff"
            }
        }
    },
    variants: [{
        props: {
            size: "small"
        },
        style: {
            padding: "8.5px 14px"
        }
    }, {
        props: ({ownerState: t}) => t.multiline,
        style: {
            padding: 0
        }
    }, {
        props: ({ownerState: t}) => t.startAdornment,
        style: {
            paddingLeft: 0
        }
    }, {
        props: ({ownerState: t}) => t.endAdornment,
        style: {
            paddingRight: 0
        }
    }]
})))
  , WE = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiOutlinedInput"
    })
      , {components: i={}, fullWidth: o=!1, inputComponent: a="input", label: s, multiline: c=!1, notched: u, slots: f={}, slotProps: h={}, type: m="text", ...y} = r
      , b = gce(r)
      , v = To()
      , S = nd({
        props: r,
        muiFormControl: v,
        states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
    })
      , C = {
        ...r,
        color: S.color || "primary",
        disabled: S.disabled,
        error: S.error,
        focused: S.focused,
        formControl: v,
        fullWidth: o,
        hiddenLabel: S.hiddenLabel,
        multiline: c,
        size: S.size,
        type: m
    }
      , w = f.root ?? i.Root ?? yce
      , k = f.input ?? i.Input ?? xce
      , [T,E] = mt("notchedOutline", {
        elementType: bce,
        className: b.notchedOutline,
        shouldForwardComponentProp: !0,
        ownerState: C,
        externalForwardedProps: {
            slots: f,
            slotProps: h
        },
        additionalProps: {
            label: s != null && s !== "" && S.required ? g.jsxs(A.Fragment, {
                children: [s, "", "*"]
            }) : s
        }
    });
    return g.jsx(Lg, {
        slots: {
            root: w,
            input: k
        },
        slotProps: h,
        renderSuffix: P => g.jsx(T, {
            ...E,
            notched: typeof u < "u" ? u : !!(P.startAdornment || P.filled || P.focused)
        }),
        fullWidth: o,
        inputComponent: a,
        multiline: c,
        ref: n,
        type: m,
        ...y,
        classes: {
            ...b,
            notchedOutline: null
        }
    })
});
WE.muiName = "Input";
const vce = _t(g.jsx("path", {
    d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}))
  , Sce = _t(g.jsx("path", {
    d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}))
  , Cce = _t(g.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}))
  , wce = _t(g.jsx("path", {
    d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
}))
  , kce = ue("span", {
    name: "MuiRadioButtonIcon",
    shouldForwardProp: ai
})({
    position: "relative",
    display: "flex"
})
  , Tce = ue(Cce, {
    name: "MuiRadioButtonIcon"
})({
    transform: "scale(1)"
})
  , _ce = ue(wce, {
    name: "MuiRadioButtonIcon"
})(pt( ({theme: e}) => ({
    left: 0,
    position: "absolute",
    transform: "scale(0)",
    transition: e.transitions.create("transform", {
        easing: e.transitions.easing.easeIn,
        duration: e.transitions.duration.shortest
    }),
    variants: [{
        props: {
            checked: !0
        },
        style: {
            transform: "scale(1)",
            transition: e.transitions.create("transform", {
                easing: e.transitions.easing.easeOut,
                duration: e.transitions.duration.shortest
            })
        }
    }]
})));
function a3(e) {
    const {checked: t=!1, classes: n={}, fontSize: r} = e
      , i = {
        ...e,
        checked: t
    };
    return g.jsxs(kce, {
        className: n.root,
        ownerState: i,
        children: [g.jsx(Tce, {
            fontSize: r,
            className: n.background,
            ownerState: i
        }), g.jsx(_ce, {
            fontSize: r,
            className: n.dot,
            ownerState: i
        })]
    })
}
const Ece = A.createContext(void 0);
function Ace() {
    return A.useContext(Ece)
}
function Mce(e) {
    return rt("MuiRadio", e)
}
const oL = ot("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"])
  , Pce = e => {
    const {classes: t, color: n, size: r} = e
      , i = {
        root: ["root", `color${Te(n)}`, r !== "medium" && `size${Te(r)}`]
    };
    return {
        ...t,
        ...tt(i, Mce, t)
    }
}
  , Rce = ue(WN, {
    shouldForwardProp: e => ai(e) || e === "classes",
    name: "MuiRadio",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.size !== "medium" && t[`size${Te(n.size)}`], t[`color${Te(n.color)}`]]
    }
})(pt( ({theme: e}) => ({
    color: (e.vars || e).palette.text.secondary,
    [`&.${oL.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
    },
    variants: [{
        props: {
            color: "default",
            disabled: !1,
            disableRipple: !1
        },
        style: {
            "&:hover": {
                backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
            }
        }
    }, ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t,
            disabled: !1,
            disableRipple: !1
        },
        style: {
            "&:hover": {
                backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
            }
        }
    })), ...Object.entries(e.palette).filter(Qn()).map( ([t]) => ({
        props: {
            color: t,
            disabled: !1
        },
        style: {
            [`&.${oL.checked}`]: {
                color: (e.vars || e).palette[t].main
            }
        }
    })), {
        props: {
            disableRipple: !1
        },
        style: {
            "&:hover": {
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        }
    }]
})));
function Dce(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t)
}
const Oce = g.jsx(a3, {
    checked: !0
})
  , Ice = g.jsx(a3, {})
  , $ce = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiRadio"
    })
      , {checked: i, checkedIcon: o=Oce, color: a="primary", icon: s=Ice, name: c, onChange: u, size: f="medium", className: h, disabled: m, disableRipple: y=!1, slots: b={}, slotProps: v={}, inputProps: S, ...C} = r
      , w = To();
    let k = m;
    w && typeof k > "u" && (k = w.disabled),
    k ??= !1;
    const T = {
        ...r,
        disabled: k,
        disableRipple: y,
        color: a,
        size: f
    }
      , E = Pce(T)
      , P = Ace();
    let D = i;
    const $ = F2(u, P && P.onChange);
    let z = c;
    P && (typeof D > "u" && (D = Dce(P.value, r.value)),
    typeof z > "u" && (z = P.name));
    const O = v.input ?? S
      , [I,M] = mt("root", {
        ref: n,
        elementType: Rce,
        className: Ne(E.root, h),
        shouldForwardComponentProp: !0,
        externalForwardedProps: {
            slots: b,
            slotProps: v,
            ...C
        },
        getSlotProps: B => ({
            ...B,
            onChange: (L, ...F) => {
                B.onChange?.(L, ...F),
                $(L, ...F)
            }
        }),
        ownerState: T,
        additionalProps: {
            type: "radio",
            icon: A.cloneElement(s, {
                fontSize: s.props.fontSize ?? f
            }),
            checkedIcon: A.cloneElement(o, {
                fontSize: o.props.fontSize ?? f
            }),
            disabled: k,
            name: z,
            checked: D,
            slots: b,
            slotProps: {
                input: typeof O == "function" ? O(T) : O
            }
        }
    });
    return g.jsx(I, {
        ...M,
        classes: E
    })
})
  , Lce = {
    border: 0,
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
};
function s3(e) {
    return rt("MuiSelect", e)
}
const Sp = ot("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var aL;
const jce = ue(i3, {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [{
            [`&.${Sp.select}`]: t.select
        }, {
            [`&.${Sp.select}`]: t[n.variant]
        }, {
            [`&.${Sp.error}`]: t.error
        }, {
            [`&.${Sp.multiple}`]: t.multiple
        }]
    }
})({
    [`&.${Sp.select}`]: {
        height: "auto",
        minHeight: "1.4375em",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        overflow: "hidden"
    }
})
  , Bce = ue(o3, {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.icon, n.variant && t[`icon${Te(n.variant)}`], n.open && t.iconOpen]
    }
})({})
  , zce = ue("input", {
    shouldForwardProp: e => kE(e) && e !== "classes",
    name: "MuiSelect",
    slot: "NativeInput"
})({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box"
});
function sL(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t)
}
function Fce(e) {
    return e == null || typeof e == "string" && !e.trim()
}
const Nce = e => {
    const {classes: t, variant: n, disabled: r, multiple: i, open: o, error: a} = e
      , s = {
        select: ["select", n, r && "disabled", i && "multiple", a && "error"],
        icon: ["icon", `icon${Te(n)}`, o && "iconOpen", r && "disabled"],
        nativeInput: ["nativeInput"]
    };
    return tt(s, s3, t)
}
  , Uce = A.forwardRef(function(t, n) {
    const {"aria-describedby": r, "aria-label": i, autoFocus: o, autoWidth: a, children: s, className: c, defaultOpen: u, defaultValue: f, disabled: h, displayEmpty: m, error: y=!1, IconComponent: b, inputRef: v, labelId: S, MenuProps: C={}, multiple: w, name: k, onBlur: T, onChange: E, onClose: P, onFocus: D, onOpen: $, open: z, readOnly: O, renderValue: I, required: M, SelectDisplayProps: B={}, tabIndex: L, type: F, value: j, variant: N="standard", ...H} = t
      , [Z,q] = go({
        controlled: j,
        default: f,
        name: "Select"
    })
      , [V,Y] = go({
        controlled: z,
        default: u,
        name: "Select"
    })
      , W = A.useRef(null)
      , te = A.useRef(null)
      , [K,ee] = A.useState(null)
      , {current: re} = A.useRef(z != null)
      , [ie,J] = A.useState()
      , oe = Cn(n, v)
      , we = A.useCallback(nt => {
        te.current = nt,
        nt && ee(nt)
    }
    , [])
      , xe = K?.parentNode;
    A.useImperativeHandle(oe, () => ({
        focus: () => {
            te.current.focus()
        }
        ,
        node: W.current,
        value: Z
    }), [Z]),
    A.useEffect( () => {
        u && V && K && !re && (J(a ? null : xe.clientWidth),
        te.current.focus())
    }
    , [K, a]),
    A.useEffect( () => {
        o && te.current.focus()
    }
    , [o]),
    A.useEffect( () => {
        if (!S)
            return;
        const nt = Kr(te.current).getElementById(S);
        if (nt) {
            const ut = () => {
                getSelection().isCollapsed && te.current.focus()
            }
            ;
            return nt.addEventListener("click", ut),
            () => {
                nt.removeEventListener("click", ut)
            }
        }
    }
    , [S]);
    const se = (nt, ut) => {
        nt ? $ && $(ut) : P && P(ut),
        re || (J(a ? null : xe.clientWidth),
        Y(nt))
    }
      , de = nt => {
        nt.button === 0 && (nt.preventDefault(),
        te.current.focus(),
        se(!0, nt))
    }
      , Se = nt => {
        se(!1, nt)
    }
      , Ce = A.Children.toArray(s)
      , Ye = nt => {
        const ut = Ce.find(Lt => Lt.props.value === nt.target.value);
        ut !== void 0 && (q(ut.props.value),
        E && E(nt, ut))
    }
      , ye = nt => ut => {
        let Lt;
        if (ut.currentTarget.hasAttribute("tabindex")) {
            if (w) {
                Lt = Array.isArray(Z) ? Z.slice() : [];
                const tn = Z.indexOf(nt.props.value);
                tn === -1 ? Lt.push(nt.props.value) : Lt.splice(tn, 1)
            } else
                Lt = nt.props.value;
            if (nt.props.onClick && nt.props.onClick(ut),
            Z !== Lt && (q(Lt),
            E)) {
                const tn = ut.nativeEvent || ut
                  , Xt = new tn.constructor(tn.type,tn);
                Object.defineProperty(Xt, "target", {
                    writable: !0,
                    value: {
                        value: Lt,
                        name: k
                    }
                }),
                E(Xt, nt)
            }
            w || se(!1, ut)
        }
    }
      , Ke = nt => {
        O || [" ", "ArrowUp", "ArrowDown", "Enter"].includes(nt.key) && (nt.preventDefault(),
        se(!0, nt))
    }
      , X = K !== null && V
      , ce = nt => {
        !X && T && (Object.defineProperty(nt, "target", {
            writable: !0,
            value: {
                value: Z,
                name: k
            }
        }),
        T(nt))
    }
    ;
    delete H["aria-invalid"];
    let fe, Xe;
    const Oe = [];
    let Re = !1;
    (b0({
        value: Z
    }) || m) && (I ? fe = I(Z) : Re = !0);
    const le = Ce.map(nt => {
        if (!A.isValidElement(nt))
            return null;
        let ut;
        if (w) {
            if (!Array.isArray(Z))
                throw new Error(Cl(2));
            ut = Z.some(Lt => sL(Lt, nt.props.value)),
            ut && Re && Oe.push(nt.props.children)
        } else
            ut = sL(Z, nt.props.value),
            ut && Re && (Xe = nt.props.children);
        return A.cloneElement(nt, {
            "aria-selected": ut ? "true" : "false",
            onClick: ye(nt),
            onKeyUp: Lt => {
                Lt.key === " " && Lt.preventDefault(),
                nt.props.onKeyUp && nt.props.onKeyUp(Lt)
            }
            ,
            role: "option",
            selected: ut,
            value: void 0,
            "data-value": nt.props.value
        })
    }
    );
    Re && (w ? Oe.length === 0 ? fe = null : fe = Oe.reduce( (nt, ut, Lt) => (nt.push(ut),
    Lt < Oe.length - 1 && nt.push(", "),
    nt), []) : fe = Xe);
    let ke = ie;
    !a && re && K && (ke = xe.clientWidth);
    let He;
    typeof L < "u" ? He = L : He = h ? null : 0;
    const st = B.id || (k ? `mui-component-select-${k}` : void 0)
      , lt = {
        ...t,
        variant: N,
        value: Z,
        open: X,
        error: y
    }
      , et = Nce(lt)
      , Ht = {
        ...C.PaperProps,
        ...typeof C.slotProps?.paper == "function" ? C.slotProps.paper(lt) : C.slotProps?.paper
    }
      , Ft = {
        ...C.MenuListProps,
        ...typeof C.slotProps?.list == "function" ? C.slotProps.list(lt) : C.slotProps?.list
    }
      , Pt = Gi();
    return g.jsxs(A.Fragment, {
        children: [g.jsx(jce, {
            as: "div",
            ref: we,
            tabIndex: He,
            role: "combobox",
            "aria-controls": X ? Pt : void 0,
            "aria-disabled": h ? "true" : void 0,
            "aria-expanded": X ? "true" : "false",
            "aria-haspopup": "listbox",
            "aria-label": i,
            "aria-labelledby": [S, st].filter(Boolean).join(" ") || void 0,
            "aria-describedby": r,
            "aria-required": M ? "true" : void 0,
            "aria-invalid": y ? "true" : void 0,
            onKeyDown: Ke,
            onMouseDown: h || O ? null : de,
            onBlur: ce,
            onFocus: D,
            ...B,
            ownerState: lt,
            className: Ne(B.className, et.select, c),
            id: st,
            children: Fce(fe) ? aL || (aL = g.jsx("span", {
                className: "notranslate",
                "aria-hidden": !0,
                children: ""
            })) : fe
        }), g.jsx(zce, {
            "aria-invalid": y,
            value: Array.isArray(Z) ? Z.join(",") : Z,
            name: k,
            ref: W,
            "aria-hidden": !0,
            onChange: Ye,
            tabIndex: -1,
            disabled: h,
            className: et.nativeInput,
            autoFocus: o,
            required: M,
            ...H,
            ownerState: lt
        }), g.jsx(Bce, {
            as: b,
            className: et.icon,
            ownerState: lt
        }), g.jsx(vf, {
            id: `menu-${k || ""}`,
            anchorEl: xe,
            open: X,
            onClose: Se,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "center"
            },
            transformOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            ...C,
            slotProps: {
                ...C.slotProps,
                list: {
                    "aria-labelledby": S,
                    role: "listbox",
                    "aria-multiselectable": w ? "true" : void 0,
                    disableListWrap: !0,
                    id: Pt,
                    ...Ft
                },
                paper: {
                    ...Ht,
                    style: {
                        minWidth: ke,
                        ...Ht != null ? Ht.style : null
                    }
                }
            },
            children: le
        })]
    })
})
  , Vce = e => {
    const {classes: t} = e
      , r = tt({
        root: ["root"]
    }, s3, t);
    return {
        ...t,
        ...r
    }
}
  , GE = {
    name: "MuiSelect",
    slot: "Root",
    shouldForwardProp: e => ai(e) && e !== "variant"
}
  , Hce = ue(UE, GE)("")
  , qce = ue(WE, GE)("")
  , Wce = ue(NE, GE)("")
  , Gm = A.forwardRef(function(t, n) {
    const r = gt({
        name: "MuiSelect",
        props: t
    })
      , {autoWidth: i=!1, children: o, classes: a={}, className: s, defaultOpen: c=!1, displayEmpty: u=!1, IconComponent: f=NN, id: h, input: m, inputProps: y, label: b, labelId: v, MenuProps: S, multiple: C=!1, native: w=!1, onClose: k, onOpen: T, open: E, renderValue: P, SelectDisplayProps: D, variant: $="outlined", ...z} = r
      , O = w ? fce : Uce
      , I = To()
      , M = nd({
        props: r,
        muiFormControl: I,
        states: ["variant", "error"]
    })
      , B = M.variant || $
      , L = {
        ...r,
        variant: B,
        classes: a
    }
      , F = Vce(L)
      , {root: j, ...N} = F
      , H = m || {
        standard: g.jsx(Hce, {
            ownerState: L
        }),
        outlined: g.jsx(qce, {
            label: b,
            ownerState: L
        }),
        filled: g.jsx(Wce, {
            ownerState: L
        })
    }[B]
      , Z = Cn(n, Rc(H));
    return g.jsx(A.Fragment, {
        children: A.cloneElement(H, {
            inputComponent: O,
            inputProps: {
                children: o,
                error: M.error,
                IconComponent: f,
                variant: B,
                type: void 0,
                multiple: C,
                ...w ? {
                    id: h
                } : {
                    autoWidth: i,
                    defaultOpen: c,
                    displayEmpty: u,
                    labelId: v,
                    MenuProps: S,
                    onClose: k,
                    onOpen: T,
                    open: E,
                    renderValue: P,
                    SelectDisplayProps: {
                        id: h,
                        ...D
                    }
                },
                ...y,
                classes: y ? ci(N, y.classes) : N,
                ...m ? m.props.inputProps : {}
            },
            ...(C && w || u) && B === "outlined" ? {
                notched: !0
            } : {},
            ref: Z,
            className: Ne(H.props.className, s, F.root),
            ...!m && {
                variant: B
            },
            ...z
        })
    })
});
Gm.muiName = "Select";
function Gce(e) {
    return rt("MuiSkeleton", e)
}
ot("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const Yce = e => {
    const {classes: t, variant: n, animation: r, hasChildren: i, width: o, height: a} = e;
    return tt({
        root: ["root", n, r, i && "withChildren", i && !o && "fitContent", i && !a && "heightAuto"]
    }, Gce, t)
}
  , aT = $s`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`
  , sT = $s`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`
  , Zce = typeof aT != "string" ? Ac`
        animation: ${aT} 2s ease-in-out 0.5s infinite;
      ` : null
  , Qce = typeof sT != "string" ? Ac`
        &::after {
          animation: ${sT} 2s linear 0.5s infinite;
        }
      ` : null
  , Kce = ue("span", {
    name: "MuiSkeleton",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[n.variant], n.animation !== !1 && t[n.animation], n.hasChildren && t.withChildren, n.hasChildren && !n.width && t.fitContent, n.hasChildren && !n.height && t.heightAuto]
    }
})(pt( ({theme: e}) => {
    const t = fne(e.shape.borderRadius) || "px"
      , n = hne(e.shape.borderRadius);
    return {
        display: "block",
        backgroundColor: e.vars ? e.vars.palette.Skeleton.bg : e.alpha(e.palette.text.primary, e.palette.mode === "light" ? .11 : .13),
        height: "1.2em",
        variants: [{
            props: {
                variant: "text"
            },
            style: {
                marginTop: 0,
                marginBottom: 0,
                height: "auto",
                transformOrigin: "0 55%",
                transform: "scale(1, 0.60)",
                borderRadius: `${n}${t}/${Math.round(n / .6 * 10) / 10}${t}`,
                "&:empty:before": {
                    content: '"\\00a0"'
                }
            }
        }, {
            props: {
                variant: "circular"
            },
            style: {
                borderRadius: "50%"
            }
        }, {
            props: {
                variant: "rounded"
            },
            style: {
                borderRadius: (e.vars || e).shape.borderRadius
            }
        }, {
            props: ({ownerState: r}) => r.hasChildren,
            style: {
                "& > *": {
                    visibility: "hidden"
                }
            }
        }, {
            props: ({ownerState: r}) => r.hasChildren && !r.width,
            style: {
                maxWidth: "fit-content"
            }
        }, {
            props: ({ownerState: r}) => r.hasChildren && !r.height,
            style: {
                height: "auto"
            }
        }, {
            props: {
                animation: "pulse"
            },
            style: Zce || {
                animation: `${aT} 2s ease-in-out 0.5s infinite`
            }
        }, {
            props: {
                animation: "wave"
            },
            style: {
                position: "relative",
                overflow: "hidden",
                WebkitMaskImage: "-webkit-radial-gradient(white, black)",
                "&::after": {
                    background: `linear-gradient(
                90deg,
                transparent,
                ${(e.vars || e).palette.action.hover},
                transparent
              )`,
                    content: '""',
                    position: "absolute",
                    transform: "translateX(-100%)",
                    bottom: 0,
                    left: 0,
                    right: 0,
                    top: 0
                }
            }
        }, {
            props: {
                animation: "wave"
            },
            style: Qce || {
                "&::after": {
                    animation: `${sT} 2s linear 0.5s infinite`
                }
            }
        }]
    }
}
))
  , Fn = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiSkeleton"
    })
      , {animation: i="pulse", className: o, component: a="span", height: s, style: c, variant: u="text", width: f, ...h} = r
      , m = {
        ...r,
        animation: i,
        component: a,
        variant: u,
        hasChildren: !!h.children
    }
      , y = Yce(m);
    return g.jsx(Kce, {
        as: a,
        ref: n,
        className: Ne(y.root, o),
        ownerState: m,
        ...h,
        style: {
            width: f,
            height: s,
            ...c
        }
    })
});
function Xce(e={}) {
    const {autoHideDuration: t=null, disableWindowBlurListener: n=!1, onClose: r, open: i, resumeHideDuration: o} = e
      , a = uc();
    A.useEffect( () => {
        if (!i)
            return;
        function C(w) {
            w.defaultPrevented || w.key === "Escape" && r?.(w, "escapeKeyDown")
        }
        return document.addEventListener("keydown", C),
        () => {
            document.removeEventListener("keydown", C)
        }
    }
    , [i, r]);
    const s = ft( (C, w) => {
        r?.(C, w)
    }
    )
      , c = ft(C => {
        !r || C == null || a.start(C, () => {
            s(null, "timeout")
        }
        )
    }
    );
    A.useEffect( () => (i && c(t),
    a.clear), [i, t, c, a]);
    const u = C => {
        r?.(C, "clickaway")
    }
      , f = a.clear
      , h = A.useCallback( () => {
        t != null && c(o ?? t * .5)
    }
    , [t, o, c])
      , m = C => w => {
        const k = C.onBlur;
        k?.(w),
        h()
    }
      , y = C => w => {
        const k = C.onFocus;
        k?.(w),
        f()
    }
      , b = C => w => {
        const k = C.onMouseEnter;
        k?.(w),
        f()
    }
      , v = C => w => {
        const k = C.onMouseLeave;
        k?.(w),
        h()
    }
    ;
    return A.useEffect( () => {
        if (!n && i)
            return window.addEventListener("focus", h),
            window.addEventListener("blur", f),
            () => {
                window.removeEventListener("focus", h),
                window.removeEventListener("blur", f)
            }
    }
    , [n, i, h, f]),
    {
        getRootProps: (C={}) => {
            const w = {
                ...p0(e),
                ...p0(C)
            };
            return {
                role: "presentation",
                ...C,
                ...w,
                onBlur: m(w),
                onFocus: y(w),
                onMouseEnter: b(w),
                onMouseLeave: v(w)
            }
        }
        ,
        onClickAway: u
    }
}
function Jce(e) {
    return rt("MuiSnackbarContent", e)
}
ot("MuiSnackbarContent", ["root", "message", "action"]);
const eue = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        action: ["action"],
        message: ["message"]
    }, Jce, t)
}
  , tue = ue(yn, {
    name: "MuiSnackbarContent",
    slot: "Root"
})(pt( ({theme: e}) => {
    const t = e.palette.mode === "light" ? .8 : .98;
    return {
        ...e.typography.body2,
        color: e.vars ? e.vars.palette.SnackbarContent.color : e.palette.getContrastText(L2(e.palette.background.default, t)),
        backgroundColor: e.vars ? e.vars.palette.SnackbarContent.bg : L2(e.palette.background.default, t),
        display: "flex",
        alignItems: "center",
        flexWrap: "wrap",
        padding: "6px 16px",
        flexGrow: 1,
        [e.breakpoints.up("sm")]: {
            flexGrow: "initial",
            minWidth: 288
        }
    }
}
))
  , nue = ue("div", {
    name: "MuiSnackbarContent",
    slot: "Message"
})({
    padding: "8px 0"
})
  , rue = ue("div", {
    name: "MuiSnackbarContent",
    slot: "Action"
})({
    display: "flex",
    alignItems: "center",
    marginLeft: "auto",
    paddingLeft: 16,
    marginRight: -8
})
  , iue = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiSnackbarContent"
    })
      , {action: i, className: o, message: a, role: s="alert", ...c} = r
      , u = r
      , f = eue(u);
    return g.jsxs(tue, {
        role: s,
        elevation: 6,
        className: Ne(f.root, o),
        ownerState: u,
        ref: n,
        ...c,
        children: [g.jsx(nue, {
            className: f.message,
            ownerState: u,
            children: a
        }), i ? g.jsx(rue, {
            className: f.action,
            ownerState: u,
            children: i
        }) : null]
    })
});
function oue(e) {
    return rt("MuiSnackbar", e)
}
ot("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const aue = e => {
    const {classes: t, anchorOrigin: n} = e
      , r = {
        root: ["root", `anchorOrigin${Te(n.vertical)}${Te(n.horizontal)}`]
    };
    return tt(r, oue, t)
}
  , sue = ue("div", {
    name: "MuiSnackbar",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[`anchorOrigin${Te(n.anchorOrigin.vertical)}${Te(n.anchorOrigin.horizontal)}`]]
    }
})(pt( ({theme: e}) => ({
    zIndex: (e.vars || e).zIndex.snackbar,
    position: "fixed",
    display: "flex",
    left: 8,
    right: 8,
    justifyContent: "center",
    alignItems: "center",
    variants: [{
        props: ({ownerState: t}) => t.anchorOrigin.vertical === "top",
        style: {
            top: 8,
            [e.breakpoints.up("sm")]: {
                top: 24
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.vertical !== "top",
        style: {
            bottom: 8,
            [e.breakpoints.up("sm")]: {
                bottom: 24
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.horizontal === "left",
        style: {
            justifyContent: "flex-start",
            [e.breakpoints.up("sm")]: {
                left: 24,
                right: "auto"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.horizontal === "right",
        style: {
            justifyContent: "flex-end",
            [e.breakpoints.up("sm")]: {
                right: 24,
                left: "auto"
            }
        }
    }, {
        props: ({ownerState: t}) => t.anchorOrigin.horizontal === "center",
        style: {
            [e.breakpoints.up("sm")]: {
                left: "50%",
                right: "auto",
                transform: "translateX(-50%)"
            }
        }
    }]
})))
  , hh = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiSnackbar"
    })
      , i = ko()
      , o = {
        enter: i.transitions.duration.enteringScreen,
        exit: i.transitions.duration.leavingScreen
    }
      , {action: a, anchorOrigin: {vertical: s, horizontal: c}={
        vertical: "bottom",
        horizontal: "left"
    }, autoHideDuration: u=null, children: f, className: h, ClickAwayListenerProps: m, ContentProps: y, disableWindowBlurListener: b=!1, message: v, onBlur: S, onClose: C, onFocus: w, onMouseEnter: k, onMouseLeave: T, open: E, resumeHideDuration: P, slots: D={}, slotProps: $={}, TransitionComponent: z, transitionDuration: O=o, TransitionProps: {onEnter: I, onExited: M, ...B}={}, ...L} = r
      , F = {
        ...r,
        anchorOrigin: {
            vertical: s,
            horizontal: c
        },
        autoHideDuration: u,
        disableWindowBlurListener: b,
        TransitionComponent: z,
        transitionDuration: O
    }
      , j = aue(F)
      , {getRootProps: N, onClickAway: H} = Xce({
        ...F
    })
      , [Z,q] = A.useState(!0)
      , V = se => {
        q(!0),
        M && M(se)
    }
      , Y = (se, de) => {
        q(!1),
        I && I(se, de)
    }
      , W = {
        slots: {
            transition: z,
            ...D
        },
        slotProps: {
            content: y,
            clickAwayListener: m,
            transition: B,
            ...$
        }
    }
      , [te,K] = mt("root", {
        ref: n,
        className: [j.root, h],
        elementType: sue,
        getSlotProps: N,
        externalForwardedProps: {
            ...W,
            ...L
        },
        ownerState: F
    })
      , [ee,{ownerState: re, ...ie}] = mt("clickAwayListener", {
        elementType: Mae,
        externalForwardedProps: W,
        getSlotProps: se => ({
            onClickAway: (...de) => {
                const Se = de[0];
                se.onClickAway?.(...de),
                !Se?.defaultMuiPrevented && H(...de)
            }
        }),
        ownerState: F
    })
      , [J,oe] = mt("content", {
        elementType: iue,
        shouldForwardComponentProp: !0,
        externalForwardedProps: W,
        additionalProps: {
            message: v,
            action: a
        },
        ownerState: F
    })
      , [we,xe] = mt("transition", {
        elementType: Wf,
        externalForwardedProps: W,
        getSlotProps: se => ({
            onEnter: (...de) => {
                se.onEnter?.(...de),
                Y(...de)
            }
            ,
            onExited: (...de) => {
                se.onExited?.(...de),
                V(...de)
            }
        }),
        additionalProps: {
            appear: !0,
            in: E,
            timeout: O,
            direction: s === "top" ? "down" : "up"
        },
        ownerState: F
    });
    return !E && Z ? null : g.jsx(ee, {
        ...ie,
        ...D.clickAwayListener && {
            ownerState: re
        },
        children: g.jsx(te, {
            ...K,
            children: g.jsx(we, {
                ...xe,
                children: f || g.jsx(J, {
                    ...oe
                })
            })
        })
    })
});
function lue(e) {
    return rt("MuiTooltip", e)
}
const Rr = ot("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function cue(e) {
    return Math.round(e * 1e5) / 1e5
}
const uue = e => {
    const {classes: t, disableInteractive: n, arrow: r, touch: i, placement: o} = e
      , a = {
        popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
        tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${Te(o.split("-")[0])}`],
        arrow: ["arrow"]
    };
    return tt(a, lue, t)
}
  , due = ue($g, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.popper, !n.disableInteractive && t.popperInteractive, n.arrow && t.popperArrow, !n.open && t.popperClose]
    }
})(pt( ({theme: e}) => ({
    zIndex: (e.vars || e).zIndex.tooltip,
    pointerEvents: "none",
    variants: [{
        props: ({ownerState: t}) => !t.disableInteractive,
        style: {
            pointerEvents: "auto"
        }
    }, {
        props: ({open: t}) => !t,
        style: {
            pointerEvents: "none"
        }
    }, {
        props: ({ownerState: t}) => t.arrow,
        style: {
            [`&[data-popper-placement*="bottom"] .${Rr.arrow}`]: {
                top: 0,
                marginTop: "-0.71em",
                "&::before": {
                    transformOrigin: "0 100%"
                }
            },
            [`&[data-popper-placement*="top"] .${Rr.arrow}`]: {
                bottom: 0,
                marginBottom: "-0.71em",
                "&::before": {
                    transformOrigin: "100% 0"
                }
            },
            [`&[data-popper-placement*="right"] .${Rr.arrow}`]: {
                height: "1em",
                width: "0.71em",
                "&::before": {
                    transformOrigin: "100% 100%"
                }
            },
            [`&[data-popper-placement*="left"] .${Rr.arrow}`]: {
                height: "1em",
                width: "0.71em",
                "&::before": {
                    transformOrigin: "0 0"
                }
            }
        }
    }, {
        props: ({ownerState: t}) => t.arrow && !t.isRtl,
        style: {
            [`&[data-popper-placement*="right"] .${Rr.arrow}`]: {
                left: 0,
                marginLeft: "-0.71em"
            }
        }
    }, {
        props: ({ownerState: t}) => t.arrow && !!t.isRtl,
        style: {
            [`&[data-popper-placement*="right"] .${Rr.arrow}`]: {
                right: 0,
                marginRight: "-0.71em"
            }
        }
    }, {
        props: ({ownerState: t}) => t.arrow && !t.isRtl,
        style: {
            [`&[data-popper-placement*="left"] .${Rr.arrow}`]: {
                right: 0,
                marginRight: "-0.71em"
            }
        }
    }, {
        props: ({ownerState: t}) => t.arrow && !!t.isRtl,
        style: {
            [`&[data-popper-placement*="left"] .${Rr.arrow}`]: {
                left: 0,
                marginLeft: "-0.71em"
            }
        }
    }]
})))
  , fue = ue("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.tooltip, n.touch && t.touch, n.arrow && t.tooltipArrow, t[`tooltipPlacement${Te(n.placement.split("-")[0])}`]]
    }
})(pt( ({theme: e}) => ({
    backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : e.alpha(e.palette.grey[700], .92),
    borderRadius: (e.vars || e).shape.borderRadius,
    color: (e.vars || e).palette.common.white,
    fontFamily: e.typography.fontFamily,
    padding: "4px 8px",
    fontSize: e.typography.pxToRem(11),
    maxWidth: 300,
    margin: 2,
    wordWrap: "break-word",
    fontWeight: e.typography.fontWeightMedium,
    [`.${Rr.popper}[data-popper-placement*="left"] &`]: {
        transformOrigin: "right center"
    },
    [`.${Rr.popper}[data-popper-placement*="right"] &`]: {
        transformOrigin: "left center"
    },
    [`.${Rr.popper}[data-popper-placement*="top"] &`]: {
        transformOrigin: "center bottom",
        marginBottom: "14px"
    },
    [`.${Rr.popper}[data-popper-placement*="bottom"] &`]: {
        transformOrigin: "center top",
        marginTop: "14px"
    },
    variants: [{
        props: ({ownerState: t}) => t.arrow,
        style: {
            position: "relative",
            margin: 0
        }
    }, {
        props: ({ownerState: t}) => t.touch,
        style: {
            padding: "8px 16px",
            fontSize: e.typography.pxToRem(14),
            lineHeight: `${cue(16 / 14)}em`,
            fontWeight: e.typography.fontWeightRegular
        }
    }, {
        props: ({ownerState: t}) => !t.isRtl,
        style: {
            [`.${Rr.popper}[data-popper-placement*="left"] &`]: {
                marginRight: "14px"
            },
            [`.${Rr.popper}[data-popper-placement*="right"] &`]: {
                marginLeft: "14px"
            }
        }
    }, {
        props: ({ownerState: t}) => !t.isRtl && t.touch,
        style: {
            [`.${Rr.popper}[data-popper-placement*="left"] &`]: {
                marginRight: "24px"
            },
            [`.${Rr.popper}[data-popper-placement*="right"] &`]: {
                marginLeft: "24px"
            }
        }
    }, {
        props: ({ownerState: t}) => !!t.isRtl,
        style: {
            [`.${Rr.popper}[data-popper-placement*="left"] &`]: {
                marginLeft: "14px"
            },
            [`.${Rr.popper}[data-popper-placement*="right"] &`]: {
                marginRight: "14px"
            }
        }
    }, {
        props: ({ownerState: t}) => !!t.isRtl && t.touch,
        style: {
            [`.${Rr.popper}[data-popper-placement*="left"] &`]: {
                marginLeft: "24px"
            },
            [`.${Rr.popper}[data-popper-placement*="right"] &`]: {
                marginRight: "24px"
            }
        }
    }, {
        props: ({ownerState: t}) => t.touch,
        style: {
            [`.${Rr.popper}[data-popper-placement*="top"] &`]: {
                marginBottom: "24px"
            }
        }
    }, {
        props: ({ownerState: t}) => t.touch,
        style: {
            [`.${Rr.popper}[data-popper-placement*="bottom"] &`]: {
                marginTop: "24px"
            }
        }
    }]
})))
  , hue = ue("span", {
    name: "MuiTooltip",
    slot: "Arrow"
})(pt( ({theme: e}) => ({
    overflow: "hidden",
    position: "absolute",
    width: "1em",
    height: "0.71em",
    boxSizing: "border-box",
    color: e.vars ? e.vars.palette.Tooltip.bg : e.alpha(e.palette.grey[700], .9),
    "&::before": {
        content: '""',
        margin: "auto",
        display: "block",
        width: "100%",
        height: "100%",
        backgroundColor: "currentColor",
        transform: "rotate(45deg)"
    }
})));
let jb = !1;
const lL = new Gv;
let Cp = {
    x: 0,
    y: 0
};
function Bb(e, t) {
    return (n, ...r) => {
        t && t(n, ...r),
        e(n, ...r)
    }
}
const pc = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTooltip"
    })
      , {arrow: i=!1, children: o, classes: a, components: s={}, componentsProps: c={}, describeChild: u=!1, disableFocusListener: f=!1, disableHoverListener: h=!1, disableInteractive: m=!1, disableTouchListener: y=!1, enterDelay: b=100, enterNextDelay: v=0, enterTouchDelay: S=700, followCursor: C=!1, id: w, leaveDelay: k=0, leaveTouchDelay: T=1500, onClose: E, onOpen: P, open: D, placement: $="bottom", PopperComponent: z, PopperProps: O={}, slotProps: I={}, slots: M={}, title: B, TransitionComponent: L, TransitionProps: F, ...j} = r
      , N = A.isValidElement(o) ? o : g.jsx("span", {
        children: o
    })
      , H = ko()
      , Z = Si()
      , [q,V] = A.useState()
      , [Y,W] = A.useState(null)
      , te = A.useRef(!1)
      , K = m || C
      , ee = uc()
      , re = uc()
      , ie = uc()
      , J = uc()
      , [oe,we] = go({
        controlled: D,
        default: !1,
        name: "Tooltip",
        state: "open"
    });
    let xe = oe;
    const se = Gi(w)
      , de = A.useRef()
      , Se = ft( () => {
        de.current !== void 0 && (document.body.style.WebkitUserSelect = de.current,
        de.current = void 0),
        J.clear()
    }
    );
    A.useEffect( () => Se, [Se]);
    const Ce = At => {
        lL.clear(),
        jb = !0,
        we(!0),
        P && !xe && P(At)
    }
      , Ye = ft(At => {
        lL.start(800 + k, () => {
            jb = !1
        }
        ),
        we(!1),
        E && xe && E(At),
        ee.start(H.transitions.duration.shortest, () => {
            te.current = !1
        }
        )
    }
    )
      , ye = At => {
        te.current && At.type !== "touchstart" || (q && q.removeAttribute("title"),
        re.clear(),
        ie.clear(),
        b || jb && v ? re.start(jb ? v : b, () => {
            Ce(At)
        }
        ) : Ce(At))
    }
      , Ke = At => {
        re.clear(),
        ie.start(k, () => {
            Ye(At)
        }
        )
    }
      , [,X] = A.useState(!1)
      , ce = At => {
        m0(At.target) || (X(!1),
        Ke(At))
    }
      , fe = At => {
        q || V(At.currentTarget),
        m0(At.target) && (X(!0),
        ye(At))
    }
      , Xe = At => {
        te.current = !0;
        const nr = N.props;
        nr.onTouchStart && nr.onTouchStart(At)
    }
      , Oe = At => {
        Xe(At),
        ie.clear(),
        ee.clear(),
        Se(),
        de.current = document.body.style.WebkitUserSelect,
        document.body.style.WebkitUserSelect = "none",
        J.start(S, () => {
            document.body.style.WebkitUserSelect = de.current,
            ye(At)
        }
        )
    }
      , Re = At => {
        N.props.onTouchEnd && N.props.onTouchEnd(At),
        Se(),
        ie.start(T, () => {
            Ye(At)
        }
        )
    }
    ;
    A.useEffect( () => {
        if (!xe)
            return;
        function At(nr) {
            nr.key === "Escape" && Ye(nr)
        }
        return document.addEventListener("keydown", At),
        () => {
            document.removeEventListener("keydown", At)
        }
    }
    , [Ye, xe]);
    const le = Cn(Rc(N), V, n);
    !B && B !== 0 && (xe = !1);
    const ke = A.useRef()
      , He = At => {
        const nr = N.props;
        nr.onMouseMove && nr.onMouseMove(At),
        Cp = {
            x: At.clientX,
            y: At.clientY
        },
        ke.current && ke.current.update()
    }
      , st = {}
      , lt = typeof B == "string";
    u ? (st.title = !xe && lt && !h ? B : null,
    st["aria-describedby"] = xe ? se : null) : (st["aria-label"] = lt ? B : null,
    st["aria-labelledby"] = xe && !lt ? se : null);
    const et = {
        ...st,
        ...j,
        ...N.props,
        className: Ne(j.className, N.props.className),
        onTouchStart: Xe,
        ref: le,
        ...C ? {
            onMouseMove: He
        } : {}
    }
      , Ht = {};
    y || (et.onTouchStart = Oe,
    et.onTouchEnd = Re),
    h || (et.onMouseOver = Bb(ye, et.onMouseOver),
    et.onMouseLeave = Bb(Ke, et.onMouseLeave),
    K || (Ht.onMouseOver = ye,
    Ht.onMouseLeave = Ke)),
    f || (et.onFocus = Bb(fe, et.onFocus),
    et.onBlur = Bb(ce, et.onBlur),
    K || (Ht.onFocus = fe,
    Ht.onBlur = ce));
    const Ft = {
        ...r,
        isRtl: Z,
        arrow: i,
        disableInteractive: K,
        placement: $,
        PopperComponentProp: z,
        touch: te.current
    }
      , Pt = typeof I.popper == "function" ? I.popper(Ft) : I.popper
      , nt = A.useMemo( () => {
        let At = [{
            name: "arrow",
            enabled: !!Y,
            options: {
                element: Y,
                padding: 4
            }
        }];
        return O.popperOptions?.modifiers && (At = At.concat(O.popperOptions.modifiers)),
        Pt?.popperOptions?.modifiers && (At = At.concat(Pt.popperOptions.modifiers)),
        {
            ...O.popperOptions,
            ...Pt?.popperOptions,
            modifiers: At
        }
    }
    , [Y, O.popperOptions, Pt?.popperOptions])
      , ut = uue(Ft)
      , Lt = typeof I.transition == "function" ? I.transition(Ft) : I.transition
      , tn = {
        slots: {
            popper: s.Popper,
            transition: s.Transition ?? L,
            tooltip: s.Tooltip,
            arrow: s.Arrow,
            ...M
        },
        slotProps: {
            arrow: I.arrow ?? c.arrow,
            popper: {
                ...O,
                ...Pt ?? c.popper
            },
            tooltip: I.tooltip ?? c.tooltip,
            transition: {
                ...F,
                ...Lt ?? c.transition
            }
        }
    }
      , [Xt,Mn] = mt("popper", {
        elementType: due,
        externalForwardedProps: tn,
        ownerState: Ft,
        className: Ne(ut.popper, O?.className)
    })
      , [Pn,wn] = mt("transition", {
        elementType: Wf,
        externalForwardedProps: tn,
        ownerState: Ft
    })
      , [Kn,vr] = mt("tooltip", {
        elementType: fue,
        className: ut.tooltip,
        externalForwardedProps: tn,
        ownerState: Ft
    })
      , [mr,kn] = mt("arrow", {
        elementType: hue,
        className: ut.arrow,
        externalForwardedProps: tn,
        ownerState: Ft,
        ref: W
    });
    return g.jsxs(A.Fragment, {
        children: [A.cloneElement(N, et), g.jsx(Xt, {
            as: z ?? $g,
            placement: $,
            anchorEl: C ? {
                getBoundingClientRect: () => ({
                    top: Cp.y,
                    left: Cp.x,
                    right: Cp.x,
                    bottom: Cp.y,
                    width: 0,
                    height: 0
                })
            } : q,
            popperRef: ke,
            open: q ? xe : !1,
            id: se,
            transition: !0,
            ...Ht,
            ...Mn,
            popperOptions: nt,
            children: ({TransitionProps: At}) => g.jsx(Pn, {
                timeout: H.transitions.duration.shorter,
                ...At,
                ...wn,
                children: g.jsxs(Kn, {
                    ...vr,
                    children: [B, i ? g.jsx(mr, {
                        ...kn
                    }) : null]
                })
            })
        })]
    })
})
  , Gf = $te({
    createStyledComponent: ue("div", {
        name: "MuiStack",
        slot: "Root"
    }),
    useThemeProps: e => gt({
        props: e,
        name: "MuiStack"
    })
});
function pue(e) {
    return rt("MuiTab", e)
}
const ca = ot("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper", "icon"])
  , mue = e => {
    const {classes: t, textColor: n, fullWidth: r, wrapped: i, icon: o, label: a, selected: s, disabled: c} = e
      , u = {
        root: ["root", o && a && "labelIcon", `textColor${Te(n)}`, r && "fullWidth", i && "wrapped", s && "selected", c && "disabled"],
        icon: ["iconWrapper", "icon"]
    };
    return tt(u, pue, t)
}
  , gue = ue(Ka, {
    name: "MuiTab",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.label && n.icon && t.labelIcon, t[`textColor${Te(n.textColor)}`], n.fullWidth && t.fullWidth, n.wrapped && t.wrapped, {
            [`& .${ca.iconWrapper}`]: t.iconWrapper
        }, {
            [`& .${ca.icon}`]: t.icon
        }]
    }
})(pt( ({theme: e}) => ({
    ...e.typography.button,
    maxWidth: 360,
    minWidth: 90,
    position: "relative",
    minHeight: 48,
    flexShrink: 0,
    padding: "12px 16px",
    overflow: "hidden",
    whiteSpace: "normal",
    textAlign: "center",
    lineHeight: 1.25,
    variants: [{
        props: ({ownerState: t}) => t.label && (t.iconPosition === "top" || t.iconPosition === "bottom"),
        style: {
            flexDirection: "column"
        }
    }, {
        props: ({ownerState: t}) => t.label && t.iconPosition !== "top" && t.iconPosition !== "bottom",
        style: {
            flexDirection: "row"
        }
    }, {
        props: ({ownerState: t}) => t.icon && t.label,
        style: {
            minHeight: 72,
            paddingTop: 9,
            paddingBottom: 9
        }
    }, {
        props: ({ownerState: t, iconPosition: n}) => t.icon && t.label && n === "top",
        style: {
            [`& > .${ca.icon}`]: {
                marginBottom: 6
            }
        }
    }, {
        props: ({ownerState: t, iconPosition: n}) => t.icon && t.label && n === "bottom",
        style: {
            [`& > .${ca.icon}`]: {
                marginTop: 6
            }
        }
    }, {
        props: ({ownerState: t, iconPosition: n}) => t.icon && t.label && n === "start",
        style: {
            [`& > .${ca.icon}`]: {
                marginRight: e.spacing(1)
            }
        }
    }, {
        props: ({ownerState: t, iconPosition: n}) => t.icon && t.label && n === "end",
        style: {
            [`& > .${ca.icon}`]: {
                marginLeft: e.spacing(1)
            }
        }
    }, {
        props: {
            textColor: "inherit"
        },
        style: {
            color: "inherit",
            opacity: .6,
            [`&.${ca.selected}`]: {
                opacity: 1
            },
            [`&.${ca.disabled}`]: {
                opacity: (e.vars || e).palette.action.disabledOpacity
            }
        }
    }, {
        props: {
            textColor: "primary"
        },
        style: {
            color: (e.vars || e).palette.text.secondary,
            [`&.${ca.selected}`]: {
                color: (e.vars || e).palette.primary.main
            },
            [`&.${ca.disabled}`]: {
                color: (e.vars || e).palette.text.disabled
            }
        }
    }, {
        props: {
            textColor: "secondary"
        },
        style: {
            color: (e.vars || e).palette.text.secondary,
            [`&.${ca.selected}`]: {
                color: (e.vars || e).palette.secondary.main
            },
            [`&.${ca.disabled}`]: {
                color: (e.vars || e).palette.text.disabled
            }
        }
    }, {
        props: ({ownerState: t}) => t.fullWidth,
        style: {
            flexShrink: 1,
            flexGrow: 1,
            flexBasis: 0,
            maxWidth: "none"
        }
    }, {
        props: ({ownerState: t}) => t.wrapped,
        style: {
            fontSize: e.typography.pxToRem(12)
        }
    }]
})))
  , xm = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTab"
    })
      , {className: i, disabled: o=!1, disableFocusRipple: a=!1, fullWidth: s, icon: c, iconPosition: u="top", indicator: f, label: h, onChange: m, onClick: y, onFocus: b, selected: v, selectionFollowsFocus: S, textColor: C="inherit", value: w, wrapped: k=!1, ...T} = r
      , E = {
        ...r,
        disabled: o,
        disableFocusRipple: a,
        selected: v,
        icon: !!c,
        iconPosition: u,
        label: !!h,
        fullWidth: s,
        textColor: C,
        wrapped: k
    }
      , P = mue(E)
      , D = c && h && A.isValidElement(c) ? A.cloneElement(c, {
        className: Ne(P.icon, c.props.className)
    }) : c
      , $ = O => {
        !v && m && m(O, w),
        y && y(O)
    }
      , z = O => {
        S && !v && m && m(O, w),
        b && b(O)
    }
    ;
    return g.jsxs(gue, {
        focusRipple: !a,
        className: Ne(P.root, i),
        ref: n,
        role: "tab",
        "aria-selected": v,
        disabled: o,
        onClick: $,
        onFocus: z,
        ownerState: E,
        tabIndex: v ? 0 : -1,
        ...T,
        children: [u === "top" || u === "start" ? g.jsxs(A.Fragment, {
            children: [D, h]
        }) : g.jsxs(A.Fragment, {
            children: [h, D]
        }), f]
    })
})
  , l3 = A.createContext();
function yue(e) {
    return rt("MuiTable", e)
}
ot("MuiTable", ["root", "stickyHeader"]);
const bue = e => {
    const {classes: t, stickyHeader: n} = e;
    return tt({
        root: ["root", n && "stickyHeader"]
    }, yue, t)
}
  , xue = ue("table", {
    name: "MuiTable",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.stickyHeader && t.stickyHeader]
    }
})(pt( ({theme: e}) => ({
    display: "table",
    width: "100%",
    borderCollapse: "collapse",
    borderSpacing: 0,
    "& caption": {
        ...e.typography.body2,
        padding: e.spacing(2),
        color: (e.vars || e).palette.text.secondary,
        textAlign: "left",
        captionSide: "bottom"
    },
    variants: [{
        props: ({ownerState: t}) => t.stickyHeader,
        style: {
            borderCollapse: "separate"
        }
    }]
})))
  , cL = "table"
  , Ua = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTable"
    })
      , {className: i, component: o=cL, padding: a="normal", size: s="medium", stickyHeader: c=!1, ...u} = r
      , f = {
        ...r,
        component: o,
        padding: a,
        size: s,
        stickyHeader: c
    }
      , h = bue(f)
      , m = A.useMemo( () => ({
        padding: a,
        size: s,
        stickyHeader: c
    }), [a, s, c]);
    return g.jsx(l3.Provider, {
        value: m,
        children: g.jsx(xue, {
            as: o,
            role: o === cL ? null : "table",
            ref: n,
            className: Ne(h.root, i),
            ownerState: f,
            ...u
        })
    })
})
  , t1 = A.createContext();
function vue(e) {
    return rt("MuiTableBody", e)
}
ot("MuiTableBody", ["root"]);
const Sue = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, vue, t)
}
  , Cue = ue("tbody", {
    name: "MuiTableBody",
    slot: "Root"
})({
    display: "table-row-group"
})
  , wue = {
    variant: "body"
}
  , uL = "tbody"
  , Va = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTableBody"
    })
      , {className: i, component: o=uL, ...a} = r
      , s = {
        ...r,
        component: o
    }
      , c = Sue(s);
    return g.jsx(t1.Provider, {
        value: wue,
        children: g.jsx(Cue, {
            className: Ne(c.root, i),
            as: o,
            ref: n,
            role: o === uL ? null : "rowgroup",
            ownerState: s,
            ...a
        })
    })
});
function kue(e) {
    return rt("MuiTableCell", e)
}
const Tue = ot("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"])
  , _ue = e => {
    const {classes: t, variant: n, align: r, padding: i, size: o, stickyHeader: a} = e
      , s = {
        root: ["root", n, a && "stickyHeader", r !== "inherit" && `align${Te(r)}`, i !== "normal" && `padding${Te(i)}`, `size${Te(o)}`]
    };
    return tt(s, kue, t)
}
  , Eue = ue("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, t[n.variant], t[`size${Te(n.size)}`], n.padding !== "normal" && t[`padding${Te(n.padding)}`], n.align !== "inherit" && t[`align${Te(n.align)}`], n.stickyHeader && t.stickyHeader]
    }
})(pt( ({theme: e}) => ({
    ...e.typography.body2,
    display: "table-cell",
    verticalAlign: "inherit",
    borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? e.lighten(e.alpha(e.palette.divider, 1), .88) : e.darken(e.alpha(e.palette.divider, 1), .68)}`,
    textAlign: "left",
    padding: 16,
    variants: [{
        props: {
            variant: "head"
        },
        style: {
            color: (e.vars || e).palette.text.primary,
            lineHeight: e.typography.pxToRem(24),
            fontWeight: e.typography.fontWeightMedium
        }
    }, {
        props: {
            variant: "body"
        },
        style: {
            color: (e.vars || e).palette.text.primary
        }
    }, {
        props: {
            variant: "footer"
        },
        style: {
            color: (e.vars || e).palette.text.secondary,
            lineHeight: e.typography.pxToRem(21),
            fontSize: e.typography.pxToRem(12)
        }
    }, {
        props: {
            size: "small"
        },
        style: {
            padding: "6px 16px",
            [`&.${Tue.paddingCheckbox}`]: {
                width: 24,
                padding: "0 12px 0 16px",
                "& > *": {
                    padding: 0
                }
            }
        }
    }, {
        props: {
            padding: "checkbox"
        },
        style: {
            width: 48,
            padding: "0 0 0 4px"
        }
    }, {
        props: {
            padding: "none"
        },
        style: {
            padding: 0
        }
    }, {
        props: {
            align: "left"
        },
        style: {
            textAlign: "left"
        }
    }, {
        props: {
            align: "center"
        },
        style: {
            textAlign: "center"
        }
    }, {
        props: {
            align: "right"
        },
        style: {
            textAlign: "right",
            flexDirection: "row-reverse"
        }
    }, {
        props: {
            align: "justify"
        },
        style: {
            textAlign: "justify"
        }
    }, {
        props: ({ownerState: t}) => t.stickyHeader,
        style: {
            position: "sticky",
            top: 0,
            zIndex: 2,
            backgroundColor: (e.vars || e).palette.background.default
        }
    }]
})))
  , Me = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTableCell"
    })
      , {align: i="inherit", className: o, component: a, padding: s, scope: c, size: u, sortDirection: f, variant: h, ...m} = r
      , y = A.useContext(l3)
      , b = A.useContext(t1)
      , v = b && b.variant === "head";
    let S;
    a ? S = a : S = v ? "th" : "td";
    let C = c;
    S === "td" ? C = void 0 : !C && v && (C = "col");
    const w = h || b && b.variant
      , k = {
        ...r,
        align: i,
        component: S,
        padding: s || (y && y.padding ? y.padding : "normal"),
        size: u || (y && y.size ? y.size : "medium"),
        sortDirection: f,
        stickyHeader: w === "head" && y && y.stickyHeader,
        variant: w
    }
      , T = _ue(k);
    let E = null;
    return f && (E = f === "asc" ? "ascending" : "descending"),
    g.jsx(Eue, {
        as: S,
        ref: n,
        className: Ne(T.root, o),
        "aria-sort": E,
        scope: C,
        ownerState: k,
        ...m
    })
});
function Aue(e) {
    return rt("MuiTableContainer", e)
}
ot("MuiTableContainer", ["root"]);
const Mue = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, Aue, t)
}
  , Pue = ue("div", {
    name: "MuiTableContainer",
    slot: "Root"
})({
    width: "100%",
    overflowX: "auto"
})
  , Ha = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTableContainer"
    })
      , {className: i, component: o="div", ...a} = r
      , s = {
        ...r,
        component: o
    }
      , c = Mue(s);
    return g.jsx(Pue, {
        ref: n,
        as: o,
        className: Ne(c.root, i),
        ownerState: s,
        ...a
    })
});
function Rue(e) {
    return rt("MuiTableHead", e)
}
ot("MuiTableHead", ["root"]);
const Due = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, Rue, t)
}
  , Oue = ue("thead", {
    name: "MuiTableHead",
    slot: "Root"
})({
    display: "table-header-group"
})
  , Iue = {
    variant: "head"
}
  , dL = "thead"
  , qa = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTableHead"
    })
      , {className: i, component: o=dL, ...a} = r
      , s = {
        ...r,
        component: o
    }
      , c = Due(s);
    return g.jsx(t1.Provider, {
        value: Iue,
        children: g.jsx(Oue, {
            as: o,
            className: Ne(c.root, i),
            ref: n,
            role: o === dL ? null : "rowgroup",
            ownerState: s,
            ...a
        })
    })
});
function $ue(e) {
    return rt("MuiToolbar", e)
}
ot("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const Lue = e => {
    const {classes: t, disableGutters: n, variant: r} = e;
    return tt({
        root: ["root", !n && "gutters", r]
    }, $ue, t)
}
  , jue = ue("div", {
    name: "MuiToolbar",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, !n.disableGutters && t.gutters, t[n.variant]]
    }
})(pt( ({theme: e}) => ({
    position: "relative",
    display: "flex",
    alignItems: "center",
    variants: [{
        props: ({ownerState: t}) => !t.disableGutters,
        style: {
            paddingLeft: e.spacing(2),
            paddingRight: e.spacing(2),
            [e.breakpoints.up("sm")]: {
                paddingLeft: e.spacing(3),
                paddingRight: e.spacing(3)
            }
        }
    }, {
        props: {
            variant: "dense"
        },
        style: {
            minHeight: 48
        }
    }, {
        props: {
            variant: "regular"
        },
        style: e.mixins.toolbar
    }]
})))
  , YE = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiToolbar"
    })
      , {className: i, component: o="div", disableGutters: a=!1, variant: s="regular", ...c} = r
      , u = {
        ...r,
        component: o,
        disableGutters: a,
        variant: s
    }
      , f = Lue(u);
    return g.jsx(jue, {
        as: o,
        className: Ne(f.root, i),
        ref: n,
        ownerState: u,
        ...c
    })
})
  , c3 = _t(g.jsx("path", {
    d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}))
  , u3 = _t(g.jsx("path", {
    d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}));
function Bue(e) {
    return rt("MuiTablePaginationActions", e)
}
ot("MuiTablePaginationActions", ["root"]);
const zue = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, Bue, t)
}
  , Fue = ue("div", {
    name: "MuiTablePaginationActions",
    slot: "Root"
})({})
  , Nue = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTablePaginationActions"
    })
      , {backIconButtonProps: i, className: o, count: a, disabled: s=!1, getItemAriaLabel: c, nextIconButtonProps: u, onPageChange: f, page: h, rowsPerPage: m, showFirstButton: y, showLastButton: b, slots: v={}, slotProps: S={}, ...C} = r
      , w = Si()
      , T = zue(r)
      , E = K => {
        f(K, 0)
    }
      , P = K => {
        f(K, h - 1)
    }
      , D = K => {
        f(K, h + 1)
    }
      , $ = K => {
        f(K, Math.max(0, Math.ceil(a / m) - 1))
    }
      , z = v.firstButton ?? In
      , O = v.lastButton ?? In
      , I = v.nextButton ?? In
      , M = v.previousButton ?? In
      , B = v.firstButtonIcon ?? vce
      , L = v.lastButtonIcon ?? Sce
      , F = v.nextButtonIcon ?? u3
      , j = v.previousButtonIcon ?? c3
      , N = w ? O : z
      , H = w ? I : M
      , Z = w ? M : I
      , q = w ? z : O
      , V = w ? S.lastButton : S.firstButton
      , Y = w ? S.nextButton : S.previousButton
      , W = w ? S.previousButton : S.nextButton
      , te = w ? S.firstButton : S.lastButton;
    return g.jsxs(Fue, {
        ref: n,
        className: Ne(T.root, o),
        ...C,
        children: [y && g.jsx(N, {
            onClick: E,
            disabled: s || h === 0,
            "aria-label": c("first", h),
            title: c("first", h),
            ...V,
            children: w ? g.jsx(L, {
                ...S.lastButtonIcon
            }) : g.jsx(B, {
                ...S.firstButtonIcon
            })
        }), g.jsx(H, {
            onClick: P,
            disabled: s || h === 0,
            color: "inherit",
            "aria-label": c("previous", h),
            title: c("previous", h),
            ...Y ?? i,
            children: w ? g.jsx(F, {
                ...S.nextButtonIcon
            }) : g.jsx(j, {
                ...S.previousButtonIcon
            })
        }), g.jsx(Z, {
            onClick: D,
            disabled: s || (a !== -1 ? h >= Math.ceil(a / m) - 1 : !1),
            color: "inherit",
            "aria-label": c("next", h),
            title: c("next", h),
            ...W ?? u,
            children: w ? g.jsx(j, {
                ...S.previousButtonIcon
            }) : g.jsx(F, {
                ...S.nextButtonIcon
            })
        }), b && g.jsx(q, {
            onClick: $,
            disabled: s || h >= Math.ceil(a / m) - 1,
            "aria-label": c("last", h),
            title: c("last", h),
            ...te,
            children: w ? g.jsx(B, {
                ...S.firstButtonIcon
            }) : g.jsx(L, {
                ...S.lastButtonIcon
            })
        })]
    })
});
function Uue(e) {
    return rt("MuiTablePagination", e)
}
const vm = ot("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
var fL;
const Vue = ue(Me, {
    name: "MuiTablePagination",
    slot: "Root"
})(pt( ({theme: e}) => ({
    overflow: "auto",
    color: (e.vars || e).palette.text.primary,
    fontSize: e.typography.pxToRem(14),
    "&:last-child": {
        padding: 0
    }
})))
  , Hue = ue(YE, {
    name: "MuiTablePagination",
    slot: "Toolbar",
    overridesResolver: (e, t) => ({
        [`& .${vm.actions}`]: t.actions,
        ...t.toolbar
    })
})(pt( ({theme: e}) => ({
    minHeight: 52,
    paddingRight: 2,
    [`${e.breakpoints.up("xs")} and (orientation: landscape)`]: {
        minHeight: 52
    },
    [e.breakpoints.up("sm")]: {
        minHeight: 52,
        paddingRight: 2
    },
    [`& .${vm.actions}`]: {
        flexShrink: 0,
        marginLeft: 20
    }
})))
  , que = ue("div", {
    name: "MuiTablePagination",
    slot: "Spacer"
})({
    flex: "1 1 100%"
})
  , Wue = ue("p", {
    name: "MuiTablePagination",
    slot: "SelectLabel"
})(pt( ({theme: e}) => ({
    ...e.typography.body2,
    flexShrink: 0
})))
  , Gue = ue(Gm, {
    name: "MuiTablePagination",
    slot: "Select",
    overridesResolver: (e, t) => ({
        [`& .${vm.selectIcon}`]: t.selectIcon,
        [`& .${vm.select}`]: t.select,
        ...t.input,
        ...t.selectRoot
    })
})({
    color: "inherit",
    fontSize: "inherit",
    flexShrink: 0,
    marginRight: 32,
    marginLeft: 8,
    [`& .${vm.select}`]: {
        paddingLeft: 8,
        paddingRight: 24,
        textAlign: "right",
        textAlignLast: "right"
    }
})
  , Yue = ue(Yr, {
    name: "MuiTablePagination",
    slot: "MenuItem"
})({})
  , Zue = ue("p", {
    name: "MuiTablePagination",
    slot: "DisplayedRows"
})(pt( ({theme: e}) => ({
    ...e.typography.body2,
    flexShrink: 0
})));
function Que({from: e, to: t, count: n}) {
    return `${e}${t} of ${n !== -1 ? n : `more than ${t}`}`
}
function Kue(e) {
    return `Go to ${e} page`
}
const Xue = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        toolbar: ["toolbar"],
        spacer: ["spacer"],
        selectLabel: ["selectLabel"],
        select: ["select"],
        input: ["input"],
        selectIcon: ["selectIcon"],
        menuItem: ["menuItem"],
        displayedRows: ["displayedRows"],
        actions: ["actions"]
    }, Uue, t)
}
  , Bg = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTablePagination"
    })
      , {ActionsComponent: i=Nue, backIconButtonProps: o, colSpan: a, component: s=Me, count: c, disabled: u=!1, getItemAriaLabel: f=Kue, labelDisplayedRows: h=Que, labelRowsPerPage: m="Rows per page:", nextIconButtonProps: y, onPageChange: b, onRowsPerPageChange: v, page: S, rowsPerPage: C, rowsPerPageOptions: w=[10, 25, 50, 100], SelectProps: k={}, showFirstButton: T=!1, showLastButton: E=!1, slotProps: P={}, slots: D={}, ...$} = r
      , z = r
      , O = Xue(z)
      , I = P?.select ?? k
      , M = I.native ? "option" : Yue;
    let B;
    (s === Me || s === "td") && (B = a || 1e3);
    const L = Gi(I.id)
      , F = Gi(I.labelId)
      , j = () => c === -1 ? (S + 1) * C : C === -1 ? c : Math.min(c, (S + 1) * C)
      , N = {
        slots: D,
        slotProps: P
    }
      , [H,Z] = mt("root", {
        ref: n,
        className: O.root,
        elementType: Vue,
        externalForwardedProps: {
            ...N,
            component: s,
            ...$
        },
        ownerState: z,
        additionalProps: {
            colSpan: B
        }
    })
      , [q,V] = mt("toolbar", {
        className: O.toolbar,
        elementType: Hue,
        externalForwardedProps: N,
        ownerState: z
    })
      , [Y,W] = mt("spacer", {
        className: O.spacer,
        elementType: que,
        externalForwardedProps: N,
        ownerState: z
    })
      , [te,K] = mt("selectLabel", {
        className: O.selectLabel,
        elementType: Wue,
        externalForwardedProps: N,
        ownerState: z,
        additionalProps: {
            id: F
        }
    })
      , [ee,re] = mt("select", {
        className: O.select,
        elementType: Gue,
        externalForwardedProps: N,
        ownerState: z
    })
      , [ie,J] = mt("menuItem", {
        className: O.menuItem,
        elementType: M,
        externalForwardedProps: N,
        ownerState: z
    })
      , [oe,we] = mt("displayedRows", {
        className: O.displayedRows,
        elementType: Zue,
        externalForwardedProps: N,
        ownerState: z
    });
    return g.jsx(H, {
        ...Z,
        children: g.jsxs(q, {
            ...V,
            children: [g.jsx(Y, {
                ...W
            }), w.length > 1 && g.jsx(te, {
                ...K,
                children: m
            }), w.length > 1 && g.jsx(ee, {
                variant: "standard",
                ...!I.variant && {
                    input: fL || (fL = g.jsx(Lg, {}))
                },
                value: C,
                onChange: v,
                id: L,
                labelId: F,
                ...I,
                classes: {
                    ...I.classes,
                    root: Ne(O.input, O.selectRoot, (I.classes || {}).root),
                    select: Ne(O.select, (I.classes || {}).select),
                    icon: Ne(O.selectIcon, (I.classes || {}).icon)
                },
                disabled: u,
                ...re,
                children: w.map(xe => A.createElement(ie, {
                    ...J,
                    key: xe.label ? xe.label : xe,
                    value: xe.value ? xe.value : xe
                }, xe.label ? xe.label : xe))
            }), g.jsx(oe, {
                ...we,
                children: h({
                    from: c === 0 ? 0 : S * C + 1,
                    to: j(),
                    count: c === -1 ? -1 : c,
                    page: S
                })
            }), g.jsx(i, {
                className: O.actions,
                backIconButtonProps: o,
                count: c,
                nextIconButtonProps: y,
                onPageChange: b,
                page: S,
                rowsPerPage: C,
                showFirstButton: T,
                showLastButton: E,
                slotProps: P.actions,
                slots: D.actions,
                getItemAriaLabel: f,
                disabled: u
            })]
        })
    })
});
function Jue(e) {
    return rt("MuiTableRow", e)
}
const hL = ot("MuiTableRow", ["root", "selected", "hover", "head", "footer"])
  , ede = e => {
    const {classes: t, selected: n, hover: r, head: i, footer: o} = e;
    return tt({
        root: ["root", n && "selected", r && "hover", i && "head", o && "footer"]
    }, Jue, t)
}
  , tde = ue("tr", {
    name: "MuiTableRow",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.head && t.head, n.footer && t.footer]
    }
})(pt( ({theme: e}) => ({
    color: "inherit",
    display: "table-row",
    verticalAlign: "middle",
    outline: 0,
    [`&.${hL.hover}:hover`]: {
        backgroundColor: (e.vars || e).palette.action.hover
    },
    [`&.${hL.selected}`]: {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
        "&:hover": {
            backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`)
        }
    }
})))
  , pL = "tr"
  , gn = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTableRow"
    })
      , {className: i, component: o=pL, hover: a=!1, selected: s=!1, ...c} = r
      , u = A.useContext(t1)
      , f = {
        ...r,
        component: o,
        hover: a,
        selected: s,
        head: u && u.variant === "head",
        footer: u && u.variant === "footer"
    }
      , h = ede(f);
    return g.jsx(tde, {
        as: o,
        ref: n,
        className: Ne(h.root, i),
        role: o === pL ? null : "row",
        ownerState: f,
        ...c
    })
})
  , nde = _t(g.jsx("path", {
    d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}));
function rde(e) {
    return rt("MuiTableSortLabel", e)
}
const Xw = ot("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"])
  , ide = e => {
    const {classes: t, direction: n, active: r} = e
      , i = {
        root: ["root", r && "active", `direction${Te(n)}`],
        icon: ["icon", `iconDirection${Te(n)}`]
    };
    return tt(i, rde, t)
}
  , ode = ue(Ka, {
    name: "MuiTableSortLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.active && t.active]
    }
})(pt( ({theme: e}) => ({
    cursor: "pointer",
    display: "inline-flex",
    justifyContent: "flex-start",
    flexDirection: "inherit",
    alignItems: "center",
    "&:focus": {
        color: (e.vars || e).palette.text.secondary
    },
    "&:hover": {
        color: (e.vars || e).palette.text.secondary,
        [`& .${Xw.icon}`]: {
            opacity: .5
        }
    },
    [`&.${Xw.active}`]: {
        color: (e.vars || e).palette.text.primary,
        [`& .${Xw.icon}`]: {
            opacity: 1,
            color: (e.vars || e).palette.text.secondary
        }
    }
})))
  , ade = ue("span", {
    name: "MuiTableSortLabel",
    slot: "Icon",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.icon, t[`iconDirection${Te(n.direction)}`]]
    }
})(pt( ({theme: e}) => ({
    fontSize: 18,
    marginRight: 4,
    marginLeft: 4,
    opacity: 0,
    transition: e.transitions.create(["opacity", "transform"], {
        duration: e.transitions.duration.shorter
    }),
    userSelect: "none",
    variants: [{
        props: {
            direction: "desc"
        },
        style: {
            transform: "rotate(0deg)"
        }
    }, {
        props: {
            direction: "asc"
        },
        style: {
            transform: "rotate(180deg)"
        }
    }]
})))
  , Fi = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTableSortLabel"
    })
      , {active: i=!1, children: o, className: a, direction: s="asc", hideSortIcon: c=!1, IconComponent: u=nde, slots: f={}, slotProps: h={}, ...m} = r
      , y = {
        ...r,
        active: i,
        direction: s,
        hideSortIcon: c,
        IconComponent: u
    }
      , b = ide(y)
      , v = {
        slots: f,
        slotProps: h
    }
      , [S,C] = mt("root", {
        elementType: ode,
        externalForwardedProps: v,
        ownerState: y,
        className: Ne(b.root, a),
        ref: n
    })
      , [w,k] = mt("icon", {
        elementType: ade,
        externalForwardedProps: v,
        ownerState: y,
        className: b.icon
    });
    return g.jsxs(S, {
        disableRipple: !0,
        component: "span",
        ...C,
        ...m,
        children: [o, c && !i ? null : g.jsx(w, {
            as: u,
            ...k
        })]
    })
});
function sde(e) {
    return (1 + Math.sin(Math.PI * e - Math.PI / 2)) / 2
}
function lde(e, t, n, r={}, i= () => {}
) {
    const {ease: o=sde, duration: a=300} = r;
    let s = null;
    const c = t[e];
    let u = !1;
    const f = () => {
        u = !0
    }
      , h = m => {
        if (u) {
            i(new Error("Animation cancelled"));
            return
        }
        s === null && (s = m);
        const y = Math.min(1, (m - s) / a);
        if (t[e] = o(y) * (n - c) + c,
        y >= 1) {
            requestAnimationFrame( () => {
                i(null)
            }
            );
            return
        }
        requestAnimationFrame(h)
    }
    ;
    return c === n ? (i(new Error("Element already at target position")),
    f) : (requestAnimationFrame(h),
    f)
}
const cde = {
    width: 99,
    height: 99,
    position: "absolute",
    top: -9999,
    overflow: "scroll"
};
function ude(e) {
    const {onChange: t, ...n} = e
      , r = A.useRef()
      , i = A.useRef(null)
      , o = () => {
        r.current = i.current.offsetHeight - i.current.clientHeight
    }
    ;
    return Cr( () => {
        const a = Rg( () => {
            const c = r.current;
            o(),
            c !== r.current && t(r.current)
        }
        )
          , s = Zo(i.current);
        return s.addEventListener("resize", a),
        () => {
            a.clear(),
            s.removeEventListener("resize", a)
        }
    }
    , [t]),
    A.useEffect( () => {
        o(),
        t(r.current)
    }
    , [t]),
    g.jsx("div", {
        style: cde,
        ...n,
        ref: i
    })
}
function dde(e) {
    return rt("MuiTabScrollButton", e)
}
const fde = ot("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"])
  , hde = e => {
    const {classes: t, orientation: n, disabled: r} = e;
    return tt({
        root: ["root", n, r && "disabled"]
    }, dde, t)
}
  , pde = ue(Ka, {
    name: "MuiTabScrollButton",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.root, n.orientation && t[n.orientation]]
    }
})({
    width: 40,
    flexShrink: 0,
    opacity: .8,
    [`&.${fde.disabled}`]: {
        opacity: 0
    },
    variants: [{
        props: {
            orientation: "vertical"
        },
        style: {
            width: "100%",
            height: 40,
            "& svg": {
                transform: "var(--TabScrollButton-svgRotate)"
            }
        }
    }]
})
  , mde = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTabScrollButton"
    })
      , {className: i, slots: o={}, slotProps: a={}, direction: s, orientation: c, disabled: u, ...f} = r
      , h = Si()
      , m = {
        isRtl: h,
        ...r
    }
      , y = hde(m)
      , b = o.StartScrollButtonIcon ?? c3
      , v = o.EndScrollButtonIcon ?? u3
      , S = _n({
        elementType: b,
        externalSlotProps: a.startScrollButtonIcon,
        additionalProps: {
            fontSize: "small"
        },
        ownerState: m
    })
      , C = _n({
        elementType: v,
        externalSlotProps: a.endScrollButtonIcon,
        additionalProps: {
            fontSize: "small"
        },
        ownerState: m
    });
    return g.jsx(pde, {
        component: "div",
        className: Ne(y.root, i),
        ref: n,
        role: null,
        ownerState: m,
        tabIndex: null,
        ...f,
        style: {
            ...f.style,
            ...c === "vertical" && {
                "--TabScrollButton-svgRotate": `rotate(${h ? -90 : 90}deg)`
            }
        },
        children: s === "left" ? g.jsx(b, {
            ...S
        }) : g.jsx(v, {
            ...C
        })
    })
});
function gde(e) {
    return rt("MuiTabs", e)
}
const Jw = ot("MuiTabs", ["root", "vertical", "list", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"])
  , mL = (e, t) => e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : e.firstChild
  , gL = (e, t) => e === t ? e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : e.lastChild
  , zb = (e, t, n) => {
    let r = !1
      , i = n(e, t);
    for (; i; ) {
        if (i === e.firstChild) {
            if (r)
                return;
            r = !0
        }
        const o = i.disabled || i.getAttribute("aria-disabled") === "true";
        if (!i.hasAttribute("tabindex") || o)
            i = n(e, i);
        else {
            i.focus();
            return
        }
    }
}
  , yde = e => {
    const {vertical: t, fixed: n, hideScrollbar: r, scrollableX: i, scrollableY: o, centered: a, scrollButtonsHideMobile: s, classes: c} = e;
    return tt({
        root: ["root", t && "vertical"],
        scroller: ["scroller", n && "fixed", r && "hideScrollbar", i && "scrollableX", o && "scrollableY"],
        list: ["list", "flexContainer", t && "flexContainerVertical", t && "vertical", a && "centered"],
        indicator: ["indicator"],
        scrollButtons: ["scrollButtons", s && "scrollButtonsHideMobile"],
        scrollableX: [i && "scrollableX"],
        hideScrollbar: [r && "hideScrollbar"]
    }, gde, c)
}
  , bde = ue("div", {
    name: "MuiTabs",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [{
            [`& .${Jw.scrollButtons}`]: t.scrollButtons
        }, {
            [`& .${Jw.scrollButtons}`]: n.scrollButtonsHideMobile && t.scrollButtonsHideMobile
        }, t.root, n.vertical && t.vertical]
    }
})(pt( ({theme: e}) => ({
    overflow: "hidden",
    minHeight: 48,
    WebkitOverflowScrolling: "touch",
    display: "flex",
    variants: [{
        props: ({ownerState: t}) => t.vertical,
        style: {
            flexDirection: "column"
        }
    }, {
        props: ({ownerState: t}) => t.scrollButtonsHideMobile,
        style: {
            [`& .${Jw.scrollButtons}`]: {
                [e.breakpoints.down("sm")]: {
                    display: "none"
                }
            }
        }
    }]
})))
  , xde = ue("div", {
    name: "MuiTabs",
    slot: "Scroller",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.scroller, n.fixed && t.fixed, n.hideScrollbar && t.hideScrollbar, n.scrollableX && t.scrollableX, n.scrollableY && t.scrollableY]
    }
})({
    position: "relative",
    display: "inline-block",
    flex: "1 1 auto",
    whiteSpace: "nowrap",
    variants: [{
        props: ({ownerState: e}) => e.fixed,
        style: {
            overflowX: "hidden",
            width: "100%"
        }
    }, {
        props: ({ownerState: e}) => e.hideScrollbar,
        style: {
            scrollbarWidth: "none",
            "&::-webkit-scrollbar": {
                display: "none"
            }
        }
    }, {
        props: ({ownerState: e}) => e.scrollableX,
        style: {
            overflowX: "auto",
            overflowY: "hidden"
        }
    }, {
        props: ({ownerState: e}) => e.scrollableY,
        style: {
            overflowY: "auto",
            overflowX: "hidden"
        }
    }]
})
  , vde = ue("div", {
    name: "MuiTabs",
    slot: "List",
    overridesResolver: (e, t) => {
        const {ownerState: n} = e;
        return [t.list, t.flexContainer, n.vertical && t.flexContainerVertical, n.centered && t.centered]
    }
})({
    display: "flex",
    variants: [{
        props: ({ownerState: e}) => e.vertical,
        style: {
            flexDirection: "column"
        }
    }, {
        props: ({ownerState: e}) => e.centered,
        style: {
            justifyContent: "center"
        }
    }]
})
  , Sde = ue("span", {
    name: "MuiTabs",
    slot: "Indicator"
})(pt( ({theme: e}) => ({
    position: "absolute",
    height: 2,
    bottom: 0,
    width: "100%",
    transition: e.transitions.create(),
    variants: [{
        props: {
            indicatorColor: "primary"
        },
        style: {
            backgroundColor: (e.vars || e).palette.primary.main
        }
    }, {
        props: {
            indicatorColor: "secondary"
        },
        style: {
            backgroundColor: (e.vars || e).palette.secondary.main
        }
    }, {
        props: ({ownerState: t}) => t.vertical,
        style: {
            height: "100%",
            width: 2,
            right: 0
        }
    }]
})))
  , Cde = ue(ude)({
    overflowX: "auto",
    overflowY: "hidden",
    scrollbarWidth: "none",
    "&::-webkit-scrollbar": {
        display: "none"
    }
})
  , yL = {}
  , d3 = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTabs"
    })
      , i = ko()
      , o = Si()
      , {"aria-label": a, "aria-labelledby": s, action: c, centered: u=!1, children: f, className: h, component: m="div", allowScrollButtonsMobile: y=!1, indicatorColor: b="primary", onChange: v, orientation: S="horizontal", ScrollButtonComponent: C, scrollButtons: w="auto", selectionFollowsFocus: k, slots: T={}, slotProps: E={}, TabIndicatorProps: P={}, TabScrollButtonProps: D={}, textColor: $="primary", value: z, variant: O="standard", visibleScrollbar: I=!1, ...M} = r
      , B = O === "scrollable"
      , L = S === "vertical"
      , F = L ? "scrollTop" : "scrollLeft"
      , j = L ? "top" : "left"
      , N = L ? "bottom" : "right"
      , H = L ? "clientHeight" : "clientWidth"
      , Z = L ? "height" : "width"
      , q = {
        ...r,
        component: m,
        allowScrollButtonsMobile: y,
        indicatorColor: b,
        orientation: S,
        vertical: L,
        scrollButtons: w,
        textColor: $,
        variant: O,
        visibleScrollbar: I,
        fixed: !B,
        hideScrollbar: B && !I,
        scrollableX: B && !L,
        scrollableY: B && L,
        centered: u && !B,
        scrollButtonsHideMobile: !y
    }
      , V = yde(q)
      , Y = _n({
        elementType: T.StartScrollButtonIcon,
        externalSlotProps: E.startScrollButtonIcon,
        ownerState: q
    })
      , W = _n({
        elementType: T.EndScrollButtonIcon,
        externalSlotProps: E.endScrollButtonIcon,
        ownerState: q
    })
      , [te,K] = A.useState(!1)
      , [ee,re] = A.useState(yL)
      , [ie,J] = A.useState(!1)
      , [oe,we] = A.useState(!1)
      , [xe,se] = A.useState(!1)
      , [de,Se] = A.useState({
        overflow: "hidden",
        scrollbarWidth: 0
    })
      , Ce = new Map
      , Ye = A.useRef(null)
      , ye = A.useRef(null)
      , Ke = {
        slots: T,
        slotProps: {
            indicator: P,
            scrollButton: D,
            ...E
        }
    }
      , X = () => {
        const he = Ye.current;
        let Le;
        if (he) {
            const Je = he.getBoundingClientRect();
            Le = {
                clientWidth: he.clientWidth,
                scrollLeft: he.scrollLeft,
                scrollTop: he.scrollTop,
                scrollWidth: he.scrollWidth,
                top: Je.top,
                bottom: Je.bottom,
                left: Je.left,
                right: Je.right
            }
        }
        let it;
        if (he && z !== !1) {
            const Je = ye.current.children;
            if (Je.length > 0) {
                const Jt = Je[Ce.get(z)];
                it = Jt ? Jt.getBoundingClientRect() : null
            }
        }
        return {
            tabsMeta: Le,
            tabMeta: it
        }
    }
      , ce = ft( () => {
        const {tabsMeta: he, tabMeta: Le} = X();
        let it = 0, Je;
        L ? (Je = "top",
        Le && he && (it = Le.top - he.top + he.scrollTop)) : (Je = o ? "right" : "left",
        Le && he && (it = (o ? -1 : 1) * (Le[Je] - he[Je] + he.scrollLeft)));
        const Jt = {
            [Je]: it,
            [Z]: Le ? Le[Z] : 0
        };
        if (typeof ee[Je] != "number" || typeof ee[Z] != "number")
            re(Jt);
        else {
            const qt = Math.abs(ee[Je] - Jt[Je])
              , dn = Math.abs(ee[Z] - Jt[Z]);
            (qt >= 1 || dn >= 1) && re(Jt)
        }
    }
    )
      , fe = (he, {animation: Le=!0}={}) => {
        Le ? lde(F, Ye.current, he, {
            duration: i.transitions.duration.standard
        }) : Ye.current[F] = he
    }
      , Xe = he => {
        let Le = Ye.current[F];
        L ? Le += he : Le += he * (o ? -1 : 1),
        fe(Le)
    }
      , Oe = () => {
        const he = Ye.current[H];
        let Le = 0;
        const it = Array.from(ye.current.children);
        for (let Je = 0; Je < it.length; Je += 1) {
            const Jt = it[Je];
            if (Le + Jt[H] > he) {
                Je === 0 && (Le = he);
                break
            }
            Le += Jt[H]
        }
        return Le
    }
      , Re = () => {
        Xe(-1 * Oe())
    }
      , le = () => {
        Xe(Oe())
    }
      , [ke,{onChange: He, ...st}] = mt("scrollbar", {
        className: Ne(V.scrollableX, V.hideScrollbar),
        elementType: Cde,
        shouldForwardComponentProp: !0,
        externalForwardedProps: Ke,
        ownerState: q
    })
      , lt = A.useCallback(he => {
        He?.(he),
        Se({
            overflow: null,
            scrollbarWidth: he
        })
    }
    , [He])
      , [et,Ht] = mt("scrollButtons", {
        className: Ne(V.scrollButtons, D.className),
        elementType: mde,
        externalForwardedProps: Ke,
        ownerState: q,
        additionalProps: {
            orientation: S,
            slots: {
                StartScrollButtonIcon: T.startScrollButtonIcon || T.StartScrollButtonIcon,
                EndScrollButtonIcon: T.endScrollButtonIcon || T.EndScrollButtonIcon
            },
            slotProps: {
                startScrollButtonIcon: Y,
                endScrollButtonIcon: W
            }
        }
    })
      , Ft = () => {
        const he = {};
        he.scrollbarSizeListener = B ? g.jsx(ke, {
            ...st,
            onChange: lt
        }) : null;
        const it = B && (w === "auto" && (ie || oe) || w === !0);
        return he.scrollButtonStart = it ? g.jsx(et, {
            direction: o ? "right" : "left",
            onClick: Re,
            disabled: !ie,
            ...Ht
        }) : null,
        he.scrollButtonEnd = it ? g.jsx(et, {
            direction: o ? "left" : "right",
            onClick: le,
            disabled: !oe,
            ...Ht
        }) : null,
        he
    }
      , Pt = ft(he => {
        const {tabsMeta: Le, tabMeta: it} = X();
        if (!(!it || !Le)) {
            if (it[j] < Le[j]) {
                const Je = Le[F] + (it[j] - Le[j]);
                fe(Je, {
                    animation: he
                })
            } else if (it[N] > Le[N]) {
                const Je = Le[F] + (it[N] - Le[N]);
                fe(Je, {
                    animation: he
                })
            }
        }
    }
    )
      , nt = ft( () => {
        B && w !== !1 && se(!xe)
    }
    );
    A.useEffect( () => {
        const he = Rg( () => {
            Ye.current && ce()
        }
        );
        let Le;
        const it = qt => {
            qt.forEach(dn => {
                dn.removedNodes.forEach(Ir => {
                    Le?.unobserve(Ir)
                }
                ),
                dn.addedNodes.forEach(Ir => {
                    Le?.observe(Ir)
                }
                )
            }
            ),
            he(),
            nt()
        }
          , Je = Zo(Ye.current);
        Je.addEventListener("resize", he);
        let Jt;
        return typeof ResizeObserver < "u" && (Le = new ResizeObserver(he),
        Array.from(ye.current.children).forEach(qt => {
            Le.observe(qt)
        }
        )),
        typeof MutationObserver < "u" && (Jt = new MutationObserver(it),
        Jt.observe(ye.current, {
            childList: !0
        })),
        () => {
            he.clear(),
            Je.removeEventListener("resize", he),
            Jt?.disconnect(),
            Le?.disconnect()
        }
    }
    , [ce, nt]),
    A.useEffect( () => {
        const he = Array.from(ye.current.children)
          , Le = he.length;
        if (typeof IntersectionObserver < "u" && Le > 0 && B && w !== !1) {
            const it = he[0]
              , Je = he[Le - 1]
              , Jt = {
                root: Ye.current,
                threshold: .99
            }
              , qt = Tr => {
                J(!Tr[0].isIntersecting)
            }
              , dn = new IntersectionObserver(qt,Jt);
            dn.observe(it);
            const Ir = Tr => {
                we(!Tr[0].isIntersecting)
            }
              , Ki = new IntersectionObserver(Ir,Jt);
            return Ki.observe(Je),
            () => {
                dn.disconnect(),
                Ki.disconnect()
            }
        }
    }
    , [B, w, xe, f?.length]),
    A.useEffect( () => {
        K(!0)
    }
    , []),
    A.useEffect( () => {
        ce()
    }
    ),
    A.useEffect( () => {
        Pt(yL !== ee)
    }
    , [Pt, ee]),
    A.useImperativeHandle(c, () => ({
        updateIndicator: ce,
        updateScrollButtons: nt
    }), [ce, nt]);
    const [ut,Lt] = mt("indicator", {
        className: Ne(V.indicator, P.className),
        elementType: Sde,
        externalForwardedProps: Ke,
        ownerState: q,
        additionalProps: {
            style: ee
        }
    })
      , tn = g.jsx(ut, {
        ...Lt
    });
    let Xt = 0;
    const Mn = A.Children.map(f, he => {
        if (!A.isValidElement(he))
            return null;
        const Le = he.props.value === void 0 ? Xt : he.props.value;
        Ce.set(Le, Xt);
        const it = Le === z;
        return Xt += 1,
        A.cloneElement(he, {
            fullWidth: O === "fullWidth",
            indicator: it && !te && tn,
            selected: it,
            selectionFollowsFocus: k,
            onChange: v,
            textColor: $,
            value: Le,
            ...Xt === 1 && z === !1 && !he.props.tabIndex ? {
                tabIndex: 0
            } : {}
        })
    }
    )
      , Pn = he => {
        if (he.altKey || he.shiftKey || he.ctrlKey || he.metaKey)
            return;
        const Le = ye.current
          , it = Kr(Le).activeElement;
        if (it.getAttribute("role") !== "tab")
            return;
        let Jt = S === "horizontal" ? "ArrowLeft" : "ArrowUp"
          , qt = S === "horizontal" ? "ArrowRight" : "ArrowDown";
        switch (S === "horizontal" && o && (Jt = "ArrowRight",
        qt = "ArrowLeft"),
        he.key) {
        case Jt:
            he.preventDefault(),
            zb(Le, it, gL);
            break;
        case qt:
            he.preventDefault(),
            zb(Le, it, mL);
            break;
        case "Home":
            he.preventDefault(),
            zb(Le, null, mL);
            break;
        case "End":
            he.preventDefault(),
            zb(Le, null, gL);
            break
        }
    }
      , wn = Ft()
      , [Kn,vr] = mt("root", {
        ref: n,
        className: Ne(V.root, h),
        elementType: bde,
        externalForwardedProps: {
            ...Ke,
            ...M,
            component: m
        },
        ownerState: q
    })
      , [mr,kn] = mt("scroller", {
        ref: Ye,
        className: V.scroller,
        elementType: xde,
        externalForwardedProps: Ke,
        ownerState: q,
        additionalProps: {
            style: {
                overflow: de.overflow,
                [L ? `margin${o ? "Left" : "Right"}` : "marginBottom"]: I ? void 0 : -de.scrollbarWidth
            }
        }
    })
      , [At,nr] = mt("list", {
        ref: ye,
        className: Ne(V.list, V.flexContainer),
        elementType: vde,
        externalForwardedProps: Ke,
        ownerState: q,
        getSlotProps: he => ({
            ...he,
            onKeyDown: Le => {
                Pn(Le),
                he.onKeyDown?.(Le)
            }
        })
    });
    return g.jsxs(Kn, {
        ...vr,
        children: [wn.scrollButtonStart, wn.scrollbarSizeListener, g.jsxs(mr, {
            ...kn,
            children: [g.jsx(At, {
                "aria-label": a,
                "aria-labelledby": s,
                "aria-orientation": S === "vertical" ? "vertical" : null,
                role: "tablist",
                ...nr,
                children: Mn
            }), te && tn]
        }), wn.scrollButtonEnd]
    })
});
function wde(e) {
    return rt("MuiTextField", e)
}
ot("MuiTextField", ["root"]);
const kde = {
    standard: UE,
    filled: NE,
    outlined: WE
}
  , Tde = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, wde, t)
}
  , _de = ue(x0, {
    name: "MuiTextField",
    slot: "Root"
})({})
  , ct = A.forwardRef(function(t, n) {
    const r = gt({
        props: t,
        name: "MuiTextField"
    })
      , {autoComplete: i, autoFocus: o=!1, children: a, className: s, color: c="primary", defaultValue: u, disabled: f=!1, error: h=!1, FormHelperTextProps: m, fullWidth: y=!1, helperText: b, id: v, InputLabelProps: S, inputProps: C, InputProps: w, inputRef: k, label: T, maxRows: E, minRows: P, multiline: D=!1, name: $, onBlur: z, onChange: O, onFocus: I, placeholder: M, required: B=!1, rows: L, select: F=!1, SelectProps: j, slots: N={}, slotProps: H={}, type: Z, value: q, variant: V="outlined", ...Y} = r
      , W = {
        ...r,
        autoFocus: o,
        color: c,
        disabled: f,
        error: h,
        fullWidth: y,
        multiline: D,
        required: B,
        select: F,
        variant: V
    }
      , te = Tde(W)
      , K = Gi(v)
      , ee = b && K ? `${K}-helper-text` : void 0
      , re = T && K ? `${K}-label` : void 0
      , ie = kde[V]
      , J = {
        slots: N,
        slotProps: {
            input: w,
            inputLabel: S,
            htmlInput: C,
            formHelperText: m,
            select: j,
            ...H
        }
    }
      , oe = {}
      , we = J.slotProps.inputLabel;
    V === "outlined" && (we && typeof we.shrink < "u" && (oe.notched = we.shrink),
    oe.label = T),
    F && ((!j || !j.native) && (oe.id = void 0),
    oe["aria-describedby"] = void 0);
    const [xe,se] = mt("root", {
        elementType: _de,
        shouldForwardComponentProp: !0,
        externalForwardedProps: {
            ...J,
            ...Y
        },
        ownerState: W,
        className: Ne(te.root, s),
        ref: n,
        additionalProps: {
            disabled: f,
            error: h,
            fullWidth: y,
            required: B,
            color: c,
            variant: V
        }
    })
      , [de,Se] = mt("input", {
        elementType: ie,
        externalForwardedProps: J,
        additionalProps: oe,
        ownerState: W
    })
      , [Ce,Ye] = mt("inputLabel", {
        elementType: S0,
        externalForwardedProps: J,
        ownerState: W
    })
      , [ye,Ke] = mt("htmlInput", {
        elementType: "input",
        externalForwardedProps: J,
        ownerState: W
    })
      , [X,ce] = mt("formHelperText", {
        elementType: e3,
        externalForwardedProps: J,
        ownerState: W
    })
      , [fe,Xe] = mt("select", {
        elementType: Gm,
        externalForwardedProps: J,
        ownerState: W
    })
      , Oe = g.jsx(de, {
        "aria-describedby": ee,
        autoComplete: i,
        autoFocus: o,
        defaultValue: u,
        fullWidth: y,
        multiline: D,
        name: $,
        rows: L,
        maxRows: E,
        minRows: P,
        type: Z,
        value: q,
        id: K,
        inputRef: k,
        onBlur: z,
        onChange: O,
        onFocus: I,
        placeholder: M,
        inputProps: Ke,
        slots: {
            input: N.htmlInput ? ye : void 0
        },
        ...Se
    });
    return g.jsxs(xe, {
        ...se,
        children: [T != null && T !== "" && g.jsx(Ce, {
            htmlFor: K,
            id: re,
            ...Ye,
            children: T
        }), F ? g.jsx(fe, {
            "aria-describedby": ee,
            id: K,
            labelId: re,
            value: q,
            input: Oe,
            ...Xe,
            children: a
        }) : Oe, b && g.jsx(X, {
            id: ee,
            ...ce,
            children: b
        })]
    })
})
  , n1 = cN({
    themeId: xa
});
function yi(e) {
    return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
}
var Ede = typeof Symbol == "function" && Symbol.observable || "@@observable"
  , bL = Ede
  , ek = () => Math.random().toString(36).substring(7).split("").join(".")
  , Ade = {
    INIT: `@@redux/INIT${ek()}`,
    REPLACE: `@@redux/REPLACE${ek()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${ek()}`
}
  , C0 = Ade;
function Sc(e) {
    if (typeof e != "object" || e === null)
        return !1;
    let t = e;
    for (; Object.getPrototypeOf(t) !== null; )
        t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(e) === t || Object.getPrototypeOf(e) === null
}
function f3(e, t, n) {
    if (typeof e != "function")
        throw new Error(yi(2));
    if (typeof t == "function" && typeof n == "function" || typeof n == "function" && typeof arguments[3] == "function")
        throw new Error(yi(0));
    if (typeof t == "function" && typeof n > "u" && (n = t,
    t = void 0),
    typeof n < "u") {
        if (typeof n != "function")
            throw new Error(yi(1));
        return n(f3)(e, t)
    }
    let r = e
      , i = t
      , o = new Map
      , a = o
      , s = 0
      , c = !1;
    function u() {
        a === o && (a = new Map,
        o.forEach( (S, C) => {
            a.set(C, S)
        }
        ))
    }
    function f() {
        if (c)
            throw new Error(yi(3));
        return i
    }
    function h(S) {
        if (typeof S != "function")
            throw new Error(yi(4));
        if (c)
            throw new Error(yi(5));
        let C = !0;
        u();
        const w = s++;
        return a.set(w, S),
        function() {
            if (C) {
                if (c)
                    throw new Error(yi(6));
                C = !1,
                u(),
                a.delete(w),
                o = null
            }
        }
    }
    function m(S) {
        if (!Sc(S))
            throw new Error(yi(7));
        if (typeof S.type > "u")
            throw new Error(yi(8));
        if (typeof S.type != "string")
            throw new Error(yi(17));
        if (c)
            throw new Error(yi(9));
        try {
            c = !0,
            i = r(i, S)
        } finally {
            c = !1
        }
        return (o = a).forEach(w => {
            w()
        }
        ),
        S
    }
    function y(S) {
        if (typeof S != "function")
            throw new Error(yi(10));
        r = S,
        m({
            type: C0.REPLACE
        })
    }
    function b() {
        const S = h;
        return {
            subscribe(C) {
                if (typeof C != "object" || C === null)
                    throw new Error(yi(11));
                function w() {
                    const T = C;
                    T.next && T.next(f())
                }
                return w(),
                {
                    unsubscribe: S(w)
                }
            },
            [bL]() {
                return this
            }
        }
    }
    return m({
        type: C0.INIT
    }),
    {
        dispatch: m,
        subscribe: h,
        getState: f,
        replaceReducer: y,
        [bL]: b
    }
}
function Mde(e) {
    Object.keys(e).forEach(t => {
        const n = e[t];
        if (typeof n(void 0, {
            type: C0.INIT
        }) > "u")
            throw new Error(yi(12));
        if (typeof n(void 0, {
            type: C0.PROBE_UNKNOWN_ACTION()
        }) > "u")
            throw new Error(yi(13))
    }
    )
}
function h3(e) {
    const t = Object.keys(e)
      , n = {};
    for (let o = 0; o < t.length; o++) {
        const a = t[o];
        typeof e[a] == "function" && (n[a] = e[a])
    }
    const r = Object.keys(n);
    let i;
    try {
        Mde(n)
    } catch (o) {
        i = o
    }
    return function(a={}, s) {
        if (i)
            throw i;
        let c = !1;
        const u = {};
        for (let f = 0; f < r.length; f++) {
            const h = r[f]
              , m = n[h]
              , y = a[h]
              , b = m(y, s);
            if (typeof b > "u")
                throw s && s.type,
                new Error(yi(14));
            u[h] = b,
            c = c || b !== y
        }
        return c = c || r.length !== Object.keys(a).length,
        c ? u : a
    }
}
function w0(...e) {
    return e.length === 0 ? t => t : e.length === 1 ? e[0] : e.reduce( (t, n) => (...r) => t(n(...r)))
}
function Pde(...e) {
    return t => (n, r) => {
        const i = t(n, r);
        let o = () => {
            throw new Error(yi(15))
        }
        ;
        const a = {
            getState: i.getState,
            dispatch: (c, ...u) => o(c, ...u)
        }
          , s = e.map(c => c(a));
        return o = w0(...s)(i.dispatch),
        {
            ...i,
            dispatch: o
        }
    }
}
function ZE(e) {
    return Sc(e) && "type"in e && typeof e.type == "string"
}
var QE = Symbol.for("immer-nothing")
  , Sm = Symbol.for("immer-draftable")
  , Co = Symbol.for("immer-state");
function vi(e, ...t) {
    throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)
}
var Nu = Object.getPrototypeOf;
function Es(e) {
    return !!e && !!e[Co]
}
function Xa(e) {
    return e ? p3(e) || Array.isArray(e) || !!e[Sm] || !!e.constructor?.[Sm] || ph(e) || zg(e) : !1
}
var Rde = Object.prototype.constructor.toString();
function p3(e) {
    if (!e || typeof e != "object")
        return !1;
    const t = Nu(e);
    if (t === null)
        return !0;
    const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
    return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Rde
}
function Dde(e) {
    return Es(e) || vi(15, e),
    e[Co].base_
}
function Ym(e, t) {
    Uu(e) === 0 ? Reflect.ownKeys(e).forEach(n => {
        t(n, e[n], e)
    }
    ) : e.forEach( (n, r) => t(r, n, e))
}
function Uu(e) {
    const t = e[Co];
    return t ? t.type_ : Array.isArray(e) ? 1 : ph(e) ? 2 : zg(e) ? 3 : 0
}
function Zm(e, t) {
    return Uu(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
}
function tk(e, t) {
    return Uu(e) === 2 ? e.get(t) : e[t]
}
function m3(e, t, n) {
    const r = Uu(e);
    r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n
}
function Ode(e, t) {
    return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t
}
function ph(e) {
    return e instanceof Map
}
function zg(e) {
    return e instanceof Set
}
function hu(e) {
    return e.copy_ || e.base_
}
function lT(e, t) {
    if (ph(e))
        return new Map(e);
    if (zg(e))
        return new Set(e);
    if (Array.isArray(e))
        return Array.prototype.slice.call(e);
    const n = p3(e);
    if (t === !0 || t === "class_only" && !n) {
        const r = Object.getOwnPropertyDescriptors(e);
        delete r[Co];
        let i = Reflect.ownKeys(r);
        for (let o = 0; o < i.length; o++) {
            const a = i[o]
              , s = r[a];
            s.writable === !1 && (s.writable = !0,
            s.configurable = !0),
            (s.get || s.set) && (r[a] = {
                configurable: !0,
                writable: !0,
                enumerable: s.enumerable,
                value: e[a]
            })
        }
        return Object.create(Nu(e), r)
    } else {
        const r = Nu(e);
        if (r !== null && n)
            return {
                ...e
            };
        const i = Object.create(r);
        return Object.assign(i, e)
    }
}
function KE(e, t=!1) {
    return r1(e) || Es(e) || !Xa(e) || (Uu(e) > 1 && Object.defineProperties(e, {
        set: {
            value: Fb
        },
        add: {
            value: Fb
        },
        clear: {
            value: Fb
        },
        delete: {
            value: Fb
        }
    }),
    Object.freeze(e),
    t && Object.values(e).forEach(n => KE(n, !0))),
    e
}
function Fb() {
    vi(2)
}
function r1(e) {
    return Object.isFrozen(e)
}
var cT = {};
function Vu(e) {
    const t = cT[e];
    return t || vi(0, e),
    t
}
function Ide(e, t) {
    cT[e] || (cT[e] = t)
}
var Qm;
function g3() {
    return Qm
}
function $de(e, t) {
    return {
        drafts_: [],
        parent_: e,
        immer_: t,
        canAutoFreeze_: !0,
        unfinalizedDrafts_: 0
    }
}
function xL(e, t) {
    t && (Vu("Patches"),
    e.patches_ = [],
    e.inversePatches_ = [],
    e.patchListener_ = t)
}
function uT(e) {
    dT(e),
    e.drafts_.forEach(Lde),
    e.drafts_ = null
}
function dT(e) {
    e === Qm && (Qm = e.parent_)
}
function vL(e) {
    return Qm = $de(Qm, e)
}
function Lde(e) {
    const t = e[Co];
    t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0
}
function SL(e, t) {
    t.unfinalizedDrafts_ = t.drafts_.length;
    const n = t.drafts_[0];
    return e !== void 0 && e !== n ? (n[Co].modified_ && (uT(t),
    vi(4)),
    Xa(e) && (e = k0(t, e),
    t.parent_ || T0(t, e)),
    t.patches_ && Vu("Patches").generateReplacementPatches_(n[Co].base_, e, t.patches_, t.inversePatches_)) : e = k0(t, n, []),
    uT(t),
    t.patches_ && t.patchListener_(t.patches_, t.inversePatches_),
    e !== QE ? e : void 0
}
function k0(e, t, n) {
    if (r1(t))
        return t;
    const r = t[Co];
    if (!r)
        return Ym(t, (i, o) => CL(e, r, t, i, o, n)),
        t;
    if (r.scope_ !== e)
        return t;
    if (!r.modified_)
        return T0(e, r.base_, !0),
        r.base_;
    if (!r.finalized_) {
        r.finalized_ = !0,
        r.scope_.unfinalizedDrafts_--;
        const i = r.copy_;
        let o = i
          , a = !1;
        r.type_ === 3 && (o = new Set(i),
        i.clear(),
        a = !0),
        Ym(o, (s, c) => CL(e, r, i, s, c, n, a)),
        T0(e, i, !1),
        n && e.patches_ && Vu("Patches").generatePatches_(r, n, e.patches_, e.inversePatches_)
    }
    return r.copy_
}
function CL(e, t, n, r, i, o, a) {
    if (Es(i)) {
        const s = o && t && t.type_ !== 3 && !Zm(t.assigned_, r) ? o.concat(r) : void 0
          , c = k0(e, i, s);
        if (m3(n, r, c),
        Es(c))
            e.canAutoFreeze_ = !1;
        else
            return
    } else
        a && n.add(i);
    if (Xa(i) && !r1(i)) {
        if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
            return;
        k0(e, i),
        (!t || !t.scope_.parent_) && typeof r != "symbol" && (ph(n) ? n.has(r) : Object.prototype.propertyIsEnumerable.call(n, r)) && T0(e, i)
    }
}
function T0(e, t, n=!1) {
    !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && KE(t, n)
}
function jde(e, t) {
    const n = Array.isArray(e)
      , r = {
        type_: n ? 1 : 0,
        scope_: t ? t.scope_ : g3(),
        modified_: !1,
        finalized_: !1,
        assigned_: {},
        parent_: t,
        base_: e,
        draft_: null,
        copy_: null,
        revoke_: null,
        isManual_: !1
    };
    let i = r
      , o = XE;
    n && (i = [r],
    o = Km);
    const {revoke: a, proxy: s} = Proxy.revocable(i, o);
    return r.draft_ = s,
    r.revoke_ = a,
    s
}
var XE = {
    get(e, t) {
        if (t === Co)
            return e;
        const n = hu(e);
        if (!Zm(n, t))
            return Bde(e, n, t);
        const r = n[t];
        return e.finalized_ || !Xa(r) ? r : r === nk(e.base_, t) ? (rk(e),
        e.copy_[t] = hT(r, e)) : r
    },
    has(e, t) {
        return t in hu(e)
    },
    ownKeys(e) {
        return Reflect.ownKeys(hu(e))
    },
    set(e, t, n) {
        const r = y3(hu(e), t);
        if (r?.set)
            return r.set.call(e.draft_, n),
            !0;
        if (!e.modified_) {
            const i = nk(hu(e), t)
              , o = i?.[Co];
            if (o && o.base_ === n)
                return e.copy_[t] = n,
                e.assigned_[t] = !1,
                !0;
            if (Ode(n, i) && (n !== void 0 || Zm(e.base_, t)))
                return !0;
            rk(e),
            fT(e)
        }
        return e.copy_[t] === n && (n !== void 0 || t in e.copy_) || Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n,
        e.assigned_[t] = !0),
        !0
    },
    deleteProperty(e, t) {
        return nk(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1,
        rk(e),
        fT(e)) : delete e.assigned_[t],
        e.copy_ && delete e.copy_[t],
        !0
    },
    getOwnPropertyDescriptor(e, t) {
        const n = hu(e)
          , r = Reflect.getOwnPropertyDescriptor(n, t);
        return r && {
            writable: !0,
            configurable: e.type_ !== 1 || t !== "length",
            enumerable: r.enumerable,
            value: n[t]
        }
    },
    defineProperty() {
        vi(11)
    },
    getPrototypeOf(e) {
        return Nu(e.base_)
    },
    setPrototypeOf() {
        vi(12)
    }
}
  , Km = {};
Ym(XE, (e, t) => {
    Km[e] = function() {
        return arguments[0] = arguments[0][0],
        t.apply(this, arguments)
    }
}
);
Km.deleteProperty = function(e, t) {
    return Km.set.call(this, e, t, void 0)
}
;
Km.set = function(e, t, n) {
    return XE.set.call(this, e[0], t, n, e[0])
}
;
function nk(e, t) {
    const n = e[Co];
    return (n ? hu(n) : e)[t]
}
function Bde(e, t, n) {
    const r = y3(t, n);
    return r ? "value"in r ? r.value : r.get?.call(e.draft_) : void 0
}
function y3(e, t) {
    if (!(t in e))
        return;
    let n = Nu(e);
    for (; n; ) {
        const r = Object.getOwnPropertyDescriptor(n, t);
        if (r)
            return r;
        n = Nu(n)
    }
}
function fT(e) {
    e.modified_ || (e.modified_ = !0,
    e.parent_ && fT(e.parent_))
}
function rk(e) {
    e.copy_ || (e.copy_ = lT(e.base_, e.scope_.immer_.useStrictShallowCopy_))
}
var zde = class {
    constructor(e) {
        this.autoFreeze_ = !0,
        this.useStrictShallowCopy_ = !1,
        this.produce = (t, n, r) => {
            if (typeof t == "function" && typeof n != "function") {
                const o = n;
                n = t;
                const a = this;
                return function(c=o, ...u) {
                    return a.produce(c, f => n.call(this, f, ...u))
                }
            }
            typeof n != "function" && vi(6),
            r !== void 0 && typeof r != "function" && vi(7);
            let i;
            if (Xa(t)) {
                const o = vL(this)
                  , a = hT(t, void 0);
                let s = !0;
                try {
                    i = n(a),
                    s = !1
                } finally {
                    s ? uT(o) : dT(o)
                }
                return xL(o, r),
                SL(i, o)
            } else if (!t || typeof t != "object") {
                if (i = n(t),
                i === void 0 && (i = t),
                i === QE && (i = void 0),
                this.autoFreeze_ && KE(i, !0),
                r) {
                    const o = []
                      , a = [];
                    Vu("Patches").generateReplacementPatches_(t, i, o, a),
                    r(o, a)
                }
                return i
            } else
                vi(1, t)
        }
        ,
        this.produceWithPatches = (t, n) => {
            if (typeof t == "function")
                return (a, ...s) => this.produceWithPatches(a, c => t(c, ...s));
            let r, i;
            return [this.produce(t, n, (a, s) => {
                r = a,
                i = s
            }
            ), r, i]
        }
        ,
        typeof e?.autoFreeze == "boolean" && this.setAutoFreeze(e.autoFreeze),
        typeof e?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy)
    }
    createDraft(e) {
        Xa(e) || vi(8),
        Es(e) && (e = Fde(e));
        const t = vL(this)
          , n = hT(e, void 0);
        return n[Co].isManual_ = !0,
        dT(t),
        n
    }
    finishDraft(e, t) {
        const n = e && e[Co];
        (!n || !n.isManual_) && vi(9);
        const {scope_: r} = n;
        return xL(r, t),
        SL(void 0, r)
    }
    setAutoFreeze(e) {
        this.autoFreeze_ = e
    }
    setUseStrictShallowCopy(e) {
        this.useStrictShallowCopy_ = e
    }
    applyPatches(e, t) {
        let n;
        for (n = t.length - 1; n >= 0; n--) {
            const i = t[n];
            if (i.path.length === 0 && i.op === "replace") {
                e = i.value;
                break
            }
        }
        n > -1 && (t = t.slice(n + 1));
        const r = Vu("Patches").applyPatches_;
        return Es(e) ? r(e, t) : this.produce(e, i => r(i, t))
    }
}
;
function hT(e, t) {
    const n = ph(e) ? Vu("MapSet").proxyMap_(e, t) : zg(e) ? Vu("MapSet").proxySet_(e, t) : jde(e, t);
    return (t ? t.scope_ : g3()).drafts_.push(n),
    n
}
function Fde(e) {
    return Es(e) || vi(10, e),
    b3(e)
}
function b3(e) {
    if (!Xa(e) || r1(e))
        return e;
    const t = e[Co];
    let n;
    if (t) {
        if (!t.modified_)
            return t.base_;
        t.finalized_ = !0,
        n = lT(e, t.scope_.immer_.useStrictShallowCopy_)
    } else
        n = lT(e, !0);
    return Ym(n, (r, i) => {
        m3(n, r, b3(i))
    }
    ),
    t && (t.finalized_ = !1),
    n
}
function Nde() {
    const t = "replace"
      , r = "remove";
    function i(m, y, b, v) {
        switch (m.type_) {
        case 0:
        case 2:
            return a(m, y, b, v);
        case 1:
            return o(m, y, b, v);
        case 3:
            return s(m, y, b, v)
        }
    }
    function o(m, y, b, v) {
        let {base_: S, assigned_: C} = m
          , w = m.copy_;
        w.length < S.length && ([S,w] = [w, S],
        [b,v] = [v, b]);
        for (let k = 0; k < S.length; k++)
            if (C[k] && w[k] !== S[k]) {
                const T = y.concat([k]);
                b.push({
                    op: t,
                    path: T,
                    value: h(w[k])
                }),
                v.push({
                    op: t,
                    path: T,
                    value: h(S[k])
                })
            }
        for (let k = S.length; k < w.length; k++) {
            const T = y.concat([k]);
            b.push({
                op: "add",
                path: T,
                value: h(w[k])
            })
        }
        for (let k = w.length - 1; S.length <= k; --k) {
            const T = y.concat([k]);
            v.push({
                op: r,
                path: T
            })
        }
    }
    function a(m, y, b, v) {
        const {base_: S, copy_: C} = m;
        Ym(m.assigned_, (w, k) => {
            const T = tk(S, w)
              , E = tk(C, w)
              , P = k ? Zm(S, w) ? t : "add" : r;
            if (T === E && P === t)
                return;
            const D = y.concat(w);
            b.push(P === r ? {
                op: P,
                path: D
            } : {
                op: P,
                path: D,
                value: E
            }),
            v.push(P === "add" ? {
                op: r,
                path: D
            } : P === r ? {
                op: "add",
                path: D,
                value: h(T)
            } : {
                op: t,
                path: D,
                value: h(T)
            })
        }
        )
    }
    function s(m, y, b, v) {
        let {base_: S, copy_: C} = m
          , w = 0;
        S.forEach(k => {
            if (!C.has(k)) {
                const T = y.concat([w]);
                b.push({
                    op: r,
                    path: T,
                    value: k
                }),
                v.unshift({
                    op: "add",
                    path: T,
                    value: k
                })
            }
            w++
        }
        ),
        w = 0,
        C.forEach(k => {
            if (!S.has(k)) {
                const T = y.concat([w]);
                b.push({
                    op: "add",
                    path: T,
                    value: k
                }),
                v.unshift({
                    op: r,
                    path: T,
                    value: k
                })
            }
            w++
        }
        )
    }
    function c(m, y, b, v) {
        b.push({
            op: t,
            path: [],
            value: y === QE ? void 0 : y
        }),
        v.push({
            op: t,
            path: [],
            value: m
        })
    }
    function u(m, y) {
        return y.forEach(b => {
            const {path: v, op: S} = b;
            let C = m;
            for (let E = 0; E < v.length - 1; E++) {
                const P = Uu(C);
                let D = v[E];
                typeof D != "string" && typeof D != "number" && (D = "" + D),
                (P === 0 || P === 1) && (D === "__proto__" || D === "constructor") && vi(19),
                typeof C == "function" && D === "prototype" && vi(19),
                C = tk(C, D),
                typeof C != "object" && vi(18, v.join("/"))
            }
            const w = Uu(C)
              , k = f(b.value)
              , T = v[v.length - 1];
            switch (S) {
            case t:
                switch (w) {
                case 2:
                    return C.set(T, k);
                case 3:
                    vi(16);
                default:
                    return C[T] = k
                }
            case "add":
                switch (w) {
                case 1:
                    return T === "-" ? C.push(k) : C.splice(T, 0, k);
                case 2:
                    return C.set(T, k);
                case 3:
                    return C.add(k);
                default:
                    return C[T] = k
                }
            case r:
                switch (w) {
                case 1:
                    return C.splice(T, 1);
                case 2:
                    return C.delete(T);
                case 3:
                    return C.delete(b.value);
                default:
                    return delete C[T]
                }
            default:
                vi(17, S)
            }
        }
        ),
        m
    }
    function f(m) {
        if (!Xa(m))
            return m;
        if (Array.isArray(m))
            return m.map(f);
        if (ph(m))
            return new Map(Array.from(m.entries()).map( ([b,v]) => [b, f(v)]));
        if (zg(m))
            return new Set(Array.from(m).map(f));
        const y = Object.create(Nu(m));
        for (const b in m)
            y[b] = f(m[b]);
        return Zm(m, Sm) && (y[Sm] = m[Sm]),
        y
    }
    function h(m) {
        return Es(m) ? f(m) : m
    }
    Ide("Patches", {
        applyPatches_: u,
        generatePatches_: i,
        generateReplacementPatches_: c
    })
}
var Xm = new zde
  , Fg = Xm.produce
  , x3 = Xm.produceWithPatches.bind(Xm)
  , wL = Xm.applyPatches.bind(Xm);
function Ude(e, t=`expected a function, instead received ${typeof e}`) {
    if (typeof e != "function")
        throw new TypeError(t)
}
function Vde(e, t=`expected an object, instead received ${typeof e}`) {
    if (typeof e != "object")
        throw new TypeError(t)
}
function Hde(e, t="expected all items to be functions, instead received the following types: ") {
    if (!e.every(n => typeof n == "function")) {
        const n = e.map(r => typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r).join(", ");
        throw new TypeError(`${t}[${n}]`)
    }
}
var kL = e => Array.isArray(e) ? e : [e];
function qde(e) {
    const t = Array.isArray(e[0]) ? e[0] : e;
    return Hde(t, "createSelector expects all input-selectors to be functions, but received the following types: "),
    t
}
function Wde(e, t) {
    const n = []
      , {length: r} = e;
    for (let i = 0; i < r; i++)
        n.push(e[i].apply(null, t));
    return n
}
var Gde = class {
    constructor(e) {
        this.value = e
    }
    deref() {
        return this.value
    }
}
  , Yde = typeof WeakRef < "u" ? WeakRef : Gde
  , Zde = 0
  , TL = 1;
function Nb() {
    return {
        s: Zde,
        v: void 0,
        o: null,
        p: null
    }
}
function _0(e, t={}) {
    let n = Nb();
    const {resultEqualityCheck: r} = t;
    let i, o = 0;
    function a() {
        let s = n;
        const {length: c} = arguments;
        for (let h = 0, m = c; h < m; h++) {
            const y = arguments[h];
            if (typeof y == "function" || typeof y == "object" && y !== null) {
                let b = s.o;
                b === null && (s.o = b = new WeakMap);
                const v = b.get(y);
                v === void 0 ? (s = Nb(),
                b.set(y, s)) : s = v
            } else {
                let b = s.p;
                b === null && (s.p = b = new Map);
                const v = b.get(y);
                v === void 0 ? (s = Nb(),
                b.set(y, s)) : s = v
            }
        }
        const u = s;
        let f;
        if (s.s === TL)
            f = s.v;
        else if (f = e.apply(null, arguments),
        o++,
        r) {
            const h = i?.deref?.() ?? i;
            h != null && r(h, f) && (f = h,
            o !== 0 && o--),
            i = typeof f == "object" && f !== null || typeof f == "function" ? new Yde(f) : f
        }
        return u.s = TL,
        u.v = f,
        f
    }
    return a.clearCache = () => {
        n = Nb(),
        a.resetResultsCount()
    }
    ,
    a.resultsCount = () => o,
    a.resetResultsCount = () => {
        o = 0
    }
    ,
    a
}
function Qde(e, ...t) {
    const n = typeof e == "function" ? {
        memoize: e,
        memoizeOptions: t
    } : e
      , r = (...i) => {
        let o = 0, a = 0, s, c = {}, u = i.pop();
        typeof u == "object" && (c = u,
        u = i.pop()),
        Ude(u, `createSelector expects an output function after the inputs, but received: [${typeof u}]`);
        const f = {
            ...n,
            ...c
        }
          , {memoize: h, memoizeOptions: m=[], argsMemoize: y=_0, argsMemoizeOptions: b=[]} = f
          , v = kL(m)
          , S = kL(b)
          , C = qde(i)
          , w = h(function() {
            return o++,
            u.apply(null, arguments)
        }, ...v)
          , k = y(function() {
            a++;
            const E = Wde(C, arguments);
            return s = w.apply(null, E),
            s
        }, ...S);
        return Object.assign(k, {
            resultFunc: u,
            memoizedResultFunc: w,
            dependencies: C,
            dependencyRecomputations: () => a,
            resetDependencyRecomputations: () => {
                a = 0
            }
            ,
            lastResult: () => s,
            recomputations: () => o,
            resetRecomputations: () => {
                o = 0
            }
            ,
            memoize: h,
            argsMemoize: y
        })
    }
    ;
    return Object.assign(r, {
        withTypes: () => r
    }),
    r
}
var JE = Qde(_0)
  , Kde = Object.assign( (e, t=JE) => {
    Vde(e, `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);
    const n = Object.keys(e)
      , r = n.map(o => e[o]);
    return t(r, (...o) => o.reduce( (a, s, c) => (a[n[c]] = s,
    a), {}))
}
, {
    withTypes: () => Kde
});
function v3(e) {
    return ({dispatch: n, getState: r}) => i => o => typeof o == "function" ? o(n, r, e) : i(o)
}
var Xde = v3()
  , Jde = v3
  , efe = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length !== 0)
        return typeof arguments[0] == "object" ? w0 : w0.apply(null, arguments)
}
  , tfe = e => e && typeof e.match == "function";
function It(e, t) {
    function n(...r) {
        if (t) {
            let i = t(...r);
            if (!i)
                throw new Error(qi(0));
            return {
                type: e,
                payload: i.payload,
                ..."meta"in i && {
                    meta: i.meta
                },
                ..."error"in i && {
                    error: i.error
                }
            }
        }
        return {
            type: e,
            payload: r[0]
        }
    }
    return n.toString = () => `${e}`,
    n.type = e,
    n.match = r => ZE(r) && r.type === e,
    n
}
var S3 = class em extends Array {
    constructor(...t) {
        super(...t),
        Object.setPrototypeOf(this, em.prototype)
    }
    static get[Symbol.species]() {
        return em
    }
    concat(...t) {
        return super.concat.apply(this, t)
    }
    prepend(...t) {
        return t.length === 1 && Array.isArray(t[0]) ? new em(...t[0].concat(this)) : new em(...t.concat(this))
    }
}
;
function _L(e) {
    return Xa(e) ? Fg(e, () => {}
    ) : e
}
function Ub(e, t, n) {
    return e.has(t) ? e.get(t) : e.set(t, n(t)).get(t)
}
function nfe(e) {
    return typeof e == "boolean"
}
var rfe = () => function(t) {
    const {thunk: n=!0, immutableCheck: r=!0, serializableCheck: i=!0, actionCreatorCheck: o=!0} = t ?? {};
    let a = new S3;
    return n && (nfe(n) ? a.push(Xde) : a.push(Jde(n.extraArgument))),
    a
}
  , i1 = "RTK_autoBatch"
  , wp = () => e => ({
    payload: e,
    meta: {
        [i1]: !0
    }
})
  , EL = e => t => {
    setTimeout(t, e)
}
  , ife = (e={
    type: "raf"
}) => t => (...n) => {
    const r = t(...n);
    let i = !0
      , o = !1
      , a = !1;
    const s = new Set
      , c = e.type === "tick" ? queueMicrotask : e.type === "raf" ? typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame : EL(10) : e.type === "callback" ? e.queueNotification : EL(e.timeout)
      , u = () => {
        a = !1,
        o && (o = !1,
        s.forEach(f => f()))
    }
    ;
    return Object.assign({}, r, {
        subscribe(f) {
            const h = () => i && f()
              , m = r.subscribe(h);
            return s.add(f),
            () => {
                m(),
                s.delete(f)
            }
        },
        dispatch(f) {
            try {
                return i = !f?.meta?.[i1],
                o = !i,
                o && (a || (a = !0,
                c(u))),
                r.dispatch(f)
            } finally {
                i = !0
            }
        }
    })
}
  , ofe = e => function(n) {
    const {autoBatch: r=!0} = n ?? {};
    let i = new S3(e);
    return r && i.push(ife(typeof r == "object" ? r : void 0)),
    i
}
;
function afe(e) {
    const t = rfe()
      , {reducer: n=void 0, middleware: r, devTools: i=!0, preloadedState: o=void 0, enhancers: a=void 0} = e || {};
    let s;
    if (typeof n == "function")
        s = n;
    else if (Sc(n))
        s = h3(n);
    else
        throw new Error(qi(1));
    let c;
    typeof r == "function" ? c = r(t) : c = t();
    let u = w0;
    i && (u = efe({
        trace: !1,
        ...typeof i == "object" && i
    }));
    const f = Pde(...c)
      , h = ofe(f);
    let m = typeof a == "function" ? a(h) : h();
    const y = u(...m);
    return f3(s, o, y)
}
function C3(e) {
    const t = {}
      , n = [];
    let r;
    const i = {
        addCase(o, a) {
            const s = typeof o == "string" ? o : o.type;
            if (!s)
                throw new Error(qi(28));
            if (s in t)
                throw new Error(qi(29));
            return t[s] = a,
            i
        },
        addAsyncThunk(o, a) {
            return a.pending && (t[o.pending.type] = a.pending),
            a.rejected && (t[o.rejected.type] = a.rejected),
            a.fulfilled && (t[o.fulfilled.type] = a.fulfilled),
            a.settled && n.push({
                matcher: o.settled,
                reducer: a.settled
            }),
            i
        },
        addMatcher(o, a) {
            return n.push({
                matcher: o,
                reducer: a
            }),
            i
        },
        addDefaultCase(o) {
            return r = o,
            i
        }
    };
    return e(i),
    [t, n, r]
}
function sfe(e) {
    return typeof e == "function"
}
function lfe(e, t) {
    let[n,r,i] = C3(t), o;
    if (sfe(e))
        o = () => _L(e());
    else {
        const s = _L(e);
        o = () => s
    }
    function a(s=o(), c) {
        let u = [n[c.type], ...r.filter( ({matcher: f}) => f(c)).map( ({reducer: f}) => f)];
        return u.filter(f => !!f).length === 0 && (u = [i]),
        u.reduce( (f, h) => {
            if (h)
                if (Es(f)) {
                    const y = h(f, c);
                    return y === void 0 ? f : y
                } else {
                    if (Xa(f))
                        return Fg(f, m => h(m, c));
                    {
                        const m = h(f, c);
                        if (m === void 0) {
                            if (f === null)
                                return f;
                            throw Error("A case reducer on a non-draftable value must not return undefined")
                        }
                        return m
                    }
                }
            return f
        }
        , s)
    }
    return a.getInitialState = o,
    a
}
var w3 = (e, t) => tfe(e) ? e.match(t) : e(t);
function kl(...e) {
    return t => e.some(n => w3(n, t))
}
function Cm(...e) {
    return t => e.every(n => w3(n, t))
}
function o1(e, t) {
    if (!e || !e.meta)
        return !1;
    const n = typeof e.meta.requestId == "string"
      , r = t.indexOf(e.meta.requestStatus) > -1;
    return n && r
}
function Ng(e) {
    return typeof e[0] == "function" && "pending"in e[0] && "fulfilled"in e[0] && "rejected"in e[0]
}
function eA(...e) {
    return e.length === 0 ? t => o1(t, ["pending"]) : Ng(e) ? kl(...e.map(t => t.pending)) : eA()(e[0])
}
function Yf(...e) {
    return e.length === 0 ? t => o1(t, ["rejected"]) : Ng(e) ? kl(...e.map(t => t.rejected)) : Yf()(e[0])
}
function a1(...e) {
    const t = n => n && n.meta && n.meta.rejectedWithValue;
    return e.length === 0 ? Cm(Yf(...e), t) : Ng(e) ? Cm(Yf(...e), t) : a1()(e[0])
}
function Cc(...e) {
    return e.length === 0 ? t => o1(t, ["fulfilled"]) : Ng(e) ? kl(...e.map(t => t.fulfilled)) : Cc()(e[0])
}
function pT(...e) {
    return e.length === 0 ? t => o1(t, ["pending", "fulfilled", "rejected"]) : Ng(e) ? kl(...e.flatMap(t => [t.pending, t.rejected, t.fulfilled])) : pT()(e[0])
}
var cfe = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"
  , s1 = (e=21) => {
    let t = ""
      , n = e;
    for (; n--; )
        t += cfe[Math.random() * 64 | 0];
    return t
}
  , ufe = ["name", "message", "stack", "code"]
  , ik = class {
    constructor(e, t) {
        this.payload = e,
        this.meta = t
    }
    _type
}
  , AL = class {
    constructor(e, t) {
        this.payload = e,
        this.meta = t
    }
    _type
}
  , dfe = e => {
    if (typeof e == "object" && e !== null) {
        const t = {};
        for (const n of ufe)
            typeof e[n] == "string" && (t[n] = e[n]);
        return t
    }
    return {
        message: String(e)
    }
}
  , ML = "External signal was aborted"
  , Ja = ( () => {
    function e(t, n, r) {
        const i = It(t + "/fulfilled", (c, u, f, h) => ({
            payload: c,
            meta: {
                ...h || {},
                arg: f,
                requestId: u,
                requestStatus: "fulfilled"
            }
        }))
          , o = It(t + "/pending", (c, u, f) => ({
            payload: void 0,
            meta: {
                ...f || {},
                arg: u,
                requestId: c,
                requestStatus: "pending"
            }
        }))
          , a = It(t + "/rejected", (c, u, f, h, m) => ({
            payload: h,
            error: (r && r.serializeError || dfe)(c || "Rejected"),
            meta: {
                ...m || {},
                arg: f,
                requestId: u,
                rejectedWithValue: !!h,
                requestStatus: "rejected",
                aborted: c?.name === "AbortError",
                condition: c?.name === "ConditionError"
            }
        }));
        function s(c, {signal: u}={}) {
            return (f, h, m) => {
                const y = r?.idGenerator ? r.idGenerator(c) : s1()
                  , b = new AbortController;
                let v, S;
                function C(k) {
                    S = k,
                    b.abort()
                }
                u && (u.aborted ? C(ML) : u.addEventListener("abort", () => C(ML), {
                    once: !0
                }));
                const w = (async function() {
                    let k;
                    try {
                        let E = r?.condition?.(c, {
                            getState: h,
                            extra: m
                        });
                        if (hfe(E) && (E = await E),
                        E === !1 || b.signal.aborted)
                            throw {
                                name: "ConditionError",
                                message: "Aborted due to condition callback returning false."
                            };
                        const P = new Promise( (D, $) => {
                            v = () => {
                                $({
                                    name: "AbortError",
                                    message: S || "Aborted"
                                })
                            }
                            ,
                            b.signal.addEventListener("abort", v)
                        }
                        );
                        f(o(y, c, r?.getPendingMeta?.({
                            requestId: y,
                            arg: c
                        }, {
                            getState: h,
                            extra: m
                        }))),
                        k = await Promise.race([P, Promise.resolve(n(c, {
                            dispatch: f,
                            getState: h,
                            extra: m,
                            requestId: y,
                            signal: b.signal,
                            abort: C,
                            rejectWithValue: (D, $) => new ik(D,$),
                            fulfillWithValue: (D, $) => new AL(D,$)
                        })).then(D => {
                            if (D instanceof ik)
                                throw D;
                            return D instanceof AL ? i(D.payload, y, c, D.meta) : i(D, y, c)
                        }
                        )])
                    } catch (E) {
                        k = E instanceof ik ? a(null, y, c, E.payload, E.meta) : a(E, y, c)
                    } finally {
                        v && b.signal.removeEventListener("abort", v)
                    }
                    return r && !r.dispatchConditionRejection && a.match(k) && k.meta.condition || f(k),
                    k
                }
                )();
                return Object.assign(w, {
                    abort: C,
                    requestId: y,
                    arg: c,
                    unwrap() {
                        return w.then(ffe)
                    }
                })
            }
        }
        return Object.assign(s, {
            pending: o,
            rejected: a,
            fulfilled: i,
            settled: kl(a, i),
            typePrefix: t
        })
    }
    return e.withTypes = () => e,
    e
}
)();
function ffe(e) {
    if (e.meta && e.meta.rejectedWithValue)
        throw e.payload;
    if (e.error)
        throw e.error;
    return e.payload
}
function hfe(e) {
    return e !== null && typeof e == "object" && typeof e.then == "function"
}
var pfe = Symbol.for("rtk-slice-createasyncthunk");
function mfe(e, t) {
    return `${e}/${t}`
}
function gfe({creators: e}={}) {
    const t = e?.asyncThunk?.[pfe];
    return function(r) {
        const {name: i, reducerPath: o=i} = r;
        if (!i)
            throw new Error(qi(11));
        const a = (typeof r.reducers == "function" ? r.reducers(bfe()) : r.reducers) || {}
          , s = Object.keys(a)
          , c = {
            sliceCaseReducersByName: {},
            sliceCaseReducersByType: {},
            actionCreators: {},
            sliceMatchers: []
        }
          , u = {
            addCase(k, T) {
                const E = typeof k == "string" ? k : k.type;
                if (!E)
                    throw new Error(qi(12));
                if (E in c.sliceCaseReducersByType)
                    throw new Error(qi(13));
                return c.sliceCaseReducersByType[E] = T,
                u
            },
            addMatcher(k, T) {
                return c.sliceMatchers.push({
                    matcher: k,
                    reducer: T
                }),
                u
            },
            exposeAction(k, T) {
                return c.actionCreators[k] = T,
                u
            },
            exposeCaseReducer(k, T) {
                return c.sliceCaseReducersByName[k] = T,
                u
            }
        };
        s.forEach(k => {
            const T = a[k]
              , E = {
                reducerName: k,
                type: mfe(i, k),
                createNotation: typeof r.reducers == "function"
            };
            vfe(T) ? Cfe(E, T, u, t) : xfe(E, T, u)
        }
        );
        function f() {
            const [k={},T=[],E=void 0] = typeof r.extraReducers == "function" ? C3(r.extraReducers) : [r.extraReducers]
              , P = {
                ...k,
                ...c.sliceCaseReducersByType
            };
            return lfe(r.initialState, D => {
                for (let $ in P)
                    D.addCase($, P[$]);
                for (let $ of c.sliceMatchers)
                    D.addMatcher($.matcher, $.reducer);
                for (let $ of T)
                    D.addMatcher($.matcher, $.reducer);
                E && D.addDefaultCase(E)
            }
            )
        }
        const h = k => k
          , m = new Map
          , y = new WeakMap;
        let b;
        function v(k, T) {
            return b || (b = f()),
            b(k, T)
        }
        function S() {
            return b || (b = f()),
            b.getInitialState()
        }
        function C(k, T=!1) {
            function E(D) {
                let $ = D[k];
                return typeof $ > "u" && T && ($ = Ub(y, E, S)),
                $
            }
            function P(D=h) {
                const $ = Ub(m, T, () => new WeakMap);
                return Ub($, D, () => {
                    const z = {};
                    for (const [O,I] of Object.entries(r.selectors ?? {}))
                        z[O] = yfe(I, D, () => Ub(y, D, S), T);
                    return z
                }
                )
            }
            return {
                reducerPath: k,
                getSelectors: P,
                get selectors() {
                    return P(E)
                },
                selectSlice: E
            }
        }
        const w = {
            name: i,
            reducer: v,
            actions: c.actionCreators,
            caseReducers: c.sliceCaseReducersByName,
            getInitialState: S,
            ...C(o),
            injectInto(k, {reducerPath: T, ...E}={}) {
                const P = T ?? o;
                return k.inject({
                    reducerPath: P,
                    reducer: v
                }, E),
                {
                    ...w,
                    ...C(P, !0)
                }
            }
        };
        return w
    }
}
function yfe(e, t, n, r) {
    function i(o, ...a) {
        let s = t(o);
        return typeof s > "u" && r && (s = n()),
        e(s, ...a)
    }
    return i.unwrapped = e,
    i
}
var Vo = gfe();
function bfe() {
    function e(t, n) {
        return {
            _reducerDefinitionType: "asyncThunk",
            payloadCreator: t,
            ...n
        }
    }
    return e.withTypes = () => e,
    {
        reducer(t) {
            return Object.assign({
                [t.name](...n) {
                    return t(...n)
                }
            }[t.name], {
                _reducerDefinitionType: "reducer"
            })
        },
        preparedReducer(t, n) {
            return {
                _reducerDefinitionType: "reducerWithPrepare",
                prepare: t,
                reducer: n
            }
        },
        asyncThunk: e
    }
}
function xfe({type: e, reducerName: t, createNotation: n}, r, i) {
    let o, a;
    if ("reducer"in r) {
        if (n && !Sfe(r))
            throw new Error(qi(17));
        o = r.reducer,
        a = r.prepare
    } else
        o = r;
    i.addCase(e, o).exposeCaseReducer(t, o).exposeAction(t, a ? It(e, a) : It(e))
}
function vfe(e) {
    return e._reducerDefinitionType === "asyncThunk"
}
function Sfe(e) {
    return e._reducerDefinitionType === "reducerWithPrepare"
}
function Cfe({type: e, reducerName: t}, n, r, i) {
    if (!i)
        throw new Error(qi(18));
    const {payloadCreator: o, fulfilled: a, pending: s, rejected: c, settled: u, options: f} = n
      , h = i(e, o, f);
    r.exposeAction(t, h),
    a && r.addCase(h.fulfilled, a),
    s && r.addCase(h.pending, s),
    c && r.addCase(h.rejected, c),
    u && r.addMatcher(h.settled, u),
    r.exposeCaseReducer(t, {
        fulfilled: a || Vb,
        pending: s || Vb,
        rejected: c || Vb,
        settled: u || Vb
    })
}
function Vb() {}
var wfe = "task"
  , k3 = "listener"
  , T3 = "completed"
  , tA = "cancelled"
  , kfe = `task-${tA}`
  , Tfe = `task-${T3}`
  , mT = `${k3}-${tA}`
  , _fe = `${k3}-${T3}`
  , l1 = class {
    constructor(e) {
        this.code = e,
        this.message = `${wfe} ${tA} (reason: ${e})`
    }
    name = "TaskAbortError";
    message
}
  , nA = (e, t) => {
    if (typeof e != "function")
        throw new TypeError(qi(32))
}
  , E0 = () => {}
  , _3 = (e, t=E0) => (e.catch(t),
e)
  , E3 = (e, t) => (e.addEventListener("abort", t, {
    once: !0
}),
() => e.removeEventListener("abort", t))
  , Pu = (e, t) => {
    const n = e.signal;
    n.aborted || ("reason"in n || Object.defineProperty(n, "reason", {
        enumerable: !0,
        value: t,
        configurable: !0,
        writable: !0
    }),
    e.abort(t))
}
  , Ru = e => {
    if (e.aborted) {
        const {reason: t} = e;
        throw new l1(t)
    }
}
;
function A3(e, t) {
    let n = E0;
    return new Promise( (r, i) => {
        const o = () => i(new l1(e.reason));
        if (e.aborted) {
            o();
            return
        }
        n = E3(e, o),
        t.finally( () => n()).then(r, i)
    }
    ).finally( () => {
        n = E0
    }
    )
}
var Efe = async (e, t) => {
    try {
        return await Promise.resolve(),
        {
            status: "ok",
            value: await e()
        }
    } catch (n) {
        return {
            status: n instanceof l1 ? "cancelled" : "rejected",
            error: n
        }
    } finally {
        t?.()
    }
}
  , A0 = e => t => _3(A3(e, t).then(n => (Ru(e),
n)))
  , M3 = e => {
    const t = A0(e);
    return n => t(new Promise(r => setTimeout(r, n)))
}
  , {assign: Sf} = Object
  , PL = {}
  , c1 = "listenerMiddleware"
  , Afe = (e, t) => {
    const n = r => E3(e, () => Pu(r, e.reason));
    return (r, i) => {
        nA(r);
        const o = new AbortController;
        n(o);
        const a = Efe(async () => {
            Ru(e),
            Ru(o.signal);
            const s = await r({
                pause: A0(o.signal),
                delay: M3(o.signal),
                signal: o.signal
            });
            return Ru(o.signal),
            s
        }
        , () => Pu(o, Tfe));
        return i?.autoJoin && t.push(a.catch(E0)),
        {
            result: A0(e)(a),
            cancel() {
                Pu(o, kfe)
            }
        }
    }
}
  , Mfe = (e, t) => {
    const n = async (r, i) => {
        Ru(t);
        let o = () => {}
        ;
        const s = [new Promise( (c, u) => {
            let f = e({
                predicate: r,
                effect: (h, m) => {
                    m.unsubscribe(),
                    c([h, m.getState(), m.getOriginalState()])
                }
            });
            o = () => {
                f(),
                u()
            }
        }
        )];
        i != null && s.push(new Promise(c => setTimeout(c, i, null)));
        try {
            const c = await A3(t, Promise.race(s));
            return Ru(t),
            c
        } finally {
            o()
        }
    }
    ;
    return (r, i) => _3(n(r, i))
}
  , P3 = e => {
    let {type: t, actionCreator: n, matcher: r, predicate: i, effect: o} = e;
    if (t)
        i = It(t).match;
    else if (n)
        t = n.type,
        i = n.match;
    else if (r)
        i = r;
    else if (!i)
        throw new Error(qi(21));
    return nA(o),
    {
        predicate: i,
        type: t,
        effect: o
    }
}
  , R3 = Sf(e => {
    const {type: t, predicate: n, effect: r} = P3(e);
    return {
        id: s1(),
        effect: r,
        type: t,
        predicate: n,
        pending: new Set,
        unsubscribe: () => {
            throw new Error(qi(22))
        }
    }
}
, {
    withTypes: () => R3
})
  , RL = (e, t) => {
    const {type: n, effect: r, predicate: i} = P3(t);
    return Array.from(e.values()).find(o => (typeof n == "string" ? o.type === n : o.predicate === i) && o.effect === r)
}
  , gT = e => {
    e.pending.forEach(t => {
        Pu(t, mT)
    }
    )
}
  , Pfe = (e, t) => () => {
    for (const n of t.keys())
        gT(n);
    e.clear()
}
  , DL = (e, t, n) => {
    try {
        e(t, n)
    } catch (r) {
        setTimeout( () => {
            throw r
        }
        , 0)
    }
}
  , D3 = Sf(It(`${c1}/add`), {
    withTypes: () => D3
})
  , Rfe = It(`${c1}/removeAll`)
  , O3 = Sf(It(`${c1}/remove`), {
    withTypes: () => O3
})
  , Dfe = (...e) => {
    console.error(`${c1}/error`, ...e)
}
  , Ofe = (e={}) => {
    const t = new Map
      , n = new Map
      , r = y => {
        const b = n.get(y) ?? 0;
        n.set(y, b + 1)
    }
      , i = y => {
        const b = n.get(y) ?? 1;
        b === 1 ? n.delete(y) : n.set(y, b - 1)
    }
      , {extra: o, onError: a=Dfe} = e;
    nA(a);
    const s = y => (y.unsubscribe = () => t.delete(y.id),
    t.set(y.id, y),
    b => {
        y.unsubscribe(),
        b?.cancelActive && gT(y)
    }
    )
      , c = y => {
        const b = RL(t, y) ?? R3(y);
        return s(b)
    }
    ;
    Sf(c, {
        withTypes: () => c
    });
    const u = y => {
        const b = RL(t, y);
        return b && (b.unsubscribe(),
        y.cancelActive && gT(b)),
        !!b
    }
    ;
    Sf(u, {
        withTypes: () => u
    });
    const f = async (y, b, v, S) => {
        const C = new AbortController
          , w = Mfe(c, C.signal)
          , k = [];
        try {
            y.pending.add(C),
            r(y),
            await Promise.resolve(y.effect(b, Sf({}, v, {
                getOriginalState: S,
                condition: (T, E) => w(T, E).then(Boolean),
                take: w,
                delay: M3(C.signal),
                pause: A0(C.signal),
                extra: o,
                signal: C.signal,
                fork: Afe(C.signal, k),
                unsubscribe: y.unsubscribe,
                subscribe: () => {
                    t.set(y.id, y)
                }
                ,
                cancelActiveListeners: () => {
                    y.pending.forEach( (T, E, P) => {
                        T !== C && (Pu(T, mT),
                        P.delete(T))
                    }
                    )
                }
                ,
                cancel: () => {
                    Pu(C, mT),
                    y.pending.delete(C)
                }
                ,
                throwIfCancelled: () => {
                    Ru(C.signal)
                }
            })))
        } catch (T) {
            T instanceof l1 || DL(a, T, {
                raisedBy: "effect"
            })
        } finally {
            await Promise.all(k),
            Pu(C, _fe),
            i(y),
            y.pending.delete(C)
        }
    }
      , h = Pfe(t, n);
    return {
        middleware: y => b => v => {
            if (!ZE(v))
                return b(v);
            if (D3.match(v))
                return c(v.payload);
            if (Rfe.match(v)) {
                h();
                return
            }
            if (O3.match(v))
                return u(v.payload);
            let S = y.getState();
            const C = () => {
                if (S === PL)
                    throw new Error(qi(23));
                return S
            }
            ;
            let w;
            try {
                if (w = b(v),
                t.size > 0) {
                    const k = y.getState()
                      , T = Array.from(t.values());
                    for (const E of T) {
                        let P = !1;
                        try {
                            P = E.predicate(v, k, S)
                        } catch (D) {
                            P = !1,
                            DL(a, D, {
                                raisedBy: "predicate"
                            })
                        }
                        P && f(E, v, y, C)
                    }
                }
            } finally {
                S = PL
            }
            return w
        }
        ,
        startListening: c,
        stopListening: u,
        clearListeners: h
    }
}
;
function qi(e) {
    return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
}
var ts = function(t) {
    return "@@redux-saga/" + t
}
  , Ife = ts("CANCEL_PROMISE")
  , I3 = ts("CHANNEL_END")
  , $3 = ts("IO")
  , OL = ts("MATCH")
  , L3 = ts("MULTICAST")
  , j3 = ts("SAGA_ACTION")
  , B3 = ts("SELF_CANCELLATION")
  , $fe = ts("TASK")
  , Cf = ts("TASK_CANCEL")
  , z3 = ts("TERMINATE")
  , Lfe = ts("LOCATION")
  , F3 = function(t) {
    return t == null
}
  , Rx = function(t) {
    return t != null
}
  , wo = function(t) {
    return typeof t == "function"
}
  , rA = function(t) {
    return typeof t == "string"
}
  , Dc = Array.isArray
  , u1 = function(t) {
    return t && wo(t.then)
}
  , iA = function(t) {
    return t && wo(t.next) && wo(t.throw)
}
  , yT = function(t) {
    return t && (rA(t) || U3(t) || wo(t) || Dc(t) && t.every(yT))
}
  , oA = function(t) {
    return t && wo(t.take) && wo(t.close)
}
  , N3 = function(t) {
    return wo(t) && t.hasOwnProperty("toString")
}
  , U3 = function(t) {
    return !!t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype
}
  , jfe = function(t) {
    return oA(t) && t[L3]
}
  , Bfe = function(t) {
    return function() {
        return t
    }
}
  , zfe = Bfe(!0)
  , zi = function() {}
  , V3 = function(t) {
    return t
}
  , aA = function(t, n) {
    ge(t, n),
    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(n).forEach(function(r) {
        t[r] = n[r]
    })
}
  , Ffe = function(t, n) {
    var r;
    return (r = []).concat.apply(r, n.map(t))
};
function d1(e, t) {
    var n = e.indexOf(t);
    n >= 0 && e.splice(n, 1)
}
function Nfe(e) {
    var t = !1;
    return function() {
        t || (t = !0,
        e())
    }
}
var Ufe = function(t) {
    throw t
}
  , Vfe = function(t) {
    return {
        value: t,
        done: !0
    }
};
function bT(e, t, n) {
    t === void 0 && (t = Ufe),
    n === void 0 && (n = "iterator");
    var r = {
        meta: {
            name: n
        },
        next: e,
        throw: t,
        return: Vfe,
        isSagaIterator: !0
    };
    return typeof Symbol < "u" && (r[Symbol.iterator] = function() {
        return r
    }
    ),
    r
}
function Hfe(e, t) {
    var n = t.sagaStack;
    console.error(e),
    console.error(n)
}
var H3 = function(t) {
    return Array.apply(null, new Array(t))
}
  , qfe = function(t) {
    return function(n) {
        return t(Object.defineProperty(n, j3, {
            value: !0
        }))
    }
}
  , q3 = function(t) {
    return t === z3
}
  , W3 = function(t) {
    return t === Cf
}
  , G3 = function(t) {
    return q3(t) || W3(t)
};
function Y3(e, t) {
    var n = Object.keys(e), r = n.length, i = 0, o, a = Dc(e) ? H3(r) : {}, s = {};
    function c() {
        i === r && (o = !0,
        t(a))
    }
    return n.forEach(function(u) {
        var f = function(m, y) {
            o || (y || G3(m) ? (t.cancel(),
            t(m, y)) : (a[u] = m,
            i++,
            c()))
        };
        f.cancel = zi,
        s[u] = f
    }),
    t.cancel = function() {
        o || (o = !0,
        n.forEach(function(u) {
            return s[u].cancel()
        }))
    }
    ,
    s
}
function sA(e) {
    return {
        name: e.name || "anonymous",
        location: Z3(e)
    }
}
function Z3(e) {
    return e[Lfe]
}
function Wfe() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return t.length === 0 ? function(r) {
        return r
    }
    : t.length === 1 ? t[0] : t.reduce(function(r, i) {
        return function() {
            return r(i.apply(void 0, arguments))
        }
    })
}
var Gfe = "Channel's Buffer overflow!"
  , Yfe = 1
  , Zfe = 3
  , Q3 = 4;
function Qfe(e, t) {
    e === void 0 && (e = 10);
    var n = new Array(e)
      , r = 0
      , i = 0
      , o = 0
      , a = function(f) {
        n[i] = f,
        i = (i + 1) % e,
        r++
    }
      , s = function() {
        if (r != 0) {
            var f = n[o];
            return n[o] = null,
            r--,
            o = (o + 1) % e,
            f
        }
    }
      , c = function() {
        for (var f = []; r; )
            f.push(s());
        return f
    };
    return {
        isEmpty: function() {
            return r == 0
        },
        put: function(f) {
            if (r < e)
                a(f);
            else {
                var h;
                switch (t) {
                case Yfe:
                    throw new Error(Gfe);
                case Zfe:
                    n[i] = f,
                    i = (i + 1) % e,
                    o = i;
                    break;
                case Q3:
                    h = 2 * e,
                    n = c(),
                    r = n.length,
                    i = n.length,
                    o = 0,
                    n.length = h,
                    e = h,
                    a(f);
                    break
                }
            }
        },
        take: s,
        flush: c
    }
}
var Kfe = function(t) {
    return Qfe(t, Q3)
}
  , Dx = "TAKE"
  , K3 = "PUT"
  , X3 = "ALL"
  , Xfe = "RACE"
  , J3 = "CALL"
  , Jfe = "CPS"
  , e4 = "FORK"
  , ehe = "JOIN"
  , t4 = "CANCEL"
  , n4 = "SELECT"
  , the = "ACTION_CHANNEL"
  , nhe = "CANCELLED"
  , rhe = "FLUSH"
  , ihe = "GET_CONTEXT"
  , ohe = "SET_CONTEXT"
  , bl = function(t, n) {
    var r;
    return r = {},
    r[$3] = !0,
    r.combinator = !1,
    r.type = t,
    r.payload = n,
    r
};
function r4(e, t) {
    if (e === void 0 && (e = "*"),
    yT(e))
        return Rx(t) && console.warn("take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types"),
        bl(Dx, {
            pattern: e
        });
    if (jfe(e) && Rx(t) && yT(t))
        return bl(Dx, {
            channel: e,
            pattern: t
        });
    if (oA(e))
        return Rx(t) && console.warn("take(channel) takes one argument but two were provided. Second argument is ignored."),
        bl(Dx, {
            channel: e
        })
}
function yt(e, t) {
    return F3(t) && (t = e,
    e = void 0),
    bl(K3, {
        channel: e,
        action: t
    })
}
function f1(e) {
    var t = bl(X3, e);
    return t.combinator = !0,
    t
}
function i4(e, t) {
    var n = null, r;
    return wo(e) ? r = e : (Dc(e) ? (n = e[0],
    r = e[1]) : (n = e.context,
    r = e.fn),
    n && rA(r) && wo(n[r]) && (r = n[r])),
    {
        context: n,
        fn: r,
        args: t
    }
}
function Dr(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        n[r - 1] = arguments[r];
    return bl(J3, i4(e, n))
}
function Un(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        n[r - 1] = arguments[r];
    return bl(e4, i4(e, n))
}
function ahe(e) {
    return e === void 0 && (e = B3),
    bl(t4, e)
}
function she(e) {
    e === void 0 && (e = V3);
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        n[r - 1] = arguments[r];
    return bl(n4, {
        selector: e,
        args: n
    })
}
function lhe() {
    var e = {};
    return e.promise = new Promise(function(t, n) {
        e.resolve = t,
        e.reject = n
    }
    ),
    e
}
var o4 = []
  , h1 = 0;
function che(e) {
    try {
        lA(),
        e()
    } finally {
        l4()
    }
}
function a4(e) {
    o4.push(e),
    h1 || (lA(),
    c4())
}
function s4(e) {
    try {
        return lA(),
        e()
    } finally {
        c4()
    }
}
function lA() {
    h1++
}
function l4() {
    h1--
}
function c4() {
    l4();
    for (var e; !h1 && (e = o4.shift()) !== void 0; )
        che(e)
}
var uhe = function(t) {
    return function(n) {
        return t.some(function(r) {
            return cA(r)(n)
        })
    }
}
  , dhe = function(t) {
    return function(n) {
        return t(n)
    }
}
  , IL = function(t) {
    return function(n) {
        return n.type === String(t)
    }
}
  , fhe = function(t) {
    return function(n) {
        return n.type === t
    }
}
  , u4 = function() {
    return zfe
};
function cA(e) {
    var t = e === "*" ? u4 : rA(e) ? IL : Dc(e) ? uhe : N3(e) ? IL : wo(e) ? dhe : U3(e) ? fhe : null;
    if (t === null)
        throw new Error("invalid pattern: " + e);
    return t(e)
}
var wm = {
    type: I3
}
  , uA = function(t) {
    return t && t.type === I3
};
function hhe(e) {
    e === void 0 && (e = Kfe());
    var t = !1
      , n = [];
    function r(s) {
        if (!t) {
            if (n.length === 0)
                return e.put(s);
            var c = n.shift();
            c(s)
        }
    }
    function i(s) {
        t && e.isEmpty() ? s(wm) : e.isEmpty() ? (n.push(s),
        s.cancel = function() {
            d1(n, s)
        }
        ) : s(e.take())
    }
    function o(s) {
        if (t && e.isEmpty()) {
            s(wm);
            return
        }
        s(e.flush())
    }
    function a() {
        if (!t) {
            t = !0;
            var s = n;
            n = [];
            for (var c = 0, u = s.length; c < u; c++) {
                var f = s[c];
                f(wm)
            }
        }
    }
    return {
        take: i,
        put: r,
        flush: o,
        close: a
    }
}
function phe() {
    var e, t = !1, n = [], r = n, i = function() {
        r === n && (r = n.slice())
    }, o = function() {
        t = !0;
        var s = n = r;
        r = [],
        s.forEach(function(c) {
            c(wm)
        })
    };
    return e = {},
    e[L3] = !0,
    e.put = function(s) {
        if (!t) {
            if (uA(s)) {
                o();
                return
            }
            for (var c = n = r, u = 0, f = c.length; u < f; u++) {
                var h = c[u];
                h[OL](s) && (h.cancel(),
                h(s))
            }
        }
    }
    ,
    e.take = function(s, c) {
        if (c === void 0 && (c = u4),
        t) {
            s(wm);
            return
        }
        s[OL] = c,
        i(),
        r.push(s),
        s.cancel = Nfe(function() {
            i(),
            d1(r, s)
        })
    }
    ,
    e.close = o,
    e
}
function d4() {
    var e = phe()
      , t = e.put;
    return e.put = function(n) {
        if (n[j3]) {
            t(n);
            return
        }
        a4(function() {
            t(n)
        })
    }
    ,
    e
}
var bu = 0
  , pl = 1
  , Ox = 2
  , f4 = 3;
function dA(e, t) {
    var n = e[Ife];
    wo(n) && (t.cancel = n),
    e.then(t, function(r) {
        t(r, !0)
    })
}
var Ug = 0, h4 = (function() {
    return ++Ug
}
), mi;
function mhe(e, t) {
    return e.isSagaIterator ? {
        name: e.meta.name
    } : sA(t)
}
function ghe(e) {
    var t = e.context
      , n = e.fn
      , r = e.args;
    try {
        var i = n.apply(t, r);
        if (iA(i))
            return i;
        var o = !1
          , a = function(c) {
            return o ? {
                value: c,
                done: !0
            } : (o = !0,
            {
                value: i,
                done: !u1(i)
            })
        };
        return bT(a)
    } catch (s) {
        return bT(function() {
            throw s
        })
    }
}
function yhe(e, t, n) {
    var r = t.channel
      , i = t.action
      , o = t.resolve;
    a4(function() {
        var a;
        try {
            a = (r ? r.put : e.dispatch)(i)
        } catch (s) {
            n(s, !0);
            return
        }
        o && u1(a) ? dA(a, n) : n(a)
    })
}
function bhe(e, t, n) {
    var r = t.channel
      , i = r === void 0 ? e.channel : r
      , o = t.pattern
      , a = t.maybe
      , s = function(u) {
        if (u instanceof Error) {
            n(u, !0);
            return
        }
        if (uA(u) && !a) {
            n(z3);
            return
        }
        n(u)
    };
    try {
        i.take(s, Rx(o) ? cA(o) : null)
    } catch (c) {
        n(c, !0);
        return
    }
    n.cancel = s.cancel
}
function xhe(e, t, n, r) {
    var i = t.context
      , o = t.fn
      , a = t.args
      , s = r.task;
    try {
        var c = o.apply(i, a);
        if (u1(c)) {
            dA(c, n);
            return
        }
        if (iA(c)) {
            p1(e, c, s.context, Ug, sA(o), !1, n);
            return
        }
        n(c)
    } catch (u) {
        n(u, !0)
    }
}
function vhe(e, t, n) {
    var r = t.context
      , i = t.fn
      , o = t.args;
    try {
        var a = function(c, u) {
            F3(c) ? n(u) : n(c, !0)
        };
        i.apply(r, o.concat(a)),
        a.cancel && (n.cancel = a.cancel)
    } catch (s) {
        n(s, !0)
    }
}
function She(e, t, n, r) {
    var i = t.context
      , o = t.fn
      , a = t.args
      , s = t.detached
      , c = r.task
      , u = ghe({
        context: i,
        fn: o,
        args: a
    })
      , f = mhe(u, o);
    s4(function() {
        var h = p1(e, u, c.context, Ug, f, s, void 0);
        s ? n(h) : h.isRunning() ? (c.queue.addTask(h),
        n(h)) : h.isAborted() ? c.queue.abort(h.error()) : n(h)
    })
}
function Che(e, t, n, r) {
    var i = r.task
      , o = function(c, u) {
        if (c.isRunning()) {
            var f = {
                task: i,
                cb: u
            };
            u.cancel = function() {
                c.isRunning() && d1(c.joiners, f)
            }
            ,
            c.joiners.push(f)
        } else
            c.isAborted() ? u(c.error(), !0) : u(c.result())
    };
    if (Dc(t)) {
        if (t.length === 0) {
            n([]);
            return
        }
        var a = Y3(t, n);
        t.forEach(function(s, c) {
            o(s, a[c])
        })
    } else
        o(t, n)
}
function ok(e) {
    e.isRunning() && e.cancel()
}
function whe(e, t, n, r) {
    var i = r.task;
    t === B3 ? ok(i) : Dc(t) ? t.forEach(ok) : ok(t),
    n()
}
function khe(e, t, n, r) {
    var i = r.digestEffect
      , o = Ug
      , a = Object.keys(t);
    if (a.length === 0) {
        n(Dc(t) ? [] : {});
        return
    }
    var s = Y3(t, n);
    a.forEach(function(c) {
        i(t[c], o, s[c], c)
    })
}
function The(e, t, n, r) {
    var i = r.digestEffect
      , o = Ug
      , a = Object.keys(t)
      , s = Dc(t) ? H3(a.length) : {}
      , c = {}
      , u = !1;
    a.forEach(function(f) {
        var h = function(y, b) {
            u || (b || G3(y) ? (n.cancel(),
            n(y, b)) : (n.cancel(),
            u = !0,
            s[f] = y,
            n(s)))
        };
        h.cancel = zi,
        c[f] = h
    }),
    n.cancel = function() {
        u || (u = !0,
        a.forEach(function(f) {
            return c[f].cancel()
        }))
    }
    ,
    a.forEach(function(f) {
        u || i(t[f], o, c[f], f)
    })
}
function _he(e, t, n) {
    var r = t.selector
      , i = t.args;
    try {
        var o = r.apply(void 0, [e.getState()].concat(i));
        n(o)
    } catch (a) {
        n(a, !0)
    }
}
function Ehe(e, t, n) {
    var r = t.pattern
      , i = t.buffer
      , o = hhe(i)
      , a = cA(r)
      , s = function(f) {
        uA(f) || e.channel.take(s, a),
        o.put(f)
    }
      , c = o.close;
    o.close = function() {
        s.cancel(),
        c()
    }
    ,
    e.channel.take(s, a),
    n(o)
}
function Ahe(e, t, n, r) {
    var i = r.task;
    n(i.isCancelled())
}
function Mhe(e, t, n) {
    t.flush(n)
}
function Phe(e, t, n, r) {
    var i = r.task;
    n(i.context[t])
}
function Rhe(e, t, n, r) {
    var i = r.task;
    aA(i.context, t),
    n()
}
var Dhe = (mi = {},
mi[Dx] = bhe,
mi[K3] = yhe,
mi[X3] = khe,
mi[Xfe] = The,
mi[J3] = xhe,
mi[Jfe] = vhe,
mi[e4] = She,
mi[ehe] = Che,
mi[t4] = whe,
mi[n4] = _he,
mi[the] = Ehe,
mi[nhe] = Ahe,
mi[rhe] = Mhe,
mi[ihe] = Phe,
mi[ohe] = Rhe,
mi);
function Ohe(e, t, n) {
    var r = [], i, o = !1;
    c(e);
    var a = function() {
        return r
    };
    function s(f) {
        t(),
        u(),
        n(f, !0)
    }
    function c(f) {
        r.push(f),
        f.cont = function(h, m) {
            o || (d1(r, f),
            f.cont = zi,
            m ? s(h) : (f === e && (i = h),
            r.length || (o = !0,
            n(i))))
        }
    }
    function u() {
        o || (o = !0,
        r.forEach(function(f) {
            f.cont = zi,
            f.cancel()
        }),
        r = [])
    }
    return {
        addTask: c,
        cancelAll: u,
        abort: s,
        getTasks: a
    }
}
function p4(e, t) {
    return e + "?" + t
}
function Ihe(e) {
    var t = Z3(e);
    if (t) {
        var n = t.code
          , r = t.fileName
          , i = t.lineNumber
          , o = n + "  " + p4(r, i);
        return o
    }
    return ""
}
function $L(e) {
    var t = e.name
      , n = e.location;
    return n ? t + "  " + p4(n.fileName, n.lineNumber) : t
}
function $he(e) {
    var t = Ffe(function(n) {
        return n.cancelledTasks
    }, e);
    return t.length ? ["Tasks cancelled due to error:"].concat(t).join(`
`) : ""
}
var fA = null
  , km = []
  , Lhe = function(t) {
    t.crashedEffect = fA,
    km.push(t)
}
  , m4 = function() {
    fA = null,
    km.length = 0
}
  , jhe = function(t) {
    fA = t
}
  , Bhe = function() {
    var t = km[0]
      , n = km.slice(1)
      , r = t.crashedEffect ? Ihe(t.crashedEffect) : null
      , i = "The above error occurred in task " + $L(t.meta) + (r ? ` 
 when executing effect ` + r : "");
    return [i].concat(n.map(function(o) {
        return "    created by " + $L(o.meta)
    }), [$he(km)]).join(`
`)
};
function zhe(e, t, n, r, i, o, a) {
    var s;
    a === void 0 && (a = zi);
    var c = bu, u, f, h = null, m = [], y = Object.create(n), b = Ohe(t, function() {
        m.push.apply(m, b.getTasks().map(function(E) {
            return E.meta.name
        }))
    }, S);
    function v() {
        c === bu && (c = pl,
        b.cancelAll(),
        S(Cf, !1))
    }
    function S(T, E) {
        if (!E)
            T === Cf ? c = pl : c !== pl && (c = f4),
            u = T,
            h && h.resolve(T);
        else {
            if (c = Ox,
            Lhe({
                meta: i,
                cancelledTasks: m
            }),
            k.isRoot) {
                var P = Bhe();
                m4(),
                e.onError(T, {
                    sagaStack: P
                })
            }
            f = T,
            h && h.reject(T)
        }
        k.cont(T, E),
        k.joiners.forEach(function(D) {
            D.cb(T, E)
        }),
        k.joiners = null
    }
    function C(T) {
        aA(y, T)
    }
    function w() {
        return h || (h = lhe(),
        c === Ox ? h.reject(f) : c !== bu && h.resolve(u)),
        h.promise
    }
    var k = (s = {},
    s[$fe] = !0,
    s.id = r,
    s.meta = i,
    s.isRoot = o,
    s.context = y,
    s.joiners = [],
    s.queue = b,
    s.cancel = v,
    s.cont = a,
    s.end = S,
    s.setContext = C,
    s.toPromise = w,
    s.isRunning = function() {
        return c === bu
    }
    ,
    s.isCancelled = function() {
        return c === pl || c === bu && t.status === pl
    }
    ,
    s.isAborted = function() {
        return c === Ox
    }
    ,
    s.result = function() {
        return u
    }
    ,
    s.error = function() {
        return f
    }
    ,
    s);
    return k
}
function p1(e, t, n, r, i, o, a) {
    var s = e.finalizeRunEffect(y);
    m.cancel = zi;
    var c = {
        meta: i,
        cancel: h,
        status: bu
    }
      , u = zhe(e, c, n, r, i, o, a)
      , f = {
        task: u,
        digestEffect: b
    };
    function h() {
        c.status === bu && (c.status = pl,
        m(Cf))
    }
    return a && (a.cancel = u.cancel),
    m(),
    u;
    function m(v, S) {
        try {
            var C;
            S ? (C = t.throw(v),
            m4()) : W3(v) ? (c.status = pl,
            m.cancel(),
            C = wo(t.return) ? t.return(Cf) : {
                done: !0,
                value: Cf
            }) : q3(v) ? C = wo(t.return) ? t.return() : {
                done: !0
            } : C = t.next(v),
            C.done ? (c.status !== pl && (c.status = f4),
            c.cont(C.value)) : b(C.value, r, m)
        } catch (w) {
            if (c.status === pl)
                throw w;
            c.status = Ox,
            c.cont(w, !0)
        }
    }
    function y(v, S, C) {
        if (u1(v))
            dA(v, C);
        else if (iA(v))
            p1(e, v, u.context, S, i, !1, C);
        else if (v && v[$3]) {
            var w = Dhe[v.type];
            w(e, v.payload, C, f)
        } else
            C(v)
    }
    function b(v, S, C, w) {
        w === void 0 && (w = "");
        var k = h4();
        e.sagaMonitor && e.sagaMonitor.effectTriggered({
            effectId: k,
            parentEffectId: S,
            label: w,
            effect: v
        });
        var T;
        function E(P, D) {
            T || (T = !0,
            C.cancel = zi,
            e.sagaMonitor && (D ? e.sagaMonitor.effectRejected(k, P) : e.sagaMonitor.effectResolved(k, P)),
            D && jhe(v),
            C(P, D))
        }
        E.cancel = zi,
        C.cancel = function() {
            T || (T = !0,
            E.cancel(),
            E.cancel = zi,
            e.sagaMonitor && e.sagaMonitor.effectCancelled(k))
        }
        ,
        s(v, k, E)
    }
}
function Fhe(e, t) {
    for (var n = e.channel, r = n === void 0 ? d4() : n, i = e.dispatch, o = e.getState, a = e.context, s = a === void 0 ? {} : a, c = e.sagaMonitor, u = e.effectMiddlewares, f = e.onError, h = f === void 0 ? Hfe : f, m = arguments.length, y = new Array(m > 2 ? m - 2 : 0), b = 2; b < m; b++)
        y[b - 2] = arguments[b];
    var v = t.apply(void 0, y)
      , S = h4();
    c && (c.rootSagaStarted = c.rootSagaStarted || zi,
    c.effectTriggered = c.effectTriggered || zi,
    c.effectResolved = c.effectResolved || zi,
    c.effectRejected = c.effectRejected || zi,
    c.effectCancelled = c.effectCancelled || zi,
    c.actionDispatched = c.actionDispatched || zi,
    c.rootSagaStarted({
        effectId: S,
        saga: t,
        args: y
    }));
    var C;
    if (u) {
        var w = Wfe.apply(void 0, u);
        C = function(E) {
            return function(P, D, $) {
                var z = function(I) {
                    return E(I, D, $)
                };
                return w(z)(P)
            }
        }
    } else
        C = V3;
    var k = {
        channel: r,
        dispatch: qfe(i),
        getState: o,
        sagaMonitor: c,
        onError: h,
        finalizeRunEffect: C
    };
    return s4(function() {
        var T = p1(k, v, s, S, sA(t), !0, void 0);
        return c && c.effectResolved(S, T),
        T
    })
}
var Nhe = ["context", "channel", "sagaMonitor"];
function Uhe(e) {
    var t = {}, n = t.context, r = n === void 0 ? {} : n, i = t.channel, o = i === void 0 ? d4() : i, a = t.sagaMonitor, s = Qt(t, Nhe), c;
    function u(f) {
        var h = f.getState
          , m = f.dispatch;
        return c = Fhe.bind(null, ge({}, s, {
            context: r,
            channel: o,
            dispatch: m,
            getState: h,
            sagaMonitor: a
        })),
        function(y) {
            return function(b) {
                a && a.actionDispatched && a.actionDispatched(b);
                var v = y(b);
                return o.put(b),
                v
            }
        }
    }
    return u.run = function() {
        return c.apply(void 0, arguments)
    }
    ,
    u.setContext = function(f) {
        aA(r, f)
    }
    ,
    u
}
const Vhe = {
    user: null,
    token: localStorage.getItem("token"),
    isAuthenticated: !1,
    loginAttempts: 0,
    lastLoginTime: null,
    sessionExpiry: null,
    refreshToken: localStorage.getItem("refreshToken")
}
  , LL = Ja("auth/login", async (e, {rejectWithValue: t}) => {
    try {
        const n = await fetch("/api/auth/login", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(e)
        });
        if (!n.ok)
            throw new Error("Login failed");
        return await n.json()
    } catch (n) {
        return t(n instanceof Error ? n.message : "Login failed")
    }
}
)
  , Hhe = Ja("auth/logout", async (e, {getState: t}) => {
    const r = t().auth.token;
    if (r)
        try {
            await fetch("/api/auth/logout", {
                method: "POST",
                headers: {
                    Authorization: `Bearer ${r}`,
                    "Content-Type": "application/json"
                }
            })
        } catch (i) {
            console.error("Server logout failed:", i)
        }
}
)
  , jL = Ja("auth/refreshToken", async (e, {getState: t, rejectWithValue: n}) => {
    try {
        const i = t().auth.refreshToken;
        if (!i)
            throw new Error("No refresh token available");
        const o = await fetch("/api/auth/refresh", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                refreshToken: i
            })
        });
        if (!o.ok)
            throw new Error("Token refresh failed");
        return await o.json()
    } catch (r) {
        return n(r instanceof Error ? r.message : "Token refresh failed")
    }
}
)
  , Tm = Vo({
    name: "auth",
    initialState: Vhe,
    reducers: {
        setCredentials: (e, t) => {
            const {user: n, token: r, refreshToken: i} = t.payload;
            e.user = n,
            e.token = r,
            e.isAuthenticated = !0,
            e.lastLoginTime = new Date().toISOString(),
            e.sessionExpiry = new Date(Date.now() + 1440 * 60 * 1e3).toISOString(),
            i && (e.refreshToken = i,
            localStorage.setItem("refreshToken", i)),
            localStorage.setItem("token", r),
            e.loginAttempts = 0
        }
        ,
        clearCredentials: e => {
            e.user = null,
            e.token = null,
            e.isAuthenticated = !1,
            e.lastLoginTime = null,
            e.sessionExpiry = null,
            e.refreshToken = null,
            localStorage.removeItem("token"),
            localStorage.removeItem("refreshToken")
        }
        ,
        incrementLoginAttempts: e => {
            e.loginAttempts += 1
        }
        ,
        resetLoginAttempts: e => {
            e.loginAttempts = 0
        }
        ,
        updateUserProfile: (e, t) => {
            e.user && (e.user = {
                ...e.user,
                ...t.payload
            })
        }
        ,
        setSessionExpiry: (e, t) => {
            e.sessionExpiry = t.payload
        }
    },
    extraReducers: e => {
        e.addCase(LL.fulfilled, (t, n) => {
            const {user: r, token: i, refreshToken: o} = n.payload;
            Tm.caseReducers.setCredentials(t, {
                type: "auth/setCredentials",
                payload: {
                    user: r,
                    token: i,
                    refreshToken: o
                }
            })
        }
        ).addCase(LL.rejected, t => {
            t.loginAttempts += 1
        }
        ).addCase(Hhe.fulfilled, t => {
            Tm.caseReducers.clearCredentials(t)
        }
        ).addCase(jL.fulfilled, (t, n) => {
            const {token: r, refreshToken: i} = n.payload;
            t.token = r,
            i && (t.refreshToken = i,
            localStorage.setItem("refreshToken", i)),
            localStorage.setItem("token", r),
            t.sessionExpiry = new Date(Date.now() + 1440 * 60 * 1e3).toISOString()
        }
        ).addCase(jL.rejected, t => {
            Tm.caseReducers.clearCredentials(t)
        }
        )
    }
})
  , {setCredentials: a8e, clearCredentials: s8e, incrementLoginAttempts: l8e, resetLoginAttempts: c8e, updateUserProfile: u8e, setSessionExpiry: d8e} = Tm.actions
  , qhe = Tm.reducer
  , Whe = {
    vendors: {
        items: [],
        loading: !1,
        error: null,
        lastFetch: null
    },
    currentVendor: {
        data: null,
        loading: !1,
        error: null
    },
    taxInformation: {
        items: [],
        loading: !1,
        error: null
    },
    bankDetails: {
        items: [],
        loading: !1,
        error: null
    },
    form: {
        data: {},
        isDirty: !1,
        validationErrors: {}
    },
    search: {
        term: "",
        filters: {
            country: null,
            state: null,
            salesStatus: null,
            language: null
        }
    },
    selectedVendor: null
}
  , ak = Ja("vendor/fetchVendors", async (e, {rejectWithValue: t}) => {
    try {
        const n = await fetch("/api/vendors");
        if (!n.ok)
            throw new Error("Failed to fetch vendors");
        return await n.json()
    } catch (n) {
        return t(n instanceof Error ? n.message : "Failed to fetch")
    }
}
)
  , sk = Ja("vendor/createVendor", async (e, {rejectWithValue: t}) => {
    try {
        const n = await fetch("/api/vendors", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(e)
        });
        if (!n.ok)
            throw new Error("Failed to create vendor");
        return await n.json()
    } catch (n) {
        return t(n instanceof Error ? n.message : "Failed to create")
    }
}
)
  , lk = Ja("vendor/updateVendor", async ({id: e, vendor: t}, {rejectWithValue: n}) => {
    try {
        const r = await fetch(`/api/vendors/${e}`, {
            method: "PUT",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(t)
        });
        if (!r.ok)
            throw new Error("Failed to update vendor");
        return await r.json()
    } catch (r) {
        return n(r instanceof Error ? r.message : "Failed to update")
    }
}
)
  , Ghe = Ja("vendor/deleteVendor", async (e, {rejectWithValue: t}) => {
    try {
        if (!(await fetch(`/api/vendors/${e}`, {
            method: "DELETE"
        })).ok)
            throw new Error("Failed to delete vendor");
        return e
    } catch (n) {
        return t(n instanceof Error ? n.message : "Failed to delete")
    }
}
)
  , g4 = Vo({
    name: "vendor",
    initialState: Whe,
    reducers: {
        setVendors: (e, t) => {
            e.vendors.items = t.payload,
            e.vendors.lastFetch = new Date().toISOString()
        }
        ,
        addVendor: (e, t) => {
            e.vendors.items.push(t.payload)
        }
        ,
        updateVendorInList: (e, t) => {
            const n = e.vendors.items.findIndex(r => r.companyName1 === t.payload.companyName1);
            n !== -1 && (e.vendors.items[n] = t.payload)
        }
        ,
        removeVendor: (e, t) => {
            e.vendors.items = e.vendors.items.filter(n => n.companyName1 !== t.payload)
        }
        ,
        setCurrentVendor: (e, t) => {
            e.currentVendor.data = t.payload
        }
        ,
        clearCurrentVendor: e => {
            e.currentVendor.data = null,
            e.currentVendor.error = null
        }
        ,
        setTaxInformation: (e, t) => {
            e.taxInformation.items = t.payload
        }
        ,
        addTaxInformation: (e, t) => {
            e.taxInformation.items.push(t.payload)
        }
        ,
        updateTaxInformation: (e, t) => {
            const n = e.taxInformation.items.findIndex(r => r.id === t.payload.id);
            n !== -1 && (e.taxInformation.items[n] = t.payload)
        }
        ,
        removeTaxInformation: (e, t) => {
            e.taxInformation.items = e.taxInformation.items.filter(n => n.id !== t.payload)
        }
        ,
        setBankDetails: (e, t) => {
            e.bankDetails.items = t.payload
        }
        ,
        addBankDetail: (e, t) => {
            e.bankDetails.items.push(t.payload)
        }
        ,
        updateBankDetail: (e, t) => {
            const n = e.bankDetails.items.findIndex(r => r.id === t.payload.id);
            n !== -1 && (e.bankDetails.items[n] = t.payload)
        }
        ,
        removeBankDetail: (e, t) => {
            e.bankDetails.items = e.bankDetails.items.filter(n => n.id !== t.payload)
        }
        ,
        setPrimaryBank: (e, t) => {
            e.bankDetails.items.forEach(r => {
                r.primary = !1
            }
            );
            const n = e.bankDetails.items.find(r => r.id === t.payload);
            n && (n.primary = !0)
        }
        ,
        setFormData: (e, t) => {
            e.form.data = {
                ...e.form.data,
                ...t.payload
            },
            e.form.isDirty = !0
        }
        ,
        resetFormData: e => {
            e.form.data = {},
            e.form.isDirty = !1,
            e.form.validationErrors = {}
        }
        ,
        setFormValidationErrors: (e, t) => {
            e.form.validationErrors = t.payload
        }
        ,
        clearFormValidationErrors: e => {
            e.form.validationErrors = {}
        }
        ,
        setFormField: (e, t) => {
            const {field: n, value: r} = t.payload;
            e.form.data = {
                ...e.form.data,
                [n]: r
            },
            e.form.isDirty = !0,
            e.form.validationErrors[n] && delete e.form.validationErrors[n]
        }
        ,
        setSearchTerm: (e, t) => {
            e.search.term = t.payload
        }
        ,
        setSearchFilter: (e, t) => {
            const {filter: n, value: r} = t.payload;
            e.search.filters[n] = r
        }
        ,
        clearSearchFilters: e => {
            e.search.filters = {
                country: null,
                state: null,
                salesStatus: null,
                language: null
            }
        }
        ,
        clearSearch: e => {
            e.search.term = "",
            e.search.filters = {
                country: null,
                state: null,
                salesStatus: null,
                language: null
            }
        }
        ,
        setSelectedVendor: (e, t) => {
            e.selectedVendor = t.payload
        }
        ,
        clearSelectedVendor: e => {
            e.selectedVendor = null
        }
    },
    extraReducers: e => {
        e.addCase(ak.pending, t => {
            t.vendors.loading = !0,
            t.vendors.error = null
        }
        ).addCase(ak.fulfilled, (t, n) => {
            t.vendors.loading = !1,
            t.vendors.items = n.payload,
            t.vendors.lastFetch = new Date().toISOString()
        }
        ).addCase(ak.rejected, (t, n) => {
            t.vendors.loading = !1,
            t.vendors.error = n.payload
        }
        ).addCase(sk.pending, t => {
            t.vendors.loading = !0,
            t.vendors.error = null
        }
        ).addCase(sk.fulfilled, (t, n) => {
            t.vendors.loading = !1,
            t.vendors.items.push(n.payload),
            t.form.data = {},
            t.form.isDirty = !1,
            t.form.validationErrors = {}
        }
        ).addCase(sk.rejected, (t, n) => {
            t.vendors.loading = !1,
            t.vendors.error = n.payload
        }
        ).addCase(lk.pending, t => {
            t.currentVendor.loading = !0,
            t.currentVendor.error = null
        }
        ).addCase(lk.fulfilled, (t, n) => {
            t.currentVendor.loading = !1,
            t.currentVendor.data = n.payload;
            const r = t.vendors.items.findIndex(i => i.companyName1 === n.payload.companyName1);
            r !== -1 && (t.vendors.items[r] = n.payload)
        }
        ).addCase(lk.rejected, (t, n) => {
            t.currentVendor.loading = !1,
            t.currentVendor.error = n.payload
        }
        ).addCase(Ghe.fulfilled, (t, n) => {
            t.vendors.items = t.vendors.items.filter(r => r.companyName1 !== n.payload),
            t.selectedVendor?.companyName1 === n.payload && (t.selectedVendor = null),
            t.currentVendor.data?.companyName1 === n.payload && (t.currentVendor.data = null)
        }
        )
    }
})
  , {setVendors: f8e, addVendor: h8e, updateVendorInList: p8e, removeVendor: m8e, setCurrentVendor: g8e, clearCurrentVendor: y8e, setTaxInformation: b8e, addTaxInformation: x8e, updateTaxInformation: v8e, removeTaxInformation: S8e, setBankDetails: C8e, addBankDetail: w8e, updateBankDetail: k8e, removeBankDetail: T8e, setPrimaryBank: _8e, setFormData: E8e, resetFormData: A8e, setFormValidationErrors: M8e, clearFormValidationErrors: P8e, setFormField: R8e, setSearchTerm: D8e, setSearchFilter: O8e, clearSearchFilters: I8e, clearSearch: $8e, setSelectedVendor: L8e, clearSelectedVendor: j8e} = g4.actions
  , Yhe = g4.reducer
  , Zhe = It("inventory/fetchLanguagesStart")
  , y4 = It("inventory/fetchLanguagesSuccess")
  , b4 = It("inventory/fetchLanguagesFailure")
  , Qhe = It("inventory/fetchSalesStatusesStart")
  , x4 = It("inventory/fetchSalesStatusesSuccess")
  , v4 = It("inventory/fetchSalesStatusesFailure")
  , Khe = It("inventory/fetchUomDimensionsStart")
  , S4 = It("inventory/fetchUomDimensionsSuccess")
  , C4 = It("inventory/fetchUomDimensionsFailure")
  , m1 = It("inventory/fetchProductTypesStart")
  , w4 = It("inventory/fetchProductTypesSuccess")
  , k4 = It("inventory/fetchProductTypesFailure")
  , Xhe = It("inventory/createProductTypeStart")
  , T4 = It("inventory/createProductTypeSuccess")
  , _4 = It("inventory/createProductTypeFailure")
  , Jhe = It("inventory/updateProductTypeStart")
  , E4 = It("inventory/updateProductTypeSuccess")
  , A4 = It("inventory/updateProductTypeFailure")
  , epe = It("inventory/deleteProductTypeStart")
  , M4 = It("inventory/deleteProductTypeSuccess")
  , P4 = It("inventory/deleteProductTypeFailure")
  , tpe = It("inventory/fetchProductGroupsStart")
  , R4 = It("inventory/fetchProductGroupsSuccess")
  , D4 = It("inventory/fetchProductGroupsFailure")
  , npe = It("inventory/fetchProductCategoriesStart")
  , O4 = It("inventory/fetchProductCategoriesSuccess")
  , I4 = It("inventory/fetchProductCategoriesFailure")
  , rpe = It("inventory/fetchProductMasterStart")
  , $4 = It("inventory/fetchProductMasterSuccess")
  , L4 = It("inventory/fetchProductMasterFailure")
  , ipe = It("inventory/createProductMasterStart")
  , j4 = It("inventory/createProductMasterSuccess")
  , B4 = It("inventory/createProductMasterFailure")
  , ope = It("inventory/updateProductMasterStart")
  , z4 = It("inventory/updateProductMasterSuccess")
  , F4 = It("inventory/updateProductMasterFailure")
  , Al = It("inventory/setComplexData")
  , fr = It("inventory/setLoadingState")
  , _o = It("inventory/setErrorState");
It("inventory/processComplexData");
const ape = {
    productTypes: {
        items: [],
        loading: !1,
        error: null,
        lastFetch: null
    },
    productGroups: {
        items: [],
        loading: !1,
        error: null,
        lastFetch: null
    },
    productCategories: {
        items: [],
        loading: !1,
        error: null,
        lastFetch: null
    },
    productMaster: {
        items: [],
        loading: !1,
        error: null,
        lastFetch: null,
        currentItem: null
    },
    uom: {
        dimensions: [],
        units: [],
        loading: !1,
        error: null,
        lastFetch: null
    },
    referenceData: {
        languages: [],
        salesStatuses: [],
        loading: !1,
        error: null,
        lastFetch: null
    },
    search: {
        productTypes: "",
        productGroups: "",
        productCategories: "",
        productMaster: ""
    },
    selectedItems: {
        productType: null,
        productGroup: null,
        productCategory: null,
        productMaster: null
    },
    complexData: {},
    loadingStates: {},
    errorStates: {}
};
Ja("inventory/fetchProductTypes", async (e, {rejectWithValue: t}) => {
    try {
        const n = await fetch("/api/products/types");
        if (!n.ok)
            throw new Error("Failed to fetch product types");
        return await n.json()
    } catch (n) {
        return t(n instanceof Error ? n.message : "Failed to fetch")
    }
}
);
Ja("inventory/createProductType", async (e, {rejectWithValue: t}) => {
    try {
        const n = await fetch("/api/products/types", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(e)
        });
        if (!n.ok)
            throw new Error("Failed to create product type");
        return await n.json()
    } catch (n) {
        return t(n instanceof Error ? n.message : "Failed to create")
    }
}
);
const N4 = Vo({
    name: "inventory",
    initialState: ape,
    reducers: {
        setProductTypes: (e, t) => {
            e.productTypes.items = t.payload,
            e.productTypes.lastFetch = new Date().toISOString()
        }
        ,
        addProductType: (e, t) => {
            e.productTypes.items.push(t.payload)
        }
        ,
        updateProductType: (e, t) => {
            const n = e.productTypes.items.findIndex(r => r.productTypeId === t.payload.productTypeId);
            n !== -1 && (e.productTypes.items[n] = t.payload)
        }
        ,
        removeProductType: (e, t) => {
            e.productTypes.items = e.productTypes.items.filter(n => n.productTypeId !== t.payload)
        }
        ,
        setProductGroups: (e, t) => {
            e.productGroups.items = t.payload,
            e.productGroups.lastFetch = new Date().toISOString()
        }
        ,
        addProductGroup: (e, t) => {
            e.productGroups.items.push(t.payload)
        }
        ,
        updateProductGroup: (e, t) => {
            const n = e.productGroups.items.findIndex(r => r.productGroupId === t.payload.productGroupId);
            n !== -1 && (e.productGroups.items[n] = t.payload)
        }
        ,
        removeProductGroup: (e, t) => {
            e.productGroups.items = e.productGroups.items.filter(n => n.productGroupId !== t.payload)
        }
        ,
        setProductCategories: (e, t) => {
            e.productCategories.items = t.payload,
            e.productCategories.lastFetch = new Date().toISOString()
        }
        ,
        addProductCategory: (e, t) => {
            e.productCategories.items.push(t.payload)
        }
        ,
        updateProductCategory: (e, t) => {
            const n = e.productCategories.items.findIndex(r => r.productCategoryId === t.payload.productCategoryId);
            n !== -1 && (e.productCategories.items[n] = t.payload)
        }
        ,
        removeProductCategory: (e, t) => {
            e.productCategories.items = e.productCategories.items.filter(n => n.productCategoryId !== t.payload)
        }
        ,
        setProductMaster: (e, t) => {
            e.productMaster.items = t.payload,
            e.productMaster.lastFetch = new Date().toISOString()
        }
        ,
        addProductMaster: (e, t) => {
            e.productMaster.items.push(t.payload)
        }
        ,
        updateProductMaster: (e, t) => {
            const n = e.productMaster.items.findIndex(r => r.productMasterId === t.payload.productMasterId);
            n !== -1 && (e.productMaster.items[n] = t.payload)
        }
        ,
        removeProductMaster: (e, t) => {
            e.productMaster.items = e.productMaster.items.filter(n => n.productMasterId !== t.payload)
        }
        ,
        setCurrentProductMaster: (e, t) => {
            e.productMaster.currentItem = t.payload
        }
        ,
        setUomDimensions: (e, t) => {
            e.uom.dimensions = t.payload,
            e.uom.lastFetch = new Date().toISOString()
        }
        ,
        setUomUnits: (e, t) => {
            e.uom.units = t.payload
        }
        ,
        setLanguages: (e, t) => {
            e.referenceData.languages = t.payload,
            e.referenceData.lastFetch = new Date().toISOString()
        }
        ,
        setSalesStatuses: (e, t) => {
            e.referenceData.salesStatuses = t.payload
        }
        ,
        setSearch: (e, t) => {
            const {category: n, value: r} = t.payload;
            e.search[n] = r
        }
        ,
        clearSearch: (e, t) => {
            e.search[t.payload] = ""
        }
        ,
        clearAllSearch: e => {
            e.search = {
                productTypes: "",
                productGroups: "",
                productCategories: "",
                productMaster: ""
            }
        }
        ,
        setSelectedItem: (e, t) => {
            const {category: n, item: r} = t.payload;
            e.selectedItems[n] = r
        }
        ,
        clearSelectedItem: (e, t) => {
            e.selectedItems[t.payload] = null
        }
        ,
        clearAllSelectedItems: e => {
            e.selectedItems = {
                productType: null,
                productGroup: null,
                productCategory: null,
                productMaster: null
            }
        }
        ,
        setComplexDataItem: (e, t) => {
            const {key: n, data: r, metadata: i} = t.payload;
            e.complexData[n] = {
                data: r,
                metadata: i
            }
        }
        ,
        removeComplexDataItem: (e, t) => {
            delete e.complexData[t.payload]
        }
        ,
        updateComplexDataMetadata: (e, t) => {
            const {key: n, metadata: r} = t.payload;
            e.complexData[n] && (e.complexData[n].metadata = {
                ...e.complexData[n].metadata,
                ...r
            })
        }
        ,
        setLoadingStateItem: (e, t) => {
            const {key: n, loading: r} = t.payload;
            e.loadingStates[n] = r
        }
        ,
        clearLoadingState: (e, t) => {
            delete e.loadingStates[t.payload]
        }
        ,
        setErrorStateItem: (e, t) => {
            const {key: n, error: r} = t.payload;
            e.errorStates[n] = r
        }
        ,
        clearErrorState: (e, t) => {
            delete e.errorStates[t.payload]
        }
        ,
        clearAllErrors: e => {
            e.errorStates = {}
        }
    },
    extraReducers: e => {
        e.addCase(y4, (t, n) => {
            t.referenceData.languages = n.payload,
            t.referenceData.lastFetch = new Date().toISOString()
        }
        ).addCase(b4, (t, n) => {
            t.referenceData.error = n.payload
        }
        ).addCase(x4, (t, n) => {
            t.referenceData.salesStatuses = n.payload
        }
        ).addCase(v4, (t, n) => {
            t.referenceData.error = n.payload
        }
        ).addCase(S4, (t, n) => {
            t.uom.dimensions = n.payload,
            t.uom.lastFetch = new Date().toISOString()
        }
        ).addCase(C4, (t, n) => {
            t.uom.error = n.payload
        }
        ).addCase(w4, (t, n) => {
            t.productTypes.items = n.payload,
            t.productTypes.lastFetch = new Date().toISOString()
        }
        ).addCase(k4, (t, n) => {
            t.productTypes.error = n.payload
        }
        ).addCase(T4, (t, n) => {
            t.productTypes.items.push(n.payload)
        }
        ).addCase(_4, (t, n) => {
            t.productTypes.error = n.payload
        }
        ).addCase(E4, (t, n) => {
            const r = t.productTypes.items.findIndex(i => i.productTypeId === n.payload.productTypeId);
            r !== -1 && (t.productTypes.items[r] = n.payload)
        }
        ).addCase(A4, (t, n) => {
            t.productTypes.error = n.payload
        }
        ).addCase(M4, (t, n) => {
            t.productTypes.items = t.productTypes.items.filter(r => r.productTypeId !== n.payload)
        }
        ).addCase(P4, (t, n) => {
            t.productTypes.error = n.payload
        }
        ).addCase(R4, (t, n) => {
            t.productGroups.items = n.payload,
            t.productGroups.lastFetch = new Date().toISOString()
        }
        ).addCase(D4, (t, n) => {
            t.productGroups.error = n.payload
        }
        ).addCase(O4, (t, n) => {
            t.productCategories.items = n.payload,
            t.productCategories.lastFetch = new Date().toISOString()
        }
        ).addCase(I4, (t, n) => {
            t.productCategories.error = n.payload
        }
        ).addCase($4, (t, n) => {
            t.productMaster.currentItem = n.payload
        }
        ).addCase(L4, (t, n) => {
            t.productMaster.error = n.payload
        }
        ).addCase(j4, (t, n) => {
            t.productMaster.items.push(n.payload)
        }
        ).addCase(B4, (t, n) => {
            t.productMaster.error = n.payload
        }
        ).addCase(z4, (t, n) => {
            const r = t.productMaster.items.findIndex(i => i.productMasterId === n.payload.productMasterId);
            r !== -1 && (t.productMaster.items[r] = n.payload),
            t.productMaster.currentItem = n.payload
        }
        ).addCase(F4, (t, n) => {
            t.productMaster.error = n.payload
        }
        ).addCase(Al, (t, n) => {
            const {key: r, data: i, metadata: o} = n.payload;
            t.complexData[r] = {
                data: i,
                metadata: o
            }
        }
        ).addCase(fr, (t, n) => {
            const {key: r, loading: i} = n.payload;
            t.loadingStates[r] = i
        }
        ).addCase(_o, (t, n) => {
            const {key: r, error: i} = n.payload;
            t.errorStates[r] = i
        }
        )
    }
})
  , {setProductTypes: B8e, addProductType: z8e, updateProductType: F8e, removeProductType: N8e, setProductGroups: U8e, addProductGroup: V8e, updateProductGroup: H8e, removeProductGroup: q8e, setProductCategories: W8e, addProductCategory: G8e, updateProductCategory: Y8e, removeProductCategory: Z8e, setProductMaster: Q8e, addProductMaster: K8e, updateProductMaster: X8e, removeProductMaster: J8e, setCurrentProductMaster: eUe, setUomDimensions: tUe, setUomUnits: nUe, setLanguages: rUe, setSalesStatuses: iUe, setSearch: oUe, clearSearch: aUe, clearAllSearch: sUe, setSelectedItem: lUe, clearSelectedItem: cUe, clearAllSelectedItems: uUe, setComplexDataItem: dUe, removeComplexDataItem: fUe, updateComplexDataMetadata: hUe, setLoadingStateItem: pUe, clearLoadingState: mUe, setErrorStateItem: gUe, clearErrorState: yUe, clearAllErrors: bUe} = N4.actions
  , spe = N4.reducer
  , U4 = Ofe()
  , Vg = U4.startListening;
Vg({
    predicate: e => e.type.endsWith("/pending"),
    effect: async (e, t) => {
        const n = e.type.replace("/pending", "");
        t.dispatch(yA({
            key: n,
            loading: !0
        })),
        t.dispatch(o6({
            key: n,
            error: null
        }))
    }
});
Vg({
    predicate: e => e.type.endsWith("/fulfilled"),
    effect: async (e, t) => {
        const n = e.type.replace("/fulfilled", "");
        if (t.dispatch(yA({
            key: n,
            loading: !1
        })),
        e.type.includes("create") || e.type.includes("update") || e.type.includes("delete")) {
            const r = e.type.includes("create") ? "created" : e.type.includes("update") ? "updated" : "deleted"
              , i = n.split("/")[0];
            t.dispatch(a6({
                id: `success_${Date.now()}`,
                message: `${i} ${r} successfully`,
                type: "success",
                timestamp: new Date().toISOString()
            }))
        }
    }
});
Vg({
    predicate: e => e.type.endsWith("/rejected"),
    effect: async (e, t) => {
        const n = e.type.replace("/rejected", "");
        t.dispatch(yA({
            key: n,
            loading: !1
        }));
        const r = e.payload || "An error occurred";
        t.dispatch(o6({
            key: n,
            error: r
        })),
        t.dispatch(a6({
            id: `error_${Date.now()}`,
            message: r,
            type: "error",
            timestamp: new Date().toISOString(),
            isRead: !1
        }))
    }
});
Vg({
    predicate: e => e.type.includes("auth/") || e.type.includes("ui/setThemeMode") || e.type.includes("ui/setDensity"),
    effect: async (e, t) => {
        const n = t.getState();
        if (e.type.includes("auth/"))
            try {
                localStorage.setItem("auth_state", JSON.stringify({
                    token: n.auth?.token,
                    refreshToken: n.auth?.refreshToken,
                    user: n.auth?.user
                }))
            } catch (r) {
                console.warn("Failed to persist auth state:", r)
            }
        if (e.type.includes("ui/"))
            try {
                localStorage.setItem("ui_preferences", JSON.stringify({
                    theme: n.ui?.theme,
                    layout: n.ui?.layout,
                    sidebar: n.ui?.sidebar
                }))
            } catch (r) {
                console.warn("Failed to persist UI preferences:", r)
            }
    }
});
let kp = {
    actionCount: 0,
    slowActions: []
};
Vg({
    predicate: () => !0,
    effect: async e => {
        kp.actionCount++,
        (e.type.includes("fetch") || e.type.includes("api")) && (kp.slowActions.push({
            type: e.type,
            timestamp: Date.now()
        }),
        kp.slowActions.length > 50 && (kp.slowActions = kp.slowActions.slice(-50)))
    }
});
var lpe = class extends Error {
    issues;
    constructor(e) {
        super(e[0].message),
        this.name = "SchemaError",
        this.issues = e
    }
}
  , V4 = (e => (e.uninitialized = "uninitialized",
e.pending = "pending",
e.fulfilled = "fulfilled",
e.rejected = "rejected",
e))(V4 || {});
function BL(e) {
    return {
        status: e,
        isUninitialized: e === "uninitialized",
        isLoading: e === "pending",
        isSuccess: e === "fulfilled",
        isError: e === "rejected"
    }
}
var zL = Sc;
function hA(e, t) {
    if (e === t || !(zL(e) && zL(t) || Array.isArray(e) && Array.isArray(t)))
        return t;
    const n = Object.keys(t)
      , r = Object.keys(e);
    let i = n.length === r.length;
    const o = Array.isArray(t) ? [] : {};
    for (const a of n)
        o[a] = hA(e[a], t[a]),
        i && (i = e[a] === o[a]);
    return i ? e : o
}
function ck(e) {
    let t = 0;
    for (const n in e)
        t++;
    return t
}
var FL = e => [].concat(...e);
function cpe(e) {
    return new RegExp("(^|:)//").test(e)
}
function upe() {
    return typeof document > "u" ? !0 : document.visibilityState !== "hidden"
}
function M0(e) {
    return e != null
}
function dpe() {
    return typeof navigator > "u" || navigator.onLine === void 0 ? !0 : navigator.onLine
}
var fpe = e => e.replace(/\/$/, "")
  , hpe = e => e.replace(/^\//, "");
function ppe(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    if (cpe(t))
        return t;
    const n = e.endsWith("/") || !t.startsWith("?") ? "/" : "";
    return e = fpe(e),
    t = hpe(t),
    `${e}${n}${t}`
}
function mpe(e, t, n) {
    return e.has(t) ? e.get(t) : e.set(t, n).get(t)
}
function xT(e, t, n) {
    return e.has(t) ? e.get(t) : e.set(t, n(t)).get(t)
}
var vT = () => new Map
  , NL = (...e) => fetch(...e)
  , gpe = e => e.status >= 200 && e.status <= 299
  , ype = e => /ion\/(vnd\.api\+)?json/.test(e.get("content-type") || "");
function UL(e) {
    if (!Sc(e))
        return e;
    const t = {
        ...e
    };
    for (const [n,r] of Object.entries(t))
        r === void 0 && delete t[n];
    return t
}
function bpe({baseUrl: e, prepareHeaders: t=h => h, fetchFn: n=NL, paramsSerializer: r, isJsonContentType: i=ype, jsonContentType: o="application/json", jsonReplacer: a, timeout: s, responseHandler: c, validateStatus: u, ...f}={}) {
    return typeof fetch > "u" && n === NL && console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),
    async (m, y, b) => {
        const {getState: v, extra: S, endpoint: C, forced: w, type: k} = y;
        let T, {url: E, headers: P=new Headers(f.headers), params: D=void 0, responseHandler: $=c ?? "json", validateStatus: z=u ?? gpe, timeout: O=s, ...I} = typeof m == "string" ? {
            url: m
        } : m, M, B = y.signal;
        O && (M = new AbortController,
        y.signal.addEventListener("abort", M.abort),
        B = M.signal);
        let L = {
            ...f,
            signal: B,
            ...I
        };
        P = new Headers(UL(P)),
        L.headers = await t(P, {
            getState: v,
            arg: m,
            extra: S,
            endpoint: C,
            forced: w,
            type: k,
            extraOptions: b
        }) || P;
        const F = te => typeof te == "object" && (Sc(te) || Array.isArray(te) || typeof te.toJSON == "function");
        if (!L.headers.has("content-type") && F(L.body) && L.headers.set("content-type", o),
        F(L.body) && i(L.headers) && (L.body = JSON.stringify(L.body, a)),
        D) {
            const te = ~E.indexOf("?") ? "&" : "?"
              , K = r ? r(D) : new URLSearchParams(UL(D));
            E += te + K
        }
        E = ppe(e, E);
        const j = new Request(E,L);
        T = {
            request: new Request(E,L)
        };
        let H, Z = !1, q = M && setTimeout( () => {
            Z = !0,
            M.abort()
        }
        , O);
        try {
            H = await n(j)
        } catch (te) {
            return {
                error: {
                    status: Z ? "TIMEOUT_ERROR" : "FETCH_ERROR",
                    error: String(te)
                },
                meta: T
            }
        } finally {
            q && clearTimeout(q),
            M?.signal.removeEventListener("abort", M.abort)
        }
        const V = H.clone();
        T.response = V;
        let Y, W = "";
        try {
            let te;
            if (await Promise.all([h(H, $).then(K => Y = K, K => te = K), V.text().then(K => W = K, () => {}
            )]),
            te)
                throw te
        } catch (te) {
            return {
                error: {
                    status: "PARSING_ERROR",
                    originalStatus: H.status,
                    data: W,
                    error: String(te)
                },
                meta: T
            }
        }
        return z(H, Y) ? {
            data: Y,
            meta: T
        } : {
            error: {
                status: H.status,
                data: Y
            },
            meta: T
        }
    }
    ;
    async function h(m, y) {
        if (typeof y == "function")
            return y(m);
        if (y === "content-type" && (y = i(m.headers) ? "json" : "text"),
        y === "json") {
            const b = await m.text();
            return b.length ? JSON.parse(b) : null
        }
        return m.text()
    }
}
var VL = class {
    constructor(e, t=void 0) {
        this.value = e,
        this.meta = t
    }
}
  , pA = It("__rtkq/focused")
  , H4 = It("__rtkq/unfocused")
  , mA = It("__rtkq/online")
  , q4 = It("__rtkq/offline");
function g1(e) {
    return e.type === "query"
}
function xpe(e) {
    return e.type === "mutation"
}
function y1(e) {
    return e.type === "infinitequery"
}
function P0(e) {
    return g1(e) || y1(e)
}
function gA(e, t, n, r, i, o) {
    return vpe(e) ? e(t, n, r, i).filter(M0).map(ST).map(o) : Array.isArray(e) ? e.map(ST).map(o) : []
}
function vpe(e) {
    return typeof e == "function"
}
function ST(e) {
    return typeof e == "string" ? {
        type: e
    } : e
}
function Spe(e, t) {
    return e.catch(t)
}
var Jm = Symbol("forceQueryFn")
  , CT = e => typeof e[Jm] == "function";
function Cpe({serializeQueryArgs: e, queryThunk: t, infiniteQueryThunk: n, mutationThunk: r, api: i, context: o, internalState: a}) {
    const {runningQueries: s, runningMutations: c} = a
      , {unsubscribeQueryResult: u, removeMutationResult: f, updateSubscriptionOptions: h} = i.internalActions;
    return {
        buildInitiateQuery: C,
        buildInitiateInfiniteQuery: w,
        buildInitiateMutation: k,
        getRunningQueryThunk: m,
        getRunningMutationThunk: y,
        getRunningQueriesThunk: b,
        getRunningMutationsThunk: v
    };
    function m(T, E) {
        return P => {
            const D = o.endpointDefinitions[T]
              , $ = e({
                queryArgs: E,
                endpointDefinition: D,
                endpointName: T
            });
            return s.get(P)?.[$]
        }
    }
    function y(T, E) {
        return P => c.get(P)?.[E]
    }
    function b() {
        return T => Object.values(s.get(T) || {}).filter(M0)
    }
    function v() {
        return T => Object.values(c.get(T) || {}).filter(M0)
    }
    function S(T, E) {
        const P = (D, {subscribe: $=!0, forceRefetch: z, subscriptionOptions: O, [Jm]: I, ...M}={}) => (B, L) => {
            const F = e({
                queryArgs: D,
                endpointDefinition: E,
                endpointName: T
            });
            let j;
            const N = {
                ...M,
                type: "query",
                subscribe: $,
                forceRefetch: z,
                subscriptionOptions: O,
                endpointName: T,
                originalArgs: D,
                queryCacheKey: F,
                [Jm]: I
            };
            if (g1(E))
                j = t(N);
            else {
                const {direction: re, initialPageParam: ie} = M;
                j = n({
                    ...N,
                    direction: re,
                    initialPageParam: ie
                })
            }
            const H = i.endpoints[T].select(D)
              , Z = B(j)
              , q = H(L())
              , {requestId: V, abort: Y} = Z
              , W = q.requestId !== V
              , te = s.get(B)?.[F]
              , K = () => H(L())
              , ee = Object.assign(I ? Z.then(K) : W && !te ? Promise.resolve(q) : Promise.all([te, Z]).then(K), {
                arg: D,
                requestId: V,
                subscriptionOptions: O,
                queryCacheKey: F,
                abort: Y,
                async unwrap() {
                    const re = await ee;
                    if (re.isError)
                        throw re.error;
                    return re.data
                },
                refetch: () => B(P(D, {
                    subscribe: !1,
                    forceRefetch: !0
                })),
                unsubscribe() {
                    $ && B(u({
                        queryCacheKey: F,
                        requestId: V
                    }))
                },
                updateSubscriptionOptions(re) {
                    ee.subscriptionOptions = re,
                    B(h({
                        endpointName: T,
                        requestId: V,
                        queryCacheKey: F,
                        options: re
                    }))
                }
            });
            if (!te && !W && !I) {
                const re = mpe(s, B, {});
                re[F] = ee,
                ee.then( () => {
                    delete re[F],
                    ck(re) || s.delete(B)
                }
                )
            }
            return ee
        }
        ;
        return P
    }
    function C(T, E) {
        return S(T, E)
    }
    function w(T, E) {
        return S(T, E)
    }
    function k(T) {
        return (E, {track: P=!0, fixedCacheKey: D}={}) => ($, z) => {
            const O = r({
                type: "mutation",
                endpointName: T,
                originalArgs: E,
                track: P,
                fixedCacheKey: D
            })
              , I = $(O)
              , {requestId: M, abort: B, unwrap: L} = I
              , F = Spe(I.unwrap().then(Z => ({
                data: Z
            })), Z => ({
                error: Z
            }))
              , j = () => {
                $(f({
                    requestId: M,
                    fixedCacheKey: D
                }))
            }
              , N = Object.assign(F, {
                arg: I.arg,
                requestId: M,
                abort: B,
                unwrap: L,
                reset: j
            })
              , H = c.get($) || {};
            return c.set($, H),
            H[M] = N,
            N.then( () => {
                delete H[M],
                ck(H) || c.delete($)
            }
            ),
            D && (H[D] = N,
            N.then( () => {
                H[D] === N && (delete H[D],
                ck(H) || c.delete($))
            }
            )),
            N
        }
    }
}
var W4 = class extends lpe {
    constructor(e, t, n, r) {
        super(e),
        this.value = t,
        this.schemaName = n,
        this._bqMeta = r
    }
}
  , iu = (e, t) => Array.isArray(e) ? e.includes(t) : !!e;
async function ou(e, t, n, r) {
    const i = await e["~standard"].validate(t);
    if (i.issues)
        throw new W4(i.issues,t,n,r);
    return i.value
}
function HL(e) {
    return e
}
var Tp = (e={}) => ({
    ...e,
    [i1]: !0
});
function wpe({reducerPath: e, baseQuery: t, context: {endpointDefinitions: n}, serializeQueryArgs: r, api: i, assertTagType: o, selectors: a, onSchemaFailure: s, catchSchemaFailure: c, skipSchemaValidation: u}) {
    const f = (I, M, B, L) => (F, j) => {
        const N = n[I]
          , H = r({
            queryArgs: M,
            endpointDefinition: N,
            endpointName: I
        });
        if (F(i.internalActions.queryResultPatched({
            queryCacheKey: H,
            patches: B
        })),
        !L)
            return;
        const Z = i.endpoints[I].select(M)(j())
          , q = gA(N.providesTags, Z.data, void 0, M, {}, o);
        F(i.internalActions.updateProvidedBy([{
            queryCacheKey: H,
            providedTags: q
        }]))
    }
    ;
    function h(I, M, B=0) {
        const L = [M, ...I];
        return B && L.length > B ? L.slice(0, -1) : L
    }
    function m(I, M, B=0) {
        const L = [...I, M];
        return B && L.length > B ? L.slice(1) : L
    }
    const y = (I, M, B, L=!0) => (F, j) => {
        const H = i.endpoints[I].select(M)(j())
          , Z = {
            patches: [],
            inversePatches: [],
            undo: () => F(i.util.patchQueryData(I, M, Z.inversePatches, L))
        };
        if (H.status === "uninitialized")
            return Z;
        let q;
        if ("data"in H)
            if (Xa(H.data)) {
                const [V,Y,W] = x3(H.data, B);
                Z.patches.push(...Y),
                Z.inversePatches.push(...W),
                q = V
            } else
                q = B(H.data),
                Z.patches.push({
                    op: "replace",
                    path: [],
                    value: q
                }),
                Z.inversePatches.push({
                    op: "replace",
                    path: [],
                    value: H.data
                });
        return Z.patches.length === 0 || F(i.util.patchQueryData(I, M, Z.patches, L)),
        Z
    }
      , b = (I, M, B) => L => L(i.endpoints[I].initiate(M, {
        subscribe: !1,
        forceRefetch: !0,
        [Jm]: () => ({
            data: B
        })
    }))
      , v = (I, M) => I.query && I[M] ? I[M] : HL
      , S = async (I, {signal: M, abort: B, rejectWithValue: L, fulfillWithValue: F, dispatch: j, getState: N, extra: H}) => {
        const Z = n[I.endpointName]
          , {metaSchema: q, skipSchemaValidation: V=u} = Z;
        try {
            let Y = HL;
            const W = {
                signal: M,
                abort: B,
                dispatch: j,
                getState: N,
                extra: H,
                endpoint: I.endpointName,
                type: I.type,
                forced: I.type === "query" ? C(I, N()) : void 0,
                queryCacheKey: I.type === "query" ? I.queryCacheKey : void 0
            }
              , te = I.type === "query" ? I[Jm] : void 0;
            let K;
            const ee = async (ie, J, oe, we) => {
                if (J == null && ie.pages.length)
                    return Promise.resolve({
                        data: ie
                    });
                const xe = {
                    queryArg: I.originalArgs,
                    pageParam: J
                }
                  , se = await re(xe)
                  , de = we ? h : m;
                return {
                    data: {
                        pages: de(ie.pages, se.data, oe),
                        pageParams: de(ie.pageParams, J, oe)
                    },
                    meta: se.meta
                }
            }
            ;
            async function re(ie) {
                let J;
                const {extraOptions: oe, argSchema: we, rawResponseSchema: xe, responseSchema: se} = Z;
                if (we && !iu(V, "arg") && (ie = await ou(we, ie, "argSchema", {})),
                te ? J = te() : Z.query ? (Y = v(Z, "transformResponse"),
                J = await t(Z.query(ie), W, oe)) : J = await Z.queryFn(ie, W, oe, Ce => t(Ce, W, oe)),
                typeof process < "u",
                J.error)
                    throw new VL(J.error,J.meta);
                let {data: de} = J;
                xe && !iu(V, "rawResponse") && (de = await ou(xe, J.data, "rawResponseSchema", J.meta));
                let Se = await Y(de, J.meta, ie);
                return se && !iu(V, "response") && (Se = await ou(se, Se, "responseSchema", J.meta)),
                {
                    ...J,
                    data: Se
                }
            }
            if (I.type === "query" && "infiniteQueryOptions"in Z) {
                const {infiniteQueryOptions: ie} = Z
                  , {maxPages: J=1 / 0} = ie;
                let oe;
                const we = {
                    pages: [],
                    pageParams: []
                }
                  , xe = a.selectQueryEntry(N(), I.queryCacheKey)?.data
                  , de = C(I, N()) && !I.direction || !xe ? we : xe;
                if ("direction"in I && I.direction && de.pages.length) {
                    const Se = I.direction === "backward"
                      , Ye = (Se ? G4 : wT)(ie, de, I.originalArgs);
                    oe = await ee(de, Ye, J, Se)
                } else {
                    const {initialPageParam: Se=ie.initialPageParam} = I
                      , Ce = xe?.pageParams ?? []
                      , Ye = Ce[0] ?? Se
                      , ye = Ce.length;
                    oe = await ee(de, Ye, J),
                    te && (oe = {
                        data: oe.data.pages[0]
                    });
                    for (let Ke = 1; Ke < ye; Ke++) {
                        const X = wT(ie, oe.data, I.originalArgs);
                        oe = await ee(oe.data, X, J)
                    }
                }
                K = oe
            } else
                K = await re(I.originalArgs);
            return q && !iu(V, "meta") && K.meta && (K.meta = await ou(q, K.meta, "metaSchema", K.meta)),
            F(K.data, Tp({
                fulfilledTimeStamp: Date.now(),
                baseQueryMeta: K.meta
            }))
        } catch (Y) {
            let W = Y;
            if (W instanceof VL) {
                let te = v(Z, "transformErrorResponse");
                const {rawErrorResponseSchema: K, errorResponseSchema: ee} = Z;
                let {value: re, meta: ie} = W;
                try {
                    K && !iu(V, "rawErrorResponse") && (re = await ou(K, re, "rawErrorResponseSchema", ie)),
                    q && !iu(V, "meta") && (ie = await ou(q, ie, "metaSchema", ie));
                    let J = await te(re, ie, I.originalArgs);
                    return ee && !iu(V, "errorResponse") && (J = await ou(ee, J, "errorResponseSchema", ie)),
                    L(J, Tp({
                        baseQueryMeta: ie
                    }))
                } catch (J) {
                    W = J
                }
            }
            try {
                if (W instanceof W4) {
                    const te = {
                        endpoint: I.endpointName,
                        arg: I.originalArgs,
                        type: I.type,
                        queryCacheKey: I.type === "query" ? I.queryCacheKey : void 0
                    };
                    Z.onSchemaFailure?.(W, te),
                    s?.(W, te);
                    const {catchSchemaFailure: K=c} = Z;
                    if (K)
                        return L(K(W, te), Tp({
                            baseQueryMeta: W._bqMeta
                        }))
                }
            } catch (te) {
                W = te
            }
            throw console.error(W),
            W
        }
    }
    ;
    function C(I, M) {
        const B = a.selectQueryEntry(M, I.queryCacheKey)
          , L = a.selectConfig(M).refetchOnMountOrArgChange
          , F = B?.fulfilledTimeStamp
          , j = I.forceRefetch ?? (I.subscribe && L);
        return j ? j === !0 || (Number(new Date) - Number(F)) / 1e3 >= j : !1
    }
    const w = () => Ja(`${e}/executeQuery`, S, {
        getPendingMeta({arg: M}) {
            const B = n[M.endpointName];
            return Tp({
                startedTimeStamp: Date.now(),
                ...y1(B) ? {
                    direction: M.direction
                } : {}
            })
        },
        condition(M, {getState: B}) {
            const L = B()
              , F = a.selectQueryEntry(L, M.queryCacheKey)
              , j = F?.fulfilledTimeStamp
              , N = M.originalArgs
              , H = F?.originalArgs
              , Z = n[M.endpointName]
              , q = M.direction;
            return CT(M) ? !0 : F?.status === "pending" ? !1 : C(M, L) || g1(Z) && Z?.forceRefetch?.({
                currentArg: N,
                previousArg: H,
                endpointState: F,
                state: L
            }) ? !0 : !(j && !q)
        },
        dispatchConditionRejection: !0
    })
      , k = w()
      , T = w()
      , E = Ja(`${e}/executeMutation`, S, {
        getPendingMeta() {
            return Tp({
                startedTimeStamp: Date.now()
            })
        }
    })
      , P = I => "force"in I
      , D = I => "ifOlderThan"in I
      , $ = (I, M, B) => (L, F) => {
        const j = P(B) && B.force
          , N = D(B) && B.ifOlderThan
          , H = (q=!0) => {
            const V = {
                forceRefetch: q,
                isPrefetch: !0
            };
            return i.endpoints[I].initiate(M, V)
        }
          , Z = i.endpoints[I].select(M)(F());
        if (j)
            L(H());
        else if (N) {
            const q = Z?.fulfilledTimeStamp;
            if (!q) {
                L(H());
                return
            }
            (Number(new Date) - Number(new Date(q))) / 1e3 >= N && L(H())
        } else
            L(H(!1))
    }
    ;
    function z(I) {
        return M => M?.meta?.arg?.endpointName === I
    }
    function O(I, M) {
        return {
            matchPending: Cm(eA(I), z(M)),
            matchFulfilled: Cm(Cc(I), z(M)),
            matchRejected: Cm(Yf(I), z(M))
        }
    }
    return {
        queryThunk: k,
        mutationThunk: E,
        infiniteQueryThunk: T,
        prefetch: $,
        updateQueryData: y,
        upsertQueryData: b,
        patchQueryData: f,
        buildMatchThunkActions: O
    }
}
function wT(e, {pages: t, pageParams: n}, r) {
    const i = t.length - 1;
    return e.getNextPageParam(t[i], t, n[i], n, r)
}
function G4(e, {pages: t, pageParams: n}, r) {
    return e.getPreviousPageParam?.(t[0], t, n[0], n, r)
}
function Y4(e, t, n, r) {
    return gA(n[e.meta.arg.endpointName][t], Cc(e) ? e.payload : void 0, a1(e) ? e.payload : void 0, e.meta.arg.originalArgs, "baseQueryMeta"in e.meta ? e.meta.baseQueryMeta : void 0, r)
}
function Hb(e, t, n) {
    const r = e[t];
    r && n(r)
}
function eg(e) {
    return ("arg"in e ? e.arg.fixedCacheKey : e.fixedCacheKey) ?? e.requestId
}
function qL(e, t, n) {
    const r = e[eg(t)];
    r && n(r)
}
var qb = {};
function kpe({reducerPath: e, queryThunk: t, mutationThunk: n, serializeQueryArgs: r, context: {endpointDefinitions: i, apiUid: o, extractRehydrationInfo: a, hasRehydrationInfo: s}, assertTagType: c, config: u}) {
    const f = It(`${e}/resetApiState`);
    function h(z, O, I, M) {
        z[O.queryCacheKey] ??= {
            status: "uninitialized",
            endpointName: O.endpointName
        },
        Hb(z, O.queryCacheKey, B => {
            B.status = "pending",
            B.requestId = I && B.requestId ? B.requestId : M.requestId,
            O.originalArgs !== void 0 && (B.originalArgs = O.originalArgs),
            B.startedTimeStamp = M.startedTimeStamp;
            const L = i[M.arg.endpointName];
            y1(L) && "direction"in O && (B.direction = O.direction)
        }
        )
    }
    function m(z, O, I, M) {
        Hb(z, O.arg.queryCacheKey, B => {
            if (B.requestId !== O.requestId && !M)
                return;
            const {merge: L} = i[O.arg.endpointName];
            if (B.status = "fulfilled",
            L)
                if (B.data !== void 0) {
                    const {fulfilledTimeStamp: F, arg: j, baseQueryMeta: N, requestId: H} = O;
                    let Z = Fg(B.data, q => L(q, I, {
                        arg: j.originalArgs,
                        baseQueryMeta: N,
                        fulfilledTimeStamp: F,
                        requestId: H
                    }));
                    B.data = Z
                } else
                    B.data = I;
            else
                B.data = i[O.arg.endpointName].structuralSharing ?? !0 ? hA(Es(B.data) ? Dde(B.data) : B.data, I) : I;
            delete B.error,
            B.fulfilledTimeStamp = O.fulfilledTimeStamp
        }
        )
    }
    const y = Vo({
        name: `${e}/queries`,
        initialState: qb,
        reducers: {
            removeQueryResult: {
                reducer(z, {payload: {queryCacheKey: O}}) {
                    delete z[O]
                },
                prepare: wp()
            },
            cacheEntriesUpserted: {
                reducer(z, O) {
                    for (const I of O.payload) {
                        const {queryDescription: M, value: B} = I;
                        h(z, M, !0, {
                            arg: M,
                            requestId: O.meta.requestId,
                            startedTimeStamp: O.meta.timestamp
                        }),
                        m(z, {
                            arg: M,
                            requestId: O.meta.requestId,
                            fulfilledTimeStamp: O.meta.timestamp,
                            baseQueryMeta: {}
                        }, B, !0)
                    }
                },
                prepare: z => ({
                    payload: z.map(M => {
                        const {endpointName: B, arg: L, value: F} = M
                          , j = i[B];
                        return {
                            queryDescription: {
                                type: "query",
                                endpointName: B,
                                originalArgs: M.arg,
                                queryCacheKey: r({
                                    queryArgs: L,
                                    endpointDefinition: j,
                                    endpointName: B
                                })
                            },
                            value: F
                        }
                    }
                    ),
                    meta: {
                        [i1]: !0,
                        requestId: s1(),
                        timestamp: Date.now()
                    }
                })
            },
            queryResultPatched: {
                reducer(z, {payload: {queryCacheKey: O, patches: I}}) {
                    Hb(z, O, M => {
                        M.data = wL(M.data, I.concat())
                    }
                    )
                },
                prepare: wp()
            }
        },
        extraReducers(z) {
            z.addCase(t.pending, (O, {meta: I, meta: {arg: M}}) => {
                const B = CT(M);
                h(O, M, B, I)
            }
            ).addCase(t.fulfilled, (O, {meta: I, payload: M}) => {
                const B = CT(I.arg);
                m(O, I, M, B)
            }
            ).addCase(t.rejected, (O, {meta: {condition: I, arg: M, requestId: B}, error: L, payload: F}) => {
                Hb(O, M.queryCacheKey, j => {
                    if (!I) {
                        if (j.requestId !== B)
                            return;
                        j.status = "rejected",
                        j.error = F ?? L
                    }
                }
                )
            }
            ).addMatcher(s, (O, I) => {
                const {queries: M} = a(I);
                for (const [B,L] of Object.entries(M))
                    (L?.status === "fulfilled" || L?.status === "rejected") && (O[B] = L)
            }
            )
        }
    })
      , b = Vo({
        name: `${e}/mutations`,
        initialState: qb,
        reducers: {
            removeMutationResult: {
                reducer(z, {payload: O}) {
                    const I = eg(O);
                    I in z && delete z[I]
                },
                prepare: wp()
            }
        },
        extraReducers(z) {
            z.addCase(n.pending, (O, {meta: I, meta: {requestId: M, arg: B, startedTimeStamp: L}}) => {
                B.track && (O[eg(I)] = {
                    requestId: M,
                    status: "pending",
                    endpointName: B.endpointName,
                    startedTimeStamp: L
                })
            }
            ).addCase(n.fulfilled, (O, {payload: I, meta: M}) => {
                M.arg.track && qL(O, M, B => {
                    B.requestId === M.requestId && (B.status = "fulfilled",
                    B.data = I,
                    B.fulfilledTimeStamp = M.fulfilledTimeStamp)
                }
                )
            }
            ).addCase(n.rejected, (O, {payload: I, error: M, meta: B}) => {
                B.arg.track && qL(O, B, L => {
                    L.requestId === B.requestId && (L.status = "rejected",
                    L.error = I ?? M)
                }
                )
            }
            ).addMatcher(s, (O, I) => {
                const {mutations: M} = a(I);
                for (const [B,L] of Object.entries(M))
                    (L?.status === "fulfilled" || L?.status === "rejected") && B !== L?.requestId && (O[B] = L)
            }
            )
        }
    })
      , v = {
        tags: {},
        keys: {}
    }
      , S = Vo({
        name: `${e}/invalidation`,
        initialState: v,
        reducers: {
            updateProvidedBy: {
                reducer(z, O) {
                    for (const {queryCacheKey: I, providedTags: M} of O.payload) {
                        C(z, I);
                        for (const {type: B, id: L} of M) {
                            const F = (z.tags[B] ??= {})[L || "__internal_without_id"] ??= [];
                            F.includes(I) || F.push(I)
                        }
                        z.keys[I] = M
                    }
                },
                prepare: wp()
            }
        },
        extraReducers(z) {
            z.addCase(y.actions.removeQueryResult, (O, {payload: {queryCacheKey: I}}) => {
                C(O, I)
            }
            ).addMatcher(s, (O, I) => {
                const {provided: M} = a(I);
                for (const [B,L] of Object.entries(M.tags ?? {}))
                    for (const [F,j] of Object.entries(L)) {
                        const N = (O.tags[B] ??= {})[F || "__internal_without_id"] ??= [];
                        for (const H of j)
                            N.includes(H) || N.push(H),
                            O.keys[H] = M.keys[H]
                    }
            }
            ).addMatcher(kl(Cc(t), a1(t)), (O, I) => {
                w(O, [I])
            }
            ).addMatcher(y.actions.cacheEntriesUpserted.match, (O, I) => {
                const M = I.payload.map( ({queryDescription: B, value: L}) => ({
                    type: "UNKNOWN",
                    payload: L,
                    meta: {
                        requestStatus: "fulfilled",
                        requestId: "UNKNOWN",
                        arg: B
                    }
                }));
                w(O, M)
            }
            )
        }
    });
    function C(z, O) {
        const I = z.keys[O] ?? [];
        for (const M of I) {
            const B = M.type
              , L = M.id ?? "__internal_without_id"
              , F = z.tags[B]?.[L];
            F && (z.tags[B][L] = F.filter(j => j !== O))
        }
        delete z.keys[O]
    }
    function w(z, O) {
        const I = O.map(M => {
            const B = Y4(M, "providesTags", i, c)
              , {queryCacheKey: L} = M.meta.arg;
            return {
                queryCacheKey: L,
                providedTags: B
            }
        }
        );
        S.caseReducers.updateProvidedBy(z, S.actions.updateProvidedBy(I))
    }
    const k = Vo({
        name: `${e}/subscriptions`,
        initialState: qb,
        reducers: {
            updateSubscriptionOptions(z, O) {},
            unsubscribeQueryResult(z, O) {},
            internal_getRTKQSubscriptions() {}
        }
    })
      , T = Vo({
        name: `${e}/internalSubscriptions`,
        initialState: qb,
        reducers: {
            subscriptionsUpdated: {
                reducer(z, O) {
                    return wL(z, O.payload)
                },
                prepare: wp()
            }
        }
    })
      , E = Vo({
        name: `${e}/config`,
        initialState: {
            online: dpe(),
            focused: upe(),
            middlewareRegistered: !1,
            ...u
        },
        reducers: {
            middlewareRegistered(z, {payload: O}) {
                z.middlewareRegistered = z.middlewareRegistered === "conflict" || o !== O ? "conflict" : !0
            }
        },
        extraReducers: z => {
            z.addCase(mA, O => {
                O.online = !0
            }
            ).addCase(q4, O => {
                O.online = !1
            }
            ).addCase(pA, O => {
                O.focused = !0
            }
            ).addCase(H4, O => {
                O.focused = !1
            }
            ).addMatcher(s, O => ({
                ...O
            }))
        }
    })
      , P = h3({
        queries: y.reducer,
        mutations: b.reducer,
        provided: S.reducer,
        subscriptions: T.reducer,
        config: E.reducer
    })
      , D = (z, O) => P(f.match(O) ? void 0 : z, O)
      , $ = {
        ...E.actions,
        ...y.actions,
        ...k.actions,
        ...T.actions,
        ...b.actions,
        ...S.actions,
        resetApiState: f
    };
    return {
        reducer: D,
        actions: $
    }
}
var La = Symbol.for("RTKQ/skipToken")
  , Z4 = {
    status: "uninitialized"
}
  , WL = Fg(Z4, () => {}
)
  , GL = Fg(Z4, () => {}
);
function Tpe({serializeQueryArgs: e, reducerPath: t, createSelector: n}) {
    const r = k => WL
      , i = k => GL;
    return {
        buildQuerySelector: m,
        buildInfiniteQuerySelector: y,
        buildMutationSelector: b,
        selectInvalidatedBy: v,
        selectCachedArgsForQuery: S,
        selectApiState: a,
        selectQueries: s,
        selectMutations: u,
        selectQueryEntry: c,
        selectConfig: f
    };
    function o(k) {
        return {
            ...k,
            ...BL(k.status)
        }
    }
    function a(k) {
        return k[t]
    }
    function s(k) {
        return a(k)?.queries
    }
    function c(k, T) {
        return s(k)?.[T]
    }
    function u(k) {
        return a(k)?.mutations
    }
    function f(k) {
        return a(k)?.config
    }
    function h(k, T, E) {
        return P => {
            if (P === La)
                return n(r, E);
            const D = e({
                queryArgs: P,
                endpointDefinition: T,
                endpointName: k
            });
            return n(z => c(z, D) ?? WL, E)
        }
    }
    function m(k, T) {
        return h(k, T, o)
    }
    function y(k, T) {
        const {infiniteQueryOptions: E} = T;
        function P(D) {
            const $ = {
                ...D,
                ...BL(D.status)
            }
              , {isLoading: z, isError: O, direction: I} = $
              , M = I === "forward"
              , B = I === "backward";
            return {
                ...$,
                hasNextPage: C(E, $.data, $.originalArgs),
                hasPreviousPage: w(E, $.data, $.originalArgs),
                isFetchingNextPage: z && M,
                isFetchingPreviousPage: z && B,
                isFetchNextPageError: O && M,
                isFetchPreviousPageError: O && B
            }
        }
        return h(k, T, P)
    }
    function b() {
        return k => {
            let T;
            return typeof k == "object" ? T = eg(k) ?? La : T = k,
            n(T === La ? i : D => a(D)?.mutations?.[T] ?? GL, o)
        }
    }
    function v(k, T) {
        const E = k[t]
          , P = new Set;
        for (const D of T.filter(M0).map(ST)) {
            const $ = E.provided.tags[D.type];
            if (!$)
                continue;
            let z = (D.id !== void 0 ? $[D.id] : FL(Object.values($))) ?? [];
            for (const O of z)
                P.add(O)
        }
        return FL(Array.from(P.values()).map(D => {
            const $ = E.queries[D];
            return $ ? [{
                queryCacheKey: D,
                endpointName: $.endpointName,
                originalArgs: $.originalArgs
            }] : []
        }
        ))
    }
    function S(k, T) {
        return Object.values(s(k)).filter(E => E?.endpointName === T && E.status !== "uninitialized").map(E => E.originalArgs)
    }
    function C(k, T, E) {
        return T ? wT(k, T, E) != null : !1
    }
    function w(k, T, E) {
        return !T || !k.getPreviousPageParam ? !1 : G4(k, T, E) != null
    }
}
var YL = WeakMap ? new WeakMap : void 0
  , ZL = ({endpointName: e, queryArgs: t}) => {
    let n = "";
    const r = YL?.get(t);
    if (typeof r == "string")
        n = r;
    else {
        const i = JSON.stringify(t, (o, a) => (a = typeof a == "bigint" ? {
            $bigint: a.toString()
        } : a,
        a = Sc(a) ? Object.keys(a).sort().reduce( (s, c) => (s[c] = a[c],
        s), {}) : a,
        a));
        Sc(t) && YL?.set(t, i),
        n = i
    }
    return `${e}(${n})`
}
;
function Q4(...e) {
    return function(n) {
        const r = _0(u => n.extractRehydrationInfo?.(u, {
            reducerPath: n.reducerPath ?? "api"
        }))
          , i = {
            reducerPath: "api",
            keepUnusedDataFor: 60,
            refetchOnMountOrArgChange: !1,
            refetchOnFocus: !1,
            refetchOnReconnect: !1,
            invalidationBehavior: "delayed",
            ...n,
            extractRehydrationInfo: r,
            serializeQueryArgs(u) {
                let f = ZL;
                if ("serializeQueryArgs"in u.endpointDefinition) {
                    const h = u.endpointDefinition.serializeQueryArgs;
                    f = m => {
                        const y = h(m);
                        return typeof y == "string" ? y : ZL({
                            ...m,
                            queryArgs: y
                        })
                    }
                } else
                    n.serializeQueryArgs && (f = n.serializeQueryArgs);
                return f(u)
            },
            tagTypes: [...n.tagTypes || []]
        }
          , o = {
            endpointDefinitions: {},
            batch(u) {
                u()
            },
            apiUid: s1(),
            extractRehydrationInfo: r,
            hasRehydrationInfo: _0(u => r(u) != null)
        }
          , a = {
            injectEndpoints: c,
            enhanceEndpoints({addTagTypes: u, endpoints: f}) {
                if (u)
                    for (const h of u)
                        i.tagTypes.includes(h) || i.tagTypes.push(h);
                if (f)
                    for (const [h,m] of Object.entries(f))
                        typeof m == "function" ? m(o.endpointDefinitions[h]) : Object.assign(o.endpointDefinitions[h] || {}, m);
                return a
            }
        }
          , s = e.map(u => u.init(a, i, o));
        function c(u) {
            const f = u.endpoints({
                query: h => ({
                    ...h,
                    type: "query"
                }),
                mutation: h => ({
                    ...h,
                    type: "mutation"
                }),
                infiniteQuery: h => ({
                    ...h,
                    type: "infinitequery"
                })
            });
            for (const [h,m] of Object.entries(f)) {
                if (u.overrideExisting !== !0 && h in o.endpointDefinitions) {
                    if (u.overrideExisting === "throw")
                        throw new Error(qi(39));
                    continue
                }
                o.endpointDefinitions[h] = m;
                for (const y of s)
                    y.injectEndpoint(h, m)
            }
            return a
        }
        return a.injectEndpoints({
            endpoints: n.endpoints
        })
    }
}
function al(e, ...t) {
    return Object.assign(e, ...t)
}
var _pe = ({api: e, queryThunk: t, internalState: n, mwApi: r}) => {
    const i = `${e.reducerPath}/subscriptions`;
    let o = null
      , a = null;
    const {updateSubscriptionOptions: s, unsubscribeQueryResult: c} = e.internalActions
      , u = (v, S) => {
        if (s.match(S)) {
            const {queryCacheKey: w, requestId: k, options: T} = S.payload
              , E = v.get(w);
            return E?.has(k) && E.set(k, T),
            !0
        }
        if (c.match(S)) {
            const {queryCacheKey: w, requestId: k} = S.payload
              , T = v.get(w);
            return T && T.delete(k),
            !0
        }
        if (e.internalActions.removeQueryResult.match(S))
            return v.delete(S.payload.queryCacheKey),
            !0;
        if (t.pending.match(S)) {
            const {meta: {arg: w, requestId: k}} = S
              , T = xT(v, w.queryCacheKey, vT);
            return w.subscribe && T.set(k, w.subscriptionOptions ?? T.get(k) ?? {}),
            !0
        }
        let C = !1;
        if (t.rejected.match(S)) {
            const {meta: {condition: w, arg: k, requestId: T}} = S;
            if (w && k.subscribe) {
                const E = xT(v, k.queryCacheKey, vT);
                E.set(T, k.subscriptionOptions ?? E.get(T) ?? {}),
                C = !0
            }
        }
        return C
    }
      , f = () => n.currentSubscriptions
      , y = {
        getSubscriptions: f,
        getSubscriptionCount: v => f().get(v)?.size ?? 0,
        isRequestSubscribed: (v, S) => !!f()?.get(v)?.get(S)
    };
    function b(v) {
        return JSON.parse(JSON.stringify(Object.fromEntries([...v].map( ([S,C]) => [S, Object.fromEntries(C)]))))
    }
    return (v, S) => {
        if (o || (o = b(n.currentSubscriptions)),
        e.util.resetApiState.match(v))
            return o = {},
            n.currentSubscriptions.clear(),
            a = null,
            [!0, !1];
        if (e.internalActions.internal_getRTKQSubscriptions.match(v))
            return [!1, y];
        const C = u(n.currentSubscriptions, v);
        let w = !0;
        if (C) {
            a || (a = setTimeout( () => {
                const E = b(n.currentSubscriptions)
                  , [,P] = x3(o, () => E);
                S.next(e.internalActions.subscriptionsUpdated(P)),
                o = E,
                a = null
            }
            , 500));
            const k = typeof v.type == "string" && !!v.type.startsWith(i)
              , T = t.rejected.match(v) && v.meta.condition && !!v.meta.arg.subscribe;
            w = !k && !T
        }
        return [w, !1]
    }
}
  , Epe = 2147483647 / 1e3 - 1
  , Ape = ({reducerPath: e, api: t, queryThunk: n, context: r, internalState: i, selectors: {selectQueryEntry: o, selectConfig: a}, getRunningQueryThunk: s, mwApi: c}) => {
    const {removeQueryResult: u, unsubscribeQueryResult: f, cacheEntriesUpserted: h} = t.internalActions
      , m = i.runningQueries.get(c.dispatch)
      , y = kl(f.match, n.fulfilled, n.rejected, h.match);
    function b(k) {
        const T = i.currentSubscriptions.get(k);
        if (!T)
            return !1;
        const E = T.size > 0
          , P = m?.[k] !== void 0;
        return E || P
    }
    const v = {}
      , S = (k, T, E) => {
        const P = T.getState()
          , D = a(P);
        if (y(k)) {
            let $;
            if (h.match(k))
                $ = k.payload.map(z => z.queryDescription.queryCacheKey);
            else {
                const {queryCacheKey: z} = f.match(k) ? k.payload : k.meta.arg;
                $ = [z]
            }
            C($, T, D)
        }
        if (t.util.resetApiState.match(k))
            for (const [$,z] of Object.entries(v))
                z && clearTimeout(z),
                delete v[$];
        if (r.hasRehydrationInfo(k)) {
            const {queries: $} = r.extractRehydrationInfo(k);
            C(Object.keys($), T, D)
        }
    }
    ;
    function C(k, T, E) {
        const P = T.getState();
        for (const D of k) {
            const $ = o(P, D);
            $?.endpointName && w(D, $.endpointName, T, E)
        }
    }
    function w(k, T, E, P) {
        const $ = r.endpointDefinitions[T]?.keepUnusedDataFor ?? P.keepUnusedDataFor;
        if ($ === 1 / 0)
            return;
        const z = Math.max(0, Math.min($, Epe));
        if (!b(k)) {
            const O = v[k];
            O && clearTimeout(O),
            v[k] = setTimeout( () => {
                if (!b(k)) {
                    const I = o(E.getState(), k);
                    I?.endpointName && E.dispatch(s(I.endpointName, I.originalArgs))?.abort(),
                    E.dispatch(u({
                        queryCacheKey: k
                    }))
                }
                delete v[k]
            }
            , z * 1e3)
        }
    }
    return S
}
  , QL = new Error("Promise never resolved before cacheEntryRemoved.")
  , Mpe = ({api: e, reducerPath: t, context: n, queryThunk: r, mutationThunk: i, internalState: o, selectors: {selectQueryEntry: a, selectApiState: s}}) => {
    const c = pT(r)
      , u = pT(i)
      , f = Cc(r, i)
      , h = {};
    function m(C, w, k) {
        const T = h[C];
        T?.valueResolved && (T.valueResolved({
            data: w,
            meta: k
        }),
        delete T.valueResolved)
    }
    function y(C) {
        const w = h[C];
        w && (delete h[C],
        w.cacheEntryRemoved())
    }
    const b = (C, w, k) => {
        const T = v(C);
        function E(P, D, $, z) {
            const O = a(k, D)
              , I = a(w.getState(), D);
            !O && I && S(P, z, D, w, $)
        }
        if (r.pending.match(C))
            E(C.meta.arg.endpointName, T, C.meta.requestId, C.meta.arg.originalArgs);
        else if (e.internalActions.cacheEntriesUpserted.match(C))
            for (const {queryDescription: P, value: D} of C.payload) {
                const {endpointName: $, originalArgs: z, queryCacheKey: O} = P;
                E($, O, C.meta.requestId, z),
                m(O, D, {})
            }
        else if (i.pending.match(C))
            w.getState()[t].mutations[T] && S(C.meta.arg.endpointName, C.meta.arg.originalArgs, T, w, C.meta.requestId);
        else if (f(C))
            m(T, C.payload, C.meta.baseQueryMeta);
        else if (e.internalActions.removeQueryResult.match(C) || e.internalActions.removeMutationResult.match(C))
            y(T);
        else if (e.util.resetApiState.match(C))
            for (const P of Object.keys(h))
                y(P)
    }
    ;
    function v(C) {
        return c(C) ? C.meta.arg.queryCacheKey : u(C) ? C.meta.arg.fixedCacheKey ?? C.meta.requestId : e.internalActions.removeQueryResult.match(C) ? C.payload.queryCacheKey : e.internalActions.removeMutationResult.match(C) ? eg(C.payload) : ""
    }
    function S(C, w, k, T, E) {
        const P = n.endpointDefinitions[C]
          , D = P?.onCacheEntryAdded;
        if (!D)
            return;
        const $ = {}
          , z = new Promise(F => {
            $.cacheEntryRemoved = F
        }
        )
          , O = Promise.race([new Promise(F => {
            $.valueResolved = F
        }
        ), z.then( () => {
            throw QL
        }
        )]);
        O.catch( () => {}
        ),
        h[k] = $;
        const I = e.endpoints[C].select(P0(P) ? w : k)
          , M = T.dispatch( (F, j, N) => N)
          , B = {
            ...T,
            getCacheEntry: () => I(T.getState()),
            requestId: E,
            extra: M,
            updateCachedData: P0(P) ? F => T.dispatch(e.util.updateQueryData(C, w, F)) : void 0,
            cacheDataLoaded: O,
            cacheEntryRemoved: z
        }
          , L = D(w, B);
        Promise.resolve(L).catch(F => {
            if (F !== QL)
                throw F
        }
        )
    }
    return b
}
  , Ppe = ({api: e, context: {apiUid: t}, reducerPath: n}) => (r, i) => {
    e.util.resetApiState.match(r) && i.dispatch(e.internalActions.middlewareRegistered(t))
}
  , Rpe = ({reducerPath: e, context: t, context: {endpointDefinitions: n}, mutationThunk: r, queryThunk: i, api: o, assertTagType: a, refetchQuery: s, internalState: c}) => {
    const {removeQueryResult: u} = o.internalActions
      , f = kl(Cc(r), a1(r))
      , h = kl(Cc(r, i), Yf(r, i));
    let m = [];
    const y = (S, C) => {
        f(S) ? v(Y4(S, "invalidatesTags", n, a), C) : h(S) ? v([], C) : o.util.invalidateTags.match(S) && v(gA(S.payload, void 0, void 0, void 0, void 0, a), C)
    }
    ;
    function b(S) {
        const {queries: C, mutations: w} = S;
        for (const k of [C, w])
            for (const T in k)
                if (k[T]?.status === "pending")
                    return !0;
        return !1
    }
    function v(S, C) {
        const w = C.getState()
          , k = w[e];
        if (m.push(...S),
        k.config.invalidationBehavior === "delayed" && b(k))
            return;
        const T = m;
        if (m = [],
        T.length === 0)
            return;
        const E = o.util.selectInvalidatedBy(w, T);
        t.batch( () => {
            const P = Array.from(E.values());
            for (const {queryCacheKey: D} of P) {
                const $ = k.queries[D]
                  , z = xT(c.currentSubscriptions, D, vT);
                $ && (z.size === 0 ? C.dispatch(u({
                    queryCacheKey: D
                })) : $.status !== "uninitialized" && C.dispatch(s($)))
            }
        }
        )
    }
    return y
}
  , Dpe = ({reducerPath: e, queryThunk: t, api: n, refetchQuery: r, internalState: i}) => {
    const {currentPolls: o, currentSubscriptions: a} = i
      , s = new Set;
    let c = null;
    const u = (S, C) => {
        (n.internalActions.updateSubscriptionOptions.match(S) || n.internalActions.unsubscribeQueryResult.match(S)) && f(S.payload.queryCacheKey, C),
        (t.pending.match(S) || t.rejected.match(S) && S.meta.condition) && f(S.meta.arg.queryCacheKey, C),
        (t.fulfilled.match(S) || t.rejected.match(S) && !S.meta.condition) && h(S.meta.arg, C),
        n.util.resetApiState.match(S) && (b(),
        c && (clearTimeout(c),
        c = null),
        s.clear())
    }
    ;
    function f(S, C) {
        s.add(S),
        c || (c = setTimeout( () => {
            for (const w of s)
                m({
                    queryCacheKey: w
                }, C);
            s.clear(),
            c = null
        }
        , 0))
    }
    function h({queryCacheKey: S}, C) {
        const w = C.getState()[e]
          , k = w.queries[S]
          , T = a.get(S);
        if (!k || k.status === "uninitialized")
            return;
        const {lowestPollingInterval: E, skipPollingIfUnfocused: P} = v(T);
        if (!Number.isFinite(E))
            return;
        const D = o.get(S);
        D?.timeout && (clearTimeout(D.timeout),
        D.timeout = void 0);
        const $ = Date.now() + E;
        o.set(S, {
            nextPollTimestamp: $,
            pollingInterval: E,
            timeout: setTimeout( () => {
                (w.config.focused || !P) && C.dispatch(r(k)),
                h({
                    queryCacheKey: S
                }, C)
            }
            , E)
        })
    }
    function m({queryCacheKey: S}, C) {
        const k = C.getState()[e].queries[S]
          , T = a.get(S);
        if (!k || k.status === "uninitialized")
            return;
        const {lowestPollingInterval: E} = v(T);
        if (!Number.isFinite(E)) {
            y(S);
            return
        }
        const P = o.get(S)
          , D = Date.now() + E;
        (!P || D < P.nextPollTimestamp) && h({
            queryCacheKey: S
        }, C)
    }
    function y(S) {
        const C = o.get(S);
        C?.timeout && clearTimeout(C.timeout),
        o.delete(S)
    }
    function b() {
        for (const S of o.keys())
            y(S)
    }
    function v(S=new Map) {
        let C = !1
          , w = Number.POSITIVE_INFINITY;
        for (const k of S.values())
            k.pollingInterval && (w = Math.min(k.pollingInterval, w),
            C = k.skipPollingIfUnfocused || C);
        return {
            lowestPollingInterval: w,
            skipPollingIfUnfocused: C
        }
    }
    return u
}
  , Ope = ({api: e, context: t, queryThunk: n, mutationThunk: r}) => {
    const i = eA(n, r)
      , o = Yf(n, r)
      , a = Cc(n, r)
      , s = {};
    return (u, f) => {
        if (i(u)) {
            const {requestId: h, arg: {endpointName: m, originalArgs: y}} = u.meta
              , b = t.endpointDefinitions[m]
              , v = b?.onQueryStarted;
            if (v) {
                const S = {}
                  , C = new Promise( (E, P) => {
                    S.resolve = E,
                    S.reject = P
                }
                );
                C.catch( () => {}
                ),
                s[h] = S;
                const w = e.endpoints[m].select(P0(b) ? y : h)
                  , k = f.dispatch( (E, P, D) => D)
                  , T = {
                    ...f,
                    getCacheEntry: () => w(f.getState()),
                    requestId: h,
                    extra: k,
                    updateCachedData: P0(b) ? E => f.dispatch(e.util.updateQueryData(m, y, E)) : void 0,
                    queryFulfilled: C
                };
                v(y, T)
            }
        } else if (a(u)) {
            const {requestId: h, baseQueryMeta: m} = u.meta;
            s[h]?.resolve({
                data: u.payload,
                meta: m
            }),
            delete s[h]
        } else if (o(u)) {
            const {requestId: h, rejectedWithValue: m, baseQueryMeta: y} = u.meta;
            s[h]?.reject({
                error: u.payload ?? u.error,
                isUnhandledError: !m,
                meta: y
            }),
            delete s[h]
        }
    }
}
  , Ipe = ({reducerPath: e, context: t, api: n, refetchQuery: r, internalState: i}) => {
    const {removeQueryResult: o} = n.internalActions
      , a = (c, u) => {
        pA.match(c) && s(u, "refetchOnFocus"),
        mA.match(c) && s(u, "refetchOnReconnect")
    }
    ;
    function s(c, u) {
        const f = c.getState()[e]
          , h = f.queries
          , m = i.currentSubscriptions;
        t.batch( () => {
            for (const y of m.keys()) {
                const b = h[y]
                  , v = m.get(y);
                if (!v || !b)
                    continue;
                const S = [...v.values()];
                (S.some(w => w[u] === !0) || S.every(w => w[u] === void 0) && f.config[u]) && (v.size === 0 ? c.dispatch(o({
                    queryCacheKey: y
                })) : b.status !== "uninitialized" && c.dispatch(r(b)))
            }
        }
        )
    }
    return a
}
;
function $pe(e) {
    const {reducerPath: t, queryThunk: n, api: r, context: i, internalState: o} = e
      , {apiUid: a} = i
      , s = {
        invalidateTags: It(`${t}/invalidateTags`)
    }
      , c = m => m.type.startsWith(`${t}/`)
      , u = [Ppe, Ape, Rpe, Dpe, Mpe, Ope];
    return {
        middleware: m => {
            let y = !1;
            const b = {
                ...e,
                internalState: o,
                refetchQuery: h,
                isThisApiSliceAction: c,
                mwApi: m
            }
              , v = u.map(w => w(b))
              , S = _pe(b)
              , C = Ipe(b);
            return w => k => {
                if (!ZE(k))
                    return w(k);
                y || (y = !0,
                m.dispatch(r.internalActions.middlewareRegistered(a)));
                const T = {
                    ...m,
                    next: w
                }
                  , E = m.getState()
                  , [P,D] = S(k, T, E);
                let $;
                if (P ? $ = w(k) : $ = D,
                m.getState()[t] && (C(k, T, E),
                c(k) || i.hasRehydrationInfo(k)))
                    for (const z of v)
                        z(k, T, E);
                return $
            }
        }
        ,
        actions: s
    };
    function h(m) {
        return e.api.endpoints[m.endpointName].initiate(m.originalArgs, {
            subscribe: !1,
            forceRefetch: !0
        })
    }
}
var KL = Symbol()
  , K4 = ({createSelector: e=JE}={}) => ({
    name: KL,
    init(t, {baseQuery: n, tagTypes: r, reducerPath: i, serializeQueryArgs: o, keepUnusedDataFor: a, refetchOnMountOrArgChange: s, refetchOnFocus: c, refetchOnReconnect: u, invalidationBehavior: f, onSchemaFailure: h, catchSchemaFailure: m, skipSchemaValidation: y}, b) {
        Nde();
        const v = ee => ee;
        Object.assign(t, {
            reducerPath: i,
            endpoints: {},
            internalActions: {
                onOnline: mA,
                onOffline: q4,
                onFocus: pA,
                onFocusLost: H4
            },
            util: {}
        });
        const S = Tpe({
            serializeQueryArgs: o,
            reducerPath: i,
            createSelector: e
        })
          , {selectInvalidatedBy: C, selectCachedArgsForQuery: w, buildQuerySelector: k, buildInfiniteQuerySelector: T, buildMutationSelector: E} = S;
        al(t.util, {
            selectInvalidatedBy: C,
            selectCachedArgsForQuery: w
        });
        const {queryThunk: P, infiniteQueryThunk: D, mutationThunk: $, patchQueryData: z, updateQueryData: O, upsertQueryData: I, prefetch: M, buildMatchThunkActions: B} = wpe({
            baseQuery: n,
            reducerPath: i,
            context: b,
            api: t,
            serializeQueryArgs: o,
            assertTagType: v,
            selectors: S,
            onSchemaFailure: h,
            catchSchemaFailure: m,
            skipSchemaValidation: y
        })
          , {reducer: L, actions: F} = kpe({
            context: b,
            queryThunk: P,
            mutationThunk: $,
            serializeQueryArgs: o,
            reducerPath: i,
            assertTagType: v,
            config: {
                refetchOnFocus: c,
                refetchOnReconnect: u,
                refetchOnMountOrArgChange: s,
                keepUnusedDataFor: a,
                reducerPath: i,
                invalidationBehavior: f
            }
        });
        al(t.util, {
            patchQueryData: z,
            updateQueryData: O,
            upsertQueryData: I,
            prefetch: M,
            resetApiState: F.resetApiState,
            upsertQueryEntries: F.cacheEntriesUpserted
        }),
        al(t.internalActions, F);
        const j = {
            currentSubscriptions: new Map,
            currentPolls: new Map,
            runningQueries: new Map,
            runningMutations: new Map
        }
          , {buildInitiateQuery: N, buildInitiateInfiniteQuery: H, buildInitiateMutation: Z, getRunningMutationThunk: q, getRunningMutationsThunk: V, getRunningQueriesThunk: Y, getRunningQueryThunk: W} = Cpe({
            queryThunk: P,
            mutationThunk: $,
            infiniteQueryThunk: D,
            api: t,
            serializeQueryArgs: o,
            context: b,
            internalState: j
        });
        al(t.util, {
            getRunningMutationThunk: q,
            getRunningMutationsThunk: V,
            getRunningQueryThunk: W,
            getRunningQueriesThunk: Y
        });
        const {middleware: te, actions: K} = $pe({
            reducerPath: i,
            context: b,
            queryThunk: P,
            mutationThunk: $,
            infiniteQueryThunk: D,
            api: t,
            assertTagType: v,
            selectors: S,
            getRunningQueryThunk: W,
            internalState: j
        });
        return al(t.util, K),
        al(t, {
            reducer: L,
            middleware: te
        }),
        {
            name: KL,
            injectEndpoint(ee, re) {
                const ie = t
                  , J = ie.endpoints[ee] ??= {};
                g1(re) && al(J, {
                    name: ee,
                    select: k(ee, re),
                    initiate: N(ee, re)
                }, B(P, ee)),
                xpe(re) && al(J, {
                    name: ee,
                    select: E(),
                    initiate: Z(ee)
                }, B($, ee)),
                y1(re) && al(J, {
                    name: ee,
                    select: T(ee, re),
                    initiate: H(ee, re)
                }, B(P, ee))
            }
        }
    }
});
K4();
function Wb(e) {
    return e.replace(e[0], e[0].toUpperCase())
}
function Lpe(e) {
    return e.type === "query"
}
function jpe(e) {
    return e.type === "mutation"
}
function X4(e) {
    return e.type === "infinitequery"
}
function _p(e, ...t) {
    return Object.assign(e, ...t)
}
var uk = Symbol();
function dk(e) {
    const t = A.useRef(e)
      , n = A.useMemo( () => hA(t.current, e), [e]);
    return A.useEffect( () => {
        t.current !== n && (t.current = n)
    }
    , [n]),
    n
}
function Gb(e) {
    const t = A.useRef(e);
    return A.useEffect( () => {
        um(t.current, e) || (t.current = e)
    }
    , [e]),
    um(t.current, e) ? t.current : e
}
var Bpe = () => typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , zpe = Bpe()
  , Fpe = () => typeof navigator < "u" && navigator.product === "ReactNative"
  , Npe = Fpe()
  , Upe = () => zpe || Npe ? A.useLayoutEffect : A.useEffect
  , Vpe = Upe()
  , XL = e => e.isUninitialized ? {
    ...e,
    isUninitialized: !1,
    isFetching: !0,
    isLoading: e.data === void 0,
    status: V4.pending
} : e;
function fk(e, ...t) {
    const n = {};
    return t.forEach(r => {
        n[r] = e[r]
    }
    ),
    n
}
var hk = ["data", "status", "isLoading", "isSuccess", "isError", "error"];
function Hpe({api: e, moduleOptions: {batch: t, hooks: {useDispatch: n, useSelector: r, useStore: i}, unstable__sideEffectsInRender: o, createSelector: a}, serializeQueryArgs: s, context: c}) {
    const u = o ? T => T() : A.useEffect;
    return {
        buildQueryHooks: C,
        buildInfiniteQueryHooks: w,
        buildMutationHook: k,
        usePrefetch: m
    };
    function f(T, E, P) {
        if (E?.endpointName && T.isUninitialized) {
            const {endpointName: M} = E
              , B = c.endpointDefinitions[M];
            P !== La && s({
                queryArgs: E.originalArgs,
                endpointDefinition: B,
                endpointName: M
            }) === s({
                queryArgs: P,
                endpointDefinition: B,
                endpointName: M
            }) && (E = void 0)
        }
        let D = T.isSuccess ? T.data : E?.data;
        D === void 0 && (D = T.data);
        const $ = D !== void 0
          , z = T.isLoading
          , O = (!E || E.isLoading || E.isUninitialized) && !$ && z
          , I = T.isSuccess || $ && (z && !E?.isError || T.isUninitialized);
        return {
            ...T,
            data: D,
            currentData: T.data,
            isFetching: z,
            isLoading: O,
            isSuccess: I
        }
    }
    function h(T, E, P) {
        if (E?.endpointName && T.isUninitialized) {
            const {endpointName: M} = E
              , B = c.endpointDefinitions[M];
            P !== La && s({
                queryArgs: E.originalArgs,
                endpointDefinition: B,
                endpointName: M
            }) === s({
                queryArgs: P,
                endpointDefinition: B,
                endpointName: M
            }) && (E = void 0)
        }
        let D = T.isSuccess ? T.data : E?.data;
        D === void 0 && (D = T.data);
        const $ = D !== void 0
          , z = T.isLoading
          , O = (!E || E.isLoading || E.isUninitialized) && !$ && z
          , I = T.isSuccess || z && $;
        return {
            ...T,
            data: D,
            currentData: T.data,
            isFetching: z,
            isLoading: O,
            isSuccess: I
        }
    }
    function m(T, E) {
        const P = n()
          , D = Gb(E);
        return A.useCallback( ($, z) => P(e.util.prefetch(T, $, {
            ...D,
            ...z
        })), [T, P, D])
    }
    function y(T, E, {refetchOnReconnect: P, refetchOnFocus: D, refetchOnMountOrArgChange: $, skip: z=!1, pollingInterval: O=0, skipPollingIfUnfocused: I=!1, ...M}={}) {
        const {initiate: B} = e.endpoints[T]
          , L = n()
          , F = A.useRef(void 0);
        if (!F.current) {
            const K = L(e.internalActions.internal_getRTKQSubscriptions());
            F.current = K
        }
        const j = dk(z ? La : E)
          , N = Gb({
            refetchOnReconnect: P,
            refetchOnFocus: D,
            pollingInterval: O,
            skipPollingIfUnfocused: I
        })
          , H = M.initialPageParam
          , Z = Gb(H)
          , q = A.useRef(void 0);
        let {queryCacheKey: V, requestId: Y} = q.current || {}
          , W = !1;
        V && Y && (W = F.current.isRequestSubscribed(V, Y));
        const te = !W && q.current !== void 0;
        return u( () => {
            te && (q.current = void 0)
        }
        , [te]),
        u( () => {
            const K = q.current;
            if (j === La) {
                K?.unsubscribe(),
                q.current = void 0;
                return
            }
            const ee = q.current?.subscriptionOptions;
            if (!K || K.arg !== j) {
                K?.unsubscribe();
                const re = L(B(j, {
                    subscriptionOptions: N,
                    forceRefetch: $,
                    ...X4(c.endpointDefinitions[T]) ? {
                        initialPageParam: Z
                    } : {}
                }));
                q.current = re
            } else
                N !== ee && K.updateSubscriptionOptions(N)
        }
        , [L, B, $, j, N, te, Z, T]),
        [q, L, B, N]
    }
    function b(T, E) {
        return (D, {skip: $=!1, selectFromResult: z}={}) => {
            const {select: O} = e.endpoints[T]
              , I = dk($ ? La : D)
              , M = A.useRef(void 0)
              , B = A.useMemo( () => a([O(I), (H, Z) => Z, H => I], E, {
                memoizeOptions: {
                    resultEqualityCheck: um
                }
            }), [O, I])
              , L = A.useMemo( () => z ? a([B], z, {
                devModeChecks: {
                    identityFunctionCheck: "never"
                }
            }) : B, [B, z])
              , F = r(H => L(H, M.current), um)
              , j = i()
              , N = B(j.getState(), M.current);
            return Vpe( () => {
                M.current = N
            }
            , [N]),
            F
        }
    }
    function v(T) {
        A.useEffect( () => () => {
            T.current?.unsubscribe?.(),
            T.current = void 0
        }
        , [T])
    }
    function S(T) {
        if (!T.current)
            throw new Error(qi(38));
        return T.current.refetch()
    }
    function C(T) {
        const E = ($, z={}) => {
            const [O] = y(T, $, z);
            return v(O),
            A.useMemo( () => ({
                refetch: () => S(O)
            }), [O])
        }
          , P = ({refetchOnReconnect: $, refetchOnFocus: z, pollingInterval: O=0, skipPollingIfUnfocused: I=!1}={}) => {
            const {initiate: M} = e.endpoints[T]
              , B = n()
              , [L,F] = A.useState(uk)
              , j = A.useRef(void 0)
              , N = Gb({
                refetchOnReconnect: $,
                refetchOnFocus: z,
                pollingInterval: O,
                skipPollingIfUnfocused: I
            });
            u( () => {
                const V = j.current?.subscriptionOptions;
                N !== V && j.current?.updateSubscriptionOptions(N)
            }
            , [N]);
            const H = A.useRef(N);
            u( () => {
                H.current = N
            }
            , [N]);
            const Z = A.useCallback(function(V, Y=!1) {
                let W;
                return t( () => {
                    j.current?.unsubscribe(),
                    j.current = W = B(M(V, {
                        subscriptionOptions: H.current,
                        forceRefetch: !Y
                    })),
                    F(V)
                }
                ),
                W
            }, [B, M])
              , q = A.useCallback( () => {
                j.current?.queryCacheKey && B(e.internalActions.removeQueryResult({
                    queryCacheKey: j.current?.queryCacheKey
                }))
            }
            , [B]);
            return A.useEffect( () => () => {
                j?.current?.unsubscribe()
            }
            , []),
            A.useEffect( () => {
                L !== uk && !j.current && Z(L, !0)
            }
            , [L, Z]),
            A.useMemo( () => [Z, L, {
                reset: q
            }], [Z, L, q])
        }
          , D = b(T, f);
        return {
            useQueryState: D,
            useQuerySubscription: E,
            useLazyQuerySubscription: P,
            useLazyQuery($) {
                const [z,O,{reset: I}] = P($)
                  , M = D(O, {
                    ...$,
                    skip: O === uk
                })
                  , B = A.useMemo( () => ({
                    lastArg: O
                }), [O]);
                return A.useMemo( () => [z, {
                    ...M,
                    reset: I
                }, B], [z, M, I, B])
            },
            useQuery($, z) {
                const O = E($, z)
                  , I = D($, {
                    selectFromResult: $ === La || z?.skip ? void 0 : XL,
                    ...z
                })
                  , M = fk(I, ...hk);
                return A.useDebugValue(M),
                A.useMemo( () => ({
                    ...I,
                    ...O
                }), [I, O])
            }
        }
    }
    function w(T) {
        const E = (D, $={}) => {
            const [z,O,I,M] = y(T, D, $)
              , B = A.useRef(M);
            u( () => {
                B.current = M
            }
            , [M]);
            const L = A.useCallback(function(N, H) {
                let Z;
                return t( () => {
                    z.current?.unsubscribe(),
                    z.current = Z = O(I(N, {
                        subscriptionOptions: B.current,
                        direction: H
                    }))
                }
                ),
                Z
            }, [z, O, I]);
            v(z);
            const F = dk($.skip ? La : D)
              , j = A.useCallback( () => S(z), [z]);
            return A.useMemo( () => ({
                trigger: L,
                refetch: j,
                fetchNextPage: () => L(F, "forward"),
                fetchPreviousPage: () => L(F, "backward")
            }), [j, L, F])
        }
          , P = b(T, h);
        return {
            useInfiniteQueryState: P,
            useInfiniteQuerySubscription: E,
            useInfiniteQuery(D, $) {
                const {refetch: z, fetchNextPage: O, fetchPreviousPage: I} = E(D, $)
                  , M = P(D, {
                    selectFromResult: D === La || $?.skip ? void 0 : XL,
                    ...$
                })
                  , B = fk(M, ...hk, "hasNextPage", "hasPreviousPage");
                return A.useDebugValue(B),
                A.useMemo( () => ({
                    ...M,
                    fetchNextPage: O,
                    fetchPreviousPage: I,
                    refetch: z
                }), [M, O, I, z])
            }
        }
    }
    function k(T) {
        return ({selectFromResult: E, fixedCacheKey: P}={}) => {
            const {select: D, initiate: $} = e.endpoints[T]
              , z = n()
              , [O,I] = A.useState();
            A.useEffect( () => () => {
                O?.arg.fixedCacheKey || O?.reset()
            }
            , [O]);
            const M = A.useCallback(function(V) {
                const Y = z($(V, {
                    fixedCacheKey: P
                }));
                return I(Y),
                Y
            }, [z, $, P])
              , {requestId: B} = O || {}
              , L = A.useMemo( () => D({
                fixedCacheKey: P,
                requestId: O?.requestId
            }), [P, O, D])
              , F = A.useMemo( () => E ? a([L], E) : L, [E, L])
              , j = r(F, um)
              , N = P == null ? O?.arg.originalArgs : void 0
              , H = A.useCallback( () => {
                t( () => {
                    O && I(void 0),
                    P && z(e.internalActions.removeMutationResult({
                        requestId: B,
                        fixedCacheKey: P
                    }))
                }
                )
            }
            , [z, P, O, B])
              , Z = fk(j, ...hk, "endpointName");
            A.useDebugValue(Z);
            const q = A.useMemo( () => ({
                ...j,
                originalArgs: N,
                reset: H
            }), [j, N, H]);
            return A.useMemo( () => [M, q], [M, q])
        }
    }
}
var qpe = Symbol()
  , Wpe = ({batch: e=BK, hooks: t={
    useDispatch: $K,
    useSelector: CF,
    useStore: SF
}, createSelector: n=JE, unstable__sideEffectsInRender: r=!1, ...i}={}) => ({
    name: qpe,
    init(o, {serializeQueryArgs: a}, s) {
        const c = o
          , {buildQueryHooks: u, buildInfiniteQueryHooks: f, buildMutationHook: h, usePrefetch: m} = Hpe({
            api: o,
            moduleOptions: {
                batch: e,
                hooks: t,
                unstable__sideEffectsInRender: r,
                createSelector: n
            },
            serializeQueryArgs: a,
            context: s
        });
        return _p(c, {
            usePrefetch: m
        }),
        _p(s, {
            batch: e
        }),
        {
            injectEndpoint(y, b) {
                if (Lpe(b)) {
                    const {useQuery: v, useLazyQuery: S, useLazyQuerySubscription: C, useQueryState: w, useQuerySubscription: k} = u(y);
                    _p(c.endpoints[y], {
                        useQuery: v,
                        useLazyQuery: S,
                        useLazyQuerySubscription: C,
                        useQueryState: w,
                        useQuerySubscription: k
                    }),
                    o[`use${Wb(y)}Query`] = v,
                    o[`useLazy${Wb(y)}Query`] = S
                }
                if (jpe(b)) {
                    const v = h(y);
                    _p(c.endpoints[y], {
                        useMutation: v
                    }),
                    o[`use${Wb(y)}Mutation`] = v
                } else if (X4(b)) {
                    const {useInfiniteQuery: v, useInfiniteQuerySubscription: S, useInfiniteQueryState: C} = f(y);
                    _p(c.endpoints[y], {
                        useInfiniteQuery: v,
                        useInfiniteQuerySubscription: S,
                        useInfiniteQueryState: C
                    }),
                    o[`use${Wb(y)}InfiniteQuery`] = v
                }
            }
        }
    }
})
  , Gpe = Q4(K4(), Wpe());
const pk = Gpe({
    reducerPath: "inventoryApi",
    baseQuery: bpe({
        baseUrl: "/api",
        prepareHeaders: (e, {getState: t}) => {
            const n = t().auth?.token;
            return n && e.set("authorization", `Bearer ${n}`),
            e
        }
    }),
    tagTypes: ["Language", "SalesStatus", "UomDimension", "Uom", "ProductType", "ProductGroup", "ProductCategory", "ProductMaster"],
    endpoints: e => ({
        getLanguages: e.query({
            query: () => "languages",
            providesTags: ["Language"]
        }),
        getSalesStatuses: e.query({
            query: () => "sales-statuses",
            providesTags: ["SalesStatus"]
        }),
        getUomDimensions: e.query({
            query: () => "uom-dimensions",
            providesTags: ["UomDimension"]
        }),
        getUomsByDimension: e.query({
            query: t => `uom-dimensions/${t}/uoms`,
            providesTags: ["Uom"]
        }),
        getProductTypes: e.query({
            query: () => "product-types",
            providesTags: ["ProductType"]
        }),
        createProductType: e.mutation({
            query: t => ({
                url: "product-types",
                method: "POST",
                body: t
            }),
            invalidatesTags: ["ProductType"]
        }),
        updateProductType: e.mutation({
            query: ({id: t, productType: n}) => ({
                url: `product-types/${t}`,
                method: "PUT",
                body: n
            }),
            invalidatesTags: ["ProductType"]
        }),
        deleteProductType: e.mutation({
            query: t => ({
                url: `product-types/${t}`,
                method: "DELETE"
            }),
            invalidatesTags: ["ProductType"]
        }),
        getProductGroups: e.query({
            query: () => "product-groups",
            providesTags: ["ProductGroup"]
        }),
        createProductGroup: e.mutation({
            query: t => ({
                url: "product-groups",
                method: "POST",
                body: t
            }),
            invalidatesTags: ["ProductGroup"]
        }),
        updateProductGroup: e.mutation({
            query: ({id: t, productGroup: n}) => ({
                url: `product-groups/${t}`,
                method: "PUT",
                body: n
            }),
            invalidatesTags: ["ProductGroup"]
        }),
        deleteProductGroup: e.mutation({
            query: t => ({
                url: `product-groups/${t}`,
                method: "DELETE"
            }),
            invalidatesTags: ["ProductGroup"]
        }),
        getProductCategories: e.query({
            query: () => "product-categories",
            providesTags: ["ProductCategory"]
        }),
        createProductCategory: e.mutation({
            query: t => ({
                url: "product-categories",
                method: "POST",
                body: t
            }),
            invalidatesTags: ["ProductCategory"]
        }),
        updateProductCategory: e.mutation({
            query: ({id: t, productCategory: n}) => ({
                url: `product-categories/${t}`,
                method: "PUT",
                body: n
            }),
            invalidatesTags: ["ProductCategory"]
        }),
        deleteProductCategory: e.mutation({
            query: t => ({
                url: `product-categories/${t}`,
                method: "DELETE"
            }),
            invalidatesTags: ["ProductCategory"]
        }),
        getProductMasterById: e.query({
            query: t => `product-master/${t}`,
            providesTags: ["ProductMaster"]
        }),
        createProductMaster: e.mutation({
            query: t => ({
                url: "product-master",
                method: "POST",
                body: t
            }),
            invalidatesTags: ["ProductMaster"]
        }),
        updateProductMaster: e.mutation({
            query: ({id: t, productMaster: n}) => ({
                url: `product-master/${t}`,
                method: "PUT",
                body: n
            }),
            invalidatesTags: ["ProductMaster"]
        }),
        deleteProductMaster: e.mutation({
            query: t => ({
                url: `product-master/${t}`,
                method: "DELETE"
            }),
            invalidatesTags: ["ProductMaster"]
        })
    })
});
var JL = function(t) {
    return {
        done: !0,
        value: t
    }
}
  , mk = {};
function J4(e) {
    return oA(e) ? "channel" : N3(e) ? String(e) : wo(e) ? e.name : String(e)
}
function e6(e, t, n) {
    var r, i, o, a = t;
    function s(c, u) {
        if (a === mk)
            return JL(c);
        if (u && !i)
            throw a = mk,
            u;
        r && r(c);
        var f = u ? e[i](u) : e[a]();
        return a = f.nextState,
        o = f.effect,
        r = f.stateUpdater,
        i = f.errorState,
        a === mk ? JL(c) : o
    }
    return bT(s, function(c) {
        return s(null, c)
    }, n)
}
function Ype(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
        r[i - 2] = arguments[i];
    var o = {
        done: !1,
        value: r4(e)
    }, a = function(f) {
        return {
            done: !1,
            value: Un.apply(void 0, [t].concat(r, [f]))
        }
    }, s, c = function(f) {
        return s = f
    };
    return e6({
        q1: function() {
            return {
                nextState: "q2",
                effect: o,
                stateUpdater: c
            }
        },
        q2: function() {
            return {
                nextState: "q1",
                effect: a(s)
            }
        }
    }, "q1", "takeEvery(" + J4(e) + ", " + t.name + ")")
}
function Zpe(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
        r[i - 2] = arguments[i];
    var o = {
        done: !1,
        value: r4(e)
    }, a = function(y) {
        return {
            done: !1,
            value: Un.apply(void 0, [t].concat(r, [y]))
        }
    }, s = function(y) {
        return {
            done: !1,
            value: ahe(y)
        }
    }, c, u, f = function(y) {
        return c = y
    }, h = function(y) {
        return u = y
    };
    return e6({
        q1: function() {
            return {
                nextState: "q2",
                effect: o,
                stateUpdater: h
            }
        },
        q2: function() {
            return c ? {
                nextState: "q3",
                effect: s(c)
            } : {
                nextState: "q1",
                effect: a(u),
                stateUpdater: f
            }
        },
        q3: function() {
            return {
                nextState: "q1",
                effect: a(u),
                stateUpdater: f
            }
        }
    }, "q1", "takeLatest(" + J4(e) + ", " + t.name + ")")
}
function Fr(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
        r[i - 2] = arguments[i];
    return Un.apply(void 0, [Ype, e, t].concat(r))
}
function t6(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
        r[i - 2] = arguments[i];
    return Un.apply(void 0, [Zpe, e, t].concat(r))
}
class Aa {
    static async fetchLanguages() {
        const t = await fetch("/api/languages");
        if (!t.ok)
            throw new Error("Failed to fetch languages");
        return t.json()
    }
    static async fetchSalesStatuses() {
        const t = await fetch("/api/sales-statuses");
        if (!t.ok)
            throw new Error("Failed to fetch sales statuses");
        return t.json()
    }
    static async fetchUomDimensions() {
        const t = await fetch("/api/uom-dimensions");
        if (!t.ok)
            throw new Error("Failed to fetch UOM dimensions");
        return t.json()
    }
    static async fetchProductTypes() {
        const t = await fetch("/api/product-types");
        if (!t.ok)
            throw new Error("Failed to fetch product types");
        return t.json()
    }
    static async createProductType(t) {
        const n = await fetch("/api/product-types", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(t)
        });
        if (!n.ok)
            throw new Error("Failed to create product type");
        return n.json()
    }
    static async updateProductType(t, n) {
        const r = await fetch(`/api/product-types/${t}`, {
            method: "PUT",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(n)
        });
        if (!r.ok)
            throw new Error("Failed to update product type");
        return r.json()
    }
    static async deleteProductType(t) {
        if (!(await fetch(`/api/product-types/${t}`, {
            method: "DELETE"
        })).ok)
            throw new Error("Failed to delete product type")
    }
    static async fetchProductGroups() {
        const t = await fetch("/api/product-groups");
        if (!t.ok)
            throw new Error("Failed to fetch product groups");
        return t.json()
    }
    static async fetchProductCategories() {
        const t = await fetch("/api/product-categories");
        if (!t.ok)
            throw new Error("Failed to fetch product categories");
        return t.json()
    }
    static async fetchProductMaster(t) {
        const n = await fetch(`/api/product-master/${t}`);
        if (!n.ok)
            throw new Error("Failed to fetch product master");
        return n.json()
    }
    static async createProductMaster(t) {
        const n = await fetch("/api/product-master", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(t)
        });
        if (!n.ok)
            throw new Error("Failed to create product master");
        return n.json()
    }
    static async updateProductMaster(t, n) {
        const r = await fetch(`/api/product-master/${t}`, {
            method: "PUT",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(n)
        });
        if (!r.ok)
            throw new Error("Failed to update product master");
        return r.json()
    }
}
function *Qpe() {
    try {
        yield yt(fr({
            key: "languages",
            loading: !0
        }));
        const e = yield Dr(Aa.fetchLanguages);
        yield yt(y4(e)),
        yield yt(Al({
            key: "languages",
            data: e,
            metadata: {
                fetchedAt: new Date().toISOString(),
                count: e.length
            }
        }))
    } catch (e) {
        yield yt(b4(e.message)),
        yield yt(_o({
            key: "languages",
            error: e.message
        }))
    } finally {
        yield yt(fr({
            key: "languages",
            loading: !1
        }))
    }
}
function *Kpe() {
    try {
        yield yt(fr({
            key: "salesStatuses",
            loading: !0
        }));
        const e = yield Dr(Aa.fetchSalesStatuses);
        yield yt(x4(e)),
        yield yt(Al({
            key: "salesStatuses",
            data: e,
            metadata: {
                fetchedAt: new Date().toISOString(),
                count: e.length
            }
        }))
    } catch (e) {
        yield yt(v4(e.message)),
        yield yt(_o({
            key: "salesStatuses",
            error: e.message
        }))
    } finally {
        yield yt(fr({
            key: "salesStatuses",
            loading: !1
        }))
    }
}
function *Xpe() {
    try {
        yield yt(fr({
            key: "uomDimensions",
            loading: !0
        }));
        const e = yield Dr(Aa.fetchUomDimensions);
        yield yt(S4(e)),
        yield yt(Al({
            key: "uomDimensions",
            data: e,
            metadata: {
                fetchedAt: new Date().toISOString(),
                count: e.length
            }
        }))
    } catch (e) {
        yield yt(C4(e.message)),
        yield yt(_o({
            key: "uomDimensions",
            error: e.message
        }))
    } finally {
        yield yt(fr({
            key: "uomDimensions",
            loading: !1
        }))
    }
}
function *Jpe() {
    try {
        yield yt(fr({
            key: "productTypes",
            loading: !0
        }));
        const e = yield Dr(Aa.fetchProductTypes);
        yield yt(w4(e)),
        yield yt(Al({
            key: "productTypes",
            data: e,
            metadata: {
                fetchedAt: new Date().toISOString(),
                count: e.length
            }
        }))
    } catch (e) {
        yield yt(k4(e.message)),
        yield yt(_o({
            key: "productTypes",
            error: e.message
        }))
    } finally {
        yield yt(fr({
            key: "productTypes",
            loading: !1
        }))
    }
}
function *eme(e) {
    try {
        yield yt(fr({
            key: "createProductType",
            loading: !0
        }));
        const t = yield Dr(Aa.createProductType, e.payload);
        yield yt(T4(t)),
        yield yt(m1())
    } catch (t) {
        yield yt(_4(t.message)),
        yield yt(_o({
            key: "createProductType",
            error: t.message
        }))
    } finally {
        yield yt(fr({
            key: "createProductType",
            loading: !1
        }))
    }
}
function *tme(e) {
    try {
        yield yt(fr({
            key: "updateProductType",
            loading: !0
        }));
        const t = yield Dr(Aa.updateProductType, e.payload.id, e.payload.productType);
        yield yt(E4(t)),
        yield yt(m1())
    } catch (t) {
        yield yt(A4(t.message)),
        yield yt(_o({
            key: "updateProductType",
            error: t.message
        }))
    } finally {
        yield yt(fr({
            key: "updateProductType",
            loading: !1
        }))
    }
}
function *nme(e) {
    try {
        yield yt(fr({
            key: "deleteProductType",
            loading: !0
        })),
        yield Dr(Aa.deleteProductType, e.payload),
        yield yt(M4(e.payload)),
        yield yt(m1())
    } catch (t) {
        yield yt(P4(t.message)),
        yield yt(_o({
            key: "deleteProductType",
            error: t.message
        }))
    } finally {
        yield yt(fr({
            key: "deleteProductType",
            loading: !1
        }))
    }
}
function *rme() {
    try {
        yield yt(fr({
            key: "productGroups",
            loading: !0
        }));
        const e = yield Dr(Aa.fetchProductGroups);
        yield yt(R4(e)),
        yield yt(Al({
            key: "productGroups",
            data: e,
            metadata: {
                fetchedAt: new Date().toISOString(),
                count: e.length
            }
        }))
    } catch (e) {
        yield yt(D4(e.message)),
        yield yt(_o({
            key: "productGroups",
            error: e.message
        }))
    } finally {
        yield yt(fr({
            key: "productGroups",
            loading: !1
        }))
    }
}
function *ime() {
    try {
        yield yt(fr({
            key: "productCategories",
            loading: !0
        }));
        const e = yield Dr(Aa.fetchProductCategories);
        yield yt(O4(e)),
        yield yt(Al({
            key: "productCategories",
            data: e,
            metadata: {
                fetchedAt: new Date().toISOString(),
                count: e.length
            }
        }))
    } catch (e) {
        yield yt(I4(e.message)),
        yield yt(_o({
            key: "productCategories",
            error: e.message
        }))
    } finally {
        yield yt(fr({
            key: "productCategories",
            loading: !1
        }))
    }
}
function *ome(e) {
    try {
        yield yt(fr({
            key: "productMaster",
            loading: !0
        }));
        const t = yield Dr(Aa.fetchProductMaster, e.payload);
        yield yt($4(t)),
        yield yt(Al({
            key: `productMaster_${e.payload}`,
            data: t,
            metadata: {
                fetchedAt: new Date().toISOString(),
                id: e.payload
            }
        }))
    } catch (t) {
        yield yt(L4(t.message)),
        yield yt(_o({
            key: "productMaster",
            error: t.message
        }))
    } finally {
        yield yt(fr({
            key: "productMaster",
            loading: !1
        }))
    }
}
function *ame(e) {
    try {
        yield yt(fr({
            key: "createProductMaster",
            loading: !0
        }));
        const t = yield Dr(Aa.createProductMaster, e.payload);
        yield yt(j4(t))
    } catch (t) {
        yield yt(B4(t.message)),
        yield yt(_o({
            key: "createProductMaster",
            error: t.message
        }))
    } finally {
        yield yt(fr({
            key: "createProductMaster",
            loading: !1
        }))
    }
}
function *sme(e) {
    try {
        yield yt(fr({
            key: "updateProductMaster",
            loading: !0
        }));
        const t = yield Dr(Aa.updateProductMaster, e.payload.id, e.payload.productMaster);
        yield yt(z4(t))
    } catch (t) {
        yield yt(F4(t.message)),
        yield yt(_o({
            key: "updateProductMaster",
            error: t.message
        }))
    } finally {
        yield yt(fr({
            key: "updateProductMaster",
            loading: !1
        }))
    }
}
function *lme() {
    try {
        const e = yield she()
          , {complexData: t} = e.inventory
          , n = {
            summary: {
                totalProductTypes: t.productTypes?.data?.length || 0,
                totalProductGroups: t.productGroups?.data?.length || 0,
                totalProductCategories: t.productCategories?.data?.length || 0,
                lastUpdated: new Date().toISOString()
            },
            relationships: {},
            statistics: {}
        };
        yield yt(Al({
            key: "processedSummary",
            data: n,
            metadata: {
                processedAt: new Date().toISOString(),
                version: "1.0"
            }
        }))
    } catch (e) {
        yield yt(_o({
            key: "processComplexData",
            error: e.message
        }))
    }
}
function *cme() {
    yield Fr(Zhe.type, Qpe)
}
function *ume() {
    yield Fr(Qhe.type, Kpe)
}
function *dme() {
    yield Fr(Khe.type, Xpe)
}
function *fme() {
    yield Fr(m1.type, Jpe)
}
function *hme() {
    yield Fr(Xhe.type, eme)
}
function *pme() {
    yield Fr(Jhe.type, tme)
}
function *mme() {
    yield Fr(epe.type, nme)
}
function *gme() {
    yield Fr(tpe.type, rme)
}
function *yme() {
    yield Fr(npe.type, ime)
}
function *bme() {
    yield Fr(rpe.type, ome)
}
function *xme() {
    yield Fr(ipe.type, ame)
}
function *vme() {
    yield Fr(ope.type, sme)
}
function *Sme() {
    yield t6("inventory/processComplexData", lme)
}
function *Cme() {
    yield f1([Un(cme), Un(ume), Un(dme), Un(fme), Un(hme), Un(pme), Un(mme), Un(gme), Un(yme), Un(bme), Un(xme), Un(vme), Un(Sme)])
}
class Hg {
    static async login(t) {
        const n = await fetch("/api/auth/login", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(t)
        });
        if (!n.ok)
            throw new Error("Login failed");
        return n.json()
    }
    static async logout() {
        const t = await fetch("/api/auth/logout", {
            method: "POST"
        });
        if (!t.ok)
            throw new Error("Logout failed");
        return t.json()
    }
    static async refreshToken(t) {
        const n = await fetch("/api/auth/refresh", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${t}`
            }
        });
        if (!n.ok)
            throw new Error("Token refresh failed");
        return n.json()
    }
    static async register(t) {
        const n = await fetch("/api/auth/register", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(t)
        });
        if (!n.ok)
            throw new Error("Registration failed");
        return n.json()
    }
    static async getUserProfile() {
        const t = await fetch("/api/auth/profile");
        if (!t.ok)
            throw new Error("Failed to fetch user profile");
        return t.json()
    }
}
function *wme(e) {
    try {
        const t = yield Dr(Hg.login, e.payload);
        console.log("Login successful:", t)
    } catch (t) {
        console.error("Login failed:", t.message)
    }
}
function *kme() {
    try {
        yield Dr(Hg.logout),
        console.log("Logout successful")
    } catch (e) {
        console.error("Logout failed:", e.message)
    }
}
function *Tme(e) {
    try {
        const t = yield Dr(Hg.refreshToken, e.payload);
        console.log("Token refresh successful:", t)
    } catch (t) {
        console.error("Token refresh failed:", t.message)
    }
}
function *_me(e) {
    try {
        const t = yield Dr(Hg.register, e.payload);
        console.log("Registration successful:", t)
    } catch (t) {
        console.error("Registration failed:", t.message)
    }
}
function *Eme() {
    try {
        const e = yield Dr(Hg.getUserProfile);
        console.log("Profile fetch successful:", e)
    } catch (e) {
        console.error("Profile fetch failed:", e.message)
    }
}
function *Ame() {
    yield t6("auth/loginStart", wme)
}
function *Mme() {
    yield Fr("auth/logoutStart", kme)
}
function *Pme() {
    yield Fr("auth/refreshTokenStart", Tme)
}
function *Rme() {
    yield Fr("auth/registerStart", _me)
}
function *Dme() {
    yield Fr("auth/getUserProfileStart", Eme)
}
function *Ome() {
    yield f1([Un(Ame), Un(Mme), Un(Pme), Un(Rme), Un(Dme)])
}
class qg {
    static async fetchVendors() {
        const t = await fetch("/api/vendors");
        if (!t.ok)
            throw new Error("Failed to fetch vendors");
        return t.json()
    }
    static async createVendor(t) {
        const n = await fetch("/api/vendors", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(t)
        });
        if (!n.ok)
            throw new Error("Failed to create vendor");
        return n.json()
    }
    static async updateVendor(t, n) {
        const r = await fetch(`/api/vendors/${t}`, {
            method: "PUT",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(n)
        });
        if (!r.ok)
            throw new Error("Failed to update vendor");
        return r.json()
    }
    static async deleteVendor(t) {
        if (!(await fetch(`/api/vendors/${t}`, {
            method: "DELETE"
        })).ok)
            throw new Error("Failed to delete vendor")
    }
    static async fetchVendorById(t) {
        const n = await fetch(`/api/vendors/${t}`);
        if (!n.ok)
            throw new Error("Failed to fetch vendor");
        return n.json()
    }
}
function *Ime() {
    try {
        const e = yield Dr(qg.fetchVendors);
        console.log("Vendors fetch successful:", e)
    } catch (e) {
        console.error("Vendors fetch failed:", e.message)
    }
}
function *$me(e) {
    try {
        const t = yield Dr(qg.createVendor, e.payload);
        console.log("Vendor creation successful:", t)
    } catch (t) {
        console.error("Vendor creation failed:", t.message)
    }
}
function *Lme(e) {
    try {
        const t = yield Dr(qg.updateVendor, e.payload.id, e.payload.vendorData);
        console.log("Vendor update successful:", t)
    } catch (t) {
        console.error("Vendor update failed:", t.message)
    }
}
function *jme(e) {
    try {
        yield Dr(qg.deleteVendor, e.payload),
        console.log("Vendor deletion successful")
    } catch (t) {
        console.error("Vendor deletion failed:", t.message)
    }
}
function *Bme(e) {
    try {
        const t = yield Dr(qg.fetchVendorById, e.payload);
        console.log("Vendor fetch by ID successful:", t)
    } catch (t) {
        console.error("Vendor fetch by ID failed:", t.message)
    }
}
function *zme() {
    yield Fr("vendor/fetchVendorsStart", Ime)
}
function *Fme() {
    yield Fr("vendor/createVendorStart", $me)
}
function *Nme() {
    yield Fr("vendor/updateVendorStart", Lme)
}
function *Ume() {
    yield Fr("vendor/deleteVendorStart", jme)
}
function *Vme() {
    yield Fr("vendor/fetchVendorByIdStart", Bme)
}
function *Hme() {
    yield f1([Un(zme), Un(Fme), Un(Nme), Un(Ume), Un(Vme)])
}
function *qme() {
    yield f1([Un(Cme), Un(Ome), Un(Hme)])
}
const n6 = Uhe()
  , r6 = Vo({
    name: "ui",
    initialState: {
        theme: {
            mode: "light",
            primaryColor: "#1976d2"
        },
        layout: {
            density: "comfortable"
        },
        sidebar: {
            isCollapsed: !1
        },
        loading: {},
        errors: {},
        modal: {
            isOpen: !1,
            type: null,
            data: null
        },
        drawer: {
            isOpen: !1,
            content: null,
            width: 250
        },
        filters: {},
        pagination: {},
        sorting: {}
    },
    reducers: {
        setThemeMode: (e, t) => {
            e.theme.mode = t.payload
        }
        ,
        setDensity: (e, t) => {
            e.layout.density = t.payload
        }
        ,
        toggleSidebar: e => {
            e.sidebar.isCollapsed = !e.sidebar.isCollapsed
        }
        ,
        setLoading: (e, t) => {
            const {key: n, loading: r} = t.payload;
            e.loading[n] = r
        }
        ,
        setError: (e, t) => {
            const {key: n, error: r} = t.payload;
            e.errors[n] = r
        }
    }
})
  , i6 = Vo({
    name: "notifications",
    initialState: {
        items: [],
        unreadCount: 0
    },
    reducers: {
        addNotification: (e, t) => {
            e.items.push(t.payload),
            e.unreadCount += 1
        }
        ,
        removeNotification: (e, t) => {
            e.items = e.items.filter(n => n.id !== t.payload),
            e.unreadCount = Math.max(0, e.unreadCount - 1)
        }
    }
})
  , Wme = Vo({
    name: "inventoryData",
    initialState: {
        productTypes: [],
        productGroups: [],
        productCategories: [],
        productMaster: [],
        uom: [],
        referenceData: {},
        search: {},
        selectedItems: {}
    },
    reducers: {
        setProductTypes: (e, t) => {
            e.productTypes = t.payload
        }
        ,
        setProductGroups: (e, t) => {
            e.productGroups = t.payload
        }
    }
})
  , {setProductTypes: xUe, setProductGroups: vUe} = Wme.actions
  , Gme = Vo({
    name: "cache",
    initialState: {
        apiCache: {},
        hitCount: 0,
        missCount: 0
    },
    reducers: {
        setCacheData: (e, t) => {
            const {key: n, data: r} = t.payload;
            e.apiCache[n] = r
        }
    }
})
  , {setThemeMode: SUe, setDensity: CUe, toggleSidebar: wUe, setLoading: yA, setError: o6} = r6.actions
  , {addNotification: a6, removeNotification: kUe} = i6.actions
  , Yme = afe({
    reducer: {
        auth: qhe,
        ui: r6.reducer,
        vendor: Yhe,
        notifications: i6.reducer,
        inventory: spe,
        cache: Gme.reducer,
        [pk.reducerPath]: pk.reducer
    },
    middleware: e => e({
        serializableCheck: {
            ignoredActions: ["cache/setCacheData", "notifications/addNotification", "persist/PERSIST", "persist/REHYDRATE"],
            ignoredActionsPaths: ["meta.arg", "payload.timestamp", "payload.action.handler"],
            ignoredPaths: ["notifications.items", "cache.apiCache"]
        },
        thunk: {
            extraArgument: {}
        }
    }).concat(pk.middleware).concat(U4.middleware).concat(n6),
    devTools: !1
});
n6.run(qme);
const s6 = A.createContext(void 0)
  , Zme = ({children: e}) => {
    const [t,n] = A.useState(null)
      , r = o => n(o)
      , i = () => n(null);
    return g.jsx(s6.Provider, {
        value: {
            token: t,
            login: r,
            logout: i
        },
        children: e
    })
}
  , Qme = () => {
    const e = A.useContext(s6);
    if (!e)
        throw new Error("useAuth must be used within an AuthProvider");
    return e
}
  , l6 = A.createContext(null)
  , bA = () => {
    const e = A.useContext(l6);
    if (!e)
        throw new Error("useNotification must be used within NotificationProvider");
    return e
}
  , c6 = ({children: e}) => {
    const [t,n] = A.useState([])
      , r = (o, a="info") => {
        const s = {
            id: crypto.randomUUID(),
            message: o,
            type: a,
            timestamp: new Date
        };
        n(c => [...c, s])
    }
      , i = () => {
        n([])
    }
    ;
    return g.jsx(l6.Provider, {
        value: {
            notifications: t,
            addNotification: r,
            clearNotifications: i
        },
        children: e
    })
}
  , Kme = CF
  , Xme = () => new sX({
    defaultOptions: {
        queries: {
            staleTime: 300 * 1e3,
            retry: e => e < 3,
            retryDelay: e => Math.min(1e3 * 2 ** e, 3e4),
            refetchOnWindowFocus: !0,
            refetchOnReconnect: !0
        },
        mutations: {
            retry: 1,
            retryDelay: 1e3
        }
    }
})
  , Jme = ({children: e}) => {
    const t = Kme(o => o.ui || {})
      , n = t?.theme?.mode || "light"
      , r = t?.theme?.primaryColor || "#1976d2"
      , i = bt.useMemo( () => qv({
        palette: {
            mode: n,
            primary: {
                main: r
            }
        },
        components: {
            MuiButton: {
                defaultProps: {
                    disableElevation: !0
                },
                styleOverrides: {
                    root: {
                        textTransform: "none",
                        borderRadius: 8
                    }
                }
            },
            MuiCard: {
                styleOverrides: {
                    root: {
                        borderRadius: 12
                    }
                }
            },
            MuiTextField: {
                defaultProps: {
                    variant: "outlined",
                    size: "small"
                }
            }
        }
    }), [n, r]);
    return g.jsxs(yne, {
        theme: i,
        children: [g.jsx(Iae, {}), e]
    })
}
  , ege = ({children: e}) => {
    const [t] = bt.useState( () => Xme());
    return bt.useEffect( () => () => {
        t.clear()
    }
    , [t]),
    g.jsx(OK, {
        store: Yme,
        children: g.jsx(lX, {
            client: t,
            children: g.jsx(lK, {
                children: g.jsx(Jme, {
                    children: g.jsx(Zme, {
                        children: g.jsx(c6, {
                            children: e
                        })
                    })
                })
            })
        })
    })
}
;
class tge extends bt.Component {
    constructor(t) {
        super(t),
        this.state = {
            hasError: !1
        }
    }
    static getDerivedStateFromError(t) {
        return {
            hasError: !0,
            error: t
        }
    }
    componentDidCatch(t, n) {
        console.error("App Error Boundary caught an error:", t, n)
    }
    render() {
        return this.state.hasError ? g.jsxs("div", {
            style: {
                padding: "2rem",
                textAlign: "center",
                minHeight: "100vh",
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                alignItems: "center"
            },
            children: [g.jsx("h1", {
                children: "Oops! Something went wrong"
            }), g.jsx("p", {
                children: "We apologize for the inconvenience. Please try refreshing the page."
            }), g.jsx("button", {
                onClick: () => window.location.reload(),
                style: {
                    padding: "0.5rem 1rem",
                    marginTop: "1rem",
                    backgroundColor: "#1976d2",
                    color: "white",
                    border: "none",
                    borderRadius: "4px",
                    cursor: "pointer"
                },
                children: "Refresh Page"
            }), !1]
        }) : this.props.children
    }
}
const nge = ({children: e}) => g.jsx(tge, {
    children: g.jsx(ege, {
        children: e
    })
})
  , Go = _t(g.jsx("path", {
    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}));
function u6(e, t) {
    return function() {
        return e.apply(t, arguments)
    }
}
const {toString: rge} = Object.prototype
  , {getPrototypeOf: xA} = Object
  , {iterator: b1, toStringTag: d6} = Symbol
  , x1 = (e => t => {
    const n = rge.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , ns = e => (e = e.toLowerCase(),
t => x1(t) === e)
  , v1 = e => t => typeof t === e
  , {isArray: mh} = Array
  , Zf = v1("undefined");
function Wg(e) {
    return e !== null && !Zf(e) && e.constructor !== null && !Zf(e.constructor) && xo(e.constructor.isBuffer) && e.constructor.isBuffer(e)
}
const f6 = ns("ArrayBuffer");
function ige(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && f6(e.buffer),
    t
}
const oge = v1("string")
  , xo = v1("function")
  , h6 = v1("number")
  , Gg = e => e !== null && typeof e == "object"
  , age = e => e === !0 || e === !1
  , Ix = e => {
    if (x1(e) !== "object")
        return !1;
    const t = xA(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(d6 in e) && !(b1 in e)
}
  , sge = e => {
    if (!Gg(e) || Wg(e))
        return !1;
    try {
        return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype
    } catch {
        return !1
    }
}
  , lge = ns("Date")
  , cge = ns("File")
  , uge = ns("Blob")
  , dge = ns("FileList")
  , fge = e => Gg(e) && xo(e.pipe)
  , hge = e => {
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || xo(e.append) && ((t = x1(e)) === "formdata" || t === "object" && xo(e.toString) && e.toString() === "[object FormData]"))
}
  , pge = ns("URLSearchParams")
  , [mge,gge,yge,bge] = ["ReadableStream", "Request", "Response", "Headers"].map(ns)
  , xge = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Yg(e, t, {allOwnKeys: n=!1}={}) {
    if (e === null || typeof e > "u")
        return;
    let r, i;
    if (typeof e != "object" && (e = [e]),
    mh(e))
        for (r = 0,
        i = e.length; r < i; r++)
            t.call(null, e[r], r, e);
    else {
        if (Wg(e))
            return;
        const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e)
          , a = o.length;
        let s;
        for (r = 0; r < a; r++)
            s = o[r],
            t.call(null, e[s], s, e)
    }
}
function p6(e, t) {
    if (Wg(e))
        return null;
    t = t.toLowerCase();
    const n = Object.keys(e);
    let r = n.length, i;
    for (; r-- > 0; )
        if (i = n[r],
        t === i.toLowerCase())
            return i;
    return null
}
const Cu = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global
  , m6 = e => !Zf(e) && e !== Cu;
function kT() {
    const {caseless: e, skipUndefined: t} = m6(this) && this || {}
      , n = {}
      , r = (i, o) => {
        const a = e && p6(n, o) || o;
        Ix(n[a]) && Ix(i) ? n[a] = kT(n[a], i) : Ix(i) ? n[a] = kT({}, i) : mh(i) ? n[a] = i.slice() : (!t || !Zf(i)) && (n[a] = i)
    }
    ;
    for (let i = 0, o = arguments.length; i < o; i++)
        arguments[i] && Yg(arguments[i], r);
    return n
}
const vge = (e, t, n, {allOwnKeys: r}={}) => (Yg(t, (i, o) => {
    n && xo(i) ? e[o] = u6(i, n) : e[o] = i
}
, {
    allOwnKeys: r
}),
e)
  , Sge = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)),
e)
  , Cge = (e, t, n, r) => {
    e.prototype = Object.create(t.prototype, r),
    e.prototype.constructor = e,
    Object.defineProperty(e, "super", {
        value: t.prototype
    }),
    n && Object.assign(e.prototype, n)
}
  , wge = (e, t, n, r) => {
    let i, o, a;
    const s = {};
    if (t = t || {},
    e == null)
        return t;
    do {
        for (i = Object.getOwnPropertyNames(e),
        o = i.length; o-- > 0; )
            a = i[o],
            (!r || r(a, e, t)) && !s[a] && (t[a] = e[a],
            s[a] = !0);
        e = n !== !1 && xA(e)
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t
}
  , kge = (e, t, n) => {
    e = String(e),
    (n === void 0 || n > e.length) && (n = e.length),
    n -= t.length;
    const r = e.indexOf(t, n);
    return r !== -1 && r === n
}
  , Tge = e => {
    if (!e)
        return null;
    if (mh(e))
        return e;
    let t = e.length;
    if (!h6(t))
        return null;
    const n = new Array(t);
    for (; t-- > 0; )
        n[t] = e[t];
    return n
}
  , _ge = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && xA(Uint8Array))
  , Ege = (e, t) => {
    const r = (e && e[b1]).call(e);
    let i;
    for (; (i = r.next()) && !i.done; ) {
        const o = i.value;
        t.call(e, o[0], o[1])
    }
}
  , Age = (e, t) => {
    let n;
    const r = [];
    for (; (n = e.exec(t)) !== null; )
        r.push(n);
    return r
}
  , Mge = ns("HTMLFormElement")
  , Pge = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, r, i) {
    return r.toUpperCase() + i
})
  , ej = ( ({hasOwnProperty: e}) => (t, n) => e.call(t, n))(Object.prototype)
  , Rge = ns("RegExp")
  , g6 = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e)
      , r = {};
    Yg(n, (i, o) => {
        let a;
        (a = t(i, o, e)) !== !1 && (r[o] = a || i)
    }
    ),
    Object.defineProperties(e, r)
}
  , Dge = e => {
    g6(e, (t, n) => {
        if (xo(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
            return !1;
        const r = e[n];
        if (xo(r)) {
            if (t.enumerable = !1,
            "writable"in t) {
                t.writable = !1;
                return
            }
            t.set || (t.set = () => {
                throw Error("Can not rewrite read-only method '" + n + "'")
            }
            )
        }
    }
    )
}
  , Oge = (e, t) => {
    const n = {}
      , r = i => {
        i.forEach(o => {
            n[o] = !0
        }
        )
    }
    ;
    return mh(e) ? r(e) : r(String(e).split(t)),
    n
}
  , Ige = () => {}
  , $ge = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function Lge(e) {
    return !!(e && xo(e.append) && e[d6] === "FormData" && e[b1])
}
const jge = e => {
    const t = new Array(10)
      , n = (r, i) => {
        if (Gg(r)) {
            if (t.indexOf(r) >= 0)
                return;
            if (Wg(r))
                return r;
            if (!("toJSON"in r)) {
                t[i] = r;
                const o = mh(r) ? [] : {};
                return Yg(r, (a, s) => {
                    const c = n(a, i + 1);
                    !Zf(c) && (o[s] = c)
                }
                ),
                t[i] = void 0,
                o
            }
        }
        return r
    }
    ;
    return n(e, 0)
}
  , Bge = ns("AsyncFunction")
  , zge = e => e && (Gg(e) || xo(e)) && xo(e.then) && xo(e.catch)
  , y6 = ( (e, t) => e ? setImmediate : t ? ( (n, r) => (Cu.addEventListener("message", ({source: i, data: o}) => {
    i === Cu && o === n && r.length && r.shift()()
}
, !1),
i => {
    r.push(i),
    Cu.postMessage(n, "*")
}
))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", xo(Cu.postMessage))
  , Fge = typeof queueMicrotask < "u" ? queueMicrotask.bind(Cu) : typeof process < "u" && process.nextTick || y6
  , Nge = e => e != null && xo(e[b1])
  , Ie = {
    isArray: mh,
    isArrayBuffer: f6,
    isBuffer: Wg,
    isFormData: hge,
    isArrayBufferView: ige,
    isString: oge,
    isNumber: h6,
    isBoolean: age,
    isObject: Gg,
    isPlainObject: Ix,
    isEmptyObject: sge,
    isReadableStream: mge,
    isRequest: gge,
    isResponse: yge,
    isHeaders: bge,
    isUndefined: Zf,
    isDate: lge,
    isFile: cge,
    isBlob: uge,
    isRegExp: Rge,
    isFunction: xo,
    isStream: fge,
    isURLSearchParams: pge,
    isTypedArray: _ge,
    isFileList: dge,
    forEach: Yg,
    merge: kT,
    extend: vge,
    trim: xge,
    stripBOM: Sge,
    inherits: Cge,
    toFlatObject: wge,
    kindOf: x1,
    kindOfTest: ns,
    endsWith: kge,
    toArray: Tge,
    forEachEntry: Ege,
    matchAll: Age,
    isHTMLForm: Mge,
    hasOwnProperty: ej,
    hasOwnProp: ej,
    reduceDescriptors: g6,
    freezeMethods: Dge,
    toObjectSet: Oge,
    toCamelCase: Pge,
    noop: Ige,
    toFiniteNumber: $ge,
    findKey: p6,
    global: Cu,
    isContextDefined: m6,
    isSpecCompliantForm: Lge,
    toJSONObject: jge,
    isAsyncFn: Bge,
    isThenable: zge,
    setImmediate: y6,
    asap: Fge,
    isIterable: Nge
};
function rn(e, t, n, r, i) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
    this.message = e,
    this.name = "AxiosError",
    t && (this.code = t),
    n && (this.config = n),
    r && (this.request = r),
    i && (this.response = i,
    this.status = i.status ? i.status : null)
}
Ie.inherits(rn, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: Ie.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const b6 = rn.prototype
  , x6 = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
    x6[e] = {
        value: e
    }
}
);
Object.defineProperties(rn, x6);
Object.defineProperty(b6, "isAxiosError", {
    value: !0
});
rn.from = (e, t, n, r, i, o) => {
    const a = Object.create(b6);
    Ie.toFlatObject(e, a, function(f) {
        return f !== Error.prototype
    }, u => u !== "isAxiosError");
    const s = e && e.message ? e.message : "Error"
      , c = t == null && e ? e.code : t;
    return rn.call(a, s, c, n, r, i),
    e && a.cause == null && Object.defineProperty(a, "cause", {
        value: e,
        configurable: !0
    }),
    a.name = e && e.name || "Error",
    o && Object.assign(a, o),
    a
}
;
const Uge = null;
function TT(e) {
    return Ie.isPlainObject(e) || Ie.isArray(e)
}
function v6(e) {
    return Ie.endsWith(e, "[]") ? e.slice(0, -2) : e
}
function tj(e, t, n) {
    return e ? e.concat(t).map(function(i, o) {
        return i = v6(i),
        !n && o ? "[" + i + "]" : i
    }).join(n ? "." : "") : t
}
function Vge(e) {
    return Ie.isArray(e) && !e.some(TT)
}
const Hge = Ie.toFlatObject(Ie, {}, null, function(t) {
    return /^is[A-Z]/.test(t)
});
function S1(e, t, n) {
    if (!Ie.isObject(e))
        throw new TypeError("target must be an object");
    t = t || new FormData,
    n = Ie.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(v, S) {
        return !Ie.isUndefined(S[v])
    });
    const r = n.metaTokens
      , i = n.visitor || f
      , o = n.dots
      , a = n.indexes
      , c = (n.Blob || typeof Blob < "u" && Blob) && Ie.isSpecCompliantForm(t);
    if (!Ie.isFunction(i))
        throw new TypeError("visitor must be a function");
    function u(b) {
        if (b === null)
            return "";
        if (Ie.isDate(b))
            return b.toISOString();
        if (Ie.isBoolean(b))
            return b.toString();
        if (!c && Ie.isBlob(b))
            throw new rn("Blob is not supported. Use a Buffer instead.");
        return Ie.isArrayBuffer(b) || Ie.isTypedArray(b) ? c && typeof Blob == "function" ? new Blob([b]) : Buffer.from(b) : b
    }
    function f(b, v, S) {
        let C = b;
        if (b && !S && typeof b == "object") {
            if (Ie.endsWith(v, "{}"))
                v = r ? v : v.slice(0, -2),
                b = JSON.stringify(b);
            else if (Ie.isArray(b) && Vge(b) || (Ie.isFileList(b) || Ie.endsWith(v, "[]")) && (C = Ie.toArray(b)))
                return v = v6(v),
                C.forEach(function(k, T) {
                    !(Ie.isUndefined(k) || k === null) && t.append(a === !0 ? tj([v], T, o) : a === null ? v : v + "[]", u(k))
                }),
                !1
        }
        return TT(b) ? !0 : (t.append(tj(S, v, o), u(b)),
        !1)
    }
    const h = []
      , m = Object.assign(Hge, {
        defaultVisitor: f,
        convertValue: u,
        isVisitable: TT
    });
    function y(b, v) {
        if (!Ie.isUndefined(b)) {
            if (h.indexOf(b) !== -1)
                throw Error("Circular reference detected in " + v.join("."));
            h.push(b),
            Ie.forEach(b, function(C, w) {
                (!(Ie.isUndefined(C) || C === null) && i.call(t, C, Ie.isString(w) ? w.trim() : w, v, m)) === !0 && y(C, v ? v.concat(w) : [w])
            }),
            h.pop()
        }
    }
    if (!Ie.isObject(e))
        throw new TypeError("data must be an object");
    return y(e),
    t
}
function nj(e) {
    const t = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
        return t[r]
    })
}
function vA(e, t) {
    this._pairs = [],
    e && S1(e, this, t)
}
const S6 = vA.prototype;
S6.append = function(t, n) {
    this._pairs.push([t, n])
}
;
S6.toString = function(t) {
    const n = t ? function(r) {
        return t.call(this, r, nj)
    }
    : nj;
    return this._pairs.map(function(i) {
        return n(i[0]) + "=" + n(i[1])
    }, "").join("&")
}
;
function qge(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+")
}
function C6(e, t, n) {
    if (!t)
        return e;
    const r = n && n.encode || qge;
    Ie.isFunction(n) && (n = {
        serialize: n
    });
    const i = n && n.serialize;
    let o;
    if (i ? o = i(t, n) : o = Ie.isURLSearchParams(t) ? t.toString() : new vA(t,n).toString(r),
    o) {
        const a = e.indexOf("#");
        a !== -1 && (e = e.slice(0, a)),
        e += (e.indexOf("?") === -1 ? "?" : "&") + o
    }
    return e
}
class rj {
    constructor() {
        this.handlers = []
    }
    use(t, n, r) {
        return this.handlers.push({
            fulfilled: t,
            rejected: n,
            synchronous: r ? r.synchronous : !1,
            runWhen: r ? r.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(t) {
        this.handlers[t] && (this.handlers[t] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(t) {
        Ie.forEach(this.handlers, function(r) {
            r !== null && t(r)
        })
    }
}
const w6 = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , Wge = typeof URLSearchParams < "u" ? URLSearchParams : vA
  , Gge = typeof FormData < "u" ? FormData : null
  , Yge = typeof Blob < "u" ? Blob : null
  , Zge = {
    isBrowser: !0,
    classes: {
        URLSearchParams: Wge,
        FormData: Gge,
        Blob: Yge
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
}
  , SA = typeof window < "u" && typeof document < "u"
  , _T = typeof navigator == "object" && navigator || void 0
  , Qge = SA && (!_T || ["ReactNative", "NativeScript", "NS"].indexOf(_T.product) < 0)
  , Kge = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function"
  , Xge = SA && window.location.href || "http://localhost"
  , Jge = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: SA,
    hasStandardBrowserEnv: Qge,
    hasStandardBrowserWebWorkerEnv: Kge,
    navigator: _T,
    origin: Xge
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Ei = {
    ...Jge,
    ...Zge
};
function eye(e, t) {
    return S1(e, new Ei.classes.URLSearchParams, {
        visitor: function(n, r, i, o) {
            return Ei.isNode && Ie.isBuffer(n) ? (this.append(r, n.toString("base64")),
            !1) : o.defaultVisitor.apply(this, arguments)
        },
        ...t
    })
}
function tye(e) {
    return Ie.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0])
}
function nye(e) {
    const t = {}
      , n = Object.keys(e);
    let r;
    const i = n.length;
    let o;
    for (r = 0; r < i; r++)
        o = n[r],
        t[o] = e[o];
    return t
}
function k6(e) {
    function t(n, r, i, o) {
        let a = n[o++];
        if (a === "__proto__")
            return !0;
        const s = Number.isFinite(+a)
          , c = o >= n.length;
        return a = !a && Ie.isArray(i) ? i.length : a,
        c ? (Ie.hasOwnProp(i, a) ? i[a] = [i[a], r] : i[a] = r,
        !s) : ((!i[a] || !Ie.isObject(i[a])) && (i[a] = []),
        t(n, r, i[a], o) && Ie.isArray(i[a]) && (i[a] = nye(i[a])),
        !s)
    }
    if (Ie.isFormData(e) && Ie.isFunction(e.entries)) {
        const n = {};
        return Ie.forEachEntry(e, (r, i) => {
            t(tye(r), i, n, 0)
        }
        ),
        n
    }
    return null
}
function rye(e, t, n) {
    if (Ie.isString(e))
        try {
            return (t || JSON.parse)(e),
            Ie.trim(e)
        } catch (r) {
            if (r.name !== "SyntaxError")
                throw r
        }
    return (n || JSON.stringify)(e)
}
const Zg = {
    transitional: w6,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(t, n) {
        const r = n.getContentType() || ""
          , i = r.indexOf("application/json") > -1
          , o = Ie.isObject(t);
        if (o && Ie.isHTMLForm(t) && (t = new FormData(t)),
        Ie.isFormData(t))
            return i ? JSON.stringify(k6(t)) : t;
        if (Ie.isArrayBuffer(t) || Ie.isBuffer(t) || Ie.isStream(t) || Ie.isFile(t) || Ie.isBlob(t) || Ie.isReadableStream(t))
            return t;
        if (Ie.isArrayBufferView(t))
            return t.buffer;
        if (Ie.isURLSearchParams(t))
            return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            t.toString();
        let s;
        if (o) {
            if (r.indexOf("application/x-www-form-urlencoded") > -1)
                return eye(t, this.formSerializer).toString();
            if ((s = Ie.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
                const c = this.env && this.env.FormData;
                return S1(s ? {
                    "files[]": t
                } : t, c && new c, this.formSerializer)
            }
        }
        return o || i ? (n.setContentType("application/json", !1),
        rye(t)) : t
    }
    ],
    transformResponse: [function(t) {
        const n = this.transitional || Zg.transitional
          , r = n && n.forcedJSONParsing
          , i = this.responseType === "json";
        if (Ie.isResponse(t) || Ie.isReadableStream(t))
            return t;
        if (t && Ie.isString(t) && (r && !this.responseType || i)) {
            const a = !(n && n.silentJSONParsing) && i;
            try {
                return JSON.parse(t, this.parseReviver)
            } catch (s) {
                if (a)
                    throw s.name === "SyntaxError" ? rn.from(s, rn.ERR_BAD_RESPONSE, this, null, this.response) : s
            }
        }
        return t
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: Ei.classes.FormData,
        Blob: Ei.classes.Blob
    },
    validateStatus: function(t) {
        return t >= 200 && t < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
Ie.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
    Zg.headers[e] = {}
}
);
const iye = Ie.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , oye = e => {
    const t = {};
    let n, r, i;
    return e && e.split(`
`).forEach(function(a) {
        i = a.indexOf(":"),
        n = a.substring(0, i).trim().toLowerCase(),
        r = a.substring(i + 1).trim(),
        !(!n || t[n] && iye[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r)
    }),
    t
}
  , ij = Symbol("internals");
function Ep(e) {
    return e && String(e).trim().toLowerCase()
}
function $x(e) {
    return e === !1 || e == null ? e : Ie.isArray(e) ? e.map($x) : String(e)
}
function aye(e) {
    const t = Object.create(null)
      , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(e); )
        t[r[1]] = r[2];
    return t
}
const sye = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function gk(e, t, n, r, i) {
    if (Ie.isFunction(r))
        return r.call(this, t, n);
    if (i && (t = n),
    !!Ie.isString(t)) {
        if (Ie.isString(r))
            return t.indexOf(r) !== -1;
        if (Ie.isRegExp(r))
            return r.test(t)
    }
}
function lye(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r)
}
function cye(e, t) {
    const n = Ie.toCamelCase(" " + t);
    ["get", "set", "has"].forEach(r => {
        Object.defineProperty(e, r + n, {
            value: function(i, o, a) {
                return this[r].call(this, t, i, o, a)
            },
            configurable: !0
        })
    }
    )
}
let vo = class {
    constructor(t) {
        t && this.set(t)
    }
    set(t, n, r) {
        const i = this;
        function o(s, c, u) {
            const f = Ep(c);
            if (!f)
                throw new Error("header name must be a non-empty string");
            const h = Ie.findKey(i, f);
            (!h || i[h] === void 0 || u === !0 || u === void 0 && i[h] !== !1) && (i[h || c] = $x(s))
        }
        const a = (s, c) => Ie.forEach(s, (u, f) => o(u, f, c));
        if (Ie.isPlainObject(t) || t instanceof this.constructor)
            a(t, n);
        else if (Ie.isString(t) && (t = t.trim()) && !sye(t))
            a(oye(t), n);
        else if (Ie.isObject(t) && Ie.isIterable(t)) {
            let s = {}, c, u;
            for (const f of t) {
                if (!Ie.isArray(f))
                    throw TypeError("Object iterator must return a key-value pair");
                s[u = f[0]] = (c = s[u]) ? Ie.isArray(c) ? [...c, f[1]] : [c, f[1]] : f[1]
            }
            a(s, n)
        } else
            t != null && o(n, t, r);
        return this
    }
    get(t, n) {
        if (t = Ep(t),
        t) {
            const r = Ie.findKey(this, t);
            if (r) {
                const i = this[r];
                if (!n)
                    return i;
                if (n === !0)
                    return aye(i);
                if (Ie.isFunction(n))
                    return n.call(this, i, r);
                if (Ie.isRegExp(n))
                    return n.exec(i);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(t, n) {
        if (t = Ep(t),
        t) {
            const r = Ie.findKey(this, t);
            return !!(r && this[r] !== void 0 && (!n || gk(this, this[r], r, n)))
        }
        return !1
    }
    delete(t, n) {
        const r = this;
        let i = !1;
        function o(a) {
            if (a = Ep(a),
            a) {
                const s = Ie.findKey(r, a);
                s && (!n || gk(r, r[s], s, n)) && (delete r[s],
                i = !0)
            }
        }
        return Ie.isArray(t) ? t.forEach(o) : o(t),
        i
    }
    clear(t) {
        const n = Object.keys(this);
        let r = n.length
          , i = !1;
        for (; r--; ) {
            const o = n[r];
            (!t || gk(this, this[o], o, t, !0)) && (delete this[o],
            i = !0)
        }
        return i
    }
    normalize(t) {
        const n = this
          , r = {};
        return Ie.forEach(this, (i, o) => {
            const a = Ie.findKey(r, o);
            if (a) {
                n[a] = $x(i),
                delete n[o];
                return
            }
            const s = t ? lye(o) : String(o).trim();
            s !== o && delete n[o],
            n[s] = $x(i),
            r[s] = !0
        }
        ),
        this
    }
    concat(...t) {
        return this.constructor.concat(this, ...t)
    }
    toJSON(t) {
        const n = Object.create(null);
        return Ie.forEach(this, (r, i) => {
            r != null && r !== !1 && (n[i] = t && Ie.isArray(r) ? r.join(", ") : r)
        }
        ),
        n
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map( ([t,n]) => t + ": " + n).join(`
`)
    }
    getSetCookie() {
        return this.get("set-cookie") || []
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(t) {
        return t instanceof this ? t : new this(t)
    }
    static concat(t, ...n) {
        const r = new this(t);
        return n.forEach(i => r.set(i)),
        r
    }
    static accessor(t) {
        const r = (this[ij] = this[ij] = {
            accessors: {}
        }).accessors
          , i = this.prototype;
        function o(a) {
            const s = Ep(a);
            r[s] || (cye(i, a),
            r[s] = !0)
        }
        return Ie.isArray(t) ? t.forEach(o) : o(t),
        this
    }
}
;
vo.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Ie.reduceDescriptors(vo.prototype, ({value: e}, t) => {
    let n = t[0].toUpperCase() + t.slice(1);
    return {
        get: () => e,
        set(r) {
            this[n] = r
        }
    }
}
);
Ie.freezeMethods(vo);
function yk(e, t) {
    const n = this || Zg
      , r = t || n
      , i = vo.from(r.headers);
    let o = r.data;
    return Ie.forEach(e, function(s) {
        o = s.call(n, o, i.normalize(), t ? t.status : void 0)
    }),
    i.normalize(),
    o
}
function T6(e) {
    return !!(e && e.__CANCEL__)
}
function gh(e, t, n) {
    rn.call(this, e ?? "canceled", rn.ERR_CANCELED, t, n),
    this.name = "CanceledError"
}
Ie.inherits(gh, rn, {
    __CANCEL__: !0
});
function _6(e, t, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? e(n) : t(new rn("Request failed with status code " + n.status,[rn.ERR_BAD_REQUEST, rn.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n))
}
function uye(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || ""
}
function dye(e, t) {
    e = e || 10;
    const n = new Array(e)
      , r = new Array(e);
    let i = 0, o = 0, a;
    return t = t !== void 0 ? t : 1e3,
    function(c) {
        const u = Date.now()
          , f = r[o];
        a || (a = u),
        n[i] = c,
        r[i] = u;
        let h = o
          , m = 0;
        for (; h !== i; )
            m += n[h++],
            h = h % e;
        if (i = (i + 1) % e,
        i === o && (o = (o + 1) % e),
        u - a < t)
            return;
        const y = f && u - f;
        return y ? Math.round(m * 1e3 / y) : void 0
    }
}
function fye(e, t) {
    let n = 0, r = 1e3 / t, i, o;
    const a = (u, f=Date.now()) => {
        n = f,
        i = null,
        o && (clearTimeout(o),
        o = null),
        e(...u)
    }
    ;
    return [ (...u) => {
        const f = Date.now()
          , h = f - n;
        h >= r ? a(u, f) : (i = u,
        o || (o = setTimeout( () => {
            o = null,
            a(i)
        }
        , r - h)))
    }
    , () => i && a(i)]
}
const R0 = (e, t, n=3) => {
    let r = 0;
    const i = dye(50, 250);
    return fye(o => {
        const a = o.loaded
          , s = o.lengthComputable ? o.total : void 0
          , c = a - r
          , u = i(c)
          , f = a <= s;
        r = a;
        const h = {
            loaded: a,
            total: s,
            progress: s ? a / s : void 0,
            bytes: c,
            rate: u || void 0,
            estimated: u && s && f ? (s - a) / u : void 0,
            event: o,
            lengthComputable: s != null,
            [t ? "download" : "upload"]: !0
        };
        e(h)
    }
    , n)
}
  , oj = (e, t) => {
    const n = e != null;
    return [r => t[0]({
        lengthComputable: n,
        total: e,
        loaded: r
    }), t[1]]
}
  , aj = e => (...t) => Ie.asap( () => e(...t))
  , hye = Ei.hasStandardBrowserEnv ? ( (e, t) => n => (n = new URL(n,Ei.origin),
e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(Ei.origin), Ei.navigator && /(msie|trident)/i.test(Ei.navigator.userAgent)) : () => !0
  , pye = Ei.hasStandardBrowserEnv ? {
    write(e, t, n, r, i, o) {
        const a = [e + "=" + encodeURIComponent(t)];
        Ie.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()),
        Ie.isString(r) && a.push("path=" + r),
        Ie.isString(i) && a.push("domain=" + i),
        o === !0 && a.push("secure"),
        document.cookie = a.join("; ")
    },
    read(e) {
        const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
        return t ? decodeURIComponent(t[3]) : null
    },
    remove(e) {
        this.write(e, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
function mye(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}
function gye(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
}
function E6(e, t, n) {
    let r = !mye(t);
    return e && (r || n == !1) ? gye(e, t) : t
}
const sj = e => e instanceof vo ? {
    ...e
} : e;
function Hu(e, t) {
    t = t || {};
    const n = {};
    function r(u, f, h, m) {
        return Ie.isPlainObject(u) && Ie.isPlainObject(f) ? Ie.merge.call({
            caseless: m
        }, u, f) : Ie.isPlainObject(f) ? Ie.merge({}, f) : Ie.isArray(f) ? f.slice() : f
    }
    function i(u, f, h, m) {
        if (Ie.isUndefined(f)) {
            if (!Ie.isUndefined(u))
                return r(void 0, u, h, m)
        } else
            return r(u, f, h, m)
    }
    function o(u, f) {
        if (!Ie.isUndefined(f))
            return r(void 0, f)
    }
    function a(u, f) {
        if (Ie.isUndefined(f)) {
            if (!Ie.isUndefined(u))
                return r(void 0, u)
        } else
            return r(void 0, f)
    }
    function s(u, f, h) {
        if (h in t)
            return r(u, f);
        if (h in e)
            return r(void 0, u)
    }
    const c = {
        url: o,
        method: o,
        data: o,
        baseURL: a,
        transformRequest: a,
        transformResponse: a,
        paramsSerializer: a,
        timeout: a,
        timeoutMessage: a,
        withCredentials: a,
        withXSRFToken: a,
        adapter: a,
        responseType: a,
        xsrfCookieName: a,
        xsrfHeaderName: a,
        onUploadProgress: a,
        onDownloadProgress: a,
        decompress: a,
        maxContentLength: a,
        maxBodyLength: a,
        beforeRedirect: a,
        transport: a,
        httpAgent: a,
        httpsAgent: a,
        cancelToken: a,
        socketPath: a,
        responseEncoding: a,
        validateStatus: s,
        headers: (u, f, h) => i(sj(u), sj(f), h, !0)
    };
    return Ie.forEach(Object.keys({
        ...e,
        ...t
    }), function(f) {
        const h = c[f] || i
          , m = h(e[f], t[f], f);
        Ie.isUndefined(m) && h !== s || (n[f] = m)
    }),
    n
}
const A6 = e => {
    const t = Hu({}, e);
    let {data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: o, headers: a, auth: s} = t;
    if (t.headers = a = vo.from(a),
    t.url = C6(E6(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer),
    s && a.set("Authorization", "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : ""))),
    Ie.isFormData(n)) {
        if (Ei.hasStandardBrowserEnv || Ei.hasStandardBrowserWebWorkerEnv)
            a.setContentType(void 0);
        else if (Ie.isFunction(n.getHeaders)) {
            const c = n.getHeaders()
              , u = ["content-type", "content-length"];
            Object.entries(c).forEach( ([f,h]) => {
                u.includes(f.toLowerCase()) && a.set(f, h)
            }
            )
        }
    }
    if (Ei.hasStandardBrowserEnv && (r && Ie.isFunction(r) && (r = r(t)),
    r || r !== !1 && hye(t.url))) {
        const c = i && o && pye.read(o);
        c && a.set(i, c)
    }
    return t
}
  , yye = typeof XMLHttpRequest < "u"
  , bye = yye && function(e) {
    return new Promise(function(n, r) {
        const i = A6(e);
        let o = i.data;
        const a = vo.from(i.headers).normalize();
        let {responseType: s, onUploadProgress: c, onDownloadProgress: u} = i, f, h, m, y, b;
        function v() {
            y && y(),
            b && b(),
            i.cancelToken && i.cancelToken.unsubscribe(f),
            i.signal && i.signal.removeEventListener("abort", f)
        }
        let S = new XMLHttpRequest;
        S.open(i.method.toUpperCase(), i.url, !0),
        S.timeout = i.timeout;
        function C() {
            if (!S)
                return;
            const k = vo.from("getAllResponseHeaders"in S && S.getAllResponseHeaders())
              , E = {
                data: !s || s === "text" || s === "json" ? S.responseText : S.response,
                status: S.status,
                statusText: S.statusText,
                headers: k,
                config: e,
                request: S
            };
            _6(function(D) {
                n(D),
                v()
            }, function(D) {
                r(D),
                v()
            }, E),
            S = null
        }
        "onloadend"in S ? S.onloadend = C : S.onreadystatechange = function() {
            !S || S.readyState !== 4 || S.status === 0 && !(S.responseURL && S.responseURL.indexOf("file:") === 0) || setTimeout(C)
        }
        ,
        S.onabort = function() {
            S && (r(new rn("Request aborted",rn.ECONNABORTED,e,S)),
            S = null)
        }
        ,
        S.onerror = function(T) {
            const E = T && T.message ? T.message : "Network Error"
              , P = new rn(E,rn.ERR_NETWORK,e,S);
            P.event = T || null,
            r(P),
            S = null
        }
        ,
        S.ontimeout = function() {
            let T = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
            const E = i.transitional || w6;
            i.timeoutErrorMessage && (T = i.timeoutErrorMessage),
            r(new rn(T,E.clarifyTimeoutError ? rn.ETIMEDOUT : rn.ECONNABORTED,e,S)),
            S = null
        }
        ,
        o === void 0 && a.setContentType(null),
        "setRequestHeader"in S && Ie.forEach(a.toJSON(), function(T, E) {
            S.setRequestHeader(E, T)
        }),
        Ie.isUndefined(i.withCredentials) || (S.withCredentials = !!i.withCredentials),
        s && s !== "json" && (S.responseType = i.responseType),
        u && ([m,b] = R0(u, !0),
        S.addEventListener("progress", m)),
        c && S.upload && ([h,y] = R0(c),
        S.upload.addEventListener("progress", h),
        S.upload.addEventListener("loadend", y)),
        (i.cancelToken || i.signal) && (f = k => {
            S && (r(!k || k.type ? new gh(null,e,S) : k),
            S.abort(),
            S = null)
        }
        ,
        i.cancelToken && i.cancelToken.subscribe(f),
        i.signal && (i.signal.aborted ? f() : i.signal.addEventListener("abort", f)));
        const w = uye(i.url);
        if (w && Ei.protocols.indexOf(w) === -1) {
            r(new rn("Unsupported protocol " + w + ":",rn.ERR_BAD_REQUEST,e));
            return
        }
        S.send(o || null)
    }
    )
}
  , xye = (e, t) => {
    const {length: n} = e = e ? e.filter(Boolean) : [];
    if (t || n) {
        let r = new AbortController, i;
        const o = function(u) {
            if (!i) {
                i = !0,
                s();
                const f = u instanceof Error ? u : this.reason;
                r.abort(f instanceof rn ? f : new gh(f instanceof Error ? f.message : f))
            }
        };
        let a = t && setTimeout( () => {
            a = null,
            o(new rn(`timeout ${t} of ms exceeded`,rn.ETIMEDOUT))
        }
        , t);
        const s = () => {
            e && (a && clearTimeout(a),
            a = null,
            e.forEach(u => {
                u.unsubscribe ? u.unsubscribe(o) : u.removeEventListener("abort", o)
            }
            ),
            e = null)
        }
        ;
        e.forEach(u => u.addEventListener("abort", o));
        const {signal: c} = r;
        return c.unsubscribe = () => Ie.asap(s),
        c
    }
}
  , vye = function*(e, t) {
    let n = e.byteLength;
    if (n < t) {
        yield e;
        return
    }
    let r = 0, i;
    for (; r < n; )
        i = r + t,
        yield e.slice(r, i),
        r = i
}
  , Sye = async function*(e, t) {
    for await(const n of Cye(e))
        yield*vye(n, t)
}
  , Cye = async function*(e) {
    if (e[Symbol.asyncIterator]) {
        yield*e;
        return
    }
    const t = e.getReader();
    try {
        for (; ; ) {
            const {done: n, value: r} = await t.read();
            if (n)
                break;
            yield r
        }
    } finally {
        await t.cancel()
    }
}
  , lj = (e, t, n, r) => {
    const i = Sye(e, t);
    let o = 0, a, s = c => {
        a || (a = !0,
        r && r(c))
    }
    ;
    return new ReadableStream({
        async pull(c) {
            try {
                const {done: u, value: f} = await i.next();
                if (u) {
                    s(),
                    c.close();
                    return
                }
                let h = f.byteLength;
                if (n) {
                    let m = o += h;
                    n(m)
                }
                c.enqueue(new Uint8Array(f))
            } catch (u) {
                throw s(u),
                u
            }
        },
        cancel(c) {
            return s(c),
            i.return()
        }
    },{
        highWaterMark: 2
    })
}
  , cj = 64 * 1024
  , {isFunction: Yb} = Ie
  , wye = ( ({Request: e, Response: t}) => ({
    Request: e,
    Response: t
}))(Ie.global)
  , {ReadableStream: uj, TextEncoder: dj} = Ie.global
  , fj = (e, ...t) => {
    try {
        return !!e(...t)
    } catch {
        return !1
    }
}
  , kye = e => {
    e = Ie.merge.call({
        skipUndefined: !0
    }, wye, e);
    const {fetch: t, Request: n, Response: r} = e
      , i = t ? Yb(t) : typeof fetch == "function"
      , o = Yb(n)
      , a = Yb(r);
    if (!i)
        return !1;
    const s = i && Yb(uj)
      , c = i && (typeof dj == "function" ? (b => v => b.encode(v))(new dj) : async b => new Uint8Array(await new n(b).arrayBuffer()))
      , u = o && s && fj( () => {
        let b = !1;
        const v = new n(Ei.origin,{
            body: new uj,
            method: "POST",
            get duplex() {
                return b = !0,
                "half"
            }
        }).headers.has("Content-Type");
        return b && !v
    }
    )
      , f = a && s && fj( () => Ie.isReadableStream(new r("").body))
      , h = {
        stream: f && (b => b.body)
    };
    i && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(b => {
        !h[b] && (h[b] = (v, S) => {
            let C = v && v[b];
            if (C)
                return C.call(v);
            throw new rn(`Response type '${b}' is not supported`,rn.ERR_NOT_SUPPORT,S)
        }
        )
    }
    );
    const m = async b => {
        if (b == null)
            return 0;
        if (Ie.isBlob(b))
            return b.size;
        if (Ie.isSpecCompliantForm(b))
            return (await new n(Ei.origin,{
                method: "POST",
                body: b
            }).arrayBuffer()).byteLength;
        if (Ie.isArrayBufferView(b) || Ie.isArrayBuffer(b))
            return b.byteLength;
        if (Ie.isURLSearchParams(b) && (b = b + ""),
        Ie.isString(b))
            return (await c(b)).byteLength
    }
      , y = async (b, v) => {
        const S = Ie.toFiniteNumber(b.getContentLength());
        return S ?? m(v)
    }
    ;
    return async b => {
        let {url: v, method: S, data: C, signal: w, cancelToken: k, timeout: T, onDownloadProgress: E, onUploadProgress: P, responseType: D, headers: $, withCredentials: z="same-origin", fetchOptions: O} = A6(b)
          , I = t || fetch;
        D = D ? (D + "").toLowerCase() : "text";
        let M = xye([w, k && k.toAbortSignal()], T)
          , B = null;
        const L = M && M.unsubscribe && ( () => {
            M.unsubscribe()
        }
        );
        let F;
        try {
            if (P && u && S !== "get" && S !== "head" && (F = await y($, C)) !== 0) {
                let V = new n(v,{
                    method: "POST",
                    body: C,
                    duplex: "half"
                }), Y;
                if (Ie.isFormData(C) && (Y = V.headers.get("content-type")) && $.setContentType(Y),
                V.body) {
                    const [W,te] = oj(F, R0(aj(P)));
                    C = lj(V.body, cj, W, te)
                }
            }
            Ie.isString(z) || (z = z ? "include" : "omit");
            const j = o && "credentials"in n.prototype
              , N = {
                ...O,
                signal: M,
                method: S.toUpperCase(),
                headers: $.normalize().toJSON(),
                body: C,
                duplex: "half",
                credentials: j ? z : void 0
            };
            B = o && new n(v,N);
            let H = await (o ? I(B, O) : I(v, N));
            const Z = f && (D === "stream" || D === "response");
            if (f && (E || Z && L)) {
                const V = {};
                ["status", "statusText", "headers"].forEach(K => {
                    V[K] = H[K]
                }
                );
                const Y = Ie.toFiniteNumber(H.headers.get("content-length"))
                  , [W,te] = E && oj(Y, R0(aj(E), !0)) || [];
                H = new r(lj(H.body, cj, W, () => {
                    te && te(),
                    L && L()
                }
                ),V)
            }
            D = D || "text";
            let q = await h[Ie.findKey(h, D) || "text"](H, b);
            return !Z && L && L(),
            await new Promise( (V, Y) => {
                _6(V, Y, {
                    data: q,
                    headers: vo.from(H.headers),
                    status: H.status,
                    statusText: H.statusText,
                    config: b,
                    request: B
                })
            }
            )
        } catch (j) {
            throw L && L(),
            j && j.name === "TypeError" && /Load failed|fetch/i.test(j.message) ? Object.assign(new rn("Network Error",rn.ERR_NETWORK,b,B), {
                cause: j.cause || j
            }) : rn.from(j, j && j.code, b, B)
        }
    }
}
  , Tye = new Map
  , M6 = e => {
    let t = e ? e.env : {};
    const {fetch: n, Request: r, Response: i} = t
      , o = [r, i, n];
    let a = o.length, s = a, c, u, f = Tye;
    for (; s--; )
        c = o[s],
        u = f.get(c),
        u === void 0 && f.set(c, u = s ? new Map : kye(t)),
        f = u;
    return u
}
;
M6();
const ET = {
    http: Uge,
    xhr: bye,
    fetch: {
        get: M6
    }
};
Ie.forEach(ET, (e, t) => {
    if (e) {
        try {
            Object.defineProperty(e, "name", {
                value: t
            })
        } catch {}
        Object.defineProperty(e, "adapterName", {
            value: t
        })
    }
}
);
const hj = e => `- ${e}`
  , _ye = e => Ie.isFunction(e) || e === null || e === !1
  , P6 = {
    getAdapter: (e, t) => {
        e = Ie.isArray(e) ? e : [e];
        const {length: n} = e;
        let r, i;
        const o = {};
        for (let a = 0; a < n; a++) {
            r = e[a];
            let s;
            if (i = r,
            !_ye(r) && (i = ET[(s = String(r)).toLowerCase()],
            i === void 0))
                throw new rn(`Unknown adapter '${s}'`);
            if (i && (Ie.isFunction(i) || (i = i.get(t))))
                break;
            o[s || "#" + a] = i
        }
        if (!i) {
            const a = Object.entries(o).map( ([c,u]) => `adapter ${c} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build"));
            let s = n ? a.length > 1 ? `since :
` + a.map(hj).join(`
`) : " " + hj(a[0]) : "as no adapter specified";
            throw new rn("There is no suitable adapter to dispatch the request " + s,"ERR_NOT_SUPPORT")
        }
        return i
    }
    ,
    adapters: ET
};
function bk(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(),
    e.signal && e.signal.aborted)
        throw new gh(null,e)
}
function pj(e) {
    return bk(e),
    e.headers = vo.from(e.headers),
    e.data = yk.call(e, e.transformRequest),
    ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1),
    P6.getAdapter(e.adapter || Zg.adapter, e)(e).then(function(r) {
        return bk(e),
        r.data = yk.call(e, e.transformResponse, r),
        r.headers = vo.from(r.headers),
        r
    }, function(r) {
        return T6(r) || (bk(e),
        r && r.response && (r.response.data = yk.call(e, e.transformResponse, r.response),
        r.response.headers = vo.from(r.response.headers))),
        Promise.reject(r)
    })
}
const R6 = "1.12.2"
  , C1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach( (e, t) => {
    C1[e] = function(r) {
        return typeof r === e || "a" + (t < 1 ? "n " : " ") + e
    }
}
);
const mj = {};
C1.transitional = function(t, n, r) {
    function i(o, a) {
        return "[Axios v" + R6 + "] Transitional option '" + o + "'" + a + (r ? ". " + r : "")
    }
    return (o, a, s) => {
        if (t === !1)
            throw new rn(i(a, " has been removed" + (n ? " in " + n : "")),rn.ERR_DEPRECATED);
        return n && !mj[a] && (mj[a] = !0,
        console.warn(i(a, " has been deprecated since v" + n + " and will be removed in the near future"))),
        t ? t(o, a, s) : !0
    }
}
;
C1.spelling = function(t) {
    return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`),
    !0)
}
;
function Eye(e, t, n) {
    if (typeof e != "object")
        throw new rn("options must be an object",rn.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(e);
    let i = r.length;
    for (; i-- > 0; ) {
        const o = r[i]
          , a = t[o];
        if (a) {
            const s = e[o]
              , c = s === void 0 || a(s, o, e);
            if (c !== !0)
                throw new rn("option " + o + " must be " + c,rn.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (n !== !0)
            throw new rn("Unknown option " + o,rn.ERR_BAD_OPTION)
    }
}
const Lx = {
    assertOptions: Eye,
    validators: C1
}
  , ds = Lx.validators;
let Du = class {
    constructor(t) {
        this.defaults = t || {},
        this.interceptors = {
            request: new rj,
            response: new rj
        }
    }
    async request(t, n) {
        try {
            return await this._request(t, n)
        } catch (r) {
            if (r instanceof Error) {
                let i = {};
                Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error;
                const o = i.stack ? i.stack.replace(/^.+\n/, "") : "";
                try {
                    r.stack ? o && !String(r.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + o) : r.stack = o
                } catch {}
            }
            throw r
        }
    }
    _request(t, n) {
        typeof t == "string" ? (n = n || {},
        n.url = t) : n = t || {},
        n = Hu(this.defaults, n);
        const {transitional: r, paramsSerializer: i, headers: o} = n;
        r !== void 0 && Lx.assertOptions(r, {
            silentJSONParsing: ds.transitional(ds.boolean),
            forcedJSONParsing: ds.transitional(ds.boolean),
            clarifyTimeoutError: ds.transitional(ds.boolean)
        }, !1),
        i != null && (Ie.isFunction(i) ? n.paramsSerializer = {
            serialize: i
        } : Lx.assertOptions(i, {
            encode: ds.function,
            serialize: ds.function
        }, !0)),
        n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0),
        Lx.assertOptions(n, {
            baseUrl: ds.spelling("baseURL"),
            withXsrfToken: ds.spelling("withXSRFToken")
        }, !0),
        n.method = (n.method || this.defaults.method || "get").toLowerCase();
        let a = o && Ie.merge(o.common, o[n.method]);
        o && Ie.forEach(["delete", "get", "head", "post", "put", "patch", "common"], b => {
            delete o[b]
        }
        ),
        n.headers = vo.concat(a, o);
        const s = [];
        let c = !0;
        this.interceptors.request.forEach(function(v) {
            typeof v.runWhen == "function" && v.runWhen(n) === !1 || (c = c && v.synchronous,
            s.unshift(v.fulfilled, v.rejected))
        });
        const u = [];
        this.interceptors.response.forEach(function(v) {
            u.push(v.fulfilled, v.rejected)
        });
        let f, h = 0, m;
        if (!c) {
            const b = [pj.bind(this), void 0];
            for (b.unshift(...s),
            b.push(...u),
            m = b.length,
            f = Promise.resolve(n); h < m; )
                f = f.then(b[h++], b[h++]);
            return f
        }
        m = s.length;
        let y = n;
        for (; h < m; ) {
            const b = s[h++]
              , v = s[h++];
            try {
                y = b(y)
            } catch (S) {
                v.call(this, S);
                break
            }
        }
        try {
            f = pj.call(this, y)
        } catch (b) {
            return Promise.reject(b)
        }
        for (h = 0,
        m = u.length; h < m; )
            f = f.then(u[h++], u[h++]);
        return f
    }
    getUri(t) {
        t = Hu(this.defaults, t);
        const n = E6(t.baseURL, t.url, t.allowAbsoluteUrls);
        return C6(n, t.params, t.paramsSerializer)
    }
}
;
Ie.forEach(["delete", "get", "head", "options"], function(t) {
    Du.prototype[t] = function(n, r) {
        return this.request(Hu(r || {}, {
            method: t,
            url: n,
            data: (r || {}).data
        }))
    }
});
Ie.forEach(["post", "put", "patch"], function(t) {
    function n(r) {
        return function(o, a, s) {
            return this.request(Hu(s || {}, {
                method: t,
                headers: r ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: o,
                data: a
            }))
        }
    }
    Du.prototype[t] = n(),
    Du.prototype[t + "Form"] = n(!0)
});
let Aye = class D6 {
    constructor(t) {
        if (typeof t != "function")
            throw new TypeError("executor must be a function.");
        let n;
        this.promise = new Promise(function(o) {
            n = o
        }
        );
        const r = this;
        this.promise.then(i => {
            if (!r._listeners)
                return;
            let o = r._listeners.length;
            for (; o-- > 0; )
                r._listeners[o](i);
            r._listeners = null
        }
        ),
        this.promise.then = i => {
            let o;
            const a = new Promise(s => {
                r.subscribe(s),
                o = s
            }
            ).then(i);
            return a.cancel = function() {
                r.unsubscribe(o)
            }
            ,
            a
        }
        ,
        t(function(o, a, s) {
            r.reason || (r.reason = new gh(o,a,s),
            n(r.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(t) {
        if (this.reason) {
            t(this.reason);
            return
        }
        this._listeners ? this._listeners.push(t) : this._listeners = [t]
    }
    unsubscribe(t) {
        if (!this._listeners)
            return;
        const n = this._listeners.indexOf(t);
        n !== -1 && this._listeners.splice(n, 1)
    }
    toAbortSignal() {
        const t = new AbortController
          , n = r => {
            t.abort(r)
        }
        ;
        return this.subscribe(n),
        t.signal.unsubscribe = () => this.unsubscribe(n),
        t.signal
    }
    static source() {
        let t;
        return {
            token: new D6(function(i) {
                t = i
            }
            ),
            cancel: t
        }
    }
}
;
function Mye(e) {
    return function(n) {
        return e.apply(null, n)
    }
}
function Pye(e) {
    return Ie.isObject(e) && e.isAxiosError === !0
}
const AT = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(AT).forEach( ([e,t]) => {
    AT[t] = e
}
);
function O6(e) {
    const t = new Du(e)
      , n = u6(Du.prototype.request, t);
    return Ie.extend(n, Du.prototype, t, {
        allOwnKeys: !0
    }),
    Ie.extend(n, t, null, {
        allOwnKeys: !0
    }),
    n.create = function(i) {
        return O6(Hu(e, i))
    }
    ,
    n
}
const wr = O6(Zg);
wr.Axios = Du;
wr.CanceledError = gh;
wr.CancelToken = Aye;
wr.isCancel = T6;
wr.VERSION = R6;
wr.toFormData = S1;
wr.AxiosError = rn;
wr.Cancel = wr.CanceledError;
wr.all = function(t) {
    return Promise.all(t)
}
;
wr.spread = Mye;
wr.isAxiosError = Pye;
wr.mergeConfig = Hu;
wr.AxiosHeaders = vo;
wr.formToJSON = e => k6(Ie.isHTMLForm(e) ? new FormData(e) : e);
wr.getAdapter = P6.getAdapter;
wr.HttpStatusCode = AT;
wr.default = wr;
const {Axios: EUe, AxiosError: AUe, CanceledError: MUe, isCancel: PUe, CancelToken: RUe, VERSION: DUe, all: OUe, Cancel: IUe, isAxiosError: $Ue, spread: LUe, toFormData: jUe, AxiosHeaders: BUe, HttpStatusCode: zUe, formToJSON: FUe, getAdapter: NUe, mergeConfig: UUe} = wr
  , Qi = wr.create({
    baseURL: "https://inventory-webapi-dev.azurewebsites.net",
    headers: {
        "Cache-Control": "no-cache"
    }
});
function I6(e=1, t=!0) {
    return Is({
        queryKey: ["languages"],
        queryFn: async () => (await Qi.get("/api/Languages/GetAllLanguages", {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Cache-Control": "no-cache"
            }
        })).data,
        staleTime: 1e3 * 60 * 5,
        retry: e,
        enabled: t
    })
}
function $6(e=1, t=!0) {
    return Is({
        queryKey: ["SalesStatus"],
        queryFn: async () => (await Qi.get("/api/SalesStatuses/GetAllSalesStatuses", {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Cache-Control": "no-cache"
            }
        })).data,
        staleTime: 1e3 * 60 * 5,
        retry: e,
        enabled: t
    })
}
function Rye(e=1, t=!0) {
    return Is({
        queryKey: ["UomDimension"],
        queryFn: async () => (await Qi.get("/api/UomDimensions/GetAllUomDimensions", {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Cache-Control": "no-cache"
            }
        })).data,
        staleTime: 1e3 * 60 * 5,
        retry: e,
        enabled: t
    })
}
function Dye(e) {
    return Is({
        queryKey: ["UomsByDimension", e],
        queryFn: async () => e ? (await Qi.get(`/api/Uoms/GetUomByDimentionId/${e}`, {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`
            }
        })).data : [],
        enabled: !!e
    })
}
function L6(e=1, t=!0) {
    return Is({
        queryKey: ["productTypes"],
        queryFn: async () => (await Qi.get("/api/ProductTypes/GetAllProductTypes", {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Cache-Control": "no-cache"
            }
        })).data,
        staleTime: 1e3 * 60 * 5,
        retry: e,
        enabled: t
    })
}
function Oye(e=1, t=!0) {
    return Is({
        queryKey: ["productGroups"],
        queryFn: async () => (await Qi.get("/api/ProductGroups/GetAllProductGroups", {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Cache-Control": "no-cache"
            }
        })).data,
        staleTime: 1e3 * 60 * 5,
        retry: e,
        enabled: t
    })
}
function Iye(e=1, t=!0) {
    return Is({
        queryKey: ["productCategories"],
        queryFn: async () => (await Qi.get("/api/ProductCategories/GetAllProductCategories", {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Cache-Control": "no-cache"
            }
        })).data,
        staleTime: 1e3 * 60 * 5,
        retry: e,
        enabled: t
    })
}
function j6() {
    return wg({
        mutationFn: async e => (await Qi.post("/api/ProductTypes/AddProductType", e, {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Content-Type": "application/json",
                "Cache-Control": "no-cache"
            }
        })).data
    })
}
function $ye() {
    return wg({
        mutationFn: async e => (await Qi.post("/api/ProductMasterForms/AddProductMasterForm", e, {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Content-Type": "application/json",
                "Cache-Control": "no-cache"
            }
        })).data
    })
}
function Lye() {
    return wg({
        mutationFn: async ({id: e, data: t}) => (await Qi.put(`/api/ProductMasterForms/UpdateProductMasterForm/${e}`, t, {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Content-Type": "application/json",
                "Cache-Control": "no-cache"
            }
        })).data
    })
}
function jye() {
    return wg({
        mutationFn: async ({id: e, data: t}) => (await Qi.put(`/api/VendorForms/UpdateVendorForm/${e}`, t, {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Content-Type": "application/json",
                "Cache-Control": "no-cache"
            }
        })).data
    })
}
function Bye() {
    return wg({
        mutationFn: async e => (await Qi.post("/api/VendorForms/AddVendorForm", e, {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Content-Type": "application/json",
                "Cache-Control": "no-cache"
            }
        })).data
    })
}
function zye(e=1, t=!0) {
    return Is({
        queryKey: ["readProductMasterForm"],
        queryFn: async () => {
            try {
                return (await Qi.get("/api/ProductMasterForms/GetAllProductMasterForm", {
                    headers: {
                        Authorization: `Bearer ${localStorage.getItem("token")}`,
                        "Cache-Control": "no-cache"
                    }
                })).data
            } catch (n) {
                throw console.log("Error fetching product master forms:", n),
                n
            }
        }
        ,
        staleTime: 1e3 * 60 * 5,
        retry: e,
        enabled: t
    })
}
function Fye(e=1, t=!0) {
    return Is({
        queryKey: ["readVendorForm"],
        queryFn: async () => (await Qi.get("/api/VendorForms/GetAllVendorForm", {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Cache-Control": "no-cache"
            }
        })).data,
        staleTime: 1e3 * 60 * 5,
        retry: e,
        enabled: t
    })
}
function Nye(e) {
    return Is({
        queryKey: ["GetVendorFormById", e],
        queryFn: async () => e ? (await Qi.get(`/api/VendorForms/GetVendorFormById/${e}`, {
            headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`
            }
        })).data : [],
        enabled: !!e
    })
}
function Uye() {
    const e = Os()
      , t = uh()
      , {data: n=[], isLoading: r} = L6()
      , {mutate: i} = j6()
      , [o,a] = A.useState(!1)
      , [s,c] = A.useState("")
      , [u,f] = A.useState("success")
      , [h,m] = A.useState(!1)
      , [y,b] = A.useState(null)
      , {addNotification: v} = bA()
      , [S,C] = A.useState(10)
      , [w,k] = A.useState(0)
      , [T,E] = A.useState({
        productTypeCode: "",
        productTypeDesc: ""
    })
      , P = te => {
        b(te || null),
        E({
            productTypeCode: te?.productTypeCode || "",
            productTypeDesc: te?.productTypeDesc.toString() || ""
        }),
        m(!0)
    }
      , D = () => {
        m(!1),
        b(null)
    }
      , $ = te => {
        E({
            ...T,
            [te.target.name]: te.target.value
        })
    }
      , z = () => {
        const {productTypeCode: te, productTypeDesc: K} = T;
        !te || !K || (y ? D() : i({
            productTypeCode: te,
            productTypeDesc: K,
            TranscationById: 1
        }, {
            onSuccess: () => {
                t.invalidateQueries({
                    queryKey: ["productTypes"]
                }),
                c("Product type added successfully"),
                f("success"),
                a(!0),
                D(),
                v("Product type added successfully", "success")
            }
            ,
            onError: re => {
                v(`Error adding product type: ${re.message}`, "error")
            }
        }))
    }
      , [O,I] = A.useState("")
      , [M,B] = A.useState("productTypeCode")
      , [L,F] = A.useState("asc")
      , j = te => {
        F(M === te && L === "asc" ? "desc" : "asc"),
        B(te)
    }
    ;
    function N(te, K, ee) {
        return K[ee] < te[ee] ? -1 : K[ee] > te[ee] ? 1 : 0
    }
    function H(te, K) {
        return te === "desc" ? (ee, re) => N(ee, re, K) : (ee, re) => -N(ee, re, K)
    }
    const Z = n.filter(te => {
        const K = O.toLowerCase()
          , ee = te.productTypeCode.toLowerCase().includes(K)
          , re = te.productTypeDesc.toLowerCase().includes(K);
        return ee || re
    }
    ).sort(H(L, M))
      , q = te => {
        C(parseInt(te.target.value, 10)),
        k(0)
    }
      , V = (te, K) => {
        k(K)
    }
      , Y = Z.slice(w * S, w * S + S)
      , W = () => Array(S).fill(0).map( (te, K) => g.jsxs(gn, {
        children: [g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "70%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "90%",
                height: 24,
                animation: "wave"
            })
        })]
    }, `skeleton-${K}`));
    return g.jsxs(g.Fragment, {
        children: [g.jsx(hh, {
            open: o,
            anchorOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            autoHideDuration: 4e3,
            onClose: () => a(!1),
            children: g.jsx(Mc, {
                onClose: () => a(!1),
                severity: u,
                sx: {
                    width: "100%"
                },
                children: s
            })
        }), g.jsxs(Be, {
            p: 2,
            children: [g.jsx(Ae, {
                variant: "h5",
                gutterBottom: !0,
                children: "Product Type"
            }), g.jsxs(Be, {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                mb: 2,
                children: [g.jsx(ct, {
                    label: "Search",
                    variant: "outlined",
                    size: "small",
                    value: O,
                    onChange: te => {
                        I(te.target.value),
                        k(0)
                    }
                    ,
                    sx: {
                        width: 250
                    },
                    disabled: r,
                    InputProps: {
                        endAdornment: r && g.jsx(Jr, {
                            color: "inherit",
                            size: 20
                        })
                    }
                }), g.jsx(Mt, {
                    variant: "contained",
                    onClick: () => e("/products/add"),
                    size: "small",
                    sx: {
                        borderRadius: "8px",
                        minWidth: "100px"
                    },
                    startIcon: r ? g.jsx(Jr, {
                        size: 20,
                        color: "inherit"
                    }) : g.jsx(Go, {}),
                    disabled: r,
                    children: "Add"
                })]
            })]
        }), g.jsxs(Ha, {
            component: yn,
            children: [g.jsxs(Ua, {
                stickyHeader: !0,
                size: "small",
                children: [g.jsx(qa, {
                    children: g.jsxs(gn, {
                        children: [g.jsx(Me, {
                            sx: {
                                py: 1.5,
                                fontWeight: 600
                            },
                            children: r ? g.jsx(Fn, {
                                variant: "text",
                                width: "70%",
                                height: 24,
                                animation: "wave"
                            }) : g.jsx(Fi, {
                                active: M === "productTypeCode",
                                direction: M === "productTypeCode" ? L : "asc",
                                onClick: () => j("productTypeCode"),
                                disabled: r,
                                children: "Product Type Code"
                            })
                        }), g.jsx(Me, {
                            sx: {
                                py: 1.5,
                                fontWeight: 600
                            },
                            children: r ? g.jsx(Fn, {
                                variant: "text",
                                width: "70%",
                                height: 24,
                                animation: "wave"
                            }) : g.jsx(Fi, {
                                active: M === "productTypeDesc",
                                direction: M === "productTypeDesc" ? L : "asc",
                                onClick: () => j("productTypeDesc"),
                                disabled: r,
                                children: "Product Type Description"
                            })
                        })]
                    })
                }), g.jsxs(Va, {
                    children: [r ? W() : Y.map(te => g.jsxs(gn, {
                        onClick: K => {
                            K.target.closest(".action-buttons") || P(te)
                        }
                        ,
                        sx: {
                            "&:hover": {
                                backgroundColor: "#f1f1fa",
                                cursor: "pointer"
                            }
                        },
                        children: [g.jsx(Me, {
                            sx: {
                                py: 1
                            },
                            children: te.productTypeCode
                        }), g.jsx(Me, {
                            sx: {
                                py: 1
                            },
                            children: te.productTypeDesc
                        })]
                    }, te.productTypeId)), !r && Y.length === 0 && g.jsx(gn, {
                        children: g.jsx(Me, {
                            colSpan: 2,
                            align: "center",
                            sx: {
                                py: 2
                            },
                            children: "No data found."
                        })
                    })]
                })]
            }), g.jsx(Bg, {
                component: "div",
                count: r ? 0 : Z.length,
                page: w,
                onPageChange: V,
                rowsPerPage: S,
                onRowsPerPageChange: q,
                disabled: r
            })]
        }), g.jsxs(sc, {
            open: h,
            onClose: D,
            maxWidth: "sm",
            fullWidth: !0,
            children: [g.jsxs(yu, {
                sx: {
                    p: 1,
                    mb: 0
                },
                children: [y ? "Edit" : "Add", " Product"]
            }), g.jsxs(cc, {
                sx: {
                    display: "flex",
                    flexDirection: "column",
                    gap: 2,
                    mt: 0
                },
                children: [g.jsx("span", {}), g.jsx(ct, {
                    name: "productTypeCode",
                    label: "Product Type Code",
                    value: T.productTypeCode,
                    onChange: $,
                    required: !0,
                    size: "small"
                }), g.jsx(ct, {
                    name: "productTypeDesc",
                    label: "Product Type Description",
                    value: T.productTypeDesc,
                    onChange: $,
                    required: !0,
                    size: "small"
                })]
            }), g.jsxs(lc, {
                children: [g.jsx(Mt, {
                    onClick: D,
                    size: "small",
                    children: "Cancel"
                }), g.jsx(Mt, {
                    onClick: z,
                    variant: "contained",
                    size: "small",
                    sx: {
                        borderRadius: "8px",
                        minWidth: "100px"
                    },
                    children: y ? "Update" : "Create"
                })]
            })]
        })]
    })
}
var Qg = e => e.type === "checkbox"
  , wu = e => e instanceof Date
  , lo = e => e == null;
const B6 = e => typeof e == "object";
var Xr = e => !lo(e) && !Array.isArray(e) && B6(e) && !wu(e)
  , z6 = e => Xr(e) && e.target ? Qg(e.target) ? e.target.checked : e.target.value : e
  , Vye = e => e.substring(0, e.search(/\.\d+(\.|$)/)) || e
  , F6 = (e, t) => e.has(Vye(t))
  , Hye = e => {
    const t = e.constructor && e.constructor.prototype;
    return Xr(t) && t.hasOwnProperty("isPrototypeOf")
}
  , CA = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function ur(e) {
    let t;
    const n = Array.isArray(e)
      , r = typeof FileList < "u" ? e instanceof FileList : !1;
    if (e instanceof Date)
        t = new Date(e);
    else if (!(CA && (e instanceof Blob || r)) && (n || Xr(e)))
        if (t = n ? [] : Object.create(Object.getPrototypeOf(e)),
        !n && !Hye(e))
            t = e;
        else
            for (const i in e)
                e.hasOwnProperty(i) && (t[i] = ur(e[i]));
    else
        return e;
    return t
}
var w1 = e => /^\w*$/.test(e)
  , ar = e => e === void 0
  , k1 = e => Array.isArray(e) ? e.filter(Boolean) : []
  , wA = e => k1(e.replace(/["|']|\]/g, "").split(/\.|\[/))
  , dt = (e, t, n) => {
    if (!t || !Xr(e))
        return n;
    const r = (w1(t) ? [t] : wA(t)).reduce( (i, o) => lo(i) ? i : i[o], e);
    return ar(r) || r === e ? ar(e[t]) ? n : e[t] : r
}
  , Uo = e => typeof e == "boolean"
  , zn = (e, t, n) => {
    let r = -1;
    const i = w1(t) ? [t] : wA(t)
      , o = i.length
      , a = o - 1;
    for (; ++r < o; ) {
        const s = i[r];
        let c = n;
        if (r !== a) {
            const u = e[s];
            c = Xr(u) || Array.isArray(u) ? u : isNaN(+i[r + 1]) ? {} : []
        }
        if (s === "__proto__" || s === "constructor" || s === "prototype")
            return;
        e[s] = c,
        e = e[s]
    }
}
;
const D0 = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
}
  , ba = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
}
  , sl = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
}
  , kA = bt.createContext(null);
kA.displayName = "HookFormContext";
const yh = () => bt.useContext(kA)
  , TA = e => {
    const {children: t, ...n} = e;
    return bt.createElement(kA.Provider, {
        value: n
    }, t)
}
;
var N6 = (e, t, n, r=!0) => {
    const i = {
        defaultValues: t._defaultValues
    };
    for (const o in e)
        Object.defineProperty(i, o, {
            get: () => {
                const a = o;
                return t._proxyFormState[a] !== ba.all && (t._proxyFormState[a] = !r || ba.all),
                n && (n[a] = !0),
                e[a]
            }
        });
    return i
}
;
const T1 = typeof window < "u" ? bt.useLayoutEffect : bt.useEffect;
function qye(e) {
    const t = yh()
      , {control: n=t.control, disabled: r, name: i, exact: o} = e || {}
      , [a,s] = bt.useState(n._formState)
      , c = bt.useRef({
        isDirty: !1,
        isLoading: !1,
        dirtyFields: !1,
        touchedFields: !1,
        validatingFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    });
    return T1( () => n._subscribe({
        name: i,
        formState: c.current,
        exact: o,
        callback: u => {
            !r && s({
                ...n._formState,
                ...u
            })
        }
    }), [i, r, o]),
    bt.useEffect( () => {
        c.current.isValid && n._setValid(!0)
    }
    , [n]),
    bt.useMemo( () => N6(a, n, c.current, !1), [a, n])
}
var qo = e => typeof e == "string"
  , U6 = (e, t, n, r, i) => qo(e) ? (r && t.watch.add(e),
dt(n, e, i)) : Array.isArray(e) ? e.map(o => (r && t.watch.add(o),
dt(n, o))) : (r && (t.watchAll = !0),
n)
  , MT = e => lo(e) || !B6(e);
function ml(e, t, n=new WeakSet) {
    if (MT(e) || MT(t))
        return e === t;
    if (wu(e) && wu(t))
        return e.getTime() === t.getTime();
    const r = Object.keys(e)
      , i = Object.keys(t);
    if (r.length !== i.length)
        return !1;
    if (n.has(e) || n.has(t))
        return !0;
    n.add(e),
    n.add(t);
    for (const o of r) {
        const a = e[o];
        if (!i.includes(o))
            return !1;
        if (o !== "ref") {
            const s = t[o];
            if (wu(a) && wu(s) || Xr(a) && Xr(s) || Array.isArray(a) && Array.isArray(s) ? !ml(a, s, n) : a !== s)
                return !1
        }
    }
    return !0
}
function Wye(e) {
    const t = yh()
      , {control: n=t.control, name: r, defaultValue: i, disabled: o, exact: a, compute: s} = e || {}
      , c = bt.useRef(i)
      , u = bt.useRef(s)
      , f = bt.useRef(void 0);
    u.current = s;
    const h = bt.useMemo( () => n._getWatch(r, c.current), [n, r])
      , [m,y] = bt.useState(u.current ? u.current(h) : h);
    return T1( () => n._subscribe({
        name: r,
        formState: {
            values: !0
        },
        exact: a,
        callback: b => {
            if (!o) {
                const v = U6(r, n._names, b.values || n._formValues, !1, c.current);
                if (u.current) {
                    const S = u.current(v);
                    ml(S, f.current) || (y(S),
                    f.current = S)
                } else
                    y(v)
            }
        }
    }), [n, o, r, a]),
    bt.useEffect( () => n._removeUnmounted()),
    m
}
function Gye(e) {
    const t = yh()
      , {name: n, disabled: r, control: i=t.control, shouldUnregister: o, defaultValue: a} = e
      , s = F6(i._names.array, n)
      , c = bt.useMemo( () => dt(i._formValues, n, dt(i._defaultValues, n, a)), [i, n, a])
      , u = Wye({
        control: i,
        name: n,
        defaultValue: c,
        exact: !0
    })
      , f = qye({
        control: i,
        name: n,
        exact: !0
    })
      , h = bt.useRef(e)
      , m = bt.useRef(void 0)
      , y = bt.useRef(i.register(n, {
        ...e.rules,
        value: u,
        ...Uo(e.disabled) ? {
            disabled: e.disabled
        } : {}
    }));
    h.current = e;
    const b = bt.useMemo( () => Object.defineProperties({}, {
        invalid: {
            enumerable: !0,
            get: () => !!dt(f.errors, n)
        },
        isDirty: {
            enumerable: !0,
            get: () => !!dt(f.dirtyFields, n)
        },
        isTouched: {
            enumerable: !0,
            get: () => !!dt(f.touchedFields, n)
        },
        isValidating: {
            enumerable: !0,
            get: () => !!dt(f.validatingFields, n)
        },
        error: {
            enumerable: !0,
            get: () => dt(f.errors, n)
        }
    }), [f, n])
      , v = bt.useCallback(k => y.current.onChange({
        target: {
            value: z6(k),
            name: n
        },
        type: D0.CHANGE
    }), [n])
      , S = bt.useCallback( () => y.current.onBlur({
        target: {
            value: dt(i._formValues, n),
            name: n
        },
        type: D0.BLUR
    }), [n, i._formValues])
      , C = bt.useCallback(k => {
        const T = dt(i._fields, n);
        T && k && (T._f.ref = {
            focus: () => k.focus && k.focus(),
            select: () => k.select && k.select(),
            setCustomValidity: E => k.setCustomValidity(E),
            reportValidity: () => k.reportValidity()
        })
    }
    , [i._fields, n])
      , w = bt.useMemo( () => ({
        name: n,
        value: u,
        ...Uo(r) || f.disabled ? {
            disabled: f.disabled || r
        } : {},
        onChange: v,
        onBlur: S,
        ref: C
    }), [n, r, f.disabled, v, S, C, u]);
    return bt.useEffect( () => {
        const k = i._options.shouldUnregister || o
          , T = m.current;
        T && T !== n && !s && i.unregister(T),
        i.register(n, {
            ...h.current.rules,
            ...Uo(h.current.disabled) ? {
                disabled: h.current.disabled
            } : {}
        });
        const E = (P, D) => {
            const $ = dt(i._fields, P);
            $ && $._f && ($._f.mount = D)
        }
        ;
        if (E(n, !0),
        k) {
            const P = ur(dt(i._options.defaultValues, n, h.current.defaultValue));
            zn(i._defaultValues, n, P),
            ar(dt(i._formValues, n)) && zn(i._formValues, n, P)
        }
        return !s && i.register(n),
        m.current = n,
        () => {
            (s ? k && !i._state.action : k) ? i.unregister(n) : E(n, !1)
        }
    }
    , [n, i, s, o]),
    bt.useEffect( () => {
        i._setDisabledField({
            disabled: r,
            name: n
        })
    }
    , [r, n, i]),
    bt.useMemo( () => ({
        field: w,
        formState: f,
        fieldState: b
    }), [w, f, b])
}
const un = e => e.render(Gye(e));
var _A = (e, t, n, r, i) => t ? {
    ...n[e],
    types: {
        ...n[e] && n[e].types ? n[e].types : {},
        [r]: i || !0
    }
} : {}
  , po = e => Array.isArray(e) ? e : [e]
  , gj = () => {
    let e = [];
    return {
        get observers() {
            return e
        },
        next: i => {
            for (const o of e)
                o.next && o.next(i)
        }
        ,
        subscribe: i => (e.push(i),
        {
            unsubscribe: () => {
                e = e.filter(o => o !== i)
            }
        }),
        unsubscribe: () => {
            e = []
        }
    }
}
;
function V6(e, t) {
    const n = {};
    for (const r in e)
        if (e.hasOwnProperty(r)) {
            const i = e[r]
              , o = t[r];
            if (i && Xr(i) && o) {
                const a = V6(i, o);
                Xr(a) && (n[r] = a)
            } else
                e[r] && (n[r] = o)
        }
    return n
}
var ji = e => Xr(e) && !Object.keys(e).length
  , EA = e => e.type === "file"
  , za = e => typeof e == "function"
  , O0 = e => {
    if (!CA)
        return !1;
    const t = e ? e.ownerDocument : 0;
    return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement)
}
  , H6 = e => e.type === "select-multiple"
  , AA = e => e.type === "radio"
  , Yye = e => AA(e) || Qg(e)
  , xk = e => O0(e) && e.isConnected;
function Zye(e, t) {
    const n = t.slice(0, -1).length;
    let r = 0;
    for (; r < n; )
        e = ar(e) ? r++ : e[t[r++]];
    return e
}
function Qye(e) {
    for (const t in e)
        if (e.hasOwnProperty(t) && !ar(e[t]))
            return !1;
    return !0
}
function jr(e, t) {
    const n = Array.isArray(t) ? t : w1(t) ? [t] : wA(t)
      , r = n.length === 1 ? e : Zye(e, n)
      , i = n.length - 1
      , o = n[i];
    return r && delete r[o],
    i !== 0 && (Xr(r) && ji(r) || Array.isArray(r) && Qye(r)) && jr(e, n.slice(0, -1)),
    e
}
var Kye = e => {
    for (const t in e)
        if (za(e[t]))
            return !0;
    return !1
}
;
function q6(e) {
    return Array.isArray(e) || Xr(e) && !Kye(e)
}
function PT(e, t={}) {
    for (const n in e)
        q6(e[n]) ? (t[n] = Array.isArray(e[n]) ? [] : {},
        PT(e[n], t[n])) : ar(e[n]) || (t[n] = !0);
    return t
}
function lf(e, t, n) {
    n || (n = PT(t));
    for (const r in e)
        q6(e[r]) ? ar(t) || MT(n[r]) ? n[r] = PT(e[r], Array.isArray(e[r]) ? [] : {}) : lf(e[r], lo(t) ? {} : t[r], n[r]) : n[r] = !ml(e[r], t[r]);
    return n
}
const yj = {
    value: !1,
    isValid: !1
}
  , bj = {
    value: !0,
    isValid: !0
};
var W6 = e => {
    if (Array.isArray(e)) {
        if (e.length > 1) {
            const t = e.filter(n => n && n.checked && !n.disabled).map(n => n.value);
            return {
                value: t,
                isValid: !!t.length
            }
        }
        return e[0].checked && !e[0].disabled ? e[0].attributes && !ar(e[0].attributes.value) ? ar(e[0].value) || e[0].value === "" ? bj : {
            value: e[0].value,
            isValid: !0
        } : bj : yj
    }
    return yj
}
  , G6 = (e, {valueAsNumber: t, valueAsDate: n, setValueAs: r}) => ar(e) ? e : t ? e === "" ? NaN : e && +e : n && qo(e) ? new Date(e) : r ? r(e) : e;
const xj = {
    isValid: !1,
    value: null
};
var Y6 = e => Array.isArray(e) ? e.reduce( (t, n) => n && n.checked && !n.disabled ? {
    isValid: !0,
    value: n.value
} : t, xj) : xj;
function vj(e) {
    const t = e.ref;
    return EA(t) ? t.files : AA(t) ? Y6(e.refs).value : H6(t) ? [...t.selectedOptions].map( ({value: n}) => n) : Qg(t) ? W6(e.refs).value : G6(ar(t.value) ? e.ref.value : t.value, e)
}
var Xye = (e, t, n, r) => {
    const i = {};
    for (const o of e) {
        const a = dt(t, o);
        a && zn(i, o, a._f)
    }
    return {
        criteriaMode: n,
        names: [...e],
        fields: i,
        shouldUseNativeValidation: r
    }
}
  , I0 = e => e instanceof RegExp
  , Ap = e => ar(e) ? e : I0(e) ? e.source : Xr(e) ? I0(e.value) ? e.value.source : e.value : e
  , hf = e => ({
    isOnSubmit: !e || e === ba.onSubmit,
    isOnBlur: e === ba.onBlur,
    isOnChange: e === ba.onChange,
    isOnAll: e === ba.all,
    isOnTouch: e === ba.onTouched
});
const Sj = "AsyncFunction";
var Jye = e => !!e && !!e.validate && !!(za(e.validate) && e.validate.constructor.name === Sj || Xr(e.validate) && Object.values(e.validate).find(t => t.constructor.name === Sj))
  , ebe = e => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate)
  , RT = (e, t, n) => !n && (t.watchAll || t.watch.has(e) || [...t.watch].some(r => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length))));
const wf = (e, t, n, r) => {
    for (const i of n || Object.keys(e)) {
        const o = dt(e, i);
        if (o) {
            const {_f: a, ...s} = o;
            if (a) {
                if (a.refs && a.refs[0] && t(a.refs[0], i) && !r)
                    return !0;
                if (a.ref && t(a.ref, a.name) && !r)
                    return !0;
                if (wf(s, t))
                    break
            } else if (Xr(s) && wf(s, t))
                break
        }
    }
}
;
function Cj(e, t, n) {
    const r = dt(e, n);
    if (r || w1(n))
        return {
            error: r,
            name: n
        };
    const i = n.split(".");
    for (; i.length; ) {
        const o = i.join(".")
          , a = dt(t, o)
          , s = dt(e, o);
        if (a && !Array.isArray(a) && n !== o)
            return {
                name: n
            };
        if (s && s.type)
            return {
                name: o,
                error: s
            };
        if (s && s.root && s.root.type)
            return {
                name: `${o}.root`,
                error: s.root
            };
        i.pop()
    }
    return {
        name: n
    }
}
var tbe = (e, t, n, r) => {
    n(e);
    const {name: i, ...o} = e;
    return ji(o) || Object.keys(o).length >= Object.keys(t).length || Object.keys(o).find(a => t[a] === (!r || ba.all))
}
  , nbe = (e, t, n) => !e || !t || e === t || po(e).some(r => r && (n ? r === t : r.startsWith(t) || t.startsWith(r)))
  , rbe = (e, t, n, r, i) => i.isOnAll ? !1 : !n && i.isOnTouch ? !(t || e) : (n ? r.isOnBlur : i.isOnBlur) ? !e : (n ? r.isOnChange : i.isOnChange) ? e : !0
  , ibe = (e, t) => !k1(dt(e, t)).length && jr(e, t)
  , Z6 = (e, t, n) => {
    const r = po(dt(e, n));
    return zn(r, "root", t[n]),
    zn(e, n, r),
    e
}
;
function wj(e, t, n="validate") {
    if (qo(e) || Array.isArray(e) && e.every(qo) || Uo(e) && !e)
        return {
            type: n,
            message: qo(e) ? e : "",
            ref: t
        }
}
var Kd = e => Xr(e) && !I0(e) ? e : {
    value: e,
    message: ""
}
  , DT = async (e, t, n, r, i, o) => {
    const {ref: a, refs: s, required: c, maxLength: u, minLength: f, min: h, max: m, pattern: y, validate: b, name: v, valueAsNumber: S, mount: C} = e._f
      , w = dt(n, v);
    if (!C || t.has(v))
        return {};
    const k = s ? s[0] : a
      , T = M => {
        i && k.reportValidity && (k.setCustomValidity(Uo(M) ? "" : M || ""),
        k.reportValidity())
    }
      , E = {}
      , P = AA(a)
      , D = Qg(a)
      , $ = P || D
      , z = (S || EA(a)) && ar(a.value) && ar(w) || O0(a) && a.value === "" || w === "" || Array.isArray(w) && !w.length
      , O = _A.bind(null, v, r, E)
      , I = (M, B, L, F=sl.maxLength, j=sl.minLength) => {
        const N = M ? B : L;
        E[v] = {
            type: M ? F : j,
            message: N,
            ref: a,
            ...O(M ? F : j, N)
        }
    }
    ;
    if (o ? !Array.isArray(w) || !w.length : c && (!$ && (z || lo(w)) || Uo(w) && !w || D && !W6(s).isValid || P && !Y6(s).isValid)) {
        const {value: M, message: B} = qo(c) ? {
            value: !!c,
            message: c
        } : Kd(c);
        if (M && (E[v] = {
            type: sl.required,
            message: B,
            ref: k,
            ...O(sl.required, B)
        },
        !r))
            return T(B),
            E
    }
    if (!z && (!lo(h) || !lo(m))) {
        let M, B;
        const L = Kd(m)
          , F = Kd(h);
        if (!lo(w) && !isNaN(w)) {
            const j = a.valueAsNumber || w && +w;
            lo(L.value) || (M = j > L.value),
            lo(F.value) || (B = j < F.value)
        } else {
            const j = a.valueAsDate || new Date(w)
              , N = q => new Date(new Date().toDateString() + " " + q)
              , H = a.type == "time"
              , Z = a.type == "week";
            qo(L.value) && w && (M = H ? N(w) > N(L.value) : Z ? w > L.value : j > new Date(L.value)),
            qo(F.value) && w && (B = H ? N(w) < N(F.value) : Z ? w < F.value : j < new Date(F.value))
        }
        if ((M || B) && (I(!!M, L.message, F.message, sl.max, sl.min),
        !r))
            return T(E[v].message),
            E
    }
    if ((u || f) && !z && (qo(w) || o && Array.isArray(w))) {
        const M = Kd(u)
          , B = Kd(f)
          , L = !lo(M.value) && w.length > +M.value
          , F = !lo(B.value) && w.length < +B.value;
        if ((L || F) && (I(L, M.message, B.message),
        !r))
            return T(E[v].message),
            E
    }
    if (y && !z && qo(w)) {
        const {value: M, message: B} = Kd(y);
        if (I0(M) && !w.match(M) && (E[v] = {
            type: sl.pattern,
            message: B,
            ref: a,
            ...O(sl.pattern, B)
        },
        !r))
            return T(B),
            E
    }
    if (b) {
        if (za(b)) {
            const M = await b(w, n)
              , B = wj(M, k);
            if (B && (E[v] = {
                ...B,
                ...O(sl.validate, B.message)
            },
            !r))
                return T(B.message),
                E
        } else if (Xr(b)) {
            let M = {};
            for (const B in b) {
                if (!ji(M) && !r)
                    break;
                const L = wj(await b[B](w, n), k, B);
                L && (M = {
                    ...L,
                    ...O(B, L.message)
                },
                T(L.message),
                r && (E[v] = M))
            }
            if (!ji(M) && (E[v] = {
                ref: k,
                ...M
            },
            !r))
                return E
        }
    }
    return T(!0),
    E
}
;
const obe = {
    mode: ba.onSubmit,
    reValidateMode: ba.onChange,
    shouldFocusError: !0
};
function abe(e={}) {
    let t = {
        ...obe,
        ...e
    }, n = {
        submitCount: 0,
        isDirty: !1,
        isReady: !1,
        isLoading: za(t.defaultValues),
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: t.errors || {},
        disabled: t.disabled || !1
    }, r = {}, i = Xr(t.defaultValues) || Xr(t.values) ? ur(t.defaultValues || t.values) || {} : {}, o = t.shouldUnregister ? {} : ur(i), a = {
        action: !1,
        mount: !1,
        watch: !1
    }, s = {
        mount: new Set,
        disabled: new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set
    }, c, u = 0;
    const f = {
        isDirty: !1,
        dirtyFields: !1,
        validatingFields: !1,
        touchedFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    };
    let h = {
        ...f
    };
    const m = {
        array: gj(),
        state: gj()
    }
      , y = t.criteriaMode === ba.all
      , b = X => ce => {
        clearTimeout(u),
        u = setTimeout(X, ce)
    }
      , v = async X => {
        if (!t.disabled && (f.isValid || h.isValid || X)) {
            const ce = t.resolver ? ji((await D()).errors) : await z(r, !0);
            ce !== n.isValid && m.state.next({
                isValid: ce
            })
        }
    }
      , S = (X, ce) => {
        !t.disabled && (f.isValidating || f.validatingFields || h.isValidating || h.validatingFields) && ((X || Array.from(s.mount)).forEach(fe => {
            fe && (ce ? zn(n.validatingFields, fe, ce) : jr(n.validatingFields, fe))
        }
        ),
        m.state.next({
            validatingFields: n.validatingFields,
            isValidating: !ji(n.validatingFields)
        }))
    }
      , C = (X, ce=[], fe, Xe, Oe=!0, Re=!0) => {
        if (Xe && fe && !t.disabled) {
            if (a.action = !0,
            Re && Array.isArray(dt(r, X))) {
                const le = fe(dt(r, X), Xe.argA, Xe.argB);
                Oe && zn(r, X, le)
            }
            if (Re && Array.isArray(dt(n.errors, X))) {
                const le = fe(dt(n.errors, X), Xe.argA, Xe.argB);
                Oe && zn(n.errors, X, le),
                ibe(n.errors, X)
            }
            if ((f.touchedFields || h.touchedFields) && Re && Array.isArray(dt(n.touchedFields, X))) {
                const le = fe(dt(n.touchedFields, X), Xe.argA, Xe.argB);
                Oe && zn(n.touchedFields, X, le)
            }
            (f.dirtyFields || h.dirtyFields) && (n.dirtyFields = lf(i, o)),
            m.state.next({
                name: X,
                isDirty: I(X, ce),
                dirtyFields: n.dirtyFields,
                errors: n.errors,
                isValid: n.isValid
            })
        } else
            zn(o, X, ce)
    }
      , w = (X, ce) => {
        zn(n.errors, X, ce),
        m.state.next({
            errors: n.errors
        })
    }
      , k = X => {
        n.errors = X,
        m.state.next({
            errors: n.errors,
            isValid: !1
        })
    }
      , T = (X, ce, fe, Xe) => {
        const Oe = dt(r, X);
        if (Oe) {
            const Re = dt(o, X, ar(fe) ? dt(i, X) : fe);
            ar(Re) || Xe && Xe.defaultChecked || ce ? zn(o, X, ce ? Re : vj(Oe._f)) : L(X, Re),
            a.mount && v()
        }
    }
      , E = (X, ce, fe, Xe, Oe) => {
        let Re = !1
          , le = !1;
        const ke = {
            name: X
        };
        if (!t.disabled) {
            if (!fe || Xe) {
                (f.isDirty || h.isDirty) && (le = n.isDirty,
                n.isDirty = ke.isDirty = I(),
                Re = le !== ke.isDirty);
                const He = ml(dt(i, X), ce);
                le = !!dt(n.dirtyFields, X),
                He ? jr(n.dirtyFields, X) : zn(n.dirtyFields, X, !0),
                ke.dirtyFields = n.dirtyFields,
                Re = Re || (f.dirtyFields || h.dirtyFields) && le !== !He
            }
            if (fe) {
                const He = dt(n.touchedFields, X);
                He || (zn(n.touchedFields, X, fe),
                ke.touchedFields = n.touchedFields,
                Re = Re || (f.touchedFields || h.touchedFields) && He !== fe)
            }
            Re && Oe && m.state.next(ke)
        }
        return Re ? ke : {}
    }
      , P = (X, ce, fe, Xe) => {
        const Oe = dt(n.errors, X)
          , Re = (f.isValid || h.isValid) && Uo(ce) && n.isValid !== ce;
        if (t.delayError && fe ? (c = b( () => w(X, fe)),
        c(t.delayError)) : (clearTimeout(u),
        c = null,
        fe ? zn(n.errors, X, fe) : jr(n.errors, X)),
        (fe ? !ml(Oe, fe) : Oe) || !ji(Xe) || Re) {
            const le = {
                ...Xe,
                ...Re && Uo(ce) ? {
                    isValid: ce
                } : {},
                errors: n.errors,
                name: X
            };
            n = {
                ...n,
                ...le
            },
            m.state.next(le)
        }
    }
      , D = async X => {
        S(X, !0);
        const ce = await t.resolver(o, t.context, Xye(X || s.mount, r, t.criteriaMode, t.shouldUseNativeValidation));
        return S(X),
        ce
    }
      , $ = async X => {
        const {errors: ce} = await D(X);
        if (X)
            for (const fe of X) {
                const Xe = dt(ce, fe);
                Xe ? zn(n.errors, fe, Xe) : jr(n.errors, fe)
            }
        else
            n.errors = ce;
        return ce
    }
      , z = async (X, ce, fe={
        valid: !0
    }) => {
        for (const Xe in X) {
            const Oe = X[Xe];
            if (Oe) {
                const {_f: Re, ...le} = Oe;
                if (Re) {
                    const ke = s.array.has(Re.name)
                      , He = Oe._f && Jye(Oe._f);
                    He && f.validatingFields && S([Re.name], !0);
                    const st = await DT(Oe, s.disabled, o, y, t.shouldUseNativeValidation && !ce, ke);
                    if (He && f.validatingFields && S([Re.name]),
                    st[Re.name] && (fe.valid = !1,
                    ce))
                        break;
                    !ce && (dt(st, Re.name) ? ke ? Z6(n.errors, st, Re.name) : zn(n.errors, Re.name, st[Re.name]) : jr(n.errors, Re.name))
                }
                !ji(le) && await z(le, ce, fe)
            }
        }
        return fe.valid
    }
      , O = () => {
        for (const X of s.unMount) {
            const ce = dt(r, X);
            ce && (ce._f.refs ? ce._f.refs.every(fe => !xk(fe)) : !xk(ce._f.ref)) && re(X)
        }
        s.unMount = new Set
    }
      , I = (X, ce) => !t.disabled && (X && ce && zn(o, X, ce),
    !ml(q(), i))
      , M = (X, ce, fe) => U6(X, s, {
        ...a.mount ? o : ar(ce) ? i : qo(X) ? {
            [X]: ce
        } : ce
    }, fe, ce)
      , B = X => k1(dt(a.mount ? o : i, X, t.shouldUnregister ? dt(i, X, []) : []))
      , L = (X, ce, fe={}) => {
        const Xe = dt(r, X);
        let Oe = ce;
        if (Xe) {
            const Re = Xe._f;
            Re && (!Re.disabled && zn(o, X, G6(ce, Re)),
            Oe = O0(Re.ref) && lo(ce) ? "" : ce,
            H6(Re.ref) ? [...Re.ref.options].forEach(le => le.selected = Oe.includes(le.value)) : Re.refs ? Qg(Re.ref) ? Re.refs.forEach(le => {
                (!le.defaultChecked || !le.disabled) && (Array.isArray(Oe) ? le.checked = !!Oe.find(ke => ke === le.value) : le.checked = Oe === le.value || !!Oe)
            }
            ) : Re.refs.forEach(le => le.checked = le.value === Oe) : EA(Re.ref) ? Re.ref.value = "" : (Re.ref.value = Oe,
            Re.ref.type || m.state.next({
                name: X,
                values: ur(o)
            })))
        }
        (fe.shouldDirty || fe.shouldTouch) && E(X, Oe, fe.shouldTouch, fe.shouldDirty, !0),
        fe.shouldValidate && Z(X)
    }
      , F = (X, ce, fe) => {
        for (const Xe in ce) {
            if (!ce.hasOwnProperty(Xe))
                return;
            const Oe = ce[Xe]
              , Re = X + "." + Xe
              , le = dt(r, Re);
            (s.array.has(X) || Xr(Oe) || le && !le._f) && !wu(Oe) ? F(Re, Oe, fe) : L(Re, Oe, fe)
        }
    }
      , j = (X, ce, fe={}) => {
        const Xe = dt(r, X)
          , Oe = s.array.has(X)
          , Re = ur(ce);
        zn(o, X, Re),
        Oe ? (m.array.next({
            name: X,
            values: ur(o)
        }),
        (f.isDirty || f.dirtyFields || h.isDirty || h.dirtyFields) && fe.shouldDirty && m.state.next({
            name: X,
            dirtyFields: lf(i, o),
            isDirty: I(X, Re)
        })) : Xe && !Xe._f && !lo(Re) ? F(X, Re, fe) : L(X, Re, fe),
        RT(X, s) && m.state.next({
            ...n,
            name: X
        }),
        m.state.next({
            name: a.mount ? X : void 0,
            values: ur(o)
        })
    }
      , N = async X => {
        a.mount = !0;
        const ce = X.target;
        let fe = ce.name
          , Xe = !0;
        const Oe = dt(r, fe)
          , Re = He => {
            Xe = Number.isNaN(He) || wu(He) && isNaN(He.getTime()) || ml(He, dt(o, fe, He))
        }
          , le = hf(t.mode)
          , ke = hf(t.reValidateMode);
        if (Oe) {
            let He, st;
            const lt = ce.type ? vj(Oe._f) : z6(X)
              , et = X.type === D0.BLUR || X.type === D0.FOCUS_OUT
              , Ht = !ebe(Oe._f) && !t.resolver && !dt(n.errors, fe) && !Oe._f.deps || rbe(et, dt(n.touchedFields, fe), n.isSubmitted, ke, le)
              , Ft = RT(fe, s, et);
            zn(o, fe, lt),
            et ? (!ce || !ce.readOnly) && (Oe._f.onBlur && Oe._f.onBlur(X),
            c && c(0)) : Oe._f.onChange && Oe._f.onChange(X);
            const Pt = E(fe, lt, et)
              , nt = !ji(Pt) || Ft;
            if (!et && m.state.next({
                name: fe,
                type: X.type,
                values: ur(o)
            }),
            Ht)
                return (f.isValid || h.isValid) && (t.mode === "onBlur" ? et && v() : et || v()),
                nt && m.state.next({
                    name: fe,
                    ...Ft ? {} : Pt
                });
            if (!et && Ft && m.state.next({
                ...n
            }),
            t.resolver) {
                const {errors: ut} = await D([fe]);
                if (Re(lt),
                Xe) {
                    const Lt = Cj(n.errors, r, fe)
                      , tn = Cj(ut, r, Lt.name || fe);
                    He = tn.error,
                    fe = tn.name,
                    st = ji(ut)
                }
            } else
                S([fe], !0),
                He = (await DT(Oe, s.disabled, o, y, t.shouldUseNativeValidation))[fe],
                S([fe]),
                Re(lt),
                Xe && (He ? st = !1 : (f.isValid || h.isValid) && (st = await z(r, !0)));
            Xe && (Oe._f.deps && (!Array.isArray(Oe._f.deps) || Oe._f.deps.length > 0) && Z(Oe._f.deps),
            P(fe, st, He, Pt))
        }
    }
      , H = (X, ce) => {
        if (dt(n.errors, ce) && X.focus)
            return X.focus(),
            1
    }
      , Z = async (X, ce={}) => {
        let fe, Xe;
        const Oe = po(X);
        if (t.resolver) {
            const Re = await $(ar(X) ? X : Oe);
            fe = ji(Re),
            Xe = X ? !Oe.some(le => dt(Re, le)) : fe
        } else
            X ? (Xe = (await Promise.all(Oe.map(async Re => {
                const le = dt(r, Re);
                return await z(le && le._f ? {
                    [Re]: le
                } : le)
            }
            ))).every(Boolean),
            !(!Xe && !n.isValid) && v()) : Xe = fe = await z(r);
        return m.state.next({
            ...!qo(X) || (f.isValid || h.isValid) && fe !== n.isValid ? {} : {
                name: X
            },
            ...t.resolver || !X ? {
                isValid: fe
            } : {},
            errors: n.errors
        }),
        ce.shouldFocus && !Xe && wf(r, H, X ? Oe : s.mount),
        Xe
    }
      , q = (X, ce) => {
        let fe = {
            ...a.mount ? o : i
        };
        return ce && (fe = V6(ce.dirtyFields ? n.dirtyFields : n.touchedFields, fe)),
        ar(X) ? fe : qo(X) ? dt(fe, X) : X.map(Xe => dt(fe, Xe))
    }
      , V = (X, ce) => ({
        invalid: !!dt((ce || n).errors, X),
        isDirty: !!dt((ce || n).dirtyFields, X),
        error: dt((ce || n).errors, X),
        isValidating: !!dt(n.validatingFields, X),
        isTouched: !!dt((ce || n).touchedFields, X)
    })
      , Y = X => {
        X && po(X).forEach(ce => jr(n.errors, ce)),
        m.state.next({
            errors: X ? n.errors : {}
        })
    }
      , W = (X, ce, fe) => {
        const Xe = (dt(r, X, {
            _f: {}
        })._f || {}).ref
          , Oe = dt(n.errors, X) || {}
          , {ref: Re, message: le, type: ke, ...He} = Oe;
        zn(n.errors, X, {
            ...He,
            ...ce,
            ref: Xe
        }),
        m.state.next({
            name: X,
            errors: n.errors,
            isValid: !1
        }),
        fe && fe.shouldFocus && Xe && Xe.focus && Xe.focus()
    }
      , te = (X, ce) => za(X) ? m.state.subscribe({
        next: fe => "values"in fe && X(M(void 0, ce), fe)
    }) : M(X, ce, !0)
      , K = X => m.state.subscribe({
        next: ce => {
            nbe(X.name, ce.name, X.exact) && tbe(ce, X.formState || f, Ye, X.reRenderRoot) && X.callback({
                values: {
                    ...o
                },
                ...n,
                ...ce,
                defaultValues: i
            })
        }
    }).unsubscribe
      , ee = X => (a.mount = !0,
    h = {
        ...h,
        ...X.formState
    },
    K({
        ...X,
        formState: h
    }))
      , re = (X, ce={}) => {
        for (const fe of X ? po(X) : s.mount)
            s.mount.delete(fe),
            s.array.delete(fe),
            ce.keepValue || (jr(r, fe),
            jr(o, fe)),
            !ce.keepError && jr(n.errors, fe),
            !ce.keepDirty && jr(n.dirtyFields, fe),
            !ce.keepTouched && jr(n.touchedFields, fe),
            !ce.keepIsValidating && jr(n.validatingFields, fe),
            !t.shouldUnregister && !ce.keepDefaultValue && jr(i, fe);
        m.state.next({
            values: ur(o)
        }),
        m.state.next({
            ...n,
            ...ce.keepDirty ? {
                isDirty: I()
            } : {}
        }),
        !ce.keepIsValid && v()
    }
      , ie = ({disabled: X, name: ce}) => {
        (Uo(X) && a.mount || X || s.disabled.has(ce)) && (X ? s.disabled.add(ce) : s.disabled.delete(ce))
    }
      , J = (X, ce={}) => {
        let fe = dt(r, X);
        const Xe = Uo(ce.disabled) || Uo(t.disabled);
        return zn(r, X, {
            ...fe || {},
            _f: {
                ...fe && fe._f ? fe._f : {
                    ref: {
                        name: X
                    }
                },
                name: X,
                mount: !0,
                ...ce
            }
        }),
        s.mount.add(X),
        fe ? ie({
            disabled: Uo(ce.disabled) ? ce.disabled : t.disabled,
            name: X
        }) : T(X, !0, ce.value),
        {
            ...Xe ? {
                disabled: ce.disabled || t.disabled
            } : {},
            ...t.progressive ? {
                required: !!ce.required,
                min: Ap(ce.min),
                max: Ap(ce.max),
                minLength: Ap(ce.minLength),
                maxLength: Ap(ce.maxLength),
                pattern: Ap(ce.pattern)
            } : {},
            name: X,
            onChange: N,
            onBlur: N,
            ref: Oe => {
                if (Oe) {
                    J(X, ce),
                    fe = dt(r, X);
                    const Re = ar(Oe.value) && Oe.querySelectorAll && Oe.querySelectorAll("input,select,textarea")[0] || Oe
                      , le = Yye(Re)
                      , ke = fe._f.refs || [];
                    if (le ? ke.find(He => He === Re) : Re === fe._f.ref)
                        return;
                    zn(r, X, {
                        _f: {
                            ...fe._f,
                            ...le ? {
                                refs: [...ke.filter(xk), Re, ...Array.isArray(dt(i, X)) ? [{}] : []],
                                ref: {
                                    type: Re.type,
                                    name: X
                                }
                            } : {
                                ref: Re
                            }
                        }
                    }),
                    T(X, !1, void 0, Re)
                } else
                    fe = dt(r, X, {}),
                    fe._f && (fe._f.mount = !1),
                    (t.shouldUnregister || ce.shouldUnregister) && !(F6(s.array, X) && a.action) && s.unMount.add(X)
            }
        }
    }
      , oe = () => t.shouldFocusError && wf(r, H, s.mount)
      , we = X => {
        Uo(X) && (m.state.next({
            disabled: X
        }),
        wf(r, (ce, fe) => {
            const Xe = dt(r, fe);
            Xe && (ce.disabled = Xe._f.disabled || X,
            Array.isArray(Xe._f.refs) && Xe._f.refs.forEach(Oe => {
                Oe.disabled = Xe._f.disabled || X
            }
            ))
        }
        , 0, !1))
    }
      , xe = (X, ce) => async fe => {
        let Xe;
        fe && (fe.preventDefault && fe.preventDefault(),
        fe.persist && fe.persist());
        let Oe = ur(o);
        if (m.state.next({
            isSubmitting: !0
        }),
        t.resolver) {
            const {errors: Re, values: le} = await D();
            n.errors = Re,
            Oe = ur(le)
        } else
            await z(r);
        if (s.disabled.size)
            for (const Re of s.disabled)
                jr(Oe, Re);
        if (jr(n.errors, "root"),
        ji(n.errors)) {
            m.state.next({
                errors: {}
            });
            try {
                await X(Oe, fe)
            } catch (Re) {
                Xe = Re
            }
        } else
            ce && await ce({
                ...n.errors
            }, fe),
            oe(),
            setTimeout(oe);
        if (m.state.next({
            isSubmitted: !0,
            isSubmitting: !1,
            isSubmitSuccessful: ji(n.errors) && !Xe,
            submitCount: n.submitCount + 1,
            errors: n.errors
        }),
        Xe)
            throw Xe
    }
      , se = (X, ce={}) => {
        dt(r, X) && (ar(ce.defaultValue) ? j(X, ur(dt(i, X))) : (j(X, ce.defaultValue),
        zn(i, X, ur(ce.defaultValue))),
        ce.keepTouched || jr(n.touchedFields, X),
        ce.keepDirty || (jr(n.dirtyFields, X),
        n.isDirty = ce.defaultValue ? I(X, ur(dt(i, X))) : I()),
        ce.keepError || (jr(n.errors, X),
        f.isValid && v()),
        m.state.next({
            ...n
        }))
    }
      , de = (X, ce={}) => {
        const fe = X ? ur(X) : i
          , Xe = ur(fe)
          , Oe = ji(X)
          , Re = Oe ? i : Xe;
        if (ce.keepDefaultValues || (i = fe),
        !ce.keepValues) {
            if (ce.keepDirtyValues) {
                const le = new Set([...s.mount, ...Object.keys(lf(i, o))]);
                for (const ke of Array.from(le))
                    dt(n.dirtyFields, ke) ? zn(Re, ke, dt(o, ke)) : j(ke, dt(Re, ke))
            } else {
                if (CA && ar(X))
                    for (const le of s.mount) {
                        const ke = dt(r, le);
                        if (ke && ke._f) {
                            const He = Array.isArray(ke._f.refs) ? ke._f.refs[0] : ke._f.ref;
                            if (O0(He)) {
                                const st = He.closest("form");
                                if (st) {
                                    st.reset();
                                    break
                                }
                            }
                        }
                    }
                if (ce.keepFieldsRef)
                    for (const le of s.mount)
                        j(le, dt(Re, le));
                else
                    r = {}
            }
            o = t.shouldUnregister ? ce.keepDefaultValues ? ur(i) : {} : ur(Re),
            m.array.next({
                values: {
                    ...Re
                }
            }),
            m.state.next({
                values: {
                    ...Re
                }
            })
        }
        s = {
            mount: ce.keepDirtyValues ? s.mount : new Set,
            unMount: new Set,
            array: new Set,
            disabled: new Set,
            watch: new Set,
            watchAll: !1,
            focus: ""
        },
        a.mount = !f.isValid || !!ce.keepIsValid || !!ce.keepDirtyValues,
        a.watch = !!t.shouldUnregister,
        m.state.next({
            submitCount: ce.keepSubmitCount ? n.submitCount : 0,
            isDirty: Oe ? !1 : ce.keepDirty ? n.isDirty : !!(ce.keepDefaultValues && !ml(X, i)),
            isSubmitted: ce.keepIsSubmitted ? n.isSubmitted : !1,
            dirtyFields: Oe ? {} : ce.keepDirtyValues ? ce.keepDefaultValues && o ? lf(i, o) : n.dirtyFields : ce.keepDefaultValues && X ? lf(i, X) : ce.keepDirty ? n.dirtyFields : {},
            touchedFields: ce.keepTouched ? n.touchedFields : {},
            errors: ce.keepErrors ? n.errors : {},
            isSubmitSuccessful: ce.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1,
            isSubmitting: !1,
            defaultValues: i
        })
    }
      , Se = (X, ce) => de(za(X) ? X(o) : X, ce)
      , Ce = (X, ce={}) => {
        const fe = dt(r, X)
          , Xe = fe && fe._f;
        if (Xe) {
            const Oe = Xe.refs ? Xe.refs[0] : Xe.ref;
            Oe.focus && (Oe.focus(),
            ce.shouldSelect && za(Oe.select) && Oe.select())
        }
    }
      , Ye = X => {
        n = {
            ...n,
            ...X
        }
    }
      , Ke = {
        control: {
            register: J,
            unregister: re,
            getFieldState: V,
            handleSubmit: xe,
            setError: W,
            _subscribe: K,
            _runSchema: D,
            _focusError: oe,
            _getWatch: M,
            _getDirty: I,
            _setValid: v,
            _setFieldArray: C,
            _setDisabledField: ie,
            _setErrors: k,
            _getFieldArray: B,
            _reset: de,
            _resetDefaultValues: () => za(t.defaultValues) && t.defaultValues().then(X => {
                Se(X, t.resetOptions),
                m.state.next({
                    isLoading: !1
                })
            }
            ),
            _removeUnmounted: O,
            _disableForm: we,
            _subjects: m,
            _proxyFormState: f,
            get _fields() {
                return r
            },
            get _formValues() {
                return o
            },
            get _state() {
                return a
            },
            set _state(X) {
                a = X
            },
            get _defaultValues() {
                return i
            },
            get _names() {
                return s
            },
            set _names(X) {
                s = X
            },
            get _formState() {
                return n
            },
            get _options() {
                return t
            },
            set _options(X) {
                t = {
                    ...t,
                    ...X
                }
            }
        },
        subscribe: ee,
        trigger: Z,
        register: J,
        handleSubmit: xe,
        watch: te,
        setValue: j,
        getValues: q,
        reset: Se,
        resetField: se,
        clearErrors: Y,
        unregister: re,
        setError: W,
        setFocus: Ce,
        getFieldState: V
    };
    return {
        ...Ke,
        formControl: Ke
    }
}
var nc = () => {
    if (typeof crypto < "u" && crypto.randomUUID)
        return crypto.randomUUID();
    const e = typeof performance > "u" ? Date.now() : performance.now() * 1e3;
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
        const n = (Math.random() * 16 + e) % 16 | 0;
        return (t == "x" ? n : n & 3 | 8).toString(16)
    }
    )
}
  , vk = (e, t, n={}) => n.shouldFocus || ar(n.shouldFocus) ? n.focusName || `${e}.${ar(n.focusIndex) ? t : n.focusIndex}.` : ""
  , Sk = (e, t) => [...e, ...po(t)]
  , Ck = e => Array.isArray(e) ? e.map( () => {}
) : void 0;
function wk(e, t, n) {
    return [...e.slice(0, t), ...po(n), ...e.slice(t)]
}
var kk = (e, t, n) => Array.isArray(e) ? (ar(e[n]) && (e[n] = void 0),
e.splice(n, 0, e.splice(t, 1)[0]),
e) : []
  , Tk = (e, t) => [...po(t), ...po(e)];
function sbe(e, t) {
    let n = 0;
    const r = [...e];
    for (const i of t)
        r.splice(i - n, 1),
        n++;
    return k1(r).length ? r : []
}
var _k = (e, t) => ar(t) ? [] : sbe(e, po(t).sort( (n, r) => n - r))
  , Ek = (e, t, n) => {
    [e[t],e[n]] = [e[n], e[t]]
}
  , kj = (e, t, n) => (e[t] = n,
e);
function Q6(e) {
    const t = yh()
      , {control: n=t.control, name: r, keyName: i="id", shouldUnregister: o, rules: a} = e
      , [s,c] = bt.useState(n._getFieldArray(r))
      , u = bt.useRef(n._getFieldArray(r).map(nc))
      , f = bt.useRef(!1);
    n._names.array.add(r),
    bt.useMemo( () => a && s.length >= 0 && n.register(r, a), [n, r, s.length, a]),
    T1( () => n._subjects.array.subscribe({
        next: ({values: T, name: E}) => {
            if (E === r || !E) {
                const P = dt(T, r);
                Array.isArray(P) && (c(P),
                u.current = P.map(nc))
            }
        }
    }).unsubscribe, [n, r]);
    const h = bt.useCallback(T => {
        f.current = !0,
        n._setFieldArray(r, T)
    }
    , [n, r])
      , m = (T, E) => {
        const P = po(ur(T))
          , D = Sk(n._getFieldArray(r), P);
        n._names.focus = vk(r, D.length - 1, E),
        u.current = Sk(u.current, P.map(nc)),
        h(D),
        c(D),
        n._setFieldArray(r, D, Sk, {
            argA: Ck(T)
        })
    }
      , y = (T, E) => {
        const P = po(ur(T))
          , D = Tk(n._getFieldArray(r), P);
        n._names.focus = vk(r, 0, E),
        u.current = Tk(u.current, P.map(nc)),
        h(D),
        c(D),
        n._setFieldArray(r, D, Tk, {
            argA: Ck(T)
        })
    }
      , b = T => {
        const E = _k(n._getFieldArray(r), T);
        u.current = _k(u.current, T),
        h(E),
        c(E),
        !Array.isArray(dt(n._fields, r)) && zn(n._fields, r, void 0),
        n._setFieldArray(r, E, _k, {
            argA: T
        })
    }
      , v = (T, E, P) => {
        const D = po(ur(E))
          , $ = wk(n._getFieldArray(r), T, D);
        n._names.focus = vk(r, T, P),
        u.current = wk(u.current, T, D.map(nc)),
        h($),
        c($),
        n._setFieldArray(r, $, wk, {
            argA: T,
            argB: Ck(E)
        })
    }
      , S = (T, E) => {
        const P = n._getFieldArray(r);
        Ek(P, T, E),
        Ek(u.current, T, E),
        h(P),
        c(P),
        n._setFieldArray(r, P, Ek, {
            argA: T,
            argB: E
        }, !1)
    }
      , C = (T, E) => {
        const P = n._getFieldArray(r);
        kk(P, T, E),
        kk(u.current, T, E),
        h(P),
        c(P),
        n._setFieldArray(r, P, kk, {
            argA: T,
            argB: E
        }, !1)
    }
      , w = (T, E) => {
        const P = ur(E)
          , D = kj(n._getFieldArray(r), T, P);
        u.current = [...D].map( ($, z) => !$ || z === T ? nc() : u.current[z]),
        h(D),
        c([...D]),
        n._setFieldArray(r, D, kj, {
            argA: T,
            argB: P
        }, !0, !1)
    }
      , k = T => {
        const E = po(ur(T));
        u.current = E.map(nc),
        h([...E]),
        c([...E]),
        n._setFieldArray(r, [...E], P => P, {}, !0, !1)
    }
    ;
    return bt.useEffect( () => {
        if (n._state.action = !1,
        RT(r, n._names) && n._subjects.state.next({
            ...n._formState
        }),
        f.current && (!hf(n._options.mode).isOnSubmit || n._formState.isSubmitted) && !hf(n._options.reValidateMode).isOnSubmit)
            if (n._options.resolver)
                n._runSchema([r]).then(T => {
                    const E = dt(T.errors, r)
                      , P = dt(n._formState.errors, r);
                    (P ? !E && P.type || E && (P.type !== E.type || P.message !== E.message) : E && E.type) && (E ? zn(n._formState.errors, r, E) : jr(n._formState.errors, r),
                    n._subjects.state.next({
                        errors: n._formState.errors
                    }))
                }
                );
            else {
                const T = dt(n._fields, r);
                T && T._f && !(hf(n._options.reValidateMode).isOnSubmit && hf(n._options.mode).isOnSubmit) && DT(T, n._names.disabled, n._formValues, n._options.criteriaMode === ba.all, n._options.shouldUseNativeValidation, !0).then(E => !ji(E) && n._subjects.state.next({
                    errors: Z6(n._formState.errors, E, r)
                }))
            }
        n._subjects.state.next({
            name: r,
            values: ur(n._formValues)
        }),
        n._names.focus && wf(n._fields, (T, E) => {
            if (n._names.focus && E.startsWith(n._names.focus) && T.focus)
                return T.focus(),
                1
        }
        ),
        n._names.focus = "",
        n._setValid(),
        f.current = !1
    }
    , [s, r, n]),
    bt.useEffect( () => (!dt(n._formValues, r) && n._setFieldArray(r),
    () => {
        const T = (E, P) => {
            const D = dt(n._fields, E);
            D && D._f && (D._f.mount = P)
        }
        ;
        n._options.shouldUnregister || o ? n.unregister(r) : T(r, !1)
    }
    ), [r, n, i, o]),
    {
        swap: bt.useCallback(S, [h, r, n]),
        move: bt.useCallback(C, [h, r, n]),
        prepend: bt.useCallback(y, [h, r, n]),
        append: bt.useCallback(m, [h, r, n]),
        remove: bt.useCallback(b, [h, r, n]),
        insert: bt.useCallback(v, [h, r, n]),
        update: bt.useCallback(w, [h, r, n]),
        replace: bt.useCallback(k, [h, r, n]),
        fields: bt.useMemo( () => s.map( (T, E) => ({
            ...T,
            [i]: u.current[E] || nc()
        })), [s, i])
    }
}
function MA(e={}) {
    const t = bt.useRef(void 0)
      , n = bt.useRef(void 0)
      , [r,i] = bt.useState({
        isDirty: !1,
        isValidating: !1,
        isLoading: za(e.defaultValues),
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: e.errors || {},
        disabled: e.disabled || !1,
        isReady: !1,
        defaultValues: za(e.defaultValues) ? void 0 : e.defaultValues
    });
    if (!t.current)
        if (e.formControl)
            t.current = {
                ...e.formControl,
                formState: r
            },
            e.defaultValues && !za(e.defaultValues) && e.formControl.reset(e.defaultValues, e.resetOptions);
        else {
            const {formControl: a, ...s} = abe(e);
            t.current = {
                ...s,
                formState: r
            }
        }
    const o = t.current.control;
    return o._options = e,
    T1( () => {
        const a = o._subscribe({
            formState: o._proxyFormState,
            callback: () => i({
                ...o._formState
            }),
            reRenderRoot: !0
        });
        return i(s => ({
            ...s,
            isReady: !0
        })),
        o._formState.isReady = !0,
        a
    }
    , [o]),
    bt.useEffect( () => o._disableForm(e.disabled), [o, e.disabled]),
    bt.useEffect( () => {
        e.mode && (o._options.mode = e.mode),
        e.reValidateMode && (o._options.reValidateMode = e.reValidateMode)
    }
    , [o, e.mode, e.reValidateMode]),
    bt.useEffect( () => {
        e.errors && (o._setErrors(e.errors),
        o._focusError())
    }
    , [o, e.errors]),
    bt.useEffect( () => {
        e.shouldUnregister && o._subjects.state.next({
            values: o._getWatch()
        })
    }
    , [o, e.shouldUnregister]),
    bt.useEffect( () => {
        if (o._proxyFormState.isDirty) {
            const a = o._getDirty();
            a !== r.isDirty && o._subjects.state.next({
                isDirty: a
            })
        }
    }
    , [o, r.isDirty]),
    bt.useEffect( () => {
        e.values && !ml(e.values, n.current) ? (o._reset(e.values, {
            keepFieldsRef: !0,
            ...o._options.resetOptions
        }),
        n.current = e.values,
        i(a => ({
            ...a
        }))) : o._resetDefaultValues()
    }
    , [o, e.values]),
    bt.useEffect( () => {
        o._state.mount || (o._setValid(),
        o._state.mount = !0),
        o._state.watch && (o._state.watch = !1,
        o._subjects.state.next({
            ...o._formState
        })),
        o._removeUnmounted()
    }
    ),
    t.current.formState = N6(r, o),
    t.current
}
const Tj = (e, t, n) => {
    if (e && "reportValidity"in e) {
        const r = dt(n, t);
        e.setCustomValidity(r && r.message || ""),
        e.reportValidity()
    }
}
  , OT = (e, t) => {
    for (const n in t.fields) {
        const r = t.fields[n];
        r && r.ref && "reportValidity"in r.ref ? Tj(r.ref, n, e) : r && r.refs && r.refs.forEach(i => Tj(i, n, e))
    }
}
  , _j = (e, t) => {
    t.shouldUseNativeValidation && OT(e, t);
    const n = {};
    for (const r in e) {
        const i = dt(t.fields, r)
          , o = Object.assign(e[r] || {}, {
            ref: i && i.ref
        });
        if (lbe(t.names || Object.keys(e), r)) {
            const a = Object.assign({}, dt(n, r));
            zn(a, "root", o),
            zn(n, r, a)
        } else
            zn(n, r, o)
    }
    return n
}
  , lbe = (e, t) => {
    const n = Ej(t);
    return e.some(r => Ej(r).match(`^${n}\\.\\d+`))
}
;
function Ej(e) {
    return e.replace(/\]|\[/g, "")
}
function Ge(e, t, n) {
    function r(s, c) {
        var u;
        Object.defineProperty(s, "_zod", {
            value: s._zod ?? {},
            enumerable: !1
        }),
        (u = s._zod).traits ?? (u.traits = new Set),
        s._zod.traits.add(e),
        t(s, c);
        for (const f in a.prototype)
            f in s || Object.defineProperty(s, f, {
                value: a.prototype[f].bind(s)
            });
        s._zod.constr = a,
        s._zod.def = c
    }
    const i = n?.Parent ?? Object;
    class o extends i {
    }
    Object.defineProperty(o, "name", {
        value: e
    });
    function a(s) {
        var c;
        const u = n?.Parent ? new o : this;
        r(u, s),
        (c = u._zod).deferred ?? (c.deferred = []);
        for (const f of u._zod.deferred)
            f();
        return u
    }
    return Object.defineProperty(a, "init", {
        value: r
    }),
    Object.defineProperty(a, Symbol.hasInstance, {
        value: s => n?.Parent && s instanceof n.Parent ? !0 : s?._zod?.traits?.has(e)
    }),
    Object.defineProperty(a, "name", {
        value: e
    }),
    a
}
class kf extends Error {
    constructor() {
        super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")
    }
}
class K6 extends Error {
    constructor(t) {
        super(`Encountered unidirectional transform during encode: ${t}`),
        this.name = "ZodEncodeError"
    }
}
const X6 = {};
function qu(e) {
    return X6
}
function cbe(e) {
    const t = Object.values(e).filter(r => typeof r == "number");
    return Object.entries(e).filter( ([r,i]) => t.indexOf(+r) === -1).map( ([r,i]) => i)
}
function IT(e, t) {
    return typeof t == "bigint" ? t.toString() : t
}
function PA(e) {
    return {
        get value() {
            {
                const t = e();
                return Object.defineProperty(this, "value", {
                    value: t
                }),
                t
            }
        }
    }
}
function RA(e) {
    return e == null
}
function DA(e) {
    const t = e.startsWith("^") ? 1 : 0
      , n = e.endsWith("$") ? e.length - 1 : e.length;
    return e.slice(t, n)
}
function ube(e, t) {
    const n = (e.toString().split(".")[1] || "").length
      , r = t.toString();
    let i = (r.split(".")[1] || "").length;
    if (i === 0 && /\d?e-\d?/.test(r)) {
        const c = r.match(/\d?e-(\d?)/);
        c?.[1] && (i = Number.parseInt(c[1]))
    }
    const o = n > i ? n : i
      , a = Number.parseInt(e.toFixed(o).replace(".", ""))
      , s = Number.parseInt(t.toFixed(o).replace(".", ""));
    return a % s / 10 ** o
}
const Aj = Symbol("evaluating");
function sr(e, t, n) {
    let r;
    Object.defineProperty(e, t, {
        get() {
            if (r !== Aj)
                return r === void 0 && (r = Aj,
                r = n()),
                r
        },
        set(i) {
            Object.defineProperty(e, t, {
                value: i
            })
        },
        configurable: !0
    })
}
function rd(e, t, n) {
    Object.defineProperty(e, t, {
        value: n,
        writable: !0,
        enumerable: !0,
        configurable: !0
    })
}
function id(...e) {
    const t = {};
    for (const n of e) {
        const r = Object.getOwnPropertyDescriptors(n);
        Object.assign(t, r)
    }
    return Object.defineProperties({}, t)
}
function Mj(e) {
    return JSON.stringify(e)
}
const J6 = "captureStackTrace"in Error ? Error.captureStackTrace : (...e) => {}
;
function $0(e) {
    return typeof e == "object" && e !== null && !Array.isArray(e)
}
const dbe = PA( () => {
    if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
        return !1;
    try {
        const e = Function;
        return new e(""),
        !0
    } catch {
        return !1
    }
}
);
function tg(e) {
    if ($0(e) === !1)
        return !1;
    const t = e.constructor;
    if (t === void 0)
        return !0;
    const n = t.prototype;
    return !($0(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1)
}
function e9(e) {
    return tg(e) ? {
        ...e
    } : Array.isArray(e) ? [...e] : e
}
const fbe = new Set(["string", "number", "symbol"]);
function Qf(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}
function Oc(e, t, n) {
    const r = new e._zod.constr(t ?? e._zod.def);
    return (!t || n?.parent) && (r._zod.parent = e),
    r
}
function $t(e) {
    const t = e;
    if (!t)
        return {};
    if (typeof t == "string")
        return {
            error: () => t
        };
    if (t?.message !== void 0) {
        if (t?.error !== void 0)
            throw new Error("Cannot specify both `message` and `error` params");
        t.error = t.message
    }
    return delete t.message,
    typeof t.error == "string" ? {
        ...t,
        error: () => t.error
    } : t
}
function hbe(e) {
    return Object.keys(e).filter(t => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional")
}
const pbe = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 34028234663852886e22],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function mbe(e, t) {
    const n = e._zod.def
      , r = id(e._zod.def, {
        get shape() {
            const i = {};
            for (const o in t) {
                if (!(o in n.shape))
                    throw new Error(`Unrecognized key: "${o}"`);
                t[o] && (i[o] = n.shape[o])
            }
            return rd(this, "shape", i),
            i
        },
        checks: []
    });
    return Oc(e, r)
}
function gbe(e, t) {
    const n = e._zod.def
      , r = id(e._zod.def, {
        get shape() {
            const i = {
                ...e._zod.def.shape
            };
            for (const o in t) {
                if (!(o in n.shape))
                    throw new Error(`Unrecognized key: "${o}"`);
                t[o] && delete i[o]
            }
            return rd(this, "shape", i),
            i
        },
        checks: []
    });
    return Oc(e, r)
}
function ybe(e, t) {
    if (!tg(t))
        throw new Error("Invalid input to extend: expected a plain object");
    const n = e._zod.def.checks;
    if (n && n.length > 0)
        throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
    const i = id(e._zod.def, {
        get shape() {
            const o = {
                ...e._zod.def.shape,
                ...t
            };
            return rd(this, "shape", o),
            o
        },
        checks: []
    });
    return Oc(e, i)
}
function bbe(e, t) {
    if (!tg(t))
        throw new Error("Invalid input to safeExtend: expected a plain object");
    const n = {
        ...e._zod.def,
        get shape() {
            const r = {
                ...e._zod.def.shape,
                ...t
            };
            return rd(this, "shape", r),
            r
        },
        checks: e._zod.def.checks
    };
    return Oc(e, n)
}
function xbe(e, t) {
    const n = id(e._zod.def, {
        get shape() {
            const r = {
                ...e._zod.def.shape,
                ...t._zod.def.shape
            };
            return rd(this, "shape", r),
            r
        },
        get catchall() {
            return t._zod.def.catchall
        },
        checks: []
    });
    return Oc(e, n)
}
function vbe(e, t, n) {
    const r = id(t._zod.def, {
        get shape() {
            const i = t._zod.def.shape
              , o = {
                ...i
            };
            if (n)
                for (const a in n) {
                    if (!(a in i))
                        throw new Error(`Unrecognized key: "${a}"`);
                    n[a] && (o[a] = e ? new e({
                        type: "optional",
                        innerType: i[a]
                    }) : i[a])
                }
            else
                for (const a in i)
                    o[a] = e ? new e({
                        type: "optional",
                        innerType: i[a]
                    }) : i[a];
            return rd(this, "shape", o),
            o
        },
        checks: []
    });
    return Oc(t, r)
}
function Sbe(e, t, n) {
    const r = id(t._zod.def, {
        get shape() {
            const i = t._zod.def.shape
              , o = {
                ...i
            };
            if (n)
                for (const a in n) {
                    if (!(a in o))
                        throw new Error(`Unrecognized key: "${a}"`);
                    n[a] && (o[a] = new e({
                        type: "nonoptional",
                        innerType: i[a]
                    }))
                }
            else
                for (const a in i)
                    o[a] = new e({
                        type: "nonoptional",
                        innerType: i[a]
                    });
            return rd(this, "shape", o),
            o
        },
        checks: []
    });
    return Oc(t, r)
}
function pf(e, t=0) {
    if (e.aborted === !0)
        return !0;
    for (let n = t; n < e.issues.length; n++)
        if (e.issues[n]?.continue !== !0)
            return !0;
    return !1
}
function t9(e, t) {
    return t.map(n => {
        var r;
        return (r = n).path ?? (r.path = []),
        n.path.unshift(e),
        n
    }
    )
}
function Zb(e) {
    return typeof e == "string" ? e : e?.message
}
function Wu(e, t, n) {
    const r = {
        ...e,
        path: e.path ?? []
    };
    if (!e.message) {
        const i = Zb(e.inst?._zod.def?.error?.(e)) ?? Zb(t?.error?.(e)) ?? Zb(n.customError?.(e)) ?? Zb(n.localeError?.(e)) ?? "Invalid input";
        r.message = i
    }
    return delete r.inst,
    delete r.continue,
    t?.reportInput || delete r.input,
    r
}
function OA(e) {
    return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown"
}
function ng(...e) {
    const [t,n,r] = e;
    return typeof t == "string" ? {
        message: t,
        code: "custom",
        input: n,
        inst: r
    } : {
        ...t
    }
}
const n9 = (e, t) => {
    e.name = "$ZodError",
    Object.defineProperty(e, "_zod", {
        value: e._zod,
        enumerable: !1
    }),
    Object.defineProperty(e, "issues", {
        value: t,
        enumerable: !1
    }),
    e.message = JSON.stringify(t, IT, 2),
    Object.defineProperty(e, "toString", {
        value: () => e.message,
        enumerable: !1
    })
}
  , IA = Ge("$ZodError", n9)
  , _1 = Ge("$ZodError", n9, {
    Parent: Error
});
function Cbe(e, t=n => n.message) {
    const n = {}
      , r = [];
    for (const i of e.issues)
        i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [],
        n[i.path[0]].push(t(i))) : r.push(t(i));
    return {
        formErrors: r,
        fieldErrors: n
    }
}
function wbe(e, t=n => n.message) {
    const n = {
        _errors: []
    }
      , r = i => {
        for (const o of i.issues)
            if (o.code === "invalid_union" && o.errors.length)
                o.errors.map(a => r({
                    issues: a
                }));
            else if (o.code === "invalid_key")
                r({
                    issues: o.issues
                });
            else if (o.code === "invalid_element")
                r({
                    issues: o.issues
                });
            else if (o.path.length === 0)
                n._errors.push(t(o));
            else {
                let a = n
                  , s = 0;
                for (; s < o.path.length; ) {
                    const c = o.path[s];
                    s === o.path.length - 1 ? (a[c] = a[c] || {
                        _errors: []
                    },
                    a[c]._errors.push(t(o))) : a[c] = a[c] || {
                        _errors: []
                    },
                    a = a[c],
                    s++
                }
            }
    }
    ;
    return r(e),
    n
}
const E1 = e => (t, n, r, i) => {
    const o = r ? Object.assign(r, {
        async: !1
    }) : {
        async: !1
    }
      , a = t._zod.run({
        value: n,
        issues: []
    }, o);
    if (a instanceof Promise)
        throw new kf;
    if (a.issues.length) {
        const s = new (i?.Err ?? e)(a.issues.map(c => Wu(c, o, qu())));
        throw J6(s, i?.callee),
        s
    }
    return a.value
}
  , kbe = E1(_1)
  , A1 = e => async (t, n, r, i) => {
    const o = r ? Object.assign(r, {
        async: !0
    }) : {
        async: !0
    };
    let a = t._zod.run({
        value: n,
        issues: []
    }, o);
    if (a instanceof Promise && (a = await a),
    a.issues.length) {
        const s = new (i?.Err ?? e)(a.issues.map(c => Wu(c, o, qu())));
        throw J6(s, i?.callee),
        s
    }
    return a.value
}
  , Tbe = A1(_1)
  , M1 = e => (t, n, r) => {
    const i = r ? {
        ...r,
        async: !1
    } : {
        async: !1
    }
      , o = t._zod.run({
        value: n,
        issues: []
    }, i);
    if (o instanceof Promise)
        throw new kf;
    return o.issues.length ? {
        success: !1,
        error: new (e ?? IA)(o.issues.map(a => Wu(a, i, qu())))
    } : {
        success: !0,
        data: o.value
    }
}
  , _be = M1(_1)
  , P1 = e => async (t, n, r) => {
    const i = r ? Object.assign(r, {
        async: !0
    }) : {
        async: !0
    };
    let o = t._zod.run({
        value: n,
        issues: []
    }, i);
    return o instanceof Promise && (o = await o),
    o.issues.length ? {
        success: !1,
        error: new e(o.issues.map(a => Wu(a, i, qu())))
    } : {
        success: !0,
        data: o.value
    }
}
  , Ebe = P1(_1)
  , Abe = e => (t, n, r) => {
    const i = r ? Object.assign(r, {
        direction: "backward"
    }) : {
        direction: "backward"
    };
    return E1(e)(t, n, i)
}
  , Mbe = e => (t, n, r) => E1(e)(t, n, r)
  , Pbe = e => async (t, n, r) => {
    const i = r ? Object.assign(r, {
        direction: "backward"
    }) : {
        direction: "backward"
    };
    return A1(e)(t, n, i)
}
  , Rbe = e => async (t, n, r) => A1(e)(t, n, r)
  , Dbe = e => (t, n, r) => {
    const i = r ? Object.assign(r, {
        direction: "backward"
    }) : {
        direction: "backward"
    };
    return M1(e)(t, n, i)
}
  , Obe = e => (t, n, r) => M1(e)(t, n, r)
  , Ibe = e => async (t, n, r) => {
    const i = r ? Object.assign(r, {
        direction: "backward"
    }) : {
        direction: "backward"
    };
    return P1(e)(t, n, i)
}
  , $be = e => async (t, n, r) => P1(e)(t, n, r)
  , Lbe = /^[cC][^\s-]{8,}$/
  , jbe = /^[0-9a-z]+$/
  , Bbe = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/
  , zbe = /^[0-9a-vA-V]{20}$/
  , Fbe = /^[A-Za-z0-9]{27}$/
  , Nbe = /^[a-zA-Z0-9_-]{21}$/
  , Ube = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/
  , Vbe = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/
  , Pj = e => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
  , Hbe = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/
  , qbe = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Wbe() {
    return new RegExp(qbe,"u")
}
const Gbe = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , Ybe = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/
  , Zbe = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/
  , Qbe = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
  , Kbe = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/
  , r9 = /^[A-Za-z0-9_-]*$/
  , Xbe = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/
  , Jbe = /^\+(?:[0-9]){6,14}[0-9]$/
  , i9 = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))"
  , exe = new RegExp(`^${i9}$`);
function o9(e) {
    const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
    return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`
}
function txe(e) {
    return new RegExp(`^${o9(e)}$`)
}
function nxe(e) {
    const t = o9({
        precision: e.precision
    })
      , n = ["Z"];
    e.local && n.push(""),
    e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
    const r = `${t}(?:${n.join("|")})`;
    return new RegExp(`^${i9}T(?:${r})$`)
}
const rxe = e => {
    const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
    return new RegExp(`^${t}$`)
}
  , ixe = /^-?\d+$/
  , oxe = /^-?\d+(?:\.\d+)?/
  , axe = /^(?:true|false)$/i
  , sxe = /^[^A-Z]*$/
  , lxe = /^[^a-z]*$/
  , Eo = Ge("$ZodCheck", (e, t) => {
    var n;
    e._zod ?? (e._zod = {}),
    e._zod.def = t,
    (n = e._zod).onattach ?? (n.onattach = [])
}
)
  , a9 = {
    number: "number",
    bigint: "bigint",
    object: "date"
}
  , s9 = Ge("$ZodCheckLessThan", (e, t) => {
    Eo.init(e, t);
    const n = a9[typeof t.value];
    e._zod.onattach.push(r => {
        const i = r._zod.bag
          , o = (t.inclusive ? i.maximum : i.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        t.value < o && (t.inclusive ? i.maximum = t.value : i.exclusiveMaximum = t.value)
    }
    ),
    e._zod.check = r => {
        (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({
            origin: n,
            code: "too_big",
            maximum: t.value,
            input: r.value,
            inclusive: t.inclusive,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , l9 = Ge("$ZodCheckGreaterThan", (e, t) => {
    Eo.init(e, t);
    const n = a9[typeof t.value];
    e._zod.onattach.push(r => {
        const i = r._zod.bag
          , o = (t.inclusive ? i.minimum : i.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        t.value > o && (t.inclusive ? i.minimum = t.value : i.exclusiveMinimum = t.value)
    }
    ),
    e._zod.check = r => {
        (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({
            origin: n,
            code: "too_small",
            minimum: t.value,
            input: r.value,
            inclusive: t.inclusive,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , cxe = Ge("$ZodCheckMultipleOf", (e, t) => {
    Eo.init(e, t),
    e._zod.onattach.push(n => {
        var r;
        (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value)
    }
    ),
    e._zod.check = n => {
        if (typeof n.value != typeof t.value)
            throw new Error("Cannot mix number and bigint in multiple_of check.");
        (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : ube(n.value, t.value) === 0) || n.issues.push({
            origin: typeof n.value,
            code: "not_multiple_of",
            divisor: t.value,
            input: n.value,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , uxe = Ge("$ZodCheckNumberFormat", (e, t) => {
    Eo.init(e, t),
    t.format = t.format || "float64";
    const n = t.format?.includes("int")
      , r = n ? "int" : "number"
      , [i,o] = pbe[t.format];
    e._zod.onattach.push(a => {
        const s = a._zod.bag;
        s.format = t.format,
        s.minimum = i,
        s.maximum = o,
        n && (s.pattern = ixe)
    }
    ),
    e._zod.check = a => {
        const s = a.value;
        if (n) {
            if (!Number.isInteger(s)) {
                a.issues.push({
                    expected: r,
                    format: t.format,
                    code: "invalid_type",
                    continue: !1,
                    input: s,
                    inst: e
                });
                return
            }
            if (!Number.isSafeInteger(s)) {
                s > 0 ? a.issues.push({
                    input: s,
                    code: "too_big",
                    maximum: Number.MAX_SAFE_INTEGER,
                    note: "Integers must be within the safe integer range.",
                    inst: e,
                    origin: r,
                    continue: !t.abort
                }) : a.issues.push({
                    input: s,
                    code: "too_small",
                    minimum: Number.MIN_SAFE_INTEGER,
                    note: "Integers must be within the safe integer range.",
                    inst: e,
                    origin: r,
                    continue: !t.abort
                });
                return
            }
        }
        s < i && a.issues.push({
            origin: "number",
            input: s,
            code: "too_small",
            minimum: i,
            inclusive: !0,
            inst: e,
            continue: !t.abort
        }),
        s > o && a.issues.push({
            origin: "number",
            input: s,
            code: "too_big",
            maximum: o,
            inst: e
        })
    }
}
)
  , dxe = Ge("$ZodCheckMaxLength", (e, t) => {
    var n;
    Eo.init(e, t),
    (n = e._zod.def).when ?? (n.when = r => {
        const i = r.value;
        return !RA(i) && i.length !== void 0
    }
    ),
    e._zod.onattach.push(r => {
        const i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        t.maximum < i && (r._zod.bag.maximum = t.maximum)
    }
    ),
    e._zod.check = r => {
        const i = r.value;
        if (i.length <= t.maximum)
            return;
        const a = OA(i);
        r.issues.push({
            origin: a,
            code: "too_big",
            maximum: t.maximum,
            inclusive: !0,
            input: i,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , fxe = Ge("$ZodCheckMinLength", (e, t) => {
    var n;
    Eo.init(e, t),
    (n = e._zod.def).when ?? (n.when = r => {
        const i = r.value;
        return !RA(i) && i.length !== void 0
    }
    ),
    e._zod.onattach.push(r => {
        const i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        t.minimum > i && (r._zod.bag.minimum = t.minimum)
    }
    ),
    e._zod.check = r => {
        const i = r.value;
        if (i.length >= t.minimum)
            return;
        const a = OA(i);
        r.issues.push({
            origin: a,
            code: "too_small",
            minimum: t.minimum,
            inclusive: !0,
            input: i,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , hxe = Ge("$ZodCheckLengthEquals", (e, t) => {
    var n;
    Eo.init(e, t),
    (n = e._zod.def).when ?? (n.when = r => {
        const i = r.value;
        return !RA(i) && i.length !== void 0
    }
    ),
    e._zod.onattach.push(r => {
        const i = r._zod.bag;
        i.minimum = t.length,
        i.maximum = t.length,
        i.length = t.length
    }
    ),
    e._zod.check = r => {
        const i = r.value
          , o = i.length;
        if (o === t.length)
            return;
        const a = OA(i)
          , s = o > t.length;
        r.issues.push({
            origin: a,
            ...s ? {
                code: "too_big",
                maximum: t.length
            } : {
                code: "too_small",
                minimum: t.length
            },
            inclusive: !0,
            exact: !0,
            input: r.value,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , R1 = Ge("$ZodCheckStringFormat", (e, t) => {
    var n, r;
    Eo.init(e, t),
    e._zod.onattach.push(i => {
        const o = i._zod.bag;
        o.format = t.format,
        t.pattern && (o.patterns ?? (o.patterns = new Set),
        o.patterns.add(t.pattern))
    }
    ),
    t.pattern ? (n = e._zod).check ?? (n.check = i => {
        t.pattern.lastIndex = 0,
        !t.pattern.test(i.value) && i.issues.push({
            origin: "string",
            code: "invalid_format",
            format: t.format,
            input: i.value,
            ...t.pattern ? {
                pattern: t.pattern.toString()
            } : {},
            inst: e,
            continue: !t.abort
        })
    }
    ) : (r = e._zod).check ?? (r.check = () => {}
    )
}
)
  , pxe = Ge("$ZodCheckRegex", (e, t) => {
    R1.init(e, t),
    e._zod.check = n => {
        t.pattern.lastIndex = 0,
        !t.pattern.test(n.value) && n.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "regex",
            input: n.value,
            pattern: t.pattern.toString(),
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , mxe = Ge("$ZodCheckLowerCase", (e, t) => {
    t.pattern ?? (t.pattern = sxe),
    R1.init(e, t)
}
)
  , gxe = Ge("$ZodCheckUpperCase", (e, t) => {
    t.pattern ?? (t.pattern = lxe),
    R1.init(e, t)
}
)
  , yxe = Ge("$ZodCheckIncludes", (e, t) => {
    Eo.init(e, t);
    const n = Qf(t.includes)
      , r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
    t.pattern = r,
    e._zod.onattach.push(i => {
        const o = i._zod.bag;
        o.patterns ?? (o.patterns = new Set),
        o.patterns.add(r)
    }
    ),
    e._zod.check = i => {
        i.value.includes(t.includes, t.position) || i.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: t.includes,
            input: i.value,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , bxe = Ge("$ZodCheckStartsWith", (e, t) => {
    Eo.init(e, t);
    const n = new RegExp(`^${Qf(t.prefix)}.*`);
    t.pattern ?? (t.pattern = n),
    e._zod.onattach.push(r => {
        const i = r._zod.bag;
        i.patterns ?? (i.patterns = new Set),
        i.patterns.add(n)
    }
    ),
    e._zod.check = r => {
        r.value.startsWith(t.prefix) || r.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: t.prefix,
            input: r.value,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , xxe = Ge("$ZodCheckEndsWith", (e, t) => {
    Eo.init(e, t);
    const n = new RegExp(`.*${Qf(t.suffix)}$`);
    t.pattern ?? (t.pattern = n),
    e._zod.onattach.push(r => {
        const i = r._zod.bag;
        i.patterns ?? (i.patterns = new Set),
        i.patterns.add(n)
    }
    ),
    e._zod.check = r => {
        r.value.endsWith(t.suffix) || r.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: t.suffix,
            input: r.value,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , vxe = Ge("$ZodCheckOverwrite", (e, t) => {
    Eo.init(e, t),
    e._zod.check = n => {
        n.value = t.tx(n.value)
    }
}
);
class Sxe {
    constructor(t=[]) {
        this.content = [],
        this.indent = 0,
        this && (this.args = t)
    }
    indented(t) {
        this.indent += 1,
        t(this),
        this.indent -= 1
    }
    write(t) {
        if (typeof t == "function") {
            t(this, {
                execution: "sync"
            }),
            t(this, {
                execution: "async"
            });
            return
        }
        const r = t.split(`
`).filter(a => a)
          , i = Math.min(...r.map(a => a.length - a.trimStart().length))
          , o = r.map(a => a.slice(i)).map(a => " ".repeat(this.indent * 2) + a);
        for (const a of o)
            this.content.push(a)
    }
    compile() {
        const t = Function
          , n = this?.args
          , i = [...(this?.content ?? [""]).map(o => `  ${o}`)];
        return new t(...n,i.join(`
`))
    }
}
const Cxe = {
    major: 4,
    minor: 1,
    patch: 12
}
  , Or = Ge("$ZodType", (e, t) => {
    var n;
    e ?? (e = {}),
    e._zod.def = t,
    e._zod.bag = e._zod.bag || {},
    e._zod.version = Cxe;
    const r = [...e._zod.def.checks ?? []];
    e._zod.traits.has("$ZodCheck") && r.unshift(e);
    for (const i of r)
        for (const o of i._zod.onattach)
            o(e);
    if (r.length === 0)
        (n = e._zod).deferred ?? (n.deferred = []),
        e._zod.deferred?.push( () => {
            e._zod.run = e._zod.parse
        }
        );
    else {
        const i = (a, s, c) => {
            let u = pf(a), f;
            for (const h of s) {
                if (h._zod.def.when) {
                    if (!h._zod.def.when(a))
                        continue
                } else if (u)
                    continue;
                const m = a.issues.length
                  , y = h._zod.check(a);
                if (y instanceof Promise && c?.async === !1)
                    throw new kf;
                if (f || y instanceof Promise)
                    f = (f ?? Promise.resolve()).then(async () => {
                        await y,
                        a.issues.length !== m && (u || (u = pf(a, m)))
                    }
                    );
                else {
                    if (a.issues.length === m)
                        continue;
                    u || (u = pf(a, m))
                }
            }
            return f ? f.then( () => a) : a
        }
          , o = (a, s, c) => {
            if (pf(a))
                return a.aborted = !0,
                a;
            const u = i(s, r, c);
            if (u instanceof Promise) {
                if (c.async === !1)
                    throw new kf;
                return u.then(f => e._zod.parse(f, c))
            }
            return e._zod.parse(u, c)
        }
        ;
        e._zod.run = (a, s) => {
            if (s.skipChecks)
                return e._zod.parse(a, s);
            if (s.direction === "backward") {
                const u = e._zod.parse({
                    value: a.value,
                    issues: []
                }, {
                    ...s,
                    skipChecks: !0
                });
                return u instanceof Promise ? u.then(f => o(f, a, s)) : o(u, a, s)
            }
            const c = e._zod.parse(a, s);
            if (c instanceof Promise) {
                if (s.async === !1)
                    throw new kf;
                return c.then(u => i(u, r, s))
            }
            return i(c, r, s)
        }
    }
    e["~standard"] = {
        validate: i => {
            try {
                const o = _be(e, i);
                return o.success ? {
                    value: o.data
                } : {
                    issues: o.error?.issues
                }
            } catch {
                return Ebe(e, i).then(a => a.success ? {
                    value: a.data
                } : {
                    issues: a.error?.issues
                })
            }
        }
        ,
        vendor: "zod",
        version: 1
    }
}
)
  , $A = Ge("$ZodString", (e, t) => {
    Or.init(e, t),
    e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? rxe(e._zod.bag),
    e._zod.parse = (n, r) => {
        if (t.coerce)
            try {
                n.value = String(n.value)
            } catch {}
        return typeof n.value == "string" || n.issues.push({
            expected: "string",
            code: "invalid_type",
            input: n.value,
            inst: e
        }),
        n
    }
}
)
  , xr = Ge("$ZodStringFormat", (e, t) => {
    R1.init(e, t),
    $A.init(e, t)
}
)
  , wxe = Ge("$ZodGUID", (e, t) => {
    t.pattern ?? (t.pattern = Vbe),
    xr.init(e, t)
}
)
  , kxe = Ge("$ZodUUID", (e, t) => {
    if (t.version) {
        const r = {
            v1: 1,
            v2: 2,
            v3: 3,
            v4: 4,
            v5: 5,
            v6: 6,
            v7: 7,
            v8: 8
        }[t.version];
        if (r === void 0)
            throw new Error(`Invalid UUID version: "${t.version}"`);
        t.pattern ?? (t.pattern = Pj(r))
    } else
        t.pattern ?? (t.pattern = Pj());
    xr.init(e, t)
}
)
  , Txe = Ge("$ZodEmail", (e, t) => {
    t.pattern ?? (t.pattern = Hbe),
    xr.init(e, t)
}
)
  , _xe = Ge("$ZodURL", (e, t) => {
    xr.init(e, t),
    e._zod.check = n => {
        try {
            const r = n.value.trim()
              , i = new URL(r);
            t.hostname && (t.hostname.lastIndex = 0,
            t.hostname.test(i.hostname) || n.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: Xbe.source,
                input: n.value,
                inst: e,
                continue: !t.abort
            })),
            t.protocol && (t.protocol.lastIndex = 0,
            t.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) || n.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: t.protocol.source,
                input: n.value,
                inst: e,
                continue: !t.abort
            })),
            t.normalize ? n.value = i.href : n.value = r;
            return
        } catch {
            n.issues.push({
                code: "invalid_format",
                format: "url",
                input: n.value,
                inst: e,
                continue: !t.abort
            })
        }
    }
}
)
  , Exe = Ge("$ZodEmoji", (e, t) => {
    t.pattern ?? (t.pattern = Wbe()),
    xr.init(e, t)
}
)
  , Axe = Ge("$ZodNanoID", (e, t) => {
    t.pattern ?? (t.pattern = Nbe),
    xr.init(e, t)
}
)
  , Mxe = Ge("$ZodCUID", (e, t) => {
    t.pattern ?? (t.pattern = Lbe),
    xr.init(e, t)
}
)
  , Pxe = Ge("$ZodCUID2", (e, t) => {
    t.pattern ?? (t.pattern = jbe),
    xr.init(e, t)
}
)
  , Rxe = Ge("$ZodULID", (e, t) => {
    t.pattern ?? (t.pattern = Bbe),
    xr.init(e, t)
}
)
  , Dxe = Ge("$ZodXID", (e, t) => {
    t.pattern ?? (t.pattern = zbe),
    xr.init(e, t)
}
)
  , Oxe = Ge("$ZodKSUID", (e, t) => {
    t.pattern ?? (t.pattern = Fbe),
    xr.init(e, t)
}
)
  , Ixe = Ge("$ZodISODateTime", (e, t) => {
    t.pattern ?? (t.pattern = nxe(t)),
    xr.init(e, t)
}
)
  , $xe = Ge("$ZodISODate", (e, t) => {
    t.pattern ?? (t.pattern = exe),
    xr.init(e, t)
}
)
  , Lxe = Ge("$ZodISOTime", (e, t) => {
    t.pattern ?? (t.pattern = txe(t)),
    xr.init(e, t)
}
)
  , jxe = Ge("$ZodISODuration", (e, t) => {
    t.pattern ?? (t.pattern = Ube),
    xr.init(e, t)
}
)
  , Bxe = Ge("$ZodIPv4", (e, t) => {
    t.pattern ?? (t.pattern = Gbe),
    xr.init(e, t),
    e._zod.onattach.push(n => {
        const r = n._zod.bag;
        r.format = "ipv4"
    }
    )
}
)
  , zxe = Ge("$ZodIPv6", (e, t) => {
    t.pattern ?? (t.pattern = Ybe),
    xr.init(e, t),
    e._zod.onattach.push(n => {
        const r = n._zod.bag;
        r.format = "ipv6"
    }
    ),
    e._zod.check = n => {
        try {
            new URL(`http://[${n.value}]`)
        } catch {
            n.issues.push({
                code: "invalid_format",
                format: "ipv6",
                input: n.value,
                inst: e,
                continue: !t.abort
            })
        }
    }
}
)
  , Fxe = Ge("$ZodCIDRv4", (e, t) => {
    t.pattern ?? (t.pattern = Zbe),
    xr.init(e, t)
}
)
  , Nxe = Ge("$ZodCIDRv6", (e, t) => {
    t.pattern ?? (t.pattern = Qbe),
    xr.init(e, t),
    e._zod.check = n => {
        const r = n.value.split("/");
        try {
            if (r.length !== 2)
                throw new Error;
            const [i,o] = r;
            if (!o)
                throw new Error;
            const a = Number(o);
            if (`${a}` !== o)
                throw new Error;
            if (a < 0 || a > 128)
                throw new Error;
            new URL(`http://[${i}]`)
        } catch {
            n.issues.push({
                code: "invalid_format",
                format: "cidrv6",
                input: n.value,
                inst: e,
                continue: !t.abort
            })
        }
    }
}
);
function c9(e) {
    if (e === "")
        return !0;
    if (e.length % 4 !== 0)
        return !1;
    try {
        return atob(e),
        !0
    } catch {
        return !1
    }
}
const Uxe = Ge("$ZodBase64", (e, t) => {
    t.pattern ?? (t.pattern = Kbe),
    xr.init(e, t),
    e._zod.onattach.push(n => {
        n._zod.bag.contentEncoding = "base64"
    }
    ),
    e._zod.check = n => {
        c9(n.value) || n.issues.push({
            code: "invalid_format",
            format: "base64",
            input: n.value,
            inst: e,
            continue: !t.abort
        })
    }
}
);
function Vxe(e) {
    if (!r9.test(e))
        return !1;
    const t = e.replace(/[-_]/g, r => r === "-" ? "+" : "/")
      , n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
    return c9(n)
}
const Hxe = Ge("$ZodBase64URL", (e, t) => {
    t.pattern ?? (t.pattern = r9),
    xr.init(e, t),
    e._zod.onattach.push(n => {
        n._zod.bag.contentEncoding = "base64url"
    }
    ),
    e._zod.check = n => {
        Vxe(n.value) || n.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: n.value,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , qxe = Ge("$ZodE164", (e, t) => {
    t.pattern ?? (t.pattern = Jbe),
    xr.init(e, t)
}
);
function Wxe(e, t=null) {
    try {
        const n = e.split(".");
        if (n.length !== 3)
            return !1;
        const [r] = n;
        if (!r)
            return !1;
        const i = JSON.parse(atob(r));
        return !("typ"in i && i?.typ !== "JWT" || !i.alg || t && (!("alg"in i) || i.alg !== t))
    } catch {
        return !1
    }
}
const Gxe = Ge("$ZodJWT", (e, t) => {
    xr.init(e, t),
    e._zod.check = n => {
        Wxe(n.value, t.alg) || n.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: n.value,
            inst: e,
            continue: !t.abort
        })
    }
}
)
  , u9 = Ge("$ZodNumber", (e, t) => {
    Or.init(e, t),
    e._zod.pattern = e._zod.bag.pattern ?? oxe,
    e._zod.parse = (n, r) => {
        if (t.coerce)
            try {
                n.value = Number(n.value)
            } catch {}
        const i = n.value;
        if (typeof i == "number" && !Number.isNaN(i) && Number.isFinite(i))
            return n;
        const o = typeof i == "number" ? Number.isNaN(i) ? "NaN" : Number.isFinite(i) ? void 0 : "Infinity" : void 0;
        return n.issues.push({
            expected: "number",
            code: "invalid_type",
            input: i,
            inst: e,
            ...o ? {
                received: o
            } : {}
        }),
        n
    }
}
)
  , Yxe = Ge("$ZodNumber", (e, t) => {
    uxe.init(e, t),
    u9.init(e, t)
}
)
  , Zxe = Ge("$ZodBoolean", (e, t) => {
    Or.init(e, t),
    e._zod.pattern = axe,
    e._zod.parse = (n, r) => {
        if (t.coerce)
            try {
                n.value = !!n.value
            } catch {}
        const i = n.value;
        return typeof i == "boolean" || n.issues.push({
            expected: "boolean",
            code: "invalid_type",
            input: i,
            inst: e
        }),
        n
    }
}
)
  , Qxe = Ge("$ZodUnknown", (e, t) => {
    Or.init(e, t),
    e._zod.parse = n => n
}
)
  , Kxe = Ge("$ZodNever", (e, t) => {
    Or.init(e, t),
    e._zod.parse = (n, r) => (n.issues.push({
        expected: "never",
        code: "invalid_type",
        input: n.value,
        inst: e
    }),
    n)
}
);
function Rj(e, t, n) {
    e.issues.length && t.issues.push(...t9(n, e.issues)),
    t.value[n] = e.value
}
const Xxe = Ge("$ZodArray", (e, t) => {
    Or.init(e, t),
    e._zod.parse = (n, r) => {
        const i = n.value;
        if (!Array.isArray(i))
            return n.issues.push({
                expected: "array",
                code: "invalid_type",
                input: i,
                inst: e
            }),
            n;
        n.value = Array(i.length);
        const o = [];
        for (let a = 0; a < i.length; a++) {
            const s = i[a]
              , c = t.element._zod.run({
                value: s,
                issues: []
            }, r);
            c instanceof Promise ? o.push(c.then(u => Rj(u, n, a))) : Rj(c, n, a)
        }
        return o.length ? Promise.all(o).then( () => n) : n
    }
}
);
function L0(e, t, n, r) {
    e.issues.length && t.issues.push(...t9(n, e.issues)),
    e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value
}
function d9(e) {
    const t = Object.keys(e.shape);
    for (const r of t)
        if (!e.shape?.[r]?._zod?.traits?.has("$ZodType"))
            throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
    const n = hbe(e.shape);
    return {
        ...e,
        keys: t,
        keySet: new Set(t),
        numKeys: t.length,
        optionalKeys: new Set(n)
    }
}
function f9(e, t, n, r, i, o) {
    const a = []
      , s = i.keySet
      , c = i.catchall._zod
      , u = c.def.type;
    for (const f of Object.keys(t)) {
        if (s.has(f))
            continue;
        if (u === "never") {
            a.push(f);
            continue
        }
        const h = c.run({
            value: t[f],
            issues: []
        }, r);
        h instanceof Promise ? e.push(h.then(m => L0(m, n, f, t))) : L0(h, n, f, t)
    }
    return a.length && n.issues.push({
        code: "unrecognized_keys",
        keys: a,
        input: t,
        inst: o
    }),
    e.length ? Promise.all(e).then( () => n) : n
}
const Jxe = Ge("$ZodObject", (e, t) => {
    if (Or.init(e, t),
    !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
        const s = t.shape;
        Object.defineProperty(t, "shape", {
            get: () => {
                const c = {
                    ...s
                };
                return Object.defineProperty(t, "shape", {
                    value: c
                }),
                c
            }
        })
    }
    const r = PA( () => d9(t));
    sr(e._zod, "propValues", () => {
        const s = t.shape
          , c = {};
        for (const u in s) {
            const f = s[u]._zod;
            if (f.values) {
                c[u] ?? (c[u] = new Set);
                for (const h of f.values)
                    c[u].add(h)
            }
        }
        return c
    }
    );
    const i = $0
      , o = t.catchall;
    let a;
    e._zod.parse = (s, c) => {
        a ?? (a = r.value);
        const u = s.value;
        if (!i(u))
            return s.issues.push({
                expected: "object",
                code: "invalid_type",
                input: u,
                inst: e
            }),
            s;
        s.value = {};
        const f = []
          , h = a.shape;
        for (const m of a.keys) {
            const b = h[m]._zod.run({
                value: u[m],
                issues: []
            }, c);
            b instanceof Promise ? f.push(b.then(v => L0(v, s, m, u))) : L0(b, s, m, u)
        }
        return o ? f9(f, u, s, c, r.value, e) : f.length ? Promise.all(f).then( () => s) : s
    }
}
)
  , e0e = Ge("$ZodObjectJIT", (e, t) => {
    Jxe.init(e, t);
    const n = e._zod.parse
      , r = PA( () => d9(t))
      , i = m => {
        const y = new Sxe(["shape", "payload", "ctx"])
          , b = r.value
          , v = k => {
            const T = Mj(k);
            return `shape[${T}]._zod.run({ value: input[${T}], issues: [] }, ctx)`
        }
        ;
        y.write("const input = payload.value;");
        const S = Object.create(null);
        let C = 0;
        for (const k of b.keys)
            S[k] = `key_${C++}`;
        y.write("const newResult = {};");
        for (const k of b.keys) {
            const T = S[k]
              , E = Mj(k);
            y.write(`const ${T} = ${v(k)};`),
            y.write(`
        if (${T}.issues.length) {
          payload.issues = payload.issues.concat(${T}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${E}, ...iss.path] : [${E}]
          })));
        }
        
        
        if (${T}.value === undefined) {
          if (${E} in input) {
            newResult[${E}] = undefined;
          }
        } else {
          newResult[${E}] = ${T}.value;
        }
        
      `)
        }
        y.write("payload.value = newResult;"),
        y.write("return payload;");
        const w = y.compile();
        return (k, T) => w(m, k, T)
    }
    ;
    let o;
    const a = $0
      , s = !X6.jitless
      , u = s && dbe.value
      , f = t.catchall;
    let h;
    e._zod.parse = (m, y) => {
        h ?? (h = r.value);
        const b = m.value;
        return a(b) ? s && u && y?.async === !1 && y.jitless !== !0 ? (o || (o = i(t.shape)),
        m = o(m, y),
        f ? f9([], b, m, y, h, e) : m) : n(m, y) : (m.issues.push({
            expected: "object",
            code: "invalid_type",
            input: b,
            inst: e
        }),
        m)
    }
}
);
function Dj(e, t, n, r) {
    for (const o of e)
        if (o.issues.length === 0)
            return t.value = o.value,
            t;
    const i = e.filter(o => !pf(o));
    return i.length === 1 ? (t.value = i[0].value,
    i[0]) : (t.issues.push({
        code: "invalid_union",
        input: t.value,
        inst: n,
        errors: e.map(o => o.issues.map(a => Wu(a, r, qu())))
    }),
    t)
}
const t0e = Ge("$ZodUnion", (e, t) => {
    Or.init(e, t),
    sr(e._zod, "optin", () => t.options.some(i => i._zod.optin === "optional") ? "optional" : void 0),
    sr(e._zod, "optout", () => t.options.some(i => i._zod.optout === "optional") ? "optional" : void 0),
    sr(e._zod, "values", () => {
        if (t.options.every(i => i._zod.values))
            return new Set(t.options.flatMap(i => Array.from(i._zod.values)))
    }
    ),
    sr(e._zod, "pattern", () => {
        if (t.options.every(i => i._zod.pattern)) {
            const i = t.options.map(o => o._zod.pattern);
            return new RegExp(`^(${i.map(o => DA(o.source)).join("|")})$`)
        }
    }
    );
    const n = t.options.length === 1
      , r = t.options[0]._zod.run;
    e._zod.parse = (i, o) => {
        if (n)
            return r(i, o);
        let a = !1;
        const s = [];
        for (const c of t.options) {
            const u = c._zod.run({
                value: i.value,
                issues: []
            }, o);
            if (u instanceof Promise)
                s.push(u),
                a = !0;
            else {
                if (u.issues.length === 0)
                    return u;
                s.push(u)
            }
        }
        return a ? Promise.all(s).then(c => Dj(c, i, e, o)) : Dj(s, i, e, o)
    }
}
)
  , n0e = Ge("$ZodIntersection", (e, t) => {
    Or.init(e, t),
    e._zod.parse = (n, r) => {
        const i = n.value
          , o = t.left._zod.run({
            value: i,
            issues: []
        }, r)
          , a = t.right._zod.run({
            value: i,
            issues: []
        }, r);
        return o instanceof Promise || a instanceof Promise ? Promise.all([o, a]).then( ([c,u]) => Oj(n, c, u)) : Oj(n, o, a)
    }
}
);
function $T(e, t) {
    if (e === t)
        return {
            valid: !0,
            data: e
        };
    if (e instanceof Date && t instanceof Date && +e == +t)
        return {
            valid: !0,
            data: e
        };
    if (tg(e) && tg(t)) {
        const n = Object.keys(t)
          , r = Object.keys(e).filter(o => n.indexOf(o) !== -1)
          , i = {
            ...e,
            ...t
        };
        for (const o of r) {
            const a = $T(e[o], t[o]);
            if (!a.valid)
                return {
                    valid: !1,
                    mergeErrorPath: [o, ...a.mergeErrorPath]
                };
            i[o] = a.data
        }
        return {
            valid: !0,
            data: i
        }
    }
    if (Array.isArray(e) && Array.isArray(t)) {
        if (e.length !== t.length)
            return {
                valid: !1,
                mergeErrorPath: []
            };
        const n = [];
        for (let r = 0; r < e.length; r++) {
            const i = e[r]
              , o = t[r]
              , a = $T(i, o);
            if (!a.valid)
                return {
                    valid: !1,
                    mergeErrorPath: [r, ...a.mergeErrorPath]
                };
            n.push(a.data)
        }
        return {
            valid: !0,
            data: n
        }
    }
    return {
        valid: !1,
        mergeErrorPath: []
    }
}
function Oj(e, t, n) {
    if (t.issues.length && e.issues.push(...t.issues),
    n.issues.length && e.issues.push(...n.issues),
    pf(e))
        return e;
    const r = $T(t.value, n.value);
    if (!r.valid)
        throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
    return e.value = r.data,
    e
}
const r0e = Ge("$ZodEnum", (e, t) => {
    Or.init(e, t);
    const n = cbe(t.entries)
      , r = new Set(n);
    e._zod.values = r,
    e._zod.pattern = new RegExp(`^(${n.filter(i => fbe.has(typeof i)).map(i => typeof i == "string" ? Qf(i) : i.toString()).join("|")})$`),
    e._zod.parse = (i, o) => {
        const a = i.value;
        return r.has(a) || i.issues.push({
            code: "invalid_value",
            values: n,
            input: a,
            inst: e
        }),
        i
    }
}
)
  , i0e = Ge("$ZodLiteral", (e, t) => {
    if (Or.init(e, t),
    t.values.length === 0)
        throw new Error("Cannot create literal schema with no valid values");
    e._zod.values = new Set(t.values),
    e._zod.pattern = new RegExp(`^(${t.values.map(n => typeof n == "string" ? Qf(n) : n ? Qf(n.toString()) : String(n)).join("|")})$`),
    e._zod.parse = (n, r) => {
        const i = n.value;
        return e._zod.values.has(i) || n.issues.push({
            code: "invalid_value",
            values: t.values,
            input: i,
            inst: e
        }),
        n
    }
}
)
  , o0e = Ge("$ZodTransform", (e, t) => {
    Or.init(e, t),
    e._zod.parse = (n, r) => {
        if (r.direction === "backward")
            throw new K6(e.constructor.name);
        const i = t.transform(n.value, n);
        if (r.async)
            return (i instanceof Promise ? i : Promise.resolve(i)).then(a => (n.value = a,
            n));
        if (i instanceof Promise)
            throw new kf;
        return n.value = i,
        n
    }
}
);
function Ij(e, t) {
    return e.issues.length && t === void 0 ? {
        issues: [],
        value: void 0
    } : e
}
const a0e = Ge("$ZodOptional", (e, t) => {
    Or.init(e, t),
    e._zod.optin = "optional",
    e._zod.optout = "optional",
    sr(e._zod, "values", () => t.innerType._zod.values ? new Set([...t.innerType._zod.values, void 0]) : void 0),
    sr(e._zod, "pattern", () => {
        const n = t.innerType._zod.pattern;
        return n ? new RegExp(`^(${DA(n.source)})?$`) : void 0
    }
    ),
    e._zod.parse = (n, r) => {
        if (t.innerType._zod.optin === "optional") {
            const i = t.innerType._zod.run(n, r);
            return i instanceof Promise ? i.then(o => Ij(o, n.value)) : Ij(i, n.value)
        }
        return n.value === void 0 ? n : t.innerType._zod.run(n, r)
    }
}
)
  , s0e = Ge("$ZodNullable", (e, t) => {
    Or.init(e, t),
    sr(e._zod, "optin", () => t.innerType._zod.optin),
    sr(e._zod, "optout", () => t.innerType._zod.optout),
    sr(e._zod, "pattern", () => {
        const n = t.innerType._zod.pattern;
        return n ? new RegExp(`^(${DA(n.source)}|null)$`) : void 0
    }
    ),
    sr(e._zod, "values", () => t.innerType._zod.values ? new Set([...t.innerType._zod.values, null]) : void 0),
    e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r)
}
)
  , l0e = Ge("$ZodDefault", (e, t) => {
    Or.init(e, t),
    e._zod.optin = "optional",
    sr(e._zod, "values", () => t.innerType._zod.values),
    e._zod.parse = (n, r) => {
        if (r.direction === "backward")
            return t.innerType._zod.run(n, r);
        if (n.value === void 0)
            return n.value = t.defaultValue,
            n;
        const i = t.innerType._zod.run(n, r);
        return i instanceof Promise ? i.then(o => $j(o, t)) : $j(i, t)
    }
}
);
function $j(e, t) {
    return e.value === void 0 && (e.value = t.defaultValue),
    e
}
const c0e = Ge("$ZodPrefault", (e, t) => {
    Or.init(e, t),
    e._zod.optin = "optional",
    sr(e._zod, "values", () => t.innerType._zod.values),
    e._zod.parse = (n, r) => (r.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue),
    t.innerType._zod.run(n, r))
}
)
  , u0e = Ge("$ZodNonOptional", (e, t) => {
    Or.init(e, t),
    sr(e._zod, "values", () => {
        const n = t.innerType._zod.values;
        return n ? new Set([...n].filter(r => r !== void 0)) : void 0
    }
    ),
    e._zod.parse = (n, r) => {
        const i = t.innerType._zod.run(n, r);
        return i instanceof Promise ? i.then(o => Lj(o, e)) : Lj(i, e)
    }
}
);
function Lj(e, t) {
    return !e.issues.length && e.value === void 0 && e.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: e.value,
        inst: t
    }),
    e
}
const d0e = Ge("$ZodCatch", (e, t) => {
    Or.init(e, t),
    sr(e._zod, "optin", () => t.innerType._zod.optin),
    sr(e._zod, "optout", () => t.innerType._zod.optout),
    sr(e._zod, "values", () => t.innerType._zod.values),
    e._zod.parse = (n, r) => {
        if (r.direction === "backward")
            return t.innerType._zod.run(n, r);
        const i = t.innerType._zod.run(n, r);
        return i instanceof Promise ? i.then(o => (n.value = o.value,
        o.issues.length && (n.value = t.catchValue({
            ...n,
            error: {
                issues: o.issues.map(a => Wu(a, r, qu()))
            },
            input: n.value
        }),
        n.issues = []),
        n)) : (n.value = i.value,
        i.issues.length && (n.value = t.catchValue({
            ...n,
            error: {
                issues: i.issues.map(o => Wu(o, r, qu()))
            },
            input: n.value
        }),
        n.issues = []),
        n)
    }
}
)
  , f0e = Ge("$ZodPipe", (e, t) => {
    Or.init(e, t),
    sr(e._zod, "values", () => t.in._zod.values),
    sr(e._zod, "optin", () => t.in._zod.optin),
    sr(e._zod, "optout", () => t.out._zod.optout),
    sr(e._zod, "propValues", () => t.in._zod.propValues),
    e._zod.parse = (n, r) => {
        if (r.direction === "backward") {
            const o = t.out._zod.run(n, r);
            return o instanceof Promise ? o.then(a => Qb(a, t.in, r)) : Qb(o, t.in, r)
        }
        const i = t.in._zod.run(n, r);
        return i instanceof Promise ? i.then(o => Qb(o, t.out, r)) : Qb(i, t.out, r)
    }
}
);
function Qb(e, t, n) {
    return e.issues.length ? (e.aborted = !0,
    e) : t._zod.run({
        value: e.value,
        issues: e.issues
    }, n)
}
const h0e = Ge("$ZodReadonly", (e, t) => {
    Or.init(e, t),
    sr(e._zod, "propValues", () => t.innerType._zod.propValues),
    sr(e._zod, "values", () => t.innerType._zod.values),
    sr(e._zod, "optin", () => t.innerType._zod.optin),
    sr(e._zod, "optout", () => t.innerType._zod.optout),
    e._zod.parse = (n, r) => {
        if (r.direction === "backward")
            return t.innerType._zod.run(n, r);
        const i = t.innerType._zod.run(n, r);
        return i instanceof Promise ? i.then(jj) : jj(i)
    }
}
);
function jj(e) {
    return e.value = Object.freeze(e.value),
    e
}
const p0e = Ge("$ZodCustom", (e, t) => {
    Eo.init(e, t),
    Or.init(e, t),
    e._zod.parse = (n, r) => n,
    e._zod.check = n => {
        const r = n.value
          , i = t.fn(r);
        if (i instanceof Promise)
            return i.then(o => Bj(o, n, r, e));
        Bj(i, n, r, e)
    }
}
);
function Bj(e, t, n, r) {
    if (!e) {
        const i = {
            code: "custom",
            input: n,
            inst: r,
            path: [...r._zod.def.path ?? []],
            continue: !r._zod.def.abort
        };
        r._zod.def.params && (i.params = r._zod.def.params),
        t.issues.push(ng(i))
    }
}
class m0e {
    constructor() {
        this._map = new WeakMap,
        this._idmap = new Map
    }
    add(t, ...n) {
        const r = n[0];
        if (this._map.set(t, r),
        r && typeof r == "object" && "id"in r) {
            if (this._idmap.has(r.id))
                throw new Error(`ID ${r.id} already exists in the registry`);
            this._idmap.set(r.id, t)
        }
        return this
    }
    clear() {
        return this._map = new WeakMap,
        this._idmap = new Map,
        this
    }
    remove(t) {
        const n = this._map.get(t);
        return n && typeof n == "object" && "id"in n && this._idmap.delete(n.id),
        this._map.delete(t),
        this
    }
    get(t) {
        const n = t._zod.parent;
        if (n) {
            const r = {
                ...this.get(n) ?? {}
            };
            delete r.id;
            const i = {
                ...r,
                ...this._map.get(t)
            };
            return Object.keys(i).length ? i : void 0
        }
        return this._map.get(t)
    }
    has(t) {
        return this._map.has(t)
    }
}
function g0e() {
    return new m0e
}
const Kb = g0e();
function y0e(e, t) {
    return new e({
        type: "string",
        ...$t(t)
    })
}
function h9(e, t) {
    return new e({
        type: "string",
        format: "email",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function zj(e, t) {
    return new e({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function b0e(e, t) {
    return new e({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function x0e(e, t) {
    return new e({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v4",
        ...$t(t)
    })
}
function v0e(e, t) {
    return new e({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v6",
        ...$t(t)
    })
}
function S0e(e, t) {
    return new e({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: !1,
        version: "v7",
        ...$t(t)
    })
}
function C0e(e, t) {
    return new e({
        type: "string",
        format: "url",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function w0e(e, t) {
    return new e({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function k0e(e, t) {
    return new e({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function T0e(e, t) {
    return new e({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function _0e(e, t) {
    return new e({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function E0e(e, t) {
    return new e({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function A0e(e, t) {
    return new e({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function M0e(e, t) {
    return new e({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function P0e(e, t) {
    return new e({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function R0e(e, t) {
    return new e({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function D0e(e, t) {
    return new e({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function O0e(e, t) {
    return new e({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function I0e(e, t) {
    return new e({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function $0e(e, t) {
    return new e({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function L0e(e, t) {
    return new e({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function j0e(e, t) {
    return new e({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: !1,
        ...$t(t)
    })
}
function B0e(e, t) {
    return new e({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: !1,
        local: !1,
        precision: null,
        ...$t(t)
    })
}
function z0e(e, t) {
    return new e({
        type: "string",
        format: "date",
        check: "string_format",
        ...$t(t)
    })
}
function F0e(e, t) {
    return new e({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...$t(t)
    })
}
function N0e(e, t) {
    return new e({
        type: "string",
        format: "duration",
        check: "string_format",
        ...$t(t)
    })
}
function U0e(e, t) {
    return new e({
        type: "number",
        checks: [],
        ...$t(t)
    })
}
function V0e(e, t) {
    return new e({
        type: "number",
        check: "number_format",
        abort: !1,
        format: "safeint",
        ...$t(t)
    })
}
function H0e(e, t) {
    return new e({
        type: "boolean",
        ...$t(t)
    })
}
function q0e(e) {
    return new e({
        type: "unknown"
    })
}
function W0e(e, t) {
    return new e({
        type: "never",
        ...$t(t)
    })
}
function Fj(e, t) {
    return new s9({
        check: "less_than",
        ...$t(t),
        value: e,
        inclusive: !1
    })
}
function Ak(e, t) {
    return new s9({
        check: "less_than",
        ...$t(t),
        value: e,
        inclusive: !0
    })
}
function Nj(e, t) {
    return new l9({
        check: "greater_than",
        ...$t(t),
        value: e,
        inclusive: !1
    })
}
function Mk(e, t) {
    return new l9({
        check: "greater_than",
        ...$t(t),
        value: e,
        inclusive: !0
    })
}
function Uj(e, t) {
    return new cxe({
        check: "multiple_of",
        ...$t(t),
        value: e
    })
}
function p9(e, t) {
    return new dxe({
        check: "max_length",
        ...$t(t),
        maximum: e
    })
}
function j0(e, t) {
    return new fxe({
        check: "min_length",
        ...$t(t),
        minimum: e
    })
}
function m9(e, t) {
    return new hxe({
        check: "length_equals",
        ...$t(t),
        length: e
    })
}
function G0e(e, t) {
    return new pxe({
        check: "string_format",
        format: "regex",
        ...$t(t),
        pattern: e
    })
}
function Y0e(e) {
    return new mxe({
        check: "string_format",
        format: "lowercase",
        ...$t(e)
    })
}
function Z0e(e) {
    return new gxe({
        check: "string_format",
        format: "uppercase",
        ...$t(e)
    })
}
function Q0e(e, t) {
    return new yxe({
        check: "string_format",
        format: "includes",
        ...$t(t),
        includes: e
    })
}
function K0e(e, t) {
    return new bxe({
        check: "string_format",
        format: "starts_with",
        ...$t(t),
        prefix: e
    })
}
function X0e(e, t) {
    return new xxe({
        check: "string_format",
        format: "ends_with",
        ...$t(t),
        suffix: e
    })
}
function Kg(e) {
    return new vxe({
        check: "overwrite",
        tx: e
    })
}
function J0e(e) {
    return Kg(t => t.normalize(e))
}
function eve() {
    return Kg(e => e.trim())
}
function tve() {
    return Kg(e => e.toLowerCase())
}
function nve() {
    return Kg(e => e.toUpperCase())
}
function rve(e, t, n) {
    return new e({
        type: "array",
        element: t,
        ...$t(n)
    })
}
function ive(e, t, n) {
    return new e({
        type: "custom",
        check: "custom",
        fn: t,
        ...$t(n)
    })
}
function ove(e) {
    const t = ave(n => (n.addIssue = r => {
        if (typeof r == "string")
            n.issues.push(ng(r, n.value, t._zod.def));
        else {
            const i = r;
            i.fatal && (i.continue = !1),
            i.code ?? (i.code = "custom"),
            i.input ?? (i.input = n.value),
            i.inst ?? (i.inst = t),
            i.continue ?? (i.continue = !t._zod.def.abort),
            n.issues.push(ng(i))
        }
    }
    ,
    e(n.value, n)));
    return t
}
function ave(e, t) {
    const n = new Eo({
        check: "custom",
        ...$t(t)
    });
    return n._zod.check = e,
    n
}
function Vj(e, t) {
    try {
        var n = e()
    } catch (r) {
        return t(r)
    }
    return n && n.then ? n.then(void 0, t) : n
}
function sve(e, t) {
    for (var n = {}; e.length; ) {
        var r = e[0]
          , i = r.code
          , o = r.message
          , a = r.path.join(".");
        if (!n[a])
            if ("unionErrors"in r) {
                var s = r.unionErrors[0].errors[0];
                n[a] = {
                    message: s.message,
                    type: s.code
                }
            } else
                n[a] = {
                    message: o,
                    type: i
                };
        if ("unionErrors"in r && r.unionErrors.forEach(function(f) {
            return f.errors.forEach(function(h) {
                return e.push(h)
            })
        }),
        t) {
            var c = n[a].types
              , u = c && c[r.code];
            n[a] = _A(a, t, n, i, u ? [].concat(u, r.message) : r.message)
        }
        e.shift()
    }
    return n
}
function lve(e, t) {
    for (var n = {}; e.length; ) {
        var r = e[0]
          , i = r.code
          , o = r.message
          , a = r.path.join(".");
        if (!n[a])
            if (r.code === "invalid_union" && r.errors.length > 0) {
                var s = r.errors[0][0];
                n[a] = {
                    message: s.message,
                    type: s.code
                }
            } else
                n[a] = {
                    message: o,
                    type: i
                };
        if (r.code === "invalid_union" && r.errors.forEach(function(f) {
            return f.forEach(function(h) {
                return e.push(h)
            })
        }),
        t) {
            var c = n[a].types
              , u = c && c[r.code];
            n[a] = _A(a, t, n, i, u ? [].concat(u, r.message) : r.message)
        }
        e.shift()
    }
    return n
}
function LA(e, t, n) {
    if (n === void 0 && (n = {}),
    (function(r) {
        return "_def"in r && typeof r._def == "object" && "typeName"in r._def
    }
    )(e))
        return function(r, i, o) {
            try {
                return Promise.resolve(Vj(function() {
                    return Promise.resolve(e[n.mode === "sync" ? "parse" : "parseAsync"](r, t)).then(function(a) {
                        return o.shouldUseNativeValidation && OT({}, o),
                        {
                            errors: {},
                            values: n.raw ? Object.assign({}, r) : a
                        }
                    })
                }, function(a) {
                    if ((function(s) {
                        return Array.isArray(s?.issues)
                    }
                    )(a))
                        return {
                            values: {},
                            errors: _j(sve(a.errors, !o.shouldUseNativeValidation && o.criteriaMode === "all"), o)
                        };
                    throw a
                }))
            } catch (a) {
                return Promise.reject(a)
            }
        }
        ;
    if ((function(r) {
        return "_zod"in r && typeof r._zod == "object"
    }
    )(e))
        return function(r, i, o) {
            try {
                return Promise.resolve(Vj(function() {
                    return Promise.resolve((n.mode === "sync" ? kbe : Tbe)(e, r, t)).then(function(a) {
                        return o.shouldUseNativeValidation && OT({}, o),
                        {
                            errors: {},
                            values: n.raw ? Object.assign({}, r) : a
                        }
                    })
                }, function(a) {
                    if ((function(s) {
                        return s instanceof IA
                    }
                    )(a))
                        return {
                            values: {},
                            errors: _j(lve(a.issues, !o.shouldUseNativeValidation && o.criteriaMode === "all"), o)
                        };
                    throw a
                }))
            } catch (a) {
                return Promise.reject(a)
            }
        }
        ;
    throw new Error("Invalid input: not a Zod schema")
}
const cve = Ge("ZodISODateTime", (e, t) => {
    Ixe.init(e, t),
    kr.init(e, t)
}
);
function uve(e) {
    return B0e(cve, e)
}
const dve = Ge("ZodISODate", (e, t) => {
    $xe.init(e, t),
    kr.init(e, t)
}
);
function fve(e) {
    return z0e(dve, e)
}
const hve = Ge("ZodISOTime", (e, t) => {
    Lxe.init(e, t),
    kr.init(e, t)
}
);
function pve(e) {
    return F0e(hve, e)
}
const mve = Ge("ZodISODuration", (e, t) => {
    jxe.init(e, t),
    kr.init(e, t)
}
);
function gve(e) {
    return N0e(mve, e)
}
const yve = (e, t) => {
    IA.init(e, t),
    e.name = "ZodError",
    Object.defineProperties(e, {
        format: {
            value: n => wbe(e, n)
        },
        flatten: {
            value: n => Cbe(e, n)
        },
        addIssue: {
            value: n => {
                e.issues.push(n),
                e.message = JSON.stringify(e.issues, IT, 2)
            }
        },
        addIssues: {
            value: n => {
                e.issues.push(...n),
                e.message = JSON.stringify(e.issues, IT, 2)
            }
        },
        isEmpty: {
            get() {
                return e.issues.length === 0
            }
        }
    })
}
  , Ma = Ge("ZodError", yve, {
    Parent: Error
})
  , bve = E1(Ma)
  , xve = A1(Ma)
  , vve = M1(Ma)
  , Sve = P1(Ma)
  , Cve = Abe(Ma)
  , wve = Mbe(Ma)
  , kve = Pbe(Ma)
  , Tve = Rbe(Ma)
  , _ve = Dbe(Ma)
  , Eve = Obe(Ma)
  , Ave = Ibe(Ma)
  , Mve = $be(Ma)
  , Nr = Ge("ZodType", (e, t) => (Or.init(e, t),
e.def = t,
e.type = t.type,
Object.defineProperty(e, "_def", {
    value: t
}),
e.check = (...n) => e.clone(id(t, {
    checks: [...t.checks ?? [], ...n.map(r => typeof r == "function" ? {
        _zod: {
            check: r,
            def: {
                check: "custom"
            },
            onattach: []
        }
    } : r)]
})),
e.clone = (n, r) => Oc(e, n, r),
e.brand = () => e,
e.register = ( (n, r) => (n.add(e, r),
e)),
e.parse = (n, r) => bve(e, n, r, {
    callee: e.parse
}),
e.safeParse = (n, r) => vve(e, n, r),
e.parseAsync = async (n, r) => xve(e, n, r, {
    callee: e.parseAsync
}),
e.safeParseAsync = async (n, r) => Sve(e, n, r),
e.spa = e.safeParseAsync,
e.encode = (n, r) => Cve(e, n, r),
e.decode = (n, r) => wve(e, n, r),
e.encodeAsync = async (n, r) => kve(e, n, r),
e.decodeAsync = async (n, r) => Tve(e, n, r),
e.safeEncode = (n, r) => _ve(e, n, r),
e.safeDecode = (n, r) => Eve(e, n, r),
e.safeEncodeAsync = async (n, r) => Ave(e, n, r),
e.safeDecodeAsync = async (n, r) => Mve(e, n, r),
e.refine = (n, r) => e.check(S1e(n, r)),
e.superRefine = n => e.check(C1e(n)),
e.overwrite = n => e.check(Kg(n)),
e.optional = () => Yj(e),
e.nullable = () => Zj(e),
e.nullish = () => Yj(Zj(e)),
e.nonoptional = n => p1e(e, n),
e.array = () => LT(e),
e.or = n => n1e([e, n]),
e.and = n => i1e(e, n),
e.transform = n => Qj(e, l1e(n)),
e.default = n => d1e(e, n),
e.prefault = n => h1e(e, n),
e.catch = n => g1e(e, n),
e.pipe = n => Qj(e, n),
e.readonly = () => x1e(e),
e.describe = n => {
    const r = e.clone();
    return Kb.add(r, {
        description: n
    }),
    r
}
,
Object.defineProperty(e, "description", {
    get() {
        return Kb.get(e)?.description
    },
    configurable: !0
}),
e.meta = (...n) => {
    if (n.length === 0)
        return Kb.get(e);
    const r = e.clone();
    return Kb.add(r, n[0]),
    r
}
,
e.isOptional = () => e.safeParse(void 0).success,
e.isNullable = () => e.safeParse(null).success,
e))
  , g9 = Ge("_ZodString", (e, t) => {
    $A.init(e, t),
    Nr.init(e, t);
    const n = e._zod.bag;
    e.format = n.format ?? null,
    e.minLength = n.minimum ?? null,
    e.maxLength = n.maximum ?? null,
    e.regex = (...r) => e.check(G0e(...r)),
    e.includes = (...r) => e.check(Q0e(...r)),
    e.startsWith = (...r) => e.check(K0e(...r)),
    e.endsWith = (...r) => e.check(X0e(...r)),
    e.min = (...r) => e.check(j0(...r)),
    e.max = (...r) => e.check(p9(...r)),
    e.length = (...r) => e.check(m9(...r)),
    e.nonempty = (...r) => e.check(j0(1, ...r)),
    e.lowercase = r => e.check(Y0e(r)),
    e.uppercase = r => e.check(Z0e(r)),
    e.trim = () => e.check(eve()),
    e.normalize = (...r) => e.check(J0e(...r)),
    e.toLowerCase = () => e.check(tve()),
    e.toUpperCase = () => e.check(nve())
}
)
  , Pve = Ge("ZodString", (e, t) => {
    $A.init(e, t),
    g9.init(e, t),
    e.email = n => e.check(h9(y9, n)),
    e.url = n => e.check(C0e(Rve, n)),
    e.jwt = n => e.check(j0e(Wve, n)),
    e.emoji = n => e.check(w0e(Dve, n)),
    e.guid = n => e.check(zj(Hj, n)),
    e.uuid = n => e.check(b0e(Xb, n)),
    e.uuidv4 = n => e.check(x0e(Xb, n)),
    e.uuidv6 = n => e.check(v0e(Xb, n)),
    e.uuidv7 = n => e.check(S0e(Xb, n)),
    e.nanoid = n => e.check(k0e(Ove, n)),
    e.guid = n => e.check(zj(Hj, n)),
    e.cuid = n => e.check(T0e(Ive, n)),
    e.cuid2 = n => e.check(_0e($ve, n)),
    e.ulid = n => e.check(E0e(Lve, n)),
    e.base64 = n => e.check(I0e(Vve, n)),
    e.base64url = n => e.check($0e(Hve, n)),
    e.xid = n => e.check(A0e(jve, n)),
    e.ksuid = n => e.check(M0e(Bve, n)),
    e.ipv4 = n => e.check(P0e(zve, n)),
    e.ipv6 = n => e.check(R0e(Fve, n)),
    e.cidrv4 = n => e.check(D0e(Nve, n)),
    e.cidrv6 = n => e.check(O0e(Uve, n)),
    e.e164 = n => e.check(L0e(qve, n)),
    e.datetime = n => e.check(uve(n)),
    e.date = n => e.check(fve(n)),
    e.time = n => e.check(pve(n)),
    e.duration = n => e.check(gve(n))
}
);
function On(e) {
    return y0e(Pve, e)
}
const kr = Ge("ZodStringFormat", (e, t) => {
    xr.init(e, t),
    g9.init(e, t)
}
)
  , y9 = Ge("ZodEmail", (e, t) => {
    Txe.init(e, t),
    kr.init(e, t)
}
);
function Pk(e) {
    return h9(y9, e)
}
const Hj = Ge("ZodGUID", (e, t) => {
    wxe.init(e, t),
    kr.init(e, t)
}
)
  , Xb = Ge("ZodUUID", (e, t) => {
    kxe.init(e, t),
    kr.init(e, t)
}
)
  , Rve = Ge("ZodURL", (e, t) => {
    _xe.init(e, t),
    kr.init(e, t)
}
)
  , Dve = Ge("ZodEmoji", (e, t) => {
    Exe.init(e, t),
    kr.init(e, t)
}
)
  , Ove = Ge("ZodNanoID", (e, t) => {
    Axe.init(e, t),
    kr.init(e, t)
}
)
  , Ive = Ge("ZodCUID", (e, t) => {
    Mxe.init(e, t),
    kr.init(e, t)
}
)
  , $ve = Ge("ZodCUID2", (e, t) => {
    Pxe.init(e, t),
    kr.init(e, t)
}
)
  , Lve = Ge("ZodULID", (e, t) => {
    Rxe.init(e, t),
    kr.init(e, t)
}
)
  , jve = Ge("ZodXID", (e, t) => {
    Dxe.init(e, t),
    kr.init(e, t)
}
)
  , Bve = Ge("ZodKSUID", (e, t) => {
    Oxe.init(e, t),
    kr.init(e, t)
}
)
  , zve = Ge("ZodIPv4", (e, t) => {
    Bxe.init(e, t),
    kr.init(e, t)
}
)
  , Fve = Ge("ZodIPv6", (e, t) => {
    zxe.init(e, t),
    kr.init(e, t)
}
)
  , Nve = Ge("ZodCIDRv4", (e, t) => {
    Fxe.init(e, t),
    kr.init(e, t)
}
)
  , Uve = Ge("ZodCIDRv6", (e, t) => {
    Nxe.init(e, t),
    kr.init(e, t)
}
)
  , Vve = Ge("ZodBase64", (e, t) => {
    Uxe.init(e, t),
    kr.init(e, t)
}
)
  , Hve = Ge("ZodBase64URL", (e, t) => {
    Hxe.init(e, t),
    kr.init(e, t)
}
)
  , qve = Ge("ZodE164", (e, t) => {
    qxe.init(e, t),
    kr.init(e, t)
}
)
  , Wve = Ge("ZodJWT", (e, t) => {
    Gxe.init(e, t),
    kr.init(e, t)
}
)
  , b9 = Ge("ZodNumber", (e, t) => {
    u9.init(e, t),
    Nr.init(e, t),
    e.gt = (r, i) => e.check(Nj(r, i)),
    e.gte = (r, i) => e.check(Mk(r, i)),
    e.min = (r, i) => e.check(Mk(r, i)),
    e.lt = (r, i) => e.check(Fj(r, i)),
    e.lte = (r, i) => e.check(Ak(r, i)),
    e.max = (r, i) => e.check(Ak(r, i)),
    e.int = r => e.check(qj(r)),
    e.safe = r => e.check(qj(r)),
    e.positive = r => e.check(Nj(0, r)),
    e.nonnegative = r => e.check(Mk(0, r)),
    e.negative = r => e.check(Fj(0, r)),
    e.nonpositive = r => e.check(Ak(0, r)),
    e.multipleOf = (r, i) => e.check(Uj(r, i)),
    e.step = (r, i) => e.check(Uj(r, i)),
    e.finite = () => e;
    const n = e._zod.bag;
    e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null,
    e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null,
    e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? .5),
    e.isFinite = !0,
    e.format = n.format ?? null
}
);
function gl(e) {
    return U0e(b9, e)
}
const Gve = Ge("ZodNumberFormat", (e, t) => {
    Yxe.init(e, t),
    b9.init(e, t)
}
);
function qj(e) {
    return V0e(Gve, e)
}
const Yve = Ge("ZodBoolean", (e, t) => {
    Zxe.init(e, t),
    Nr.init(e, t)
}
);
function Zve(e) {
    return H0e(Yve, e)
}
const Qve = Ge("ZodUnknown", (e, t) => {
    Qxe.init(e, t),
    Nr.init(e, t)
}
);
function Wj() {
    return q0e(Qve)
}
const Kve = Ge("ZodNever", (e, t) => {
    Kxe.init(e, t),
    Nr.init(e, t)
}
);
function Xve(e) {
    return W0e(Kve, e)
}
const Jve = Ge("ZodArray", (e, t) => {
    Xxe.init(e, t),
    Nr.init(e, t),
    e.element = t.element,
    e.min = (n, r) => e.check(j0(n, r)),
    e.nonempty = n => e.check(j0(1, n)),
    e.max = (n, r) => e.check(p9(n, r)),
    e.length = (n, r) => e.check(m9(n, r)),
    e.unwrap = () => e.element
}
);
function LT(e, t) {
    return rve(Jve, e, t)
}
const e1e = Ge("ZodObject", (e, t) => {
    e0e.init(e, t),
    Nr.init(e, t),
    sr(e, "shape", () => t.shape),
    e.keyof = () => o1e(Object.keys(e._zod.def.shape)),
    e.catchall = n => e.clone({
        ...e._zod.def,
        catchall: n
    }),
    e.passthrough = () => e.clone({
        ...e._zod.def,
        catchall: Wj()
    }),
    e.loose = () => e.clone({
        ...e._zod.def,
        catchall: Wj()
    }),
    e.strict = () => e.clone({
        ...e._zod.def,
        catchall: Xve()
    }),
    e.strip = () => e.clone({
        ...e._zod.def,
        catchall: void 0
    }),
    e.extend = n => ybe(e, n),
    e.safeExtend = n => bbe(e, n),
    e.merge = n => xbe(e, n),
    e.pick = n => mbe(e, n),
    e.omit = n => gbe(e, n),
    e.partial = (...n) => vbe(x9, e, n[0]),
    e.required = (...n) => Sbe(v9, e, n[0])
}
);
function Xg(e, t) {
    const n = {
        type: "object",
        shape: e ?? {},
        ...$t(t)
    };
    return new e1e(n)
}
const t1e = Ge("ZodUnion", (e, t) => {
    t0e.init(e, t),
    Nr.init(e, t),
    e.options = t.options
}
);
function n1e(e, t) {
    return new t1e({
        type: "union",
        options: e,
        ...$t(t)
    })
}
const r1e = Ge("ZodIntersection", (e, t) => {
    n0e.init(e, t),
    Nr.init(e, t)
}
);
function i1e(e, t) {
    return new r1e({
        type: "intersection",
        left: e,
        right: t
    })
}
const jT = Ge("ZodEnum", (e, t) => {
    r0e.init(e, t),
    Nr.init(e, t),
    e.enum = t.entries,
    e.options = Object.values(t.entries);
    const n = new Set(Object.keys(t.entries));
    e.extract = (r, i) => {
        const o = {};
        for (const a of r)
            if (n.has(a))
                o[a] = t.entries[a];
            else
                throw new Error(`Key ${a} not found in enum`);
        return new jT({
            ...t,
            checks: [],
            ...$t(i),
            entries: o
        })
    }
    ,
    e.exclude = (r, i) => {
        const o = {
            ...t.entries
        };
        for (const a of r)
            if (n.has(a))
                delete o[a];
            else
                throw new Error(`Key ${a} not found in enum`);
        return new jT({
            ...t,
            checks: [],
            ...$t(i),
            entries: o
        })
    }
}
);
function o1e(e, t) {
    const n = Array.isArray(e) ? Object.fromEntries(e.map(r => [r, r])) : e;
    return new jT({
        type: "enum",
        entries: n,
        ...$t(t)
    })
}
const a1e = Ge("ZodLiteral", (e, t) => {
    i0e.init(e, t),
    Nr.init(e, t),
    e.values = new Set(t.values),
    Object.defineProperty(e, "value", {
        get() {
            if (t.values.length > 1)
                throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
            return t.values[0]
        }
    })
}
);
function Gj(e, t) {
    return new a1e({
        type: "literal",
        values: Array.isArray(e) ? e : [e],
        ...$t(t)
    })
}
const s1e = Ge("ZodTransform", (e, t) => {
    o0e.init(e, t),
    Nr.init(e, t),
    e._zod.parse = (n, r) => {
        if (r.direction === "backward")
            throw new K6(e.constructor.name);
        n.addIssue = o => {
            if (typeof o == "string")
                n.issues.push(ng(o, n.value, t));
            else {
                const a = o;
                a.fatal && (a.continue = !1),
                a.code ?? (a.code = "custom"),
                a.input ?? (a.input = n.value),
                a.inst ?? (a.inst = e),
                n.issues.push(ng(a))
            }
        }
        ;
        const i = t.transform(n.value, n);
        return i instanceof Promise ? i.then(o => (n.value = o,
        n)) : (n.value = i,
        n)
    }
}
);
function l1e(e) {
    return new s1e({
        type: "transform",
        transform: e
    })
}
const x9 = Ge("ZodOptional", (e, t) => {
    a0e.init(e, t),
    Nr.init(e, t),
    e.unwrap = () => e._zod.def.innerType
}
);
function Yj(e) {
    return new x9({
        type: "optional",
        innerType: e
    })
}
const c1e = Ge("ZodNullable", (e, t) => {
    s0e.init(e, t),
    Nr.init(e, t),
    e.unwrap = () => e._zod.def.innerType
}
);
function Zj(e) {
    return new c1e({
        type: "nullable",
        innerType: e
    })
}
const u1e = Ge("ZodDefault", (e, t) => {
    l0e.init(e, t),
    Nr.init(e, t),
    e.unwrap = () => e._zod.def.innerType,
    e.removeDefault = e.unwrap
}
);
function d1e(e, t) {
    return new u1e({
        type: "default",
        innerType: e,
        get defaultValue() {
            return typeof t == "function" ? t() : e9(t)
        }
    })
}
const f1e = Ge("ZodPrefault", (e, t) => {
    c0e.init(e, t),
    Nr.init(e, t),
    e.unwrap = () => e._zod.def.innerType
}
);
function h1e(e, t) {
    return new f1e({
        type: "prefault",
        innerType: e,
        get defaultValue() {
            return typeof t == "function" ? t() : e9(t)
        }
    })
}
const v9 = Ge("ZodNonOptional", (e, t) => {
    u0e.init(e, t),
    Nr.init(e, t),
    e.unwrap = () => e._zod.def.innerType
}
);
function p1e(e, t) {
    return new v9({
        type: "nonoptional",
        innerType: e,
        ...$t(t)
    })
}
const m1e = Ge("ZodCatch", (e, t) => {
    d0e.init(e, t),
    Nr.init(e, t),
    e.unwrap = () => e._zod.def.innerType,
    e.removeCatch = e.unwrap
}
);
function g1e(e, t) {
    return new m1e({
        type: "catch",
        innerType: e,
        catchValue: typeof t == "function" ? t : () => t
    })
}
const y1e = Ge("ZodPipe", (e, t) => {
    f0e.init(e, t),
    Nr.init(e, t),
    e.in = t.in,
    e.out = t.out
}
);
function Qj(e, t) {
    return new y1e({
        type: "pipe",
        in: e,
        out: t
    })
}
const b1e = Ge("ZodReadonly", (e, t) => {
    h0e.init(e, t),
    Nr.init(e, t),
    e.unwrap = () => e._zod.def.innerType
}
);
function x1e(e) {
    return new b1e({
        type: "readonly",
        innerType: e
    })
}
const v1e = Ge("ZodCustom", (e, t) => {
    p0e.init(e, t),
    Nr.init(e, t)
}
);
function S1e(e, t={}) {
    return ive(v1e, e, t)
}
function C1e(e) {
    return ove(e)
}
const w1e = Xg({
    productCode: On().min(1, "Product Code is required").max(50, "Product Code cannot exceed 50 characters").regex(/^[A-Za-z0-9-_]+$/, "Product Code can only contain alphanumeric characters, hyphens and underscores"),
    productDescription: On().optional().nullable().transform(e => e === "" ? null : e)
})
  , k1e = (e, t, n, r) => {
    const i = e.target.value;
    i && !t.test(i) && r(n, {
        type: "manual",
        message: "Invalid characters detected"
    })
}
  , Kj = {
    productCode: "",
    productDescription: ""
}
  , T1e = () => {
    const [e,t] = A.useState(!1)
      , [n,r] = A.useState("")
      , [i,o] = A.useState("success")
      , [a,s] = A.useState(!1)
      , c = Os()
      , u = uh()
      , {mutate: f} = j6()
      , h = MA({
        resolver: LA(w1e),
        defaultValues: Kj,
        mode: "onTouched"
    })
      , {control: m, handleSubmit: y, reset: b, formState: v, setError: S, getValues: C} = h
      , {errors: w, isSubmitting: k} = v
      , T = () => {
        const P = C("productCode");
        return P && !/^[A-Za-z0-9-_]+$/.test(P) ? (S("productCode", {
            type: "manual",
            message: "Product Code can only contain alphanumeric characters, hyphens and underscores"
        }),
        !1) : !0
    }
      , E = P => {
        if (!T()) {
            r("Please fix validation errors before submitting"),
            o("error"),
            t(!0);
            return
        }
        s(!0);
        const D = {
            productTypeCode: P.productCode,
            productTypeDesc: P.productDescription || "",
            productDescription: P.productDescription || "",
            TranscationById: 1
        };
        f(D, {
            onSuccess: () => {
                u.invalidateQueries({
                    queryKey: ["productTypes"]
                }),
                r("Product type added successfully"),
                o("success"),
                t(!0),
                setTimeout( () => {
                    c("/products")
                }
                , 1500)
            }
            ,
            onError: $ => {
                console.error("Failed to add product:", $),
                r(`Failed to add product: ${$?.message || "Unknown error"}`),
                o("error"),
                t(!0)
            }
            ,
            onSettled: () => {
                s(!1)
            }
        })
    }
    ;
    return g.jsxs(Be, {
        p: 1,
        children: [g.jsxs(yn, {
            sx: {
                p: 3
            },
            children: [g.jsxs(Be, {
                mb: 3,
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                children: [g.jsx(Ae, {
                    variant: "h5",
                    children: "Add New Product Type"
                }), g.jsx(Mt, {
                    variant: "outlined",
                    onClick: () => c("/products"),
                    size: "small",
                    sx: {
                        borderRadius: "8px",
                        minWidth: "100px"
                    },
                    children: "Back to List"
                })]
            }), g.jsx(TA, {
                ...h,
                children: g.jsxs("form", {
                    onSubmit: y(P => E(P)),
                    children: [g.jsxs(je, {
                        container: !0,
                        spacing: 2,
                        children: [g.jsx(je, {
                            size: {
                                xs: 12
                            },
                            children: g.jsx(Ae, {
                                variant: "body1",
                                gutterBottom: !0,
                                children: "Product Type Details"
                            })
                        }), g.jsx(je, {
                            size: {
                                xs: 12,
                                sm: 12,
                                md: 6
                            },
                            children: g.jsx(un, {
                                name: "productCode",
                                control: m,
                                render: ({field: P}) => g.jsx(ct, {
                                    ...P,
                                    label: "Product Code *",
                                    fullWidth: !0,
                                    size: "small",
                                    error: !!w.productCode,
                                    helperText: w.productCode?.message,
                                    inputProps: {
                                        pattern: "[A-Za-z0-9-_]+",
                                        title: "Product Code can only contain alphanumeric characters, hyphens and underscores"
                                    },
                                    onChange: D => {
                                        P.onChange(D),
                                        k1e(D, /^[A-Za-z0-9-_]+$/, "productCode", S)
                                    }
                                    ,
                                    onBlur: () => {
                                        const D = P.value;
                                        D && !/^[A-Za-z0-9-_]+$/.test(D) && S("productCode", {
                                            type: "manual",
                                            message: "Product Code can only contain alphanumeric characters, hyphens and underscores"
                                        })
                                    }
                                })
                            })
                        }), g.jsx(je, {
                            size: {
                                xs: 12,
                                sm: 12,
                                md: 6
                            },
                            children: g.jsx(un, {
                                name: "productDescription",
                                control: m,
                                render: ({field: P}) => g.jsx(ct, {
                                    ...P,
                                    label: "Product Description",
                                    fullWidth: !0,
                                    size: "small",
                                    multiline: !0,
                                    rows: 2,
                                    error: !!w.productDescription,
                                    helperText: w.productDescription?.message
                                })
                            })
                        }), g.jsxs(je, {
                            size: {
                                xs: 12,
                                sm: 12,
                                md: 6,
                                lg: 12
                            },
                            sx: {
                                mt: 2
                            },
                            children: [g.jsx(Mt, {
                                variant: "contained",
                                type: "submit",
                                disabled: k,
                                size: "small",
                                sx: {
                                    borderRadius: "8px",
                                    minWidth: "100px"
                                },
                                children: k ? g.jsx(Jr, {
                                    size: 20,
                                    color: "inherit"
                                }) : "Submit"
                            }), g.jsx(Mt, {
                                variant: "outlined",
                                onClick: () => b(Kj),
                                disabled: k,
                                size: "small",
                                sx: {
                                    ml: 2,
                                    borderRadius: "8px",
                                    minWidth: "100px"
                                },
                                children: "Reset"
                            })]
                        })]
                    }), g.jsx(jg, {
                        open: a,
                        sx: {
                            color: "#fff",
                            zIndex: P => P.zIndex.drawer + 1
                        },
                        children: g.jsx(Jr, {
                            color: "inherit"
                        })
                    })]
                })
            })]
        }), g.jsx(hh, {
            open: e,
            autoHideDuration: 5e3,
            onClose: () => t(!1),
            anchorOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            children: g.jsx(Mc, {
                onClose: () => t(!1),
                severity: i,
                variant: "filled",
                sx: {
                    width: "100%"
                },
                children: n
            })
        })]
    })
}
  , S9 = _t(g.jsx("path", {
    d: "M3 18h18v-2H3zm0-5h18v-2H3zm0-7v2h18V6z"
}))
  , C9 = _t(g.jsx("path", {
    d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}))
  , _1e = _t(g.jsx("path", {
    d: "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2m6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1z"
}))
  , E1e = _t(g.jsx("path", {
    d: "M11 18h2v-2h-2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4"
}))
  , A1e = _t(g.jsx("path", {
    d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}))
  , M1e = ({onMenuClick: e}) => {
    const [t,n] = A.useState(null)
      , [r,i] = A.useState(null)
      , [o,a] = A.useState("")
      , [s,c] = A.useState(!1)
      , u = Os()
      , f = w => {
        n(w.currentTarget)
    }
      , h = () => {
        n(null)
    }
      , m = w => {
        i(w.currentTarget)
    }
      , y = () => {
        i(null)
    }
      , b = () => {
        n(null),
        u("/login")
    }
      , v = () => {
        u("/profile"),
        h()
    }
      , S = w => {
        a(w.target.value)
    }
      , C = () => {
        a("")
    }
    ;
    return g.jsx(PN, {
        position: "fixed",
        sx: {
            zIndex: w => w.zIndex.drawer + 1
        },
        children: g.jsxs(YE, {
            children: [g.jsx(In, {
                size: "large",
                edge: "start",
                color: "inherit",
                "aria-label": "open drawer",
                sx: {
                    mr: 2
                },
                onClick: w => {
                    w.stopPropagation(),
                    e()
                }
                ,
                children: g.jsx(S9, {})
            }), g.jsx(Ae, {
                variant: "h6",
                component: "div",
                sx: {
                    display: {
                        xs: "none",
                        sm: "block"
                    },
                    mr: 2
                },
                children: g.jsx("img", {
                    src: "/Zitatech-Logo.svg",
                    alt: "InventoryAI Logo",
                    style: {
                        height: 40,
                        verticalAlign: "middle",
                        marginRight: 10
                    }
                })
            }), g.jsx(Be, {
                sx: {
                    flexGrow: 1
                }
            }), g.jsxs(Be, {
                sx: {
                    display: "flex",
                    alignItems: "center",
                    gap: 1
                },
                children: [g.jsxs(yn, {
                    elevation: s ? 4 : 1,
                    sx: {
                        display: "flex",
                        alignItems: "center",
                        width: {
                            xs: "120px",
                            sm: "200px",
                            md: "280px"
                        },
                        borderRadius: 2,
                        px: 1.5,
                        py: .5,
                        mr: 1,
                        transition: "all 0.3s ease",
                        border: s ? "1px solid #1976d2" : "1px solid transparent",
                        "&:hover": {
                            width: {
                                xs: "140px",
                                sm: "240px",
                                md: "320px"
                            }
                        },
                        ...s && {
                            width: {
                                xs: "160px",
                                sm: "280px",
                                md: "360px"
                            }
                        }
                    },
                    children: [g.jsx(C9, {
                        sx: {
                            color: "text.secondary",
                            fontSize: "1.2rem"
                        }
                    }), g.jsx(Lg, {
                        placeholder: "Search...",
                        value: o,
                        onChange: S,
                        onFocus: () => c(!0),
                        onBlur: () => c(!1),
                        sx: {
                            flexGrow: 1,
                            ml: 1,
                            "& .MuiInputBase-input": {
                                padding: "6px 0",
                                fontSize: "0.9rem"
                            }
                        }
                    }), o && g.jsx(In, {
                        size: "small",
                        onClick: C,
                        children: g.jsx(A1e, {
                            fontSize: "small",
                            sx: {
                                color: "text.secondary"
                            }
                        })
                    })]
                }), g.jsx(pc, {
                    title: "Help & Resources",
                    children: g.jsx(In, {
                        color: "inherit",
                        size: "medium",
                        children: g.jsx(E1e, {})
                    })
                }), g.jsx(pc, {
                    title: "Notifications",
                    children: g.jsx(In, {
                        color: "inherit",
                        size: "medium",
                        onClick: m,
                        children: g.jsx(UN, {
                            badgeContent: 3,
                            color: "error",
                            children: g.jsx(_1e, {})
                        })
                    })
                }), g.jsx(In, {
                    size: "medium",
                    "aria-label": "account menu",
                    "aria-controls": "menu-appbar",
                    "aria-haspopup": "true",
                    onClick: f,
                    color: "inherit",
                    children: g.jsx(zu, {
                        sx: {
                            backgroundColor: vX[500],
                            width: 32,
                            height: 32
                        },
                        children: localStorage.getItem("userName")?.[0]?.toUpperCase() || "U"
                    })
                })]
            }), g.jsxs(vf, {
                anchorEl: r,
                open: !!r,
                onClose: y,
                PaperProps: {
                    sx: {
                        width: 320,
                        maxHeight: 360,
                        mt: 1
                    }
                },
                children: [g.jsx(Yr, {
                    sx: {
                        fontWeight: "bold",
                        borderBottom: "1px solid #eee"
                    },
                    children: "Recent Notifications"
                }), g.jsx(Yr, {
                    onClick: y,
                    children: g.jsxs(Be, {
                        children: [g.jsx(Ae, {
                            variant: "body2",
                            fontWeight: "bold",
                            children: "New workflow assigned"
                        }), g.jsx(Ae, {
                            variant: "caption",
                            color: "text.secondary",
                            children: "10 minutes ago"
                        })]
                    })
                }), g.jsx(Yr, {
                    onClick: y,
                    children: g.jsxs(Be, {
                        children: [g.jsx(Ae, {
                            variant: "body2",
                            fontWeight: "bold",
                            children: "Stock level alert"
                        }), g.jsx(Ae, {
                            variant: "caption",
                            color: "text.secondary",
                            children: "2 hours ago"
                        })]
                    })
                }), g.jsx(Yr, {
                    onClick: y,
                    children: g.jsxs(Be, {
                        children: [g.jsx(Ae, {
                            variant: "body2",
                            fontWeight: "bold",
                            children: "System maintenance scheduled"
                        }), g.jsx(Ae, {
                            variant: "caption",
                            color: "text.secondary",
                            children: "Yesterday"
                        })]
                    })
                })]
            }), g.jsxs(vf, {
                id: "menu-appbar",
                anchorEl: t,
                anchorOrigin: {
                    vertical: "top",
                    horizontal: "right"
                },
                keepMounted: !0,
                transformOrigin: {
                    vertical: "top",
                    horizontal: "right"
                },
                open: !!t,
                onClose: h,
                children: [g.jsx(Yr, {
                    onClick: v,
                    children: "Profile"
                }), g.jsx(Yr, {
                    onClick: h,
                    children: "Account Settings"
                }), g.jsx(Yr, {
                    onClick: b,
                    children: "Logout"
                })]
            })]
        })
    })
}
  , P1e = _t(g.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-7 3c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6m7 13H5v-.23c0-.62.28-1.2.76-1.58C7.47 15.82 9.64 15 12 15s4.53.82 6.24 2.19c.48.38.76.97.76 1.58z"
}))
  , Xj = _t(g.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2M9 17H7v-5h2zm4 0h-2v-3h2zm0-5h-2v-2h2zm4 5h-2V7h2z"
}))
  , Jb = _t(g.jsx("path", {
    d: "m20.54 5.23-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27M12 17.5 6.5 12H10v-2h4v2h3.5zM5.12 5l.81-1h12l.94 1z"
}))
  , R1e = _t(g.jsx("path", {
    d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"
}))
  , ex = _t(g.jsx("path", {
    d: "m4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8z"
}))
  , Rk = _t(g.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-5 14H7v-2h7zm3-4H7v-2h10zm0-4H7V7h10z"
}))
  , D1e = _t(g.jsx("path", {
    d: "M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6z"
}))
  , O1e = _t([g.jsx("path", {
    d: "m12 2-5.5 9h11z"
}, "0"), g.jsx("circle", {
    cx: "17.5",
    cy: "17.5",
    r: "4.5"
}, "1"), g.jsx("path", {
    d: "M3 13.5h8v8H3z"
}, "2")])
  , w9 = _t(g.jsx("path", {
    d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2M6 9h12v2H6zm8 5H6v-2h8zm4-6H6V6h12z"
}))
  , I1e = _t(g.jsx("path", {
    d: "M4 4h16v12H5.17L4 17.17zm0-2c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm2 10h8v2H6zm0-3h12v2H6zm0-3h12v2H6z"
}))
  , $1e = _t(g.jsx("path", {
    d: "M15.41 7.41 14 6l-6 6 6 6 1.41-1.41L10.83 12z"
}))
  , Jj = _t(g.jsx("path", {
    d: "M3 13h8V3H3zm0 8h8v-6H3zm10 0h8V11h-8zm0-18v6h8V3z"
}))
  , L1e = _t(g.jsx("path", {
    d: "M19 5v2h-4V5zM9 5v6H5V5zm10 8v6h-4v-6zM9 17v2H5v-2zM21 3h-8v6h8zM11 3H3v10h8zm10 8h-8v10h8zm-10 4H3v6h8z"
}))
  , D1 = _t(g.jsx("path", {
    d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}))
  , eB = _t(g.jsx("path", {
    d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zm2.46-7.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"
}))
  , Dk = _t(g.jsx("path", {
    d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8zm7.5-5-1-1h-5l-1 1H5v2h14V4z"
}))
  , rg = _t(g.jsx("path", {
    d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
}))
  , j1e = _t(g.jsx("path", {
    d: "m17.58 6.25 1.77 1.77L14.37 13H12.6v-1.77zm3.27-.44-1.06-1.06c-.2-.2-.51-.2-.71 0l-.85.85L20 7.37l.85-.85c.2-.2.2-.52 0-.71M18 12.2V17h2v2H4v-2h2v-7c0-2.79 1.91-5.14 4.5-5.8v-.7c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v.7c.82.21 1.57.59 2.21 1.09l-1.43 1.43C13.64 6.26 12.85 6 12 6c-2.21 0-4 1.79-4 4v7h8v-2.8zM10 20h4c0 1.1-.9 2-2 2s-2-.9-2-2"
}))
  , jA = _t(g.jsx("path", {
    d: "m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
}))
  , BA = _t(g.jsx("path", {
    d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}))
  , B1e = _t(g.jsx("path", {
    d: "M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8z"
}))
  , tB = _t(g.jsx("path", {
    d: "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"
}))
  , z1e = _t(g.jsx("path", {
    d: "M20 2H4c-1 0-2 .9-2 2v3.01c0 .72.43 1.34 1 1.69V20c0 1.1 1.1 2 2 2h14c.9 0 2-.9 2-2V8.7c.57-.35 1-.97 1-1.69V4c0-1.1-1-2-2-2m-5 12H9v-2h6zm5-7H4V4h16z"
}))
  , F1e = _t(g.jsx("path", {
    d: "M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6z"
}))
  , N1e = _t(g.jsx("path", {
    d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6z"
}))
  , U1e = _t(g.jsx("path", {
    d: "M3 18h13v-2H3zm0-5h10v-2H3zm0-7v2h13V6zm18 9.59L17.42 12 21 8.41 19.59 7l-5 5 5 5z"
}))
  , V1e = _t(g.jsx("path", {
    d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}))
  , H1e = _t(g.jsx("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.89-2-2-2m0 16H5V7h14zm-5.5-6c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5.67-1.5 1.5-1.5 1.5.67 1.5 1.5M12 9c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5"
}))
  , q1e = _t(g.jsx("path", {
    d: "M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"
}))
  , jx = _t(g.jsx("path", {
    d: "m20.55 5.22-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.15.55L3.46 5.22C3.17 5.57 3 6.01 3 6.5V19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.49-.17-.93-.45-1.28M12 9.5l5.5 5.5H14v2h-4v-2H6.5zM5.12 5l.82-1h12l.93 1z"
}))
  , W1e = [{
    text: "Home",
    icon: g.jsx(tB, {}),
    path: "/home"
}, {
    text: "Chat Assistant",
    icon: g.jsx(I1e, {}),
    path: "/chat"
}, {
    text: "Active Workflows",
    icon: g.jsx(tB, {}),
    path: "/workflow"
}, {
    text: "Master Data",
    icon: g.jsx(z1e, {}),
    children: [{
        text: "Material / Product",
        path: "/form",
        icon: g.jsx(H1e, {})
    }, {
        text: "Customer",
        path: "/vendorform",
        icon: g.jsx(O1e, {})
    }, {
        text: "Supplier / Vendor",
        path: "/vendor",
        icon: g.jsx(Go, {})
    }]
}, {
    text: "Transational Data",
    icon: g.jsx(P1e, {}),
    children: [{
        text: "Purchase Requisition",
        path: "/form",
        icon: g.jsx(Go, {})
    }, {
        text: "Purchase Orders",
        path: "/form/submitted",
        icon: g.jsx(ex, {})
    }, {
        text: "Quotations",
        path: "/form/submitted",
        icon: g.jsx(ex, {})
    }, {
        text: "Sales Orders",
        path: "/form/submitted",
        icon: g.jsx(ex, {})
    }, {
        text: "Inventory",
        path: "/form/submitted",
        icon: g.jsx(ex, {})
    }]
}, {
    text: "Configuration",
    icon: g.jsx(Jj, {}),
    children: [{
        text: "Product Type",
        path: "/products",
        icon: g.jsx(Xj, {})
    }, {
        text: "Product Group",
        path: "/productGroup",
        icon: g.jsx(Rk, {})
    }, {
        text: "Product Category",
        path: "/dashboard/reports",
        icon: g.jsx(Rk, {})
    }]
}, {
    text: "Dashboard",
    icon: g.jsx(Jj, {}),
    children: [{
        text: "Analytics",
        path: "/dashboard/analytics",
        icon: g.jsx(Xj, {})
    }, {
        text: "Reports",
        path: "/dashboard",
        icon: g.jsx(Rk, {})
    }]
}];
function G1e({open: e, onClose: t, isSmallScreen: n}) {
    const [r,i] = A.useState({})
      , [o,a] = A.useState(!1)
      , s = Os()
      , [c,u] = A.useState(window.location.pathname)
      , f = y => {
        u(y),
        s(y),
        n && t()
    }
      , h = y => {
        i(b => ({
            ...b,
            [y]: !b[y]
        }))
    }
      , m = () => {
        a(y => !y)
    }
    ;
    return g.jsx(JN, {
        variant: n ? "temporary" : "permanent",
        open: e && !o,
        onClose: t,
        ModalProps: {
            keepMounted: !0
        },
        sx: {
            width: e && !o ? 250 : 64,
            flexShrink: 0,
            whiteSpace: "nowrap",
            "& .MuiDrawer-paper": {
                width: e && !o ? 250 : 64,
                boxSizing: "border-box",
                overflowX: "hidden",
                height: "100vh",
                display: "flex",
                flexDirection: "column",
                bgcolor: "#f8fafc",
                borderRight: "1px solid #e0e0e0"
            }
        },
        children: g.jsxs(Be, {
            sx: {
                width: e && !o ? 250 : 64,
                height: "100%",
                display: "flex",
                flexDirection: "column"
            },
            children: [g.jsxs(Be, {
                sx: {
                    flex: 1,
                    minHeight: 0,
                    overflowY: "auto"
                },
                children: [g.jsx(Be, {
                    sx: y => y.mixins.toolbar
                }), g.jsx(Fu, {
                    children: W1e.map( ({text: y, icon: b, path: v, children: S}) => g.jsxs(Be, {
                        children: [g.jsx(HE, {
                            disablePadding: !0,
                            sx: {
                                display: "block"
                            },
                            children: g.jsx(pc, {
                                title: !e || o ? y : "",
                                placement: "right",
                                children: g.jsxs(bm, {
                                    onClick: () => S ? h(y) : f(v),
                                    selected: c === v,
                                    sx: {
                                        minHeight: 48,
                                        justifyContent: e && !o ? "initial" : "center",
                                        px: 2.5,
                                        borderRadius: 2,
                                        mb: .5,
                                        bgcolor: c === v ? "rgba(25, 118, 210, 0.12)" : "transparent",
                                        "&:hover": {
                                            bgcolor: "rgba(25, 118, 210, 0.18)"
                                        },
                                        transition: "background-color 0.2s",
                                        boxShadow: c === v ? "0 2px 8px 0 rgba(25,118,210,0.08)" : "none"
                                    },
                                    children: [g.jsx(ha, {
                                        sx: {
                                            minWidth: 0,
                                            mr: e && !o ? 2 : "auto",
                                            justifyContent: "center",
                                            color: c === v ? "primary.main" : "inherit",
                                            transition: "color 0.2s"
                                        },
                                        children: b
                                    }), e && !o && g.jsxs(g.Fragment, {
                                        children: [g.jsx(zo, {
                                            primary: y
                                        }), S && g.jsx(Be, {
                                            sx: {
                                                display: "flex",
                                                alignItems: "center",
                                                ml: 1,
                                                transition: "transform 0.2s",
                                                transform: r[y] ? "rotate(180deg)" : "rotate(0deg)"
                                            },
                                            children: r[y] ? g.jsx(jA, {}) : g.jsx(BA, {})
                                        })]
                                    })]
                                })
                            })
                        }), S && g.jsx(h0, {
                            in: r[y],
                            timeout: "auto",
                            unmountOnExit: !0,
                            children: g.jsx(Fu, {
                                component: "div",
                                disablePadding: !0,
                                children: S.map(C => g.jsxs(bm, {
                                    sx: {
                                        pl: e && !o ? 6 : 2,
                                        justifyContent: e && !o ? "initial" : "center",
                                        borderRadius: 2,
                                        mb: .5,
                                        bgcolor: c === C.path ? "rgba(25, 118, 210, 0.10)" : "transparent",
                                        "&:hover": {
                                            bgcolor: "rgba(25, 118, 210, 0.16)"
                                        },
                                        transition: "background-color 0.2s"
                                    },
                                    selected: c === C.path,
                                    onClick: () => f(C.path),
                                    children: [g.jsx(ha, {
                                        sx: {
                                            minWidth: 0,
                                            mr: e && !o ? 2 : "auto",
                                            justifyContent: "center",
                                            color: c === C.path ? "primary.main" : "inherit",
                                            transition: "color 0.2s"
                                        },
                                        children: C.icon
                                    }), e && !o && g.jsx(zo, {
                                        primary: C.text
                                    }), !e && !n && g.jsx(pc, {
                                        title: C.text,
                                        placement: "right",
                                        children: g.jsx(zo, {
                                            primary: ""
                                        })
                                    })]
                                }, C.text))
                            })
                        })]
                    }, y))
                })]
            }), g.jsxs(Be, {
                sx: {
                    display: "flex",
                    alignItems: "center",
                    px: e && !o ? 2 : 0,
                    py: 1.5,
                    borderTop: "1px solid #e0e0e0",
                    minHeight: 64,
                    bgcolor: "#f3f6fa",
                    transition: "all 0.2s"
                },
                children: [g.jsx(zu, {
                    sx: {
                        width: 36,
                        height: 36,
                        color: "#fffff",
                        backgroundColor: "#3f55a0ff",
                        mr: e && !o ? 1.5 : 0,
                        ml: e && !o ? 0 : "auto"
                    },
                    children: "JD"
                }), e && !o && g.jsxs(Be, {
                    sx: {
                        ml: 1
                    },
                    children: [g.jsx(Be, {
                        sx: {
                            fontWeight: 600,
                            fontSize: 15,
                            color: "#222"
                        },
                        children: "Ravindra Machha"
                    }), g.jsx(Be, {
                        sx: {
                            fontSize: 12,
                            color: "#888"
                        },
                        children: "Admin"
                    })]
                })]
            }), !n && g.jsx(Be, {
                sx: {
                    p: 1,
                    display: "flex",
                    justifyContent: e && !o ? "flex-end" : "center"
                },
                children: g.jsx(pc, {
                    title: e && !o ? "Collapse sidebar" : "Expand sidebar",
                    placement: "right",
                    children: g.jsx(bm, {
                        onClick: m,
                        sx: {
                            borderRadius: 2,
                            minHeight: 40,
                            justifyContent: "center",
                            bgcolor: "#e3e8f0",
                            "&:hover": {
                                bgcolor: "#d1d5db"
                            },
                            transition: "background-color 0.2s"
                        },
                        children: e && !o ? g.jsx($1e, {}) : g.jsx(U1e, {})
                    })
                })
            })]
        })
    })
}
function Y1e() {
    const e = ko()
      , t = n1(e.breakpoints.down("md"))
      , [n,r] = A.useState(!1);
    bt.useEffect( () => {
        t || r(!0)
    }
    , [t]);
    const i = () => {
        r(a => !a)
    }
      , o = () => {
        t && r(!1)
    }
    ;
    return g.jsxs(Be, {
        sx: {
            display: "flex",
            height: "100vh",
            overflow: "hidden"
        },
        children: [g.jsx(M1e, {
            onMenuClick: i
        }), g.jsx(G1e, {
            open: n,
            onClose: o,
            isSmallScreen: t
        }), g.jsx(Be, {
            component: "main",
            sx: {
                flexGrow: 1,
                p: 2,
                mt: 8,
                width: "100%",
                transition: "margin 0.3s",
                overflowX: "hidden",
                minWidth: 0
            },
            children: g.jsx(jQ, {})
        })]
    })
}
function Z1e(e, t) {
    const n = {};
    return (e[e.length - 1] === "" ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")).trim()
}
const Q1e = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u
  , K1e = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u
  , X1e = {};
function nB(e, t) {
    return (X1e.jsx ? K1e : Q1e).test(e)
}
const J1e = /[ \t\n\f\r]/g;
function eSe(e) {
    return typeof e == "object" ? e.type === "text" ? rB(e.value) : !1 : rB(e)
}
function rB(e) {
    return e.replace(J1e, "") === ""
}
class Jg {
    constructor(t, n, r) {
        this.normal = n,
        this.property = t,
        r && (this.space = r)
    }
}
Jg.prototype.normal = {};
Jg.prototype.property = {};
Jg.prototype.space = void 0;
function k9(e, t) {
    const n = {}
      , r = {};
    for (const i of e)
        Object.assign(n, i.property),
        Object.assign(r, i.normal);
    return new Jg(n,r,t)
}
function BT(e) {
    return e.toLowerCase()
}
class Ao {
    constructor(t, n) {
        this.attribute = n,
        this.property = t
    }
}
Ao.prototype.attribute = "";
Ao.prototype.booleanish = !1;
Ao.prototype.boolean = !1;
Ao.prototype.commaOrSpaceSeparated = !1;
Ao.prototype.commaSeparated = !1;
Ao.prototype.defined = !1;
Ao.prototype.mustUseProperty = !1;
Ao.prototype.number = !1;
Ao.prototype.overloadedBoolean = !1;
Ao.prototype.property = "";
Ao.prototype.spaceSeparated = !1;
Ao.prototype.space = void 0;
let tSe = 0;
const an = od()
  , Wr = od()
  , zT = od()
  , at = od()
  , or = od()
  , Tf = od()
  , Bo = od();
function od() {
    return 2 ** ++tSe
}
const FT = Object.freeze(Object.defineProperty({
    __proto__: null,
    boolean: an,
    booleanish: Wr,
    commaOrSpaceSeparated: Bo,
    commaSeparated: Tf,
    number: at,
    overloadedBoolean: zT,
    spaceSeparated: or
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Ok = Object.keys(FT);
class zA extends Ao {
    constructor(t, n, r, i) {
        let o = -1;
        if (super(t, n),
        iB(this, "space", i),
        typeof r == "number")
            for (; ++o < Ok.length; ) {
                const a = Ok[o];
                iB(this, Ok[o], (r & FT[a]) === FT[a])
            }
    }
}
zA.prototype.defined = !0;
function iB(e, t, n) {
    n && (e[t] = n)
}
function bh(e) {
    const t = {}
      , n = {};
    for (const [r,i] of Object.entries(e.properties)) {
        const o = new zA(r,e.transform(e.attributes || {}, r),i,e.space);
        e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0),
        t[r] = o,
        n[BT(r)] = r,
        n[BT(o.attribute)] = r
    }
    return new Jg(t,n,e.space)
}
const T9 = bh({
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: Wr,
        ariaAutoComplete: null,
        ariaBusy: Wr,
        ariaChecked: Wr,
        ariaColCount: at,
        ariaColIndex: at,
        ariaColSpan: at,
        ariaControls: or,
        ariaCurrent: null,
        ariaDescribedBy: or,
        ariaDetails: null,
        ariaDisabled: Wr,
        ariaDropEffect: or,
        ariaErrorMessage: null,
        ariaExpanded: Wr,
        ariaFlowTo: or,
        ariaGrabbed: Wr,
        ariaHasPopup: null,
        ariaHidden: Wr,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: or,
        ariaLevel: at,
        ariaLive: null,
        ariaModal: Wr,
        ariaMultiLine: Wr,
        ariaMultiSelectable: Wr,
        ariaOrientation: null,
        ariaOwns: or,
        ariaPlaceholder: null,
        ariaPosInSet: at,
        ariaPressed: Wr,
        ariaReadOnly: Wr,
        ariaRelevant: null,
        ariaRequired: Wr,
        ariaRoleDescription: or,
        ariaRowCount: at,
        ariaRowIndex: at,
        ariaRowSpan: at,
        ariaSelected: Wr,
        ariaSetSize: at,
        ariaSort: null,
        ariaValueMax: at,
        ariaValueMin: at,
        ariaValueNow: at,
        ariaValueText: null,
        role: null
    },
    transform(e, t) {
        return t === "role" ? t : "aria-" + t.slice(4).toLowerCase()
    }
});
function _9(e, t) {
    return t in e ? e[t] : t
}
function E9(e, t) {
    return _9(e, t.toLowerCase())
}
const nSe = bh({
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
        abbr: null,
        accept: Tf,
        acceptCharset: or,
        accessKey: or,
        action: null,
        allow: null,
        allowFullScreen: an,
        allowPaymentRequest: an,
        allowUserMedia: an,
        alt: null,
        as: null,
        async: an,
        autoCapitalize: null,
        autoComplete: or,
        autoFocus: an,
        autoPlay: an,
        blocking: or,
        capture: null,
        charSet: null,
        checked: an,
        cite: null,
        className: or,
        cols: at,
        colSpan: null,
        content: null,
        contentEditable: Wr,
        controls: an,
        controlsList: or,
        coords: at | Tf,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: an,
        defer: an,
        dir: null,
        dirName: null,
        disabled: an,
        download: zT,
        draggable: Wr,
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: an,
        formTarget: null,
        headers: or,
        height: at,
        hidden: zT,
        high: at,
        href: null,
        hrefLang: null,
        htmlFor: or,
        httpEquiv: or,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: an,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: an,
        itemId: null,
        itemProp: or,
        itemRef: or,
        itemScope: an,
        itemType: or,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: an,
        low: at,
        manifest: null,
        max: null,
        maxLength: at,
        media: null,
        method: null,
        min: null,
        minLength: at,
        multiple: an,
        muted: an,
        name: null,
        nonce: null,
        noModule: an,
        noValidate: an,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeToggle: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: an,
        optimum: at,
        pattern: null,
        ping: or,
        placeholder: null,
        playsInline: an,
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: an,
        referrerPolicy: null,
        rel: or,
        required: an,
        reversed: an,
        rows: at,
        rowSpan: at,
        sandbox: or,
        scope: null,
        scoped: an,
        seamless: an,
        selected: an,
        shadowRootClonable: an,
        shadowRootDelegatesFocus: an,
        shadowRootMode: null,
        shape: null,
        size: at,
        sizes: null,
        slot: null,
        span: at,
        spellCheck: Wr,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: at,
        step: null,
        style: null,
        tabIndex: at,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: an,
        useMap: null,
        value: Wr,
        width: at,
        wrap: null,
        writingSuggestions: null,
        align: null,
        aLink: null,
        archive: or,
        axis: null,
        background: null,
        bgColor: null,
        border: at,
        borderColor: null,
        bottomMargin: at,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: an,
        declare: an,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: at,
        leftMargin: at,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: at,
        marginWidth: at,
        noResize: an,
        noHref: an,
        noShade: an,
        noWrap: an,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: at,
        rules: null,
        scheme: null,
        scrolling: Wr,
        standby: null,
        summary: null,
        text: null,
        topMargin: at,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: at,
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: an,
        disableRemotePlayback: an,
        prefix: null,
        property: null,
        results: at,
        security: null,
        unselectable: null
    },
    space: "html",
    transform: E9
})
  , rSe = bh({
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    properties: {
        about: Bo,
        accentHeight: at,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: at,
        amplitude: at,
        arabicForm: null,
        ascent: at,
        attributeName: null,
        attributeType: null,
        azimuth: at,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: at,
        by: null,
        calcMode: null,
        capHeight: at,
        className: or,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: at,
        diffuseConstant: at,
        direction: null,
        display: null,
        dur: null,
        divisor: at,
        dominantBaseline: null,
        download: an,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: at,
        enableBackground: null,
        end: null,
        event: null,
        exponent: at,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: at,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: Tf,
        g2: Tf,
        glyphName: Tf,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: at,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: at,
        horizOriginX: at,
        horizOriginY: at,
        id: null,
        ideographic: at,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: at,
        k: at,
        k1: at,
        k2: at,
        k3: at,
        k4: at,
        kernelMatrix: Bo,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: at,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: at,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: at,
        overlineThickness: at,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: at,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: or,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: at,
        pointsAtY: at,
        pointsAtZ: at,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: Bo,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: Bo,
        rev: Bo,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: Bo,
        requiredFeatures: Bo,
        requiredFonts: Bo,
        requiredFormats: Bo,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: at,
        specularExponent: at,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: at,
        strikethroughThickness: at,
        string: null,
        stroke: null,
        strokeDashArray: Bo,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: at,
        strokeOpacity: at,
        strokeWidth: null,
        style: null,
        surfaceScale: at,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: Bo,
        tabIndex: at,
        tableValues: null,
        target: null,
        targetX: at,
        targetY: at,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: Bo,
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: at,
        underlineThickness: at,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: at,
        values: null,
        vAlphabetic: at,
        vMathematical: at,
        vectorEffect: null,
        vHanging: at,
        vIdeographic: at,
        version: null,
        vertAdvY: at,
        vertOriginX: at,
        vertOriginY: at,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: at,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    },
    space: "svg",
    transform: _9
})
  , A9 = bh({
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    },
    space: "xlink",
    transform(e, t) {
        return "xlink:" + t.slice(5).toLowerCase()
    }
})
  , M9 = bh({
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    properties: {
        xmlnsXLink: null,
        xmlns: null
    },
    space: "xmlns",
    transform: E9
})
  , P9 = bh({
    properties: {
        xmlBase: null,
        xmlLang: null,
        xmlSpace: null
    },
    space: "xml",
    transform(e, t) {
        return "xml:" + t.slice(3).toLowerCase()
    }
})
  , iSe = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
}
  , oSe = /[A-Z]/g
  , oB = /-[a-z]/g
  , aSe = /^data[-\w.:]+$/i;
function sSe(e, t) {
    const n = BT(t);
    let r = t
      , i = Ao;
    if (n in e.normal)
        return e.property[e.normal[n]];
    if (n.length > 4 && n.slice(0, 4) === "data" && aSe.test(t)) {
        if (t.charAt(4) === "-") {
            const o = t.slice(5).replace(oB, cSe);
            r = "data" + o.charAt(0).toUpperCase() + o.slice(1)
        } else {
            const o = t.slice(4);
            if (!oB.test(o)) {
                let a = o.replace(oSe, lSe);
                a.charAt(0) !== "-" && (a = "-" + a),
                t = "data" + a
            }
        }
        i = zA
    }
    return new i(r,t)
}
function lSe(e) {
    return "-" + e.toLowerCase()
}
function cSe(e) {
    return e.charAt(1).toUpperCase()
}
const uSe = k9([T9, nSe, A9, M9, P9], "html")
  , FA = k9([T9, rSe, A9, M9, P9], "svg");
function dSe(e) {
    return e.join(" ").trim()
}
var Xd = {}, Ik, aB;
function fSe() {
    if (aB)
        return Ik;
    aB = 1;
    var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g
      , t = /\n/g
      , n = /^\s*/
      , r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/
      , i = /^:\s*/
      , o = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/
      , a = /^[;\s]*/
      , s = /^\s+|\s+$/g
      , c = `
`
      , u = "/"
      , f = "*"
      , h = ""
      , m = "comment"
      , y = "declaration";
    Ik = function(v, S) {
        if (typeof v != "string")
            throw new TypeError("First argument must be a string");
        if (!v)
            return [];
        S = S || {};
        var C = 1
          , w = 1;
        function k(B) {
            var L = B.match(t);
            L && (C += L.length);
            var F = B.lastIndexOf(c);
            w = ~F ? B.length - F : w + B.length
        }
        function T() {
            var B = {
                line: C,
                column: w
            };
            return function(L) {
                return L.position = new E(B),
                $(),
                L
            }
        }
        function E(B) {
            this.start = B,
            this.end = {
                line: C,
                column: w
            },
            this.source = S.source
        }
        E.prototype.content = v;
        function P(B) {
            var L = new Error(S.source + ":" + C + ":" + w + ": " + B);
            if (L.reason = B,
            L.filename = S.source,
            L.line = C,
            L.column = w,
            L.source = v,
            !S.silent)
                throw L
        }
        function D(B) {
            var L = B.exec(v);
            if (L) {
                var F = L[0];
                return k(F),
                v = v.slice(F.length),
                L
            }
        }
        function $() {
            D(n)
        }
        function z(B) {
            var L;
            for (B = B || []; L = O(); )
                L !== !1 && B.push(L);
            return B
        }
        function O() {
            var B = T();
            if (!(u != v.charAt(0) || f != v.charAt(1))) {
                for (var L = 2; h != v.charAt(L) && (f != v.charAt(L) || u != v.charAt(L + 1)); )
                    ++L;
                if (L += 2,
                h === v.charAt(L - 1))
                    return P("End of comment missing");
                var F = v.slice(2, L - 2);
                return w += 2,
                k(F),
                v = v.slice(L),
                w += 2,
                B({
                    type: m,
                    comment: F
                })
            }
        }
        function I() {
            var B = T()
              , L = D(r);
            if (L) {
                if (O(),
                !D(i))
                    return P("property missing ':'");
                var F = D(o)
                  , j = B({
                    type: y,
                    property: b(L[0].replace(e, h)),
                    value: F ? b(F[0].replace(e, h)) : h
                });
                return D(a),
                j
            }
        }
        function M() {
            var B = [];
            z(B);
            for (var L; L = I(); )
                L !== !1 && (B.push(L),
                z(B));
            return B
        }
        return $(),
        M()
    }
    ;
    function b(v) {
        return v ? v.replace(s, h) : h
    }
    return Ik
}
var sB;
function hSe() {
    if (sB)
        return Xd;
    sB = 1;
    var e = Xd && Xd.__importDefault || function(r) {
        return r && r.__esModule ? r : {
            default: r
        }
    }
    ;
    Object.defineProperty(Xd, "__esModule", {
        value: !0
    }),
    Xd.default = n;
    const t = e(fSe());
    function n(r, i) {
        let o = null;
        if (!r || typeof r != "string")
            return o;
        const a = (0,
        t.default)(r)
          , s = typeof i == "function";
        return a.forEach(c => {
            if (c.type !== "declaration")
                return;
            const {property: u, value: f} = c;
            s ? i(u, f, c) : f && (o = o || {},
            o[u] = f)
        }
        ),
        o
    }
    return Xd
}
var Mp = {}, lB;
function pSe() {
    if (lB)
        return Mp;
    lB = 1,
    Object.defineProperty(Mp, "__esModule", {
        value: !0
    }),
    Mp.camelCase = void 0;
    var e = /^--[a-zA-Z0-9_-]+$/
      , t = /-([a-z])/g
      , n = /^[^-]+$/
      , r = /^-(webkit|moz|ms|o|khtml)-/
      , i = /^-(ms)-/
      , o = function(u) {
        return !u || n.test(u) || e.test(u)
    }
      , a = function(u, f) {
        return f.toUpperCase()
    }
      , s = function(u, f) {
        return "".concat(f, "-")
    }
      , c = function(u, f) {
        return f === void 0 && (f = {}),
        o(u) ? u : (u = u.toLowerCase(),
        f.reactCompat ? u = u.replace(i, s) : u = u.replace(r, s),
        u.replace(t, a))
    };
    return Mp.camelCase = c,
    Mp
}
var Pp, cB;
function mSe() {
    if (cB)
        return Pp;
    cB = 1;
    var e = Pp && Pp.__importDefault || function(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
      , t = e(hSe())
      , n = pSe();
    function r(i, o) {
        var a = {};
        return !i || typeof i != "string" || (0,
        t.default)(i, function(s, c) {
            s && c && (a[(0,
            n.camelCase)(s, o)] = c)
        }),
        a
    }
    return r.default = r,
    Pp = r,
    Pp
}
var gSe = mSe();
const ySe = es(gSe)
  , R9 = D9("end")
  , NA = D9("start");
function D9(e) {
    return t;
    function t(n) {
        const r = n && n.position && n.position[e] || {};
        if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
            return {
                line: r.line,
                column: r.column,
                offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
            }
    }
}
function bSe(e) {
    const t = NA(e)
      , n = R9(e);
    if (t && n)
        return {
            start: t,
            end: n
        }
}
function _m(e) {
    return !e || typeof e != "object" ? "" : "position"in e || "type"in e ? uB(e.position) : "start"in e || "end"in e ? uB(e) : "line"in e || "column"in e ? NT(e) : ""
}
function NT(e) {
    return dB(e && e.line) + ":" + dB(e && e.column)
}
function uB(e) {
    return NT(e && e.start) + "-" + NT(e && e.end)
}
function dB(e) {
    return e && typeof e == "number" ? e : 1
}
class Di extends Error {
    constructor(t, n, r) {
        super(),
        typeof n == "string" && (r = n,
        n = void 0);
        let i = ""
          , o = {}
          , a = !1;
        if (n && ("line"in n && "column"in n ? o = {
            place: n
        } : "start"in n && "end"in n ? o = {
            place: n
        } : "type"in n ? o = {
            ancestors: [n],
            place: n.position
        } : o = {
            ...n
        }),
        typeof t == "string" ? i = t : !o.cause && t && (a = !0,
        i = t.message,
        o.cause = t),
        !o.ruleId && !o.source && typeof r == "string") {
            const c = r.indexOf(":");
            c === -1 ? o.ruleId = r : (o.source = r.slice(0, c),
            o.ruleId = r.slice(c + 1))
        }
        if (!o.place && o.ancestors && o.ancestors) {
            const c = o.ancestors[o.ancestors.length - 1];
            c && (o.place = c.position)
        }
        const s = o.place && "start"in o.place ? o.place.start : o.place;
        this.ancestors = o.ancestors || void 0,
        this.cause = o.cause || void 0,
        this.column = s ? s.column : void 0,
        this.fatal = void 0,
        this.file = "",
        this.message = i,
        this.line = s ? s.line : void 0,
        this.name = _m(o.place) || "1:1",
        this.place = o.place || void 0,
        this.reason = this.message,
        this.ruleId = o.ruleId || void 0,
        this.source = o.source || void 0,
        this.stack = a && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "",
        this.actual = void 0,
        this.expected = void 0,
        this.note = void 0,
        this.url = void 0
    }
}
Di.prototype.file = "";
Di.prototype.name = "";
Di.prototype.reason = "";
Di.prototype.message = "";
Di.prototype.stack = "";
Di.prototype.column = void 0;
Di.prototype.line = void 0;
Di.prototype.ancestors = void 0;
Di.prototype.cause = void 0;
Di.prototype.fatal = void 0;
Di.prototype.place = void 0;
Di.prototype.ruleId = void 0;
Di.prototype.source = void 0;
const UA = {}.hasOwnProperty
  , xSe = new Map
  , vSe = /[A-Z]/g
  , SSe = new Set(["table", "tbody", "thead", "tfoot", "tr"])
  , CSe = new Set(["td", "th"])
  , O9 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function wSe(e, t) {
    if (!t || t.Fragment === void 0)
        throw new TypeError("Expected `Fragment` in options");
    const n = t.filePath || void 0;
    let r;
    if (t.development) {
        if (typeof t.jsxDEV != "function")
            throw new TypeError("Expected `jsxDEV` in options when `development: true`");
        r = RSe(n, t.jsxDEV)
    } else {
        if (typeof t.jsx != "function")
            throw new TypeError("Expected `jsx` in production options");
        if (typeof t.jsxs != "function")
            throw new TypeError("Expected `jsxs` in production options");
        r = PSe(n, t.jsx, t.jsxs)
    }
    const i = {
        Fragment: t.Fragment,
        ancestors: [],
        components: t.components || {},
        create: r,
        elementAttributeNameCase: t.elementAttributeNameCase || "react",
        evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
        filePath: n,
        ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
        passKeys: t.passKeys !== !1,
        passNode: t.passNode || !1,
        schema: t.space === "svg" ? FA : uSe,
        stylePropertyNameCase: t.stylePropertyNameCase || "dom",
        tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
    }
      , o = I9(i, e, void 0);
    return o && typeof o != "string" ? o : i.create(e, i.Fragment, {
        children: o || void 0
    }, void 0)
}
function I9(e, t, n) {
    if (t.type === "element")
        return kSe(e, t, n);
    if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
        return TSe(e, t);
    if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
        return ESe(e, t, n);
    if (t.type === "mdxjsEsm")
        return _Se(e, t);
    if (t.type === "root")
        return ASe(e, t, n);
    if (t.type === "text")
        return MSe(e, t)
}
function kSe(e, t, n) {
    const r = e.schema;
    let i = r;
    t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = FA,
    e.schema = i),
    e.ancestors.push(t);
    const o = L9(e, t.tagName, !1)
      , a = DSe(e, t);
    let s = HA(e, t);
    return SSe.has(t.tagName) && (s = s.filter(function(c) {
        return typeof c == "string" ? !eSe(c) : !0
    })),
    $9(e, a, o, t),
    VA(a, s),
    e.ancestors.pop(),
    e.schema = r,
    e.create(t, o, a, n)
}
function TSe(e, t) {
    if (t.data && t.data.estree && e.evaluater) {
        const r = t.data.estree.body[0];
        return r.type,
        e.evaluater.evaluateExpression(r.expression)
    }
    ig(e, t.position)
}
function _Se(e, t) {
    if (t.data && t.data.estree && e.evaluater)
        return e.evaluater.evaluateProgram(t.data.estree);
    ig(e, t.position)
}
function ESe(e, t, n) {
    const r = e.schema;
    let i = r;
    t.name === "svg" && r.space === "html" && (i = FA,
    e.schema = i),
    e.ancestors.push(t);
    const o = t.name === null ? e.Fragment : L9(e, t.name, !0)
      , a = OSe(e, t)
      , s = HA(e, t);
    return $9(e, a, o, t),
    VA(a, s),
    e.ancestors.pop(),
    e.schema = r,
    e.create(t, o, a, n)
}
function ASe(e, t, n) {
    const r = {};
    return VA(r, HA(e, t)),
    e.create(t, e.Fragment, r, n)
}
function MSe(e, t) {
    return t.value
}
function $9(e, t, n, r) {
    typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r)
}
function VA(e, t) {
    if (t.length > 0) {
        const n = t.length > 1 ? t : t[0];
        n && (e.children = n)
    }
}
function PSe(e, t, n) {
    return r;
    function r(i, o, a, s) {
        const u = Array.isArray(a.children) ? n : t;
        return s ? u(o, a, s) : u(o, a)
    }
}
function RSe(e, t) {
    return n;
    function n(r, i, o, a) {
        const s = Array.isArray(o.children)
          , c = NA(r);
        return t(i, o, a, s, {
            columnNumber: c ? c.column - 1 : void 0,
            fileName: e,
            lineNumber: c ? c.line : void 0
        }, void 0)
    }
}
function DSe(e, t) {
    const n = {};
    let r, i;
    for (i in t.properties)
        if (i !== "children" && UA.call(t.properties, i)) {
            const o = ISe(e, i, t.properties[i]);
            if (o) {
                const [a,s] = o;
                e.tableCellAlignToStyle && a === "align" && typeof s == "string" && CSe.has(t.tagName) ? r = s : n[a] = s
            }
        }
    if (r) {
        const o = n.style || (n.style = {});
        o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r
    }
    return n
}
function OSe(e, t) {
    const n = {};
    for (const r of t.attributes)
        if (r.type === "mdxJsxExpressionAttribute")
            if (r.data && r.data.estree && e.evaluater) {
                const o = r.data.estree.body[0];
                o.type;
                const a = o.expression;
                a.type;
                const s = a.properties[0];
                s.type,
                Object.assign(n, e.evaluater.evaluateExpression(s.argument))
            } else
                ig(e, t.position);
        else {
            const i = r.name;
            let o;
            if (r.value && typeof r.value == "object")
                if (r.value.data && r.value.data.estree && e.evaluater) {
                    const s = r.value.data.estree.body[0];
                    s.type,
                    o = e.evaluater.evaluateExpression(s.expression)
                } else
                    ig(e, t.position);
            else
                o = r.value === null ? !0 : r.value;
            n[i] = o
        }
    return n
}
function HA(e, t) {
    const n = [];
    let r = -1;
    const i = e.passKeys ? new Map : xSe;
    for (; ++r < t.children.length; ) {
        const o = t.children[r];
        let a;
        if (e.passKeys) {
            const c = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
            if (c) {
                const u = i.get(c) || 0;
                a = c + "-" + u,
                i.set(c, u + 1)
            }
        }
        const s = I9(e, o, a);
        s !== void 0 && n.push(s)
    }
    return n
}
function ISe(e, t, n) {
    const r = sSe(e.schema, t);
    if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
        if (Array.isArray(n) && (n = r.commaSeparated ? Z1e(n) : dSe(n)),
        r.property === "style") {
            let i = typeof n == "object" ? n : $Se(e, String(n));
            return e.stylePropertyNameCase === "css" && (i = LSe(i)),
            ["style", i]
        }
        return [e.elementAttributeNameCase === "react" && r.space ? iSe[r.property] || r.property : r.attribute, n]
    }
}
function $Se(e, t) {
    try {
        return ySe(t, {
            reactCompat: !0
        })
    } catch (n) {
        if (e.ignoreInvalidStyle)
            return {};
        const r = n
          , i = new Di("Cannot parse `style` attribute",{
            ancestors: e.ancestors,
            cause: r,
            ruleId: "style",
            source: "hast-util-to-jsx-runtime"
        });
        throw i.file = e.filePath || void 0,
        i.url = O9 + "#cannot-parse-style-attribute",
        i
    }
}
function L9(e, t, n) {
    let r;
    if (!n)
        r = {
            type: "Literal",
            value: t
        };
    else if (t.includes(".")) {
        const i = t.split(".");
        let o = -1, a;
        for (; ++o < i.length; ) {
            const s = nB(i[o]) ? {
                type: "Identifier",
                name: i[o]
            } : {
                type: "Literal",
                value: i[o]
            };
            a = a ? {
                type: "MemberExpression",
                object: a,
                property: s,
                computed: !!(o && s.type === "Literal"),
                optional: !1
            } : s
        }
        r = a
    } else
        r = nB(t) && !/^[a-z]/.test(t) ? {
            type: "Identifier",
            name: t
        } : {
            type: "Literal",
            value: t
        };
    if (r.type === "Literal") {
        const i = r.value;
        return UA.call(e.components, i) ? e.components[i] : i
    }
    if (e.evaluater)
        return e.evaluater.evaluateExpression(r);
    ig(e)
}
function ig(e, t) {
    const n = new Di("Cannot handle MDX estrees without `createEvaluater`",{
        ancestors: e.ancestors,
        place: t,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime"
    });
    throw n.file = e.filePath || void 0,
    n.url = O9 + "#cannot-handle-mdx-estrees-without-createevaluater",
    n
}
function LSe(e) {
    const t = {};
    let n;
    for (n in e)
        UA.call(e, n) && (t[jSe(n)] = e[n]);
    return t
}
function jSe(e) {
    let t = e.replace(vSe, BSe);
    return t.slice(0, 3) === "ms-" && (t = "-" + t),
    t
}
function BSe(e) {
    return "-" + e.toLowerCase()
}
const $k = {
    action: ["form"],
    cite: ["blockquote", "del", "ins", "q"],
    data: ["object"],
    formAction: ["button", "input"],
    href: ["a", "area", "base", "link"],
    icon: ["menuitem"],
    itemId: null,
    manifest: ["html"],
    ping: ["a", "area"],
    poster: ["video"],
    src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"]
}
  , zSe = {};
function qA(e, t) {
    const n = zSe
      , r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0
      , i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
    return j9(e, r, i)
}
function j9(e, t, n) {
    if (FSe(e)) {
        if ("value"in e)
            return e.type === "html" && !n ? "" : e.value;
        if (t && "alt"in e && e.alt)
            return e.alt;
        if ("children"in e)
            return fB(e.children, t, n)
    }
    return Array.isArray(e) ? fB(e, t, n) : ""
}
function fB(e, t, n) {
    const r = [];
    let i = -1;
    for (; ++i < e.length; )
        r[i] = j9(e[i], t, n);
    return r.join("")
}
function FSe(e) {
    return !!(e && typeof e == "object")
}
const hB = document.createElement("i");
function WA(e) {
    const t = "&" + e + ";";
    hB.innerHTML = t;
    const n = hB.textContent;
    return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
}
function Yo(e, t, n, r) {
    const i = e.length;
    let o = 0, a;
    if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t,
    n = n > 0 ? n : 0,
    r.length < 1e4)
        a = Array.from(r),
        a.unshift(t, n),
        e.splice(...a);
    else
        for (n && e.splice(t, n); o < r.length; )
            a = r.slice(o, o + 1e4),
            a.unshift(t, 0),
            e.splice(...a),
            o += 1e4,
            t += 1e4
}
function ya(e, t) {
    return e.length > 0 ? (Yo(e, e.length, 0, t),
    e) : t
}
const pB = {}.hasOwnProperty;
function B9(e) {
    const t = {};
    let n = -1;
    for (; ++n < e.length; )
        NSe(t, e[n]);
    return t
}
function NSe(e, t) {
    let n;
    for (n in t) {
        const i = (pB.call(e, n) ? e[n] : void 0) || (e[n] = {})
          , o = t[n];
        let a;
        if (o)
            for (a in o) {
                pB.call(i, a) || (i[a] = []);
                const s = o[a];
                USe(i[a], Array.isArray(s) ? s : s ? [s] : [])
            }
    }
}
function USe(e, t) {
    let n = -1;
    const r = [];
    for (; ++n < t.length; )
        (t[n].add === "after" ? e : r).push(t[n]);
    Yo(e, 0, 0, r)
}
function z9(e, t) {
    const n = Number.parseInt(e, t);
    return n < 9 || n === 11 || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || (n & 65535) === 65535 || (n & 65535) === 65534 || n > 1114111 ? "" : String.fromCodePoint(n)
}
function Ga(e) {
    return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase()
}
const Ni = Ic(/[A-Za-z]/)
  , Ai = Ic(/[\dA-Za-z]/)
  , VSe = Ic(/[#-'*+\--9=?A-Z^-~]/);
function B0(e) {
    return e !== null && (e < 32 || e === 127)
}
const UT = Ic(/\d/)
  , HSe = Ic(/[\dA-Fa-f]/)
  , qSe = Ic(/[!-/:-@[-`{-~]/);
function zt(e) {
    return e !== null && e < -2
}
function ir(e) {
    return e !== null && (e < 0 || e === 32)
}
function bn(e) {
    return e === -2 || e === -1 || e === 32
}
const O1 = Ic(new RegExp("\\p{P}|\\p{S}","u"))
  , Gu = Ic(/\s/);
function Ic(e) {
    return t;
    function t(n) {
        return n !== null && n > -1 && e.test(String.fromCharCode(n))
    }
}
function xh(e) {
    const t = [];
    let n = -1
      , r = 0
      , i = 0;
    for (; ++n < e.length; ) {
        const o = e.charCodeAt(n);
        let a = "";
        if (o === 37 && Ai(e.charCodeAt(n + 1)) && Ai(e.charCodeAt(n + 2)))
            i = 2;
        else if (o < 128)
            /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (a = String.fromCharCode(o));
        else if (o > 55295 && o < 57344) {
            const s = e.charCodeAt(n + 1);
            o < 56320 && s > 56319 && s < 57344 ? (a = String.fromCharCode(o, s),
            i = 1) : a = ""
        } else
            a = String.fromCharCode(o);
        a && (t.push(e.slice(r, n), encodeURIComponent(a)),
        r = n + i + 1,
        a = ""),
        i && (n += i,
        i = 0)
    }
    return t.join("") + e.slice(r)
}
function An(e, t, n, r) {
    const i = r ? r - 1 : Number.POSITIVE_INFINITY;
    let o = 0;
    return a;
    function a(c) {
        return bn(c) ? (e.enter(n),
        s(c)) : t(c)
    }
    function s(c) {
        return bn(c) && o++ < i ? (e.consume(c),
        s) : (e.exit(n),
        t(c))
    }
}
const WSe = {
    tokenize: GSe
};
function GSe(e) {
    const t = e.attempt(this.parser.constructs.contentInitial, r, i);
    let n;
    return t;
    function r(s) {
        if (s === null) {
            e.consume(s);
            return
        }
        return e.enter("lineEnding"),
        e.consume(s),
        e.exit("lineEnding"),
        An(e, t, "linePrefix")
    }
    function i(s) {
        return e.enter("paragraph"),
        o(s)
    }
    function o(s) {
        const c = e.enter("chunkText", {
            contentType: "text",
            previous: n
        });
        return n && (n.next = c),
        n = c,
        a(s)
    }
    function a(s) {
        if (s === null) {
            e.exit("chunkText"),
            e.exit("paragraph"),
            e.consume(s);
            return
        }
        return zt(s) ? (e.consume(s),
        e.exit("chunkText"),
        o) : (e.consume(s),
        a)
    }
}
const YSe = {
    tokenize: ZSe
}
  , mB = {
    tokenize: QSe
};
function ZSe(e) {
    const t = this
      , n = [];
    let r = 0, i, o, a;
    return s;
    function s(k) {
        if (r < n.length) {
            const T = n[r];
            return t.containerState = T[1],
            e.attempt(T[0].continuation, c, u)(k)
        }
        return u(k)
    }
    function c(k) {
        if (r++,
        t.containerState._closeFlow) {
            t.containerState._closeFlow = void 0,
            i && w();
            const T = t.events.length;
            let E = T, P;
            for (; E--; )
                if (t.events[E][0] === "exit" && t.events[E][1].type === "chunkFlow") {
                    P = t.events[E][1].end;
                    break
                }
            C(r);
            let D = T;
            for (; D < t.events.length; )
                t.events[D][1].end = {
                    ...P
                },
                D++;
            return Yo(t.events, E + 1, 0, t.events.slice(T)),
            t.events.length = D,
            u(k)
        }
        return s(k)
    }
    function u(k) {
        if (r === n.length) {
            if (!i)
                return m(k);
            if (i.currentConstruct && i.currentConstruct.concrete)
                return b(k);
            t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack)
        }
        return t.containerState = {},
        e.check(mB, f, h)(k)
    }
    function f(k) {
        return i && w(),
        C(r),
        m(k)
    }
    function h(k) {
        return t.parser.lazy[t.now().line] = r !== n.length,
        a = t.now().offset,
        b(k)
    }
    function m(k) {
        return t.containerState = {},
        e.attempt(mB, y, b)(k)
    }
    function y(k) {
        return r++,
        n.push([t.currentConstruct, t.containerState]),
        m(k)
    }
    function b(k) {
        if (k === null) {
            i && w(),
            C(0),
            e.consume(k);
            return
        }
        return i = i || t.parser.flow(t.now()),
        e.enter("chunkFlow", {
            _tokenizer: i,
            contentType: "flow",
            previous: o
        }),
        v(k)
    }
    function v(k) {
        if (k === null) {
            S(e.exit("chunkFlow"), !0),
            C(0),
            e.consume(k);
            return
        }
        return zt(k) ? (e.consume(k),
        S(e.exit("chunkFlow")),
        r = 0,
        t.interrupt = void 0,
        s) : (e.consume(k),
        v)
    }
    function S(k, T) {
        const E = t.sliceStream(k);
        if (T && E.push(null),
        k.previous = o,
        o && (o.next = k),
        o = k,
        i.defineSkip(k.start),
        i.write(E),
        t.parser.lazy[k.start.line]) {
            let P = i.events.length;
            for (; P--; )
                if (i.events[P][1].start.offset < a && (!i.events[P][1].end || i.events[P][1].end.offset > a))
                    return;
            const D = t.events.length;
            let $ = D, z, O;
            for (; $--; )
                if (t.events[$][0] === "exit" && t.events[$][1].type === "chunkFlow") {
                    if (z) {
                        O = t.events[$][1].end;
                        break
                    }
                    z = !0
                }
            for (C(r),
            P = D; P < t.events.length; )
                t.events[P][1].end = {
                    ...O
                },
                P++;
            Yo(t.events, $ + 1, 0, t.events.slice(D)),
            t.events.length = P
        }
    }
    function C(k) {
        let T = n.length;
        for (; T-- > k; ) {
            const E = n[T];
            t.containerState = E[1],
            E[0].exit.call(t, e)
        }
        n.length = k
    }
    function w() {
        i.write([null]),
        o = void 0,
        i = void 0,
        t.containerState._closeFlow = void 0
    }
}
function QSe(e, t, n) {
    return An(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)
}
function Kf(e) {
    if (e === null || ir(e) || Gu(e))
        return 1;
    if (O1(e))
        return 2
}
function I1(e, t, n) {
    const r = [];
    let i = -1;
    for (; ++i < e.length; ) {
        const o = e[i].resolveAll;
        o && !r.includes(o) && (t = o(t, n),
        r.push(o))
    }
    return t
}
const VT = {
    name: "attention",
    resolveAll: KSe,
    tokenize: XSe
};
function KSe(e, t) {
    let n = -1, r, i, o, a, s, c, u, f;
    for (; ++n < e.length; )
        if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
            for (r = n; r--; )
                if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
                    if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
                        continue;
                    c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
                    const h = {
                        ...e[r][1].end
                    }
                      , m = {
                        ...e[n][1].start
                    };
                    gB(h, -c),
                    gB(m, c),
                    a = {
                        type: c > 1 ? "strongSequence" : "emphasisSequence",
                        start: h,
                        end: {
                            ...e[r][1].end
                        }
                    },
                    s = {
                        type: c > 1 ? "strongSequence" : "emphasisSequence",
                        start: {
                            ...e[n][1].start
                        },
                        end: m
                    },
                    o = {
                        type: c > 1 ? "strongText" : "emphasisText",
                        start: {
                            ...e[r][1].end
                        },
                        end: {
                            ...e[n][1].start
                        }
                    },
                    i = {
                        type: c > 1 ? "strong" : "emphasis",
                        start: {
                            ...a.start
                        },
                        end: {
                            ...s.end
                        }
                    },
                    e[r][1].end = {
                        ...a.start
                    },
                    e[n][1].start = {
                        ...s.end
                    },
                    u = [],
                    e[r][1].end.offset - e[r][1].start.offset && (u = ya(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])),
                    u = ya(u, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["enter", o, t]]),
                    u = ya(u, I1(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)),
                    u = ya(u, [["exit", o, t], ["enter", s, t], ["exit", s, t], ["exit", i, t]]),
                    e[n][1].end.offset - e[n][1].start.offset ? (f = 2,
                    u = ya(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : f = 0,
                    Yo(e, r - 1, n - r + 3, u),
                    n = r + u.length - f - 2;
                    break
                }
        }
    for (n = -1; ++n < e.length; )
        e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
    return e
}
function XSe(e, t) {
    const n = this.parser.constructs.attentionMarkers.null
      , r = this.previous
      , i = Kf(r);
    let o;
    return a;
    function a(c) {
        return o = c,
        e.enter("attentionSequence"),
        s(c)
    }
    function s(c) {
        if (c === o)
            return e.consume(c),
            s;
        const u = e.exit("attentionSequence")
          , f = Kf(c)
          , h = !f || f === 2 && i || n.includes(c)
          , m = !i || i === 2 && f || n.includes(r);
        return u._open = !!(o === 42 ? h : h && (i || !m)),
        u._close = !!(o === 42 ? m : m && (f || !h)),
        t(c)
    }
}
function gB(e, t) {
    e.column += t,
    e.offset += t,
    e._bufferIndex += t
}
const JSe = {
    name: "autolink",
    tokenize: eCe
};
function eCe(e, t, n) {
    let r = 0;
    return i;
    function i(y) {
        return e.enter("autolink"),
        e.enter("autolinkMarker"),
        e.consume(y),
        e.exit("autolinkMarker"),
        e.enter("autolinkProtocol"),
        o
    }
    function o(y) {
        return Ni(y) ? (e.consume(y),
        a) : y === 64 ? n(y) : u(y)
    }
    function a(y) {
        return y === 43 || y === 45 || y === 46 || Ai(y) ? (r = 1,
        s(y)) : u(y)
    }
    function s(y) {
        return y === 58 ? (e.consume(y),
        r = 0,
        c) : (y === 43 || y === 45 || y === 46 || Ai(y)) && r++ < 32 ? (e.consume(y),
        s) : (r = 0,
        u(y))
    }
    function c(y) {
        return y === 62 ? (e.exit("autolinkProtocol"),
        e.enter("autolinkMarker"),
        e.consume(y),
        e.exit("autolinkMarker"),
        e.exit("autolink"),
        t) : y === null || y === 32 || y === 60 || B0(y) ? n(y) : (e.consume(y),
        c)
    }
    function u(y) {
        return y === 64 ? (e.consume(y),
        f) : VSe(y) ? (e.consume(y),
        u) : n(y)
    }
    function f(y) {
        return Ai(y) ? h(y) : n(y)
    }
    function h(y) {
        return y === 46 ? (e.consume(y),
        r = 0,
        f) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail",
        e.enter("autolinkMarker"),
        e.consume(y),
        e.exit("autolinkMarker"),
        e.exit("autolink"),
        t) : m(y)
    }
    function m(y) {
        if ((y === 45 || Ai(y)) && r++ < 63) {
            const b = y === 45 ? m : h;
            return e.consume(y),
            b
        }
        return n(y)
    }
}
const ey = {
    partial: !0,
    tokenize: tCe
};
function tCe(e, t, n) {
    return r;
    function r(o) {
        return bn(o) ? An(e, i, "linePrefix")(o) : i(o)
    }
    function i(o) {
        return o === null || zt(o) ? t(o) : n(o)
    }
}
const F9 = {
    continuation: {
        tokenize: rCe
    },
    exit: iCe,
    name: "blockQuote",
    tokenize: nCe
};
function nCe(e, t, n) {
    const r = this;
    return i;
    function i(a) {
        if (a === 62) {
            const s = r.containerState;
            return s.open || (e.enter("blockQuote", {
                _container: !0
            }),
            s.open = !0),
            e.enter("blockQuotePrefix"),
            e.enter("blockQuoteMarker"),
            e.consume(a),
            e.exit("blockQuoteMarker"),
            o
        }
        return n(a)
    }
    function o(a) {
        return bn(a) ? (e.enter("blockQuotePrefixWhitespace"),
        e.consume(a),
        e.exit("blockQuotePrefixWhitespace"),
        e.exit("blockQuotePrefix"),
        t) : (e.exit("blockQuotePrefix"),
        t(a))
    }
}
function rCe(e, t, n) {
    const r = this;
    return i;
    function i(a) {
        return bn(a) ? An(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : o(a)
    }
    function o(a) {
        return e.attempt(F9, t, n)(a)
    }
}
function iCe(e) {
    e.exit("blockQuote")
}
const N9 = {
    name: "characterEscape",
    tokenize: oCe
};
function oCe(e, t, n) {
    return r;
    function r(o) {
        return e.enter("characterEscape"),
        e.enter("escapeMarker"),
        e.consume(o),
        e.exit("escapeMarker"),
        i
    }
    function i(o) {
        return qSe(o) ? (e.enter("characterEscapeValue"),
        e.consume(o),
        e.exit("characterEscapeValue"),
        e.exit("characterEscape"),
        t) : n(o)
    }
}
const U9 = {
    name: "characterReference",
    tokenize: aCe
};
function aCe(e, t, n) {
    const r = this;
    let i = 0, o, a;
    return s;
    function s(h) {
        return e.enter("characterReference"),
        e.enter("characterReferenceMarker"),
        e.consume(h),
        e.exit("characterReferenceMarker"),
        c
    }
    function c(h) {
        return h === 35 ? (e.enter("characterReferenceMarkerNumeric"),
        e.consume(h),
        e.exit("characterReferenceMarkerNumeric"),
        u) : (e.enter("characterReferenceValue"),
        o = 31,
        a = Ai,
        f(h))
    }
    function u(h) {
        return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"),
        e.consume(h),
        e.exit("characterReferenceMarkerHexadecimal"),
        e.enter("characterReferenceValue"),
        o = 6,
        a = HSe,
        f) : (e.enter("characterReferenceValue"),
        o = 7,
        a = UT,
        f(h))
    }
    function f(h) {
        if (h === 59 && i) {
            const m = e.exit("characterReferenceValue");
            return a === Ai && !WA(r.sliceSerialize(m)) ? n(h) : (e.enter("characterReferenceMarker"),
            e.consume(h),
            e.exit("characterReferenceMarker"),
            e.exit("characterReference"),
            t)
        }
        return a(h) && i++ < o ? (e.consume(h),
        f) : n(h)
    }
}
const yB = {
    partial: !0,
    tokenize: lCe
}
  , bB = {
    concrete: !0,
    name: "codeFenced",
    tokenize: sCe
};
function sCe(e, t, n) {
    const r = this
      , i = {
        partial: !0,
        tokenize: E
    };
    let o = 0, a = 0, s;
    return c;
    function c(P) {
        return u(P)
    }
    function u(P) {
        const D = r.events[r.events.length - 1];
        return o = D && D[1].type === "linePrefix" ? D[2].sliceSerialize(D[1], !0).length : 0,
        s = P,
        e.enter("codeFenced"),
        e.enter("codeFencedFence"),
        e.enter("codeFencedFenceSequence"),
        f(P)
    }
    function f(P) {
        return P === s ? (a++,
        e.consume(P),
        f) : a < 3 ? n(P) : (e.exit("codeFencedFenceSequence"),
        bn(P) ? An(e, h, "whitespace")(P) : h(P))
    }
    function h(P) {
        return P === null || zt(P) ? (e.exit("codeFencedFence"),
        r.interrupt ? t(P) : e.check(yB, v, T)(P)) : (e.enter("codeFencedFenceInfo"),
        e.enter("chunkString", {
            contentType: "string"
        }),
        m(P))
    }
    function m(P) {
        return P === null || zt(P) ? (e.exit("chunkString"),
        e.exit("codeFencedFenceInfo"),
        h(P)) : bn(P) ? (e.exit("chunkString"),
        e.exit("codeFencedFenceInfo"),
        An(e, y, "whitespace")(P)) : P === 96 && P === s ? n(P) : (e.consume(P),
        m)
    }
    function y(P) {
        return P === null || zt(P) ? h(P) : (e.enter("codeFencedFenceMeta"),
        e.enter("chunkString", {
            contentType: "string"
        }),
        b(P))
    }
    function b(P) {
        return P === null || zt(P) ? (e.exit("chunkString"),
        e.exit("codeFencedFenceMeta"),
        h(P)) : P === 96 && P === s ? n(P) : (e.consume(P),
        b)
    }
    function v(P) {
        return e.attempt(i, T, S)(P)
    }
    function S(P) {
        return e.enter("lineEnding"),
        e.consume(P),
        e.exit("lineEnding"),
        C
    }
    function C(P) {
        return o > 0 && bn(P) ? An(e, w, "linePrefix", o + 1)(P) : w(P)
    }
    function w(P) {
        return P === null || zt(P) ? e.check(yB, v, T)(P) : (e.enter("codeFlowValue"),
        k(P))
    }
    function k(P) {
        return P === null || zt(P) ? (e.exit("codeFlowValue"),
        w(P)) : (e.consume(P),
        k)
    }
    function T(P) {
        return e.exit("codeFenced"),
        t(P)
    }
    function E(P, D, $) {
        let z = 0;
        return O;
        function O(F) {
            return P.enter("lineEnding"),
            P.consume(F),
            P.exit("lineEnding"),
            I
        }
        function I(F) {
            return P.enter("codeFencedFence"),
            bn(F) ? An(P, M, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(F) : M(F)
        }
        function M(F) {
            return F === s ? (P.enter("codeFencedFenceSequence"),
            B(F)) : $(F)
        }
        function B(F) {
            return F === s ? (z++,
            P.consume(F),
            B) : z >= a ? (P.exit("codeFencedFenceSequence"),
            bn(F) ? An(P, L, "whitespace")(F) : L(F)) : $(F)
        }
        function L(F) {
            return F === null || zt(F) ? (P.exit("codeFencedFence"),
            D(F)) : $(F)
        }
    }
}
function lCe(e, t, n) {
    const r = this;
    return i;
    function i(a) {
        return a === null ? n(a) : (e.enter("lineEnding"),
        e.consume(a),
        e.exit("lineEnding"),
        o)
    }
    function o(a) {
        return r.parser.lazy[r.now().line] ? n(a) : t(a)
    }
}
const Lk = {
    name: "codeIndented",
    tokenize: uCe
}
  , cCe = {
    partial: !0,
    tokenize: dCe
};
function uCe(e, t, n) {
    const r = this;
    return i;
    function i(u) {
        return e.enter("codeIndented"),
        An(e, o, "linePrefix", 5)(u)
    }
    function o(u) {
        const f = r.events[r.events.length - 1];
        return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? a(u) : n(u)
    }
    function a(u) {
        return u === null ? c(u) : zt(u) ? e.attempt(cCe, a, c)(u) : (e.enter("codeFlowValue"),
        s(u))
    }
    function s(u) {
        return u === null || zt(u) ? (e.exit("codeFlowValue"),
        a(u)) : (e.consume(u),
        s)
    }
    function c(u) {
        return e.exit("codeIndented"),
        t(u)
    }
}
function dCe(e, t, n) {
    const r = this;
    return i;
    function i(a) {
        return r.parser.lazy[r.now().line] ? n(a) : zt(a) ? (e.enter("lineEnding"),
        e.consume(a),
        e.exit("lineEnding"),
        i) : An(e, o, "linePrefix", 5)(a)
    }
    function o(a) {
        const s = r.events[r.events.length - 1];
        return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : zt(a) ? i(a) : n(a)
    }
}
const fCe = {
    name: "codeText",
    previous: pCe,
    resolve: hCe,
    tokenize: mCe
};
function hCe(e) {
    let t = e.length - 4, n = 3, r, i;
    if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
        for (r = n; ++r < t; )
            if (e[r][1].type === "codeTextData") {
                e[n][1].type = "codeTextPadding",
                e[t][1].type = "codeTextPadding",
                n += 2,
                t -= 2;
                break
            }
    }
    for (r = n - 1,
    t++; ++r <= t; )
        i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData",
        r !== i + 2 && (e[i][1].end = e[r - 1][1].end,
        e.splice(i + 2, r - i - 2),
        t -= r - i - 2,
        r = i + 2),
        i = void 0);
    return e
}
function pCe(e) {
    return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape"
}
function mCe(e, t, n) {
    let r = 0, i, o;
    return a;
    function a(h) {
        return e.enter("codeText"),
        e.enter("codeTextSequence"),
        s(h)
    }
    function s(h) {
        return h === 96 ? (e.consume(h),
        r++,
        s) : (e.exit("codeTextSequence"),
        c(h))
    }
    function c(h) {
        return h === null ? n(h) : h === 32 ? (e.enter("space"),
        e.consume(h),
        e.exit("space"),
        c) : h === 96 ? (o = e.enter("codeTextSequence"),
        i = 0,
        f(h)) : zt(h) ? (e.enter("lineEnding"),
        e.consume(h),
        e.exit("lineEnding"),
        c) : (e.enter("codeTextData"),
        u(h))
    }
    function u(h) {
        return h === null || h === 32 || h === 96 || zt(h) ? (e.exit("codeTextData"),
        c(h)) : (e.consume(h),
        u)
    }
    function f(h) {
        return h === 96 ? (e.consume(h),
        i++,
        f) : i === r ? (e.exit("codeTextSequence"),
        e.exit("codeText"),
        t(h)) : (o.type = "codeTextData",
        u(h))
    }
}
class gCe {
    constructor(t) {
        this.left = t ? [...t] : [],
        this.right = []
    }
    get(t) {
        if (t < 0 || t >= this.left.length + this.right.length)
            throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
        return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1]
    }
    get length() {
        return this.left.length + this.right.length
    }
    shift() {
        return this.setCursor(0),
        this.right.pop()
    }
    slice(t, n) {
        const r = n ?? Number.POSITIVE_INFINITY;
        return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse())
    }
    splice(t, n, r) {
        const i = n || 0;
        this.setCursor(Math.trunc(t));
        const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
        return r && Rp(this.left, r),
        o.reverse()
    }
    pop() {
        return this.setCursor(Number.POSITIVE_INFINITY),
        this.left.pop()
    }
    push(t) {
        this.setCursor(Number.POSITIVE_INFINITY),
        this.left.push(t)
    }
    pushMany(t) {
        this.setCursor(Number.POSITIVE_INFINITY),
        Rp(this.left, t)
    }
    unshift(t) {
        this.setCursor(0),
        this.right.push(t)
    }
    unshiftMany(t) {
        this.setCursor(0),
        Rp(this.right, t.reverse())
    }
    setCursor(t) {
        if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
            if (t < this.left.length) {
                const n = this.left.splice(t, Number.POSITIVE_INFINITY);
                Rp(this.right, n.reverse())
            } else {
                const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
                Rp(this.left, n.reverse())
            }
    }
}
function Rp(e, t) {
    let n = 0;
    if (t.length < 1e4)
        e.push(...t);
    else
        for (; n < t.length; )
            e.push(...t.slice(n, n + 1e4)),
            n += 1e4
}
function V9(e) {
    const t = {};
    let n = -1, r, i, o, a, s, c, u;
    const f = new gCe(e);
    for (; ++n < f.length; ) {
        for (; n in t; )
            n = t[n];
        if (r = f.get(n),
        n && r[1].type === "chunkFlow" && f.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events,
        o = 0,
        o < c.length && c[o][1].type === "lineEndingBlank" && (o += 2),
        o < c.length && c[o][1].type === "content"))
            for (; ++o < c.length && c[o][1].type !== "content"; )
                c[o][1].type === "chunkText" && (c[o][1]._isInFirstContentOfListItem = !0,
                o++);
        if (r[0] === "enter")
            r[1].contentType && (Object.assign(t, yCe(f, n)),
            n = t[n],
            u = !0);
        else if (r[1]._container) {
            for (o = n,
            i = void 0; o--; )
                if (a = f.get(o),
                a[1].type === "lineEnding" || a[1].type === "lineEndingBlank")
                    a[0] === "enter" && (i && (f.get(i)[1].type = "lineEndingBlank"),
                    a[1].type = "lineEnding",
                    i = o);
                else if (!(a[1].type === "linePrefix" || a[1].type === "listItemIndent"))
                    break;
            i && (r[1].end = {
                ...f.get(i)[1].start
            },
            s = f.slice(i, n),
            s.unshift(r),
            f.splice(i, n - i + 1, s))
        }
    }
    return Yo(e, 0, Number.POSITIVE_INFINITY, f.slice(0)),
    !u
}
function yCe(e, t) {
    const n = e.get(t)[1]
      , r = e.get(t)[2];
    let i = t - 1;
    const o = [];
    let a = n._tokenizer;
    a || (a = r.parser[n.contentType](n.start),
    n._contentTypeTextTrailing && (a._contentTypeTextTrailing = !0));
    const s = a.events
      , c = []
      , u = {};
    let f, h, m = -1, y = n, b = 0, v = 0;
    const S = [v];
    for (; y; ) {
        for (; e.get(++i)[1] !== y; )
            ;
        o.push(i),
        y._tokenizer || (f = r.sliceStream(y),
        y.next || f.push(null),
        h && a.defineSkip(y.start),
        y._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0),
        a.write(f),
        y._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)),
        h = y,
        y = y.next
    }
    for (y = n; ++m < s.length; )
        s[m][0] === "exit" && s[m - 1][0] === "enter" && s[m][1].type === s[m - 1][1].type && s[m][1].start.line !== s[m][1].end.line && (v = m + 1,
        S.push(v),
        y._tokenizer = void 0,
        y.previous = void 0,
        y = y.next);
    for (a.events = [],
    y ? (y._tokenizer = void 0,
    y.previous = void 0) : S.pop(),
    m = S.length; m--; ) {
        const C = s.slice(S[m], S[m + 1])
          , w = o.pop();
        c.push([w, w + C.length - 1]),
        e.splice(w, 2, C)
    }
    for (c.reverse(),
    m = -1; ++m < c.length; )
        u[b + c[m][0]] = b + c[m][1],
        b += c[m][1] - c[m][0] - 1;
    return u
}
const bCe = {
    resolve: vCe,
    tokenize: SCe
}
  , xCe = {
    partial: !0,
    tokenize: CCe
};
function vCe(e) {
    return V9(e),
    e
}
function SCe(e, t) {
    let n;
    return r;
    function r(s) {
        return e.enter("content"),
        n = e.enter("chunkContent", {
            contentType: "content"
        }),
        i(s)
    }
    function i(s) {
        return s === null ? o(s) : zt(s) ? e.check(xCe, a, o)(s) : (e.consume(s),
        i)
    }
    function o(s) {
        return e.exit("chunkContent"),
        e.exit("content"),
        t(s)
    }
    function a(s) {
        return e.consume(s),
        e.exit("chunkContent"),
        n.next = e.enter("chunkContent", {
            contentType: "content",
            previous: n
        }),
        n = n.next,
        i
    }
}
function CCe(e, t, n) {
    const r = this;
    return i;
    function i(a) {
        return e.exit("chunkContent"),
        e.enter("lineEnding"),
        e.consume(a),
        e.exit("lineEnding"),
        An(e, o, "linePrefix")
    }
    function o(a) {
        if (a === null || zt(a))
            return n(a);
        const s = r.events[r.events.length - 1];
        return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : e.interrupt(r.parser.constructs.flow, n, t)(a)
    }
}
function H9(e, t, n, r, i, o, a, s, c) {
    const u = c || Number.POSITIVE_INFINITY;
    let f = 0;
    return h;
    function h(C) {
        return C === 60 ? (e.enter(r),
        e.enter(i),
        e.enter(o),
        e.consume(C),
        e.exit(o),
        m) : C === null || C === 32 || C === 41 || B0(C) ? n(C) : (e.enter(r),
        e.enter(a),
        e.enter(s),
        e.enter("chunkString", {
            contentType: "string"
        }),
        v(C))
    }
    function m(C) {
        return C === 62 ? (e.enter(o),
        e.consume(C),
        e.exit(o),
        e.exit(i),
        e.exit(r),
        t) : (e.enter(s),
        e.enter("chunkString", {
            contentType: "string"
        }),
        y(C))
    }
    function y(C) {
        return C === 62 ? (e.exit("chunkString"),
        e.exit(s),
        m(C)) : C === null || C === 60 || zt(C) ? n(C) : (e.consume(C),
        C === 92 ? b : y)
    }
    function b(C) {
        return C === 60 || C === 62 || C === 92 ? (e.consume(C),
        y) : y(C)
    }
    function v(C) {
        return !f && (C === null || C === 41 || ir(C)) ? (e.exit("chunkString"),
        e.exit(s),
        e.exit(a),
        e.exit(r),
        t(C)) : f < u && C === 40 ? (e.consume(C),
        f++,
        v) : C === 41 ? (e.consume(C),
        f--,
        v) : C === null || C === 32 || C === 40 || B0(C) ? n(C) : (e.consume(C),
        C === 92 ? S : v)
    }
    function S(C) {
        return C === 40 || C === 41 || C === 92 ? (e.consume(C),
        v) : v(C)
    }
}
function q9(e, t, n, r, i, o) {
    const a = this;
    let s = 0, c;
    return u;
    function u(y) {
        return e.enter(r),
        e.enter(i),
        e.consume(y),
        e.exit(i),
        e.enter(o),
        f
    }
    function f(y) {
        return s > 999 || y === null || y === 91 || y === 93 && !c || y === 94 && !s && "_hiddenFootnoteSupport"in a.parser.constructs ? n(y) : y === 93 ? (e.exit(o),
        e.enter(i),
        e.consume(y),
        e.exit(i),
        e.exit(r),
        t) : zt(y) ? (e.enter("lineEnding"),
        e.consume(y),
        e.exit("lineEnding"),
        f) : (e.enter("chunkString", {
            contentType: "string"
        }),
        h(y))
    }
    function h(y) {
        return y === null || y === 91 || y === 93 || zt(y) || s++ > 999 ? (e.exit("chunkString"),
        f(y)) : (e.consume(y),
        c || (c = !bn(y)),
        y === 92 ? m : h)
    }
    function m(y) {
        return y === 91 || y === 92 || y === 93 ? (e.consume(y),
        s++,
        h) : h(y)
    }
}
function W9(e, t, n, r, i, o) {
    let a;
    return s;
    function s(m) {
        return m === 34 || m === 39 || m === 40 ? (e.enter(r),
        e.enter(i),
        e.consume(m),
        e.exit(i),
        a = m === 40 ? 41 : m,
        c) : n(m)
    }
    function c(m) {
        return m === a ? (e.enter(i),
        e.consume(m),
        e.exit(i),
        e.exit(r),
        t) : (e.enter(o),
        u(m))
    }
    function u(m) {
        return m === a ? (e.exit(o),
        c(a)) : m === null ? n(m) : zt(m) ? (e.enter("lineEnding"),
        e.consume(m),
        e.exit("lineEnding"),
        An(e, u, "linePrefix")) : (e.enter("chunkString", {
            contentType: "string"
        }),
        f(m))
    }
    function f(m) {
        return m === a || m === null || zt(m) ? (e.exit("chunkString"),
        u(m)) : (e.consume(m),
        m === 92 ? h : f)
    }
    function h(m) {
        return m === a || m === 92 ? (e.consume(m),
        f) : f(m)
    }
}
function Em(e, t) {
    let n;
    return r;
    function r(i) {
        return zt(i) ? (e.enter("lineEnding"),
        e.consume(i),
        e.exit("lineEnding"),
        n = !0,
        r) : bn(i) ? An(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i)
    }
}
const wCe = {
    name: "definition",
    tokenize: TCe
}
  , kCe = {
    partial: !0,
    tokenize: _Ce
};
function TCe(e, t, n) {
    const r = this;
    let i;
    return o;
    function o(y) {
        return e.enter("definition"),
        a(y)
    }
    function a(y) {
        return q9.call(r, e, s, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(y)
    }
    function s(y) {
        return i = Ga(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)),
        y === 58 ? (e.enter("definitionMarker"),
        e.consume(y),
        e.exit("definitionMarker"),
        c) : n(y)
    }
    function c(y) {
        return ir(y) ? Em(e, u)(y) : u(y)
    }
    function u(y) {
        return H9(e, f, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(y)
    }
    function f(y) {
        return e.attempt(kCe, h, h)(y)
    }
    function h(y) {
        return bn(y) ? An(e, m, "whitespace")(y) : m(y)
    }
    function m(y) {
        return y === null || zt(y) ? (e.exit("definition"),
        r.parser.defined.push(i),
        t(y)) : n(y)
    }
}
function _Ce(e, t, n) {
    return r;
    function r(s) {
        return ir(s) ? Em(e, i)(s) : n(s)
    }
    function i(s) {
        return W9(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s)
    }
    function o(s) {
        return bn(s) ? An(e, a, "whitespace")(s) : a(s)
    }
    function a(s) {
        return s === null || zt(s) ? t(s) : n(s)
    }
}
const ECe = {
    name: "hardBreakEscape",
    tokenize: ACe
};
function ACe(e, t, n) {
    return r;
    function r(o) {
        return e.enter("hardBreakEscape"),
        e.consume(o),
        i
    }
    function i(o) {
        return zt(o) ? (e.exit("hardBreakEscape"),
        t(o)) : n(o)
    }
}
const MCe = {
    name: "headingAtx",
    resolve: PCe,
    tokenize: RCe
};
function PCe(e, t) {
    let n = e.length - 2, r = 3, i, o;
    return e[r][1].type === "whitespace" && (r += 2),
    n - 2 > r && e[n][1].type === "whitespace" && (n -= 2),
    e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4),
    n > r && (i = {
        type: "atxHeadingText",
        start: e[r][1].start,
        end: e[n][1].end
    },
    o = {
        type: "chunkText",
        start: e[r][1].start,
        end: e[n][1].end,
        contentType: "text"
    },
    Yo(e, r, n - r + 1, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]])),
    e
}
function RCe(e, t, n) {
    let r = 0;
    return i;
    function i(f) {
        return e.enter("atxHeading"),
        o(f)
    }
    function o(f) {
        return e.enter("atxHeadingSequence"),
        a(f)
    }
    function a(f) {
        return f === 35 && r++ < 6 ? (e.consume(f),
        a) : f === null || ir(f) ? (e.exit("atxHeadingSequence"),
        s(f)) : n(f)
    }
    function s(f) {
        return f === 35 ? (e.enter("atxHeadingSequence"),
        c(f)) : f === null || zt(f) ? (e.exit("atxHeading"),
        t(f)) : bn(f) ? An(e, s, "whitespace")(f) : (e.enter("atxHeadingText"),
        u(f))
    }
    function c(f) {
        return f === 35 ? (e.consume(f),
        c) : (e.exit("atxHeadingSequence"),
        s(f))
    }
    function u(f) {
        return f === null || f === 35 || ir(f) ? (e.exit("atxHeadingText"),
        s(f)) : (e.consume(f),
        u)
    }
}
const DCe = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]
  , xB = ["pre", "script", "style", "textarea"]
  , OCe = {
    concrete: !0,
    name: "htmlFlow",
    resolveTo: LCe,
    tokenize: jCe
}
  , ICe = {
    partial: !0,
    tokenize: zCe
}
  , $Ce = {
    partial: !0,
    tokenize: BCe
};
function LCe(e) {
    let t = e.length;
    for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
        ;
    return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start,
    e[t + 1][1].start = e[t - 2][1].start,
    e.splice(t - 2, 2)),
    e
}
function jCe(e, t, n) {
    const r = this;
    let i, o, a, s, c;
    return u;
    function u(W) {
        return f(W)
    }
    function f(W) {
        return e.enter("htmlFlow"),
        e.enter("htmlFlowData"),
        e.consume(W),
        h
    }
    function h(W) {
        return W === 33 ? (e.consume(W),
        m) : W === 47 ? (e.consume(W),
        o = !0,
        v) : W === 63 ? (e.consume(W),
        i = 3,
        r.interrupt ? t : q) : Ni(W) ? (e.consume(W),
        a = String.fromCharCode(W),
        S) : n(W)
    }
    function m(W) {
        return W === 45 ? (e.consume(W),
        i = 2,
        y) : W === 91 ? (e.consume(W),
        i = 5,
        s = 0,
        b) : Ni(W) ? (e.consume(W),
        i = 4,
        r.interrupt ? t : q) : n(W)
    }
    function y(W) {
        return W === 45 ? (e.consume(W),
        r.interrupt ? t : q) : n(W)
    }
    function b(W) {
        const te = "CDATA[";
        return W === te.charCodeAt(s++) ? (e.consume(W),
        s === te.length ? r.interrupt ? t : M : b) : n(W)
    }
    function v(W) {
        return Ni(W) ? (e.consume(W),
        a = String.fromCharCode(W),
        S) : n(W)
    }
    function S(W) {
        if (W === null || W === 47 || W === 62 || ir(W)) {
            const te = W === 47
              , K = a.toLowerCase();
            return !te && !o && xB.includes(K) ? (i = 1,
            r.interrupt ? t(W) : M(W)) : DCe.includes(a.toLowerCase()) ? (i = 6,
            te ? (e.consume(W),
            C) : r.interrupt ? t(W) : M(W)) : (i = 7,
            r.interrupt && !r.parser.lazy[r.now().line] ? n(W) : o ? w(W) : k(W))
        }
        return W === 45 || Ai(W) ? (e.consume(W),
        a += String.fromCharCode(W),
        S) : n(W)
    }
    function C(W) {
        return W === 62 ? (e.consume(W),
        r.interrupt ? t : M) : n(W)
    }
    function w(W) {
        return bn(W) ? (e.consume(W),
        w) : O(W)
    }
    function k(W) {
        return W === 47 ? (e.consume(W),
        O) : W === 58 || W === 95 || Ni(W) ? (e.consume(W),
        T) : bn(W) ? (e.consume(W),
        k) : O(W)
    }
    function T(W) {
        return W === 45 || W === 46 || W === 58 || W === 95 || Ai(W) ? (e.consume(W),
        T) : E(W)
    }
    function E(W) {
        return W === 61 ? (e.consume(W),
        P) : bn(W) ? (e.consume(W),
        E) : k(W)
    }
    function P(W) {
        return W === null || W === 60 || W === 61 || W === 62 || W === 96 ? n(W) : W === 34 || W === 39 ? (e.consume(W),
        c = W,
        D) : bn(W) ? (e.consume(W),
        P) : $(W)
    }
    function D(W) {
        return W === c ? (e.consume(W),
        c = null,
        z) : W === null || zt(W) ? n(W) : (e.consume(W),
        D)
    }
    function $(W) {
        return W === null || W === 34 || W === 39 || W === 47 || W === 60 || W === 61 || W === 62 || W === 96 || ir(W) ? E(W) : (e.consume(W),
        $)
    }
    function z(W) {
        return W === 47 || W === 62 || bn(W) ? k(W) : n(W)
    }
    function O(W) {
        return W === 62 ? (e.consume(W),
        I) : n(W)
    }
    function I(W) {
        return W === null || zt(W) ? M(W) : bn(W) ? (e.consume(W),
        I) : n(W)
    }
    function M(W) {
        return W === 45 && i === 2 ? (e.consume(W),
        j) : W === 60 && i === 1 ? (e.consume(W),
        N) : W === 62 && i === 4 ? (e.consume(W),
        V) : W === 63 && i === 3 ? (e.consume(W),
        q) : W === 93 && i === 5 ? (e.consume(W),
        Z) : zt(W) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"),
        e.check(ICe, Y, B)(W)) : W === null || zt(W) ? (e.exit("htmlFlowData"),
        B(W)) : (e.consume(W),
        M)
    }
    function B(W) {
        return e.check($Ce, L, Y)(W)
    }
    function L(W) {
        return e.enter("lineEnding"),
        e.consume(W),
        e.exit("lineEnding"),
        F
    }
    function F(W) {
        return W === null || zt(W) ? B(W) : (e.enter("htmlFlowData"),
        M(W))
    }
    function j(W) {
        return W === 45 ? (e.consume(W),
        q) : M(W)
    }
    function N(W) {
        return W === 47 ? (e.consume(W),
        a = "",
        H) : M(W)
    }
    function H(W) {
        if (W === 62) {
            const te = a.toLowerCase();
            return xB.includes(te) ? (e.consume(W),
            V) : M(W)
        }
        return Ni(W) && a.length < 8 ? (e.consume(W),
        a += String.fromCharCode(W),
        H) : M(W)
    }
    function Z(W) {
        return W === 93 ? (e.consume(W),
        q) : M(W)
    }
    function q(W) {
        return W === 62 ? (e.consume(W),
        V) : W === 45 && i === 2 ? (e.consume(W),
        q) : M(W)
    }
    function V(W) {
        return W === null || zt(W) ? (e.exit("htmlFlowData"),
        Y(W)) : (e.consume(W),
        V)
    }
    function Y(W) {
        return e.exit("htmlFlow"),
        t(W)
    }
}
function BCe(e, t, n) {
    const r = this;
    return i;
    function i(a) {
        return zt(a) ? (e.enter("lineEnding"),
        e.consume(a),
        e.exit("lineEnding"),
        o) : n(a)
    }
    function o(a) {
        return r.parser.lazy[r.now().line] ? n(a) : t(a)
    }
}
function zCe(e, t, n) {
    return r;
    function r(i) {
        return e.enter("lineEnding"),
        e.consume(i),
        e.exit("lineEnding"),
        e.attempt(ey, t, n)
    }
}
const FCe = {
    name: "htmlText",
    tokenize: NCe
};
function NCe(e, t, n) {
    const r = this;
    let i, o, a;
    return s;
    function s(q) {
        return e.enter("htmlText"),
        e.enter("htmlTextData"),
        e.consume(q),
        c
    }
    function c(q) {
        return q === 33 ? (e.consume(q),
        u) : q === 47 ? (e.consume(q),
        E) : q === 63 ? (e.consume(q),
        k) : Ni(q) ? (e.consume(q),
        $) : n(q)
    }
    function u(q) {
        return q === 45 ? (e.consume(q),
        f) : q === 91 ? (e.consume(q),
        o = 0,
        b) : Ni(q) ? (e.consume(q),
        w) : n(q)
    }
    function f(q) {
        return q === 45 ? (e.consume(q),
        y) : n(q)
    }
    function h(q) {
        return q === null ? n(q) : q === 45 ? (e.consume(q),
        m) : zt(q) ? (a = h,
        N(q)) : (e.consume(q),
        h)
    }
    function m(q) {
        return q === 45 ? (e.consume(q),
        y) : h(q)
    }
    function y(q) {
        return q === 62 ? j(q) : q === 45 ? m(q) : h(q)
    }
    function b(q) {
        const V = "CDATA[";
        return q === V.charCodeAt(o++) ? (e.consume(q),
        o === V.length ? v : b) : n(q)
    }
    function v(q) {
        return q === null ? n(q) : q === 93 ? (e.consume(q),
        S) : zt(q) ? (a = v,
        N(q)) : (e.consume(q),
        v)
    }
    function S(q) {
        return q === 93 ? (e.consume(q),
        C) : v(q)
    }
    function C(q) {
        return q === 62 ? j(q) : q === 93 ? (e.consume(q),
        C) : v(q)
    }
    function w(q) {
        return q === null || q === 62 ? j(q) : zt(q) ? (a = w,
        N(q)) : (e.consume(q),
        w)
    }
    function k(q) {
        return q === null ? n(q) : q === 63 ? (e.consume(q),
        T) : zt(q) ? (a = k,
        N(q)) : (e.consume(q),
        k)
    }
    function T(q) {
        return q === 62 ? j(q) : k(q)
    }
    function E(q) {
        return Ni(q) ? (e.consume(q),
        P) : n(q)
    }
    function P(q) {
        return q === 45 || Ai(q) ? (e.consume(q),
        P) : D(q)
    }
    function D(q) {
        return zt(q) ? (a = D,
        N(q)) : bn(q) ? (e.consume(q),
        D) : j(q)
    }
    function $(q) {
        return q === 45 || Ai(q) ? (e.consume(q),
        $) : q === 47 || q === 62 || ir(q) ? z(q) : n(q)
    }
    function z(q) {
        return q === 47 ? (e.consume(q),
        j) : q === 58 || q === 95 || Ni(q) ? (e.consume(q),
        O) : zt(q) ? (a = z,
        N(q)) : bn(q) ? (e.consume(q),
        z) : j(q)
    }
    function O(q) {
        return q === 45 || q === 46 || q === 58 || q === 95 || Ai(q) ? (e.consume(q),
        O) : I(q)
    }
    function I(q) {
        return q === 61 ? (e.consume(q),
        M) : zt(q) ? (a = I,
        N(q)) : bn(q) ? (e.consume(q),
        I) : z(q)
    }
    function M(q) {
        return q === null || q === 60 || q === 61 || q === 62 || q === 96 ? n(q) : q === 34 || q === 39 ? (e.consume(q),
        i = q,
        B) : zt(q) ? (a = M,
        N(q)) : bn(q) ? (e.consume(q),
        M) : (e.consume(q),
        L)
    }
    function B(q) {
        return q === i ? (e.consume(q),
        i = void 0,
        F) : q === null ? n(q) : zt(q) ? (a = B,
        N(q)) : (e.consume(q),
        B)
    }
    function L(q) {
        return q === null || q === 34 || q === 39 || q === 60 || q === 61 || q === 96 ? n(q) : q === 47 || q === 62 || ir(q) ? z(q) : (e.consume(q),
        L)
    }
    function F(q) {
        return q === 47 || q === 62 || ir(q) ? z(q) : n(q)
    }
    function j(q) {
        return q === 62 ? (e.consume(q),
        e.exit("htmlTextData"),
        e.exit("htmlText"),
        t) : n(q)
    }
    function N(q) {
        return e.exit("htmlTextData"),
        e.enter("lineEnding"),
        e.consume(q),
        e.exit("lineEnding"),
        H
    }
    function H(q) {
        return bn(q) ? An(e, Z, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(q) : Z(q)
    }
    function Z(q) {
        return e.enter("htmlTextData"),
        a(q)
    }
}
const GA = {
    name: "labelEnd",
    resolveAll: qCe,
    resolveTo: WCe,
    tokenize: GCe
}
  , UCe = {
    tokenize: YCe
}
  , VCe = {
    tokenize: ZCe
}
  , HCe = {
    tokenize: QCe
};
function qCe(e) {
    let t = -1;
    const n = [];
    for (; ++t < e.length; ) {
        const r = e[t][1];
        if (n.push(e[t]),
        r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
            const i = r.type === "labelImage" ? 4 : 2;
            r.type = "data",
            t += i
        }
    }
    return e.length !== n.length && Yo(e, 0, e.length, n),
    e
}
function WCe(e, t) {
    let n = e.length, r = 0, i, o, a, s;
    for (; n--; )
        if (i = e[n][1],
        o) {
            if (i.type === "link" || i.type === "labelLink" && i._inactive)
                break;
            e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0)
        } else if (a) {
            if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = n,
            i.type !== "labelLink")) {
                r = 2;
                break
            }
        } else
            i.type === "labelEnd" && (a = n);
    const c = {
        type: e[o][1].type === "labelLink" ? "link" : "image",
        start: {
            ...e[o][1].start
        },
        end: {
            ...e[e.length - 1][1].end
        }
    }
      , u = {
        type: "label",
        start: {
            ...e[o][1].start
        },
        end: {
            ...e[a][1].end
        }
    }
      , f = {
        type: "labelText",
        start: {
            ...e[o + r + 2][1].end
        },
        end: {
            ...e[a - 2][1].start
        }
    };
    return s = [["enter", c, t], ["enter", u, t]],
    s = ya(s, e.slice(o + 1, o + r + 3)),
    s = ya(s, [["enter", f, t]]),
    s = ya(s, I1(t.parser.constructs.insideSpan.null, e.slice(o + r + 4, a - 3), t)),
    s = ya(s, [["exit", f, t], e[a - 2], e[a - 1], ["exit", u, t]]),
    s = ya(s, e.slice(a + 1)),
    s = ya(s, [["exit", c, t]]),
    Yo(e, o, e.length, s),
    e
}
function GCe(e, t, n) {
    const r = this;
    let i = r.events.length, o, a;
    for (; i--; )
        if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
            o = r.events[i][1];
            break
        }
    return s;
    function s(m) {
        return o ? o._inactive ? h(m) : (a = r.parser.defined.includes(Ga(r.sliceSerialize({
            start: o.end,
            end: r.now()
        }))),
        e.enter("labelEnd"),
        e.enter("labelMarker"),
        e.consume(m),
        e.exit("labelMarker"),
        e.exit("labelEnd"),
        c) : n(m)
    }
    function c(m) {
        return m === 40 ? e.attempt(UCe, f, a ? f : h)(m) : m === 91 ? e.attempt(VCe, f, a ? u : h)(m) : a ? f(m) : h(m)
    }
    function u(m) {
        return e.attempt(HCe, f, h)(m)
    }
    function f(m) {
        return t(m)
    }
    function h(m) {
        return o._balanced = !0,
        n(m)
    }
}
function YCe(e, t, n) {
    return r;
    function r(h) {
        return e.enter("resource"),
        e.enter("resourceMarker"),
        e.consume(h),
        e.exit("resourceMarker"),
        i
    }
    function i(h) {
        return ir(h) ? Em(e, o)(h) : o(h)
    }
    function o(h) {
        return h === 41 ? f(h) : H9(e, a, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h)
    }
    function a(h) {
        return ir(h) ? Em(e, c)(h) : f(h)
    }
    function s(h) {
        return n(h)
    }
    function c(h) {
        return h === 34 || h === 39 || h === 40 ? W9(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : f(h)
    }
    function u(h) {
        return ir(h) ? Em(e, f)(h) : f(h)
    }
    function f(h) {
        return h === 41 ? (e.enter("resourceMarker"),
        e.consume(h),
        e.exit("resourceMarker"),
        e.exit("resource"),
        t) : n(h)
    }
}
function ZCe(e, t, n) {
    const r = this;
    return i;
    function i(s) {
        return q9.call(r, e, o, a, "reference", "referenceMarker", "referenceString")(s)
    }
    function o(s) {
        return r.parser.defined.includes(Ga(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(s) : n(s)
    }
    function a(s) {
        return n(s)
    }
}
function QCe(e, t, n) {
    return r;
    function r(o) {
        return e.enter("reference"),
        e.enter("referenceMarker"),
        e.consume(o),
        e.exit("referenceMarker"),
        i
    }
    function i(o) {
        return o === 93 ? (e.enter("referenceMarker"),
        e.consume(o),
        e.exit("referenceMarker"),
        e.exit("reference"),
        t) : n(o)
    }
}
const KCe = {
    name: "labelStartImage",
    resolveAll: GA.resolveAll,
    tokenize: XCe
};
function XCe(e, t, n) {
    const r = this;
    return i;
    function i(s) {
        return e.enter("labelImage"),
        e.enter("labelImageMarker"),
        e.consume(s),
        e.exit("labelImageMarker"),
        o
    }
    function o(s) {
        return s === 91 ? (e.enter("labelMarker"),
        e.consume(s),
        e.exit("labelMarker"),
        e.exit("labelImage"),
        a) : n(s)
    }
    function a(s) {
        return s === 94 && "_hiddenFootnoteSupport"in r.parser.constructs ? n(s) : t(s)
    }
}
const JCe = {
    name: "labelStartLink",
    resolveAll: GA.resolveAll,
    tokenize: ewe
};
function ewe(e, t, n) {
    const r = this;
    return i;
    function i(a) {
        return e.enter("labelLink"),
        e.enter("labelMarker"),
        e.consume(a),
        e.exit("labelMarker"),
        e.exit("labelLink"),
        o
    }
    function o(a) {
        return a === 94 && "_hiddenFootnoteSupport"in r.parser.constructs ? n(a) : t(a)
    }
}
const jk = {
    name: "lineEnding",
    tokenize: twe
};
function twe(e, t) {
    return n;
    function n(r) {
        return e.enter("lineEnding"),
        e.consume(r),
        e.exit("lineEnding"),
        An(e, t, "linePrefix")
    }
}
const Bx = {
    name: "thematicBreak",
    tokenize: nwe
};
function nwe(e, t, n) {
    let r = 0, i;
    return o;
    function o(u) {
        return e.enter("thematicBreak"),
        a(u)
    }
    function a(u) {
        return i = u,
        s(u)
    }
    function s(u) {
        return u === i ? (e.enter("thematicBreakSequence"),
        c(u)) : r >= 3 && (u === null || zt(u)) ? (e.exit("thematicBreak"),
        t(u)) : n(u)
    }
    function c(u) {
        return u === i ? (e.consume(u),
        r++,
        c) : (e.exit("thematicBreakSequence"),
        bn(u) ? An(e, s, "whitespace")(u) : s(u))
    }
}
const so = {
    continuation: {
        tokenize: awe
    },
    exit: lwe,
    name: "list",
    tokenize: owe
}
  , rwe = {
    partial: !0,
    tokenize: cwe
}
  , iwe = {
    partial: !0,
    tokenize: swe
};
function owe(e, t, n) {
    const r = this
      , i = r.events[r.events.length - 1];
    let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0
      , a = 0;
    return s;
    function s(y) {
        const b = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered");
        if (b === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : UT(y)) {
            if (r.containerState.type || (r.containerState.type = b,
            e.enter(b, {
                _container: !0
            })),
            b === "listUnordered")
                return e.enter("listItemPrefix"),
                y === 42 || y === 45 ? e.check(Bx, n, u)(y) : u(y);
            if (!r.interrupt || y === 49)
                return e.enter("listItemPrefix"),
                e.enter("listItemValue"),
                c(y)
        }
        return n(y)
    }
    function c(y) {
        return UT(y) && ++a < 10 ? (e.consume(y),
        c) : (!r.interrupt || a < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"),
        u(y)) : n(y)
    }
    function u(y) {
        return e.enter("listItemMarker"),
        e.consume(y),
        e.exit("listItemMarker"),
        r.containerState.marker = r.containerState.marker || y,
        e.check(ey, r.interrupt ? n : f, e.attempt(rwe, m, h))
    }
    function f(y) {
        return r.containerState.initialBlankLine = !0,
        o++,
        m(y)
    }
    function h(y) {
        return bn(y) ? (e.enter("listItemPrefixWhitespace"),
        e.consume(y),
        e.exit("listItemPrefixWhitespace"),
        m) : n(y)
    }
    function m(y) {
        return r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length,
        t(y)
    }
}
function awe(e, t, n) {
    const r = this;
    return r.containerState._closeFlow = void 0,
    e.check(ey, i, o);
    function i(s) {
        return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine,
        An(e, t, "listItemIndent", r.containerState.size + 1)(s)
    }
    function o(s) {
        return r.containerState.furtherBlankLines || !bn(s) ? (r.containerState.furtherBlankLines = void 0,
        r.containerState.initialBlankLine = void 0,
        a(s)) : (r.containerState.furtherBlankLines = void 0,
        r.containerState.initialBlankLine = void 0,
        e.attempt(iwe, t, a)(s))
    }
    function a(s) {
        return r.containerState._closeFlow = !0,
        r.interrupt = void 0,
        An(e, e.attempt(so, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s)
    }
}
function swe(e, t, n) {
    const r = this;
    return An(e, i, "listItemIndent", r.containerState.size + 1);
    function i(o) {
        const a = r.events[r.events.length - 1];
        return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? t(o) : n(o)
    }
}
function lwe(e) {
    e.exit(this.containerState.type)
}
function cwe(e, t, n) {
    const r = this;
    return An(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
    function i(o) {
        const a = r.events[r.events.length - 1];
        return !bn(o) && a && a[1].type === "listItemPrefixWhitespace" ? t(o) : n(o)
    }
}
const vB = {
    name: "setextUnderline",
    resolveTo: uwe,
    tokenize: dwe
};
function uwe(e, t) {
    let n = e.length, r, i, o;
    for (; n--; )
        if (e[n][0] === "enter") {
            if (e[n][1].type === "content") {
                r = n;
                break
            }
            e[n][1].type === "paragraph" && (i = n)
        } else
            e[n][1].type === "content" && e.splice(n, 1),
            !o && e[n][1].type === "definition" && (o = n);
    const a = {
        type: "setextHeading",
        start: {
            ...e[r][1].start
        },
        end: {
            ...e[e.length - 1][1].end
        }
    };
    return e[i][1].type = "setextHeadingText",
    o ? (e.splice(i, 0, ["enter", a, t]),
    e.splice(o + 1, 0, ["exit", e[r][1], t]),
    e[r][1].end = {
        ...e[o][1].end
    }) : e[r][1] = a,
    e.push(["exit", a, t]),
    e
}
function dwe(e, t, n) {
    const r = this;
    let i;
    return o;
    function o(u) {
        let f = r.events.length, h;
        for (; f--; )
            if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") {
                h = r.events[f][1].type === "paragraph";
                break
            }
        return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (e.enter("setextHeadingLine"),
        i = u,
        a(u)) : n(u)
    }
    function a(u) {
        return e.enter("setextHeadingLineSequence"),
        s(u)
    }
    function s(u) {
        return u === i ? (e.consume(u),
        s) : (e.exit("setextHeadingLineSequence"),
        bn(u) ? An(e, c, "lineSuffix")(u) : c(u))
    }
    function c(u) {
        return u === null || zt(u) ? (e.exit("setextHeadingLine"),
        t(u)) : n(u)
    }
}
const fwe = {
    tokenize: hwe
};
function hwe(e) {
    const t = this
      , n = e.attempt(ey, r, e.attempt(this.parser.constructs.flowInitial, i, An(e, e.attempt(this.parser.constructs.flow, i, e.attempt(bCe, i)), "linePrefix")));
    return n;
    function r(o) {
        if (o === null) {
            e.consume(o);
            return
        }
        return e.enter("lineEndingBlank"),
        e.consume(o),
        e.exit("lineEndingBlank"),
        t.currentConstruct = void 0,
        n
    }
    function i(o) {
        if (o === null) {
            e.consume(o);
            return
        }
        return e.enter("lineEnding"),
        e.consume(o),
        e.exit("lineEnding"),
        t.currentConstruct = void 0,
        n
    }
}
const pwe = {
    resolveAll: Y9()
}
  , mwe = G9("string")
  , gwe = G9("text");
function G9(e) {
    return {
        resolveAll: Y9(e === "text" ? ywe : void 0),
        tokenize: t
    };
    function t(n) {
        const r = this
          , i = this.parser.constructs[e]
          , o = n.attempt(i, a, s);
        return a;
        function a(f) {
            return u(f) ? o(f) : s(f)
        }
        function s(f) {
            if (f === null) {
                n.consume(f);
                return
            }
            return n.enter("data"),
            n.consume(f),
            c
        }
        function c(f) {
            return u(f) ? (n.exit("data"),
            o(f)) : (n.consume(f),
            c)
        }
        function u(f) {
            if (f === null)
                return !0;
            const h = i[f];
            let m = -1;
            if (h)
                for (; ++m < h.length; ) {
                    const y = h[m];
                    if (!y.previous || y.previous.call(r, r.previous))
                        return !0
                }
            return !1
        }
    }
}
function Y9(e) {
    return t;
    function t(n, r) {
        let i = -1, o;
        for (; ++i <= n.length; )
            o === void 0 ? n[i] && n[i][1].type === "data" && (o = i,
            i++) : (!n[i] || n[i][1].type !== "data") && (i !== o + 2 && (n[o][1].end = n[i - 1][1].end,
            n.splice(o + 2, i - o - 2),
            i = o + 2),
            o = void 0);
        return e ? e(n, r) : n
    }
}
function ywe(e, t) {
    let n = 0;
    for (; ++n <= e.length; )
        if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
            const r = e[n - 1][1]
              , i = t.sliceStream(r);
            let o = i.length, a = -1, s = 0, c;
            for (; o--; ) {
                const u = i[o];
                if (typeof u == "string") {
                    for (a = u.length; u.charCodeAt(a - 1) === 32; )
                        s++,
                        a--;
                    if (a)
                        break;
                    a = -1
                } else if (u === -2)
                    c = !0,
                    s++;
                else if (u !== -1) {
                    o++;
                    break
                }
            }
            if (t._contentTypeTextTrailing && n === e.length && (s = 0),
            s) {
                const u = {
                    type: n === e.length || c || s < 2 ? "lineSuffix" : "hardBreakTrailing",
                    start: {
                        _bufferIndex: o ? a : r.start._bufferIndex + a,
                        _index: r.start._index + o,
                        line: r.end.line,
                        column: r.end.column - s,
                        offset: r.end.offset - s
                    },
                    end: {
                        ...r.end
                    }
                };
                r.end = {
                    ...u.start
                },
                r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(n, 0, ["enter", u, t], ["exit", u, t]),
                n += 2)
            }
            n++
        }
    return e
}
const bwe = {
    42: so,
    43: so,
    45: so,
    48: so,
    49: so,
    50: so,
    51: so,
    52: so,
    53: so,
    54: so,
    55: so,
    56: so,
    57: so,
    62: F9
}
  , xwe = {
    91: wCe
}
  , vwe = {
    [-2]: Lk,
    [-1]: Lk,
    32: Lk
}
  , Swe = {
    35: MCe,
    42: Bx,
    45: [vB, Bx],
    60: OCe,
    61: vB,
    95: Bx,
    96: bB,
    126: bB
}
  , Cwe = {
    38: U9,
    92: N9
}
  , wwe = {
    [-5]: jk,
    [-4]: jk,
    [-3]: jk,
    33: KCe,
    38: U9,
    42: VT,
    60: [JSe, FCe],
    91: JCe,
    92: [ECe, N9],
    93: GA,
    95: VT,
    96: fCe
}
  , kwe = {
    null: [VT, pwe]
}
  , Twe = {
    null: [42, 95]
}
  , _we = {
    null: []
}
  , Ewe = Object.freeze(Object.defineProperty({
    __proto__: null,
    attentionMarkers: Twe,
    contentInitial: xwe,
    disable: _we,
    document: bwe,
    flow: Swe,
    flowInitial: vwe,
    insideSpan: kwe,
    string: Cwe,
    text: wwe
}, Symbol.toStringTag, {
    value: "Module"
}));
function Awe(e, t, n) {
    let r = {
        _bufferIndex: -1,
        _index: 0,
        line: n && n.line || 1,
        column: n && n.column || 1,
        offset: n && n.offset || 0
    };
    const i = {}
      , o = [];
    let a = []
      , s = [];
    const c = {
        attempt: D(E),
        check: D(P),
        consume: w,
        enter: k,
        exit: T,
        interrupt: D(P, {
            interrupt: !0
        })
    }
      , u = {
        code: null,
        containerState: {},
        defineSkip: v,
        events: [],
        now: b,
        parser: e,
        previous: null,
        sliceSerialize: m,
        sliceStream: y,
        write: h
    };
    let f = t.tokenize.call(u, c);
    return t.resolveAll && o.push(t),
    u;
    function h(I) {
        return a = ya(a, I),
        S(),
        a[a.length - 1] !== null ? [] : ($(t, 0),
        u.events = I1(o, u.events, u),
        u.events)
    }
    function m(I, M) {
        return Pwe(y(I), M)
    }
    function y(I) {
        return Mwe(a, I)
    }
    function b() {
        const {_bufferIndex: I, _index: M, line: B, column: L, offset: F} = r;
        return {
            _bufferIndex: I,
            _index: M,
            line: B,
            column: L,
            offset: F
        }
    }
    function v(I) {
        i[I.line] = I.column,
        O()
    }
    function S() {
        let I;
        for (; r._index < a.length; ) {
            const M = a[r._index];
            if (typeof M == "string")
                for (I = r._index,
                r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === I && r._bufferIndex < M.length; )
                    C(M.charCodeAt(r._bufferIndex));
            else
                C(M)
        }
    }
    function C(I) {
        f = f(I)
    }
    function w(I) {
        zt(I) ? (r.line++,
        r.column = 1,
        r.offset += I === -3 ? 2 : 1,
        O()) : I !== -1 && (r.column++,
        r.offset++),
        r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++,
        r._bufferIndex === a[r._index].length && (r._bufferIndex = -1,
        r._index++)),
        u.previous = I
    }
    function k(I, M) {
        const B = M || {};
        return B.type = I,
        B.start = b(),
        u.events.push(["enter", B, u]),
        s.push(B),
        B
    }
    function T(I) {
        const M = s.pop();
        return M.end = b(),
        u.events.push(["exit", M, u]),
        M
    }
    function E(I, M) {
        $(I, M.from)
    }
    function P(I, M) {
        M.restore()
    }
    function D(I, M) {
        return B;
        function B(L, F, j) {
            let N, H, Z, q;
            return Array.isArray(L) ? Y(L) : "tokenize"in L ? Y([L]) : V(L);
            function V(ee) {
                return re;
                function re(ie) {
                    const J = ie !== null && ee[ie]
                      , oe = ie !== null && ee.null
                      , we = [...Array.isArray(J) ? J : J ? [J] : [], ...Array.isArray(oe) ? oe : oe ? [oe] : []];
                    return Y(we)(ie)
                }
            }
            function Y(ee) {
                return N = ee,
                H = 0,
                ee.length === 0 ? j : W(ee[H])
            }
            function W(ee) {
                return re;
                function re(ie) {
                    return q = z(),
                    Z = ee,
                    ee.partial || (u.currentConstruct = ee),
                    ee.name && u.parser.constructs.disable.null.includes(ee.name) ? K() : ee.tokenize.call(M ? Object.assign(Object.create(u), M) : u, c, te, K)(ie)
                }
            }
            function te(ee) {
                return I(Z, q),
                F
            }
            function K(ee) {
                return q.restore(),
                ++H < N.length ? W(N[H]) : j
            }
        }
    }
    function $(I, M) {
        I.resolveAll && !o.includes(I) && o.push(I),
        I.resolve && Yo(u.events, M, u.events.length - M, I.resolve(u.events.slice(M), u)),
        I.resolveTo && (u.events = I.resolveTo(u.events, u))
    }
    function z() {
        const I = b()
          , M = u.previous
          , B = u.currentConstruct
          , L = u.events.length
          , F = Array.from(s);
        return {
            from: L,
            restore: j
        };
        function j() {
            r = I,
            u.previous = M,
            u.currentConstruct = B,
            u.events.length = L,
            s = F,
            O()
        }
    }
    function O() {
        r.line in i && r.column < 2 && (r.column = i[r.line],
        r.offset += i[r.line] - 1)
    }
}
function Mwe(e, t) {
    const n = t.start._index
      , r = t.start._bufferIndex
      , i = t.end._index
      , o = t.end._bufferIndex;
    let a;
    if (n === i)
        a = [e[n].slice(r, o)];
    else {
        if (a = e.slice(n, i),
        r > -1) {
            const s = a[0];
            typeof s == "string" ? a[0] = s.slice(r) : a.shift()
        }
        o > 0 && a.push(e[i].slice(0, o))
    }
    return a
}
function Pwe(e, t) {
    let n = -1;
    const r = [];
    let i;
    for (; ++n < e.length; ) {
        const o = e[n];
        let a;
        if (typeof o == "string")
            a = o;
        else
            switch (o) {
            case -5:
                {
                    a = "\r";
                    break
                }
            case -4:
                {
                    a = `
`;
                    break
                }
            case -3:
                {
                    a = `\r
`;
                    break
                }
            case -2:
                {
                    a = t ? " " : "	";
                    break
                }
            case -1:
                {
                    if (!t && i)
                        continue;
                    a = " ";
                    break
                }
            default:
                a = String.fromCharCode(o)
            }
        i = o === -2,
        r.push(a)
    }
    return r.join("")
}
function Rwe(e) {
    const r = {
        constructs: B9([Ewe, ...(e || {}).extensions || []]),
        content: i(WSe),
        defined: [],
        document: i(YSe),
        flow: i(fwe),
        lazy: {},
        string: i(mwe),
        text: i(gwe)
    };
    return r;
    function i(o) {
        return a;
        function a(s) {
            return Awe(r, o, s)
        }
    }
}
function Dwe(e) {
    for (; !V9(e); )
        ;
    return e
}
const SB = /[\0\t\n\r]/g;
function Owe() {
    let e = 1, t = "", n = !0, r;
    return i;
    function i(o, a, s) {
        const c = [];
        let u, f, h, m, y;
        for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(a || void 0).decode(o)),
        h = 0,
        t = "",
        n && (o.charCodeAt(0) === 65279 && h++,
        n = void 0); h < o.length; ) {
            if (SB.lastIndex = h,
            u = SB.exec(o),
            m = u && u.index !== void 0 ? u.index : o.length,
            y = o.charCodeAt(m),
            !u) {
                t = o.slice(h);
                break
            }
            if (y === 10 && h === m && r)
                c.push(-3),
                r = void 0;
            else
                switch (r && (c.push(-5),
                r = void 0),
                h < m && (c.push(o.slice(h, m)),
                e += m - h),
                y) {
                case 0:
                    {
                        c.push(65533),
                        e++;
                        break
                    }
                case 9:
                    {
                        for (f = Math.ceil(e / 4) * 4,
                        c.push(-2); e++ < f; )
                            c.push(-1);
                        break
                    }
                case 10:
                    {
                        c.push(-4),
                        e = 1;
                        break
                    }
                default:
                    r = !0,
                    e = 1
                }
            h = m + 1
        }
        return s && (r && c.push(-5),
        t && c.push(t),
        c.push(null)),
        c
    }
}
const Iwe = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function $we(e) {
    return e.replace(Iwe, Lwe)
}
function Lwe(e, t, n) {
    if (t)
        return t;
    if (n.charCodeAt(0) === 35) {
        const i = n.charCodeAt(1)
          , o = i === 120 || i === 88;
        return z9(n.slice(o ? 2 : 1), o ? 16 : 10)
    }
    return WA(n) || e
}
const Z9 = {}.hasOwnProperty;
function jwe(e, t, n) {
    return typeof t != "string" && (n = t,
    t = void 0),
    Bwe(n)(Dwe(Rwe(n).document().write(Owe()(e, t, !0))))
}
function Bwe(e) {
    const t = {
        transforms: [],
        canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
        enter: {
            autolink: o(Ke),
            autolinkProtocol: z,
            autolinkEmail: z,
            atxHeading: o(Se),
            blockQuote: o(oe),
            characterEscape: z,
            characterReference: z,
            codeFenced: o(we),
            codeFencedFenceInfo: a,
            codeFencedFenceMeta: a,
            codeIndented: o(we, a),
            codeText: o(xe, a),
            codeTextData: z,
            data: z,
            codeFlowValue: z,
            definition: o(se),
            definitionDestinationString: a,
            definitionLabelString: a,
            definitionTitleString: a,
            emphasis: o(de),
            hardBreakEscape: o(Ce),
            hardBreakTrailing: o(Ce),
            htmlFlow: o(Ye, a),
            htmlFlowData: z,
            htmlText: o(Ye, a),
            htmlTextData: z,
            image: o(ye),
            label: a,
            link: o(Ke),
            listItem: o(ce),
            listItemValue: m,
            listOrdered: o(X, h),
            listUnordered: o(X),
            paragraph: o(fe),
            reference: W,
            referenceString: a,
            resourceDestinationString: a,
            resourceTitleString: a,
            setextHeading: o(Se),
            strong: o(Xe),
            thematicBreak: o(Re)
        },
        exit: {
            atxHeading: c(),
            atxHeadingSequence: E,
            autolink: c(),
            autolinkEmail: J,
            autolinkProtocol: ie,
            blockQuote: c(),
            characterEscapeValue: O,
            characterReferenceMarkerHexadecimal: K,
            characterReferenceMarkerNumeric: K,
            characterReferenceValue: ee,
            characterReference: re,
            codeFenced: c(S),
            codeFencedFence: v,
            codeFencedFenceInfo: y,
            codeFencedFenceMeta: b,
            codeFlowValue: O,
            codeIndented: c(C),
            codeText: c(F),
            codeTextData: O,
            data: O,
            definition: c(),
            definitionDestinationString: T,
            definitionLabelString: w,
            definitionTitleString: k,
            emphasis: c(),
            hardBreakEscape: c(M),
            hardBreakTrailing: c(M),
            htmlFlow: c(B),
            htmlFlowData: O,
            htmlText: c(L),
            htmlTextData: O,
            image: c(N),
            label: Z,
            labelText: H,
            lineEnding: I,
            link: c(j),
            listItem: c(),
            listOrdered: c(),
            listUnordered: c(),
            paragraph: c(),
            referenceString: te,
            resourceDestinationString: q,
            resourceTitleString: V,
            resource: Y,
            setextHeading: c($),
            setextHeadingLineSequence: D,
            setextHeadingText: P,
            strong: c(),
            thematicBreak: c()
        }
    };
    Q9(t, (e || {}).mdastExtensions || []);
    const n = {};
    return r;
    function r(le) {
        let ke = {
            type: "root",
            children: []
        };
        const He = {
            stack: [ke],
            tokenStack: [],
            config: t,
            enter: s,
            exit: u,
            buffer: a,
            resume: f,
            data: n
        }
          , st = [];
        let lt = -1;
        for (; ++lt < le.length; )
            if (le[lt][1].type === "listOrdered" || le[lt][1].type === "listUnordered")
                if (le[lt][0] === "enter")
                    st.push(lt);
                else {
                    const et = st.pop();
                    lt = i(le, et, lt)
                }
        for (lt = -1; ++lt < le.length; ) {
            const et = t[le[lt][0]];
            Z9.call(et, le[lt][1].type) && et[le[lt][1].type].call(Object.assign({
                sliceSerialize: le[lt][2].sliceSerialize
            }, He), le[lt][1])
        }
        if (He.tokenStack.length > 0) {
            const et = He.tokenStack[He.tokenStack.length - 1];
            (et[1] || CB).call(He, void 0, et[0])
        }
        for (ke.position = {
            start: rc(le.length > 0 ? le[0][1].start : {
                line: 1,
                column: 1,
                offset: 0
            }),
            end: rc(le.length > 0 ? le[le.length - 2][1].end : {
                line: 1,
                column: 1,
                offset: 0
            })
        },
        lt = -1; ++lt < t.transforms.length; )
            ke = t.transforms[lt](ke) || ke;
        return ke
    }
    function i(le, ke, He) {
        let st = ke - 1, lt = -1, et = !1, Ht, Ft, Pt, nt;
        for (; ++st <= He; ) {
            const ut = le[st];
            switch (ut[1].type) {
            case "listUnordered":
            case "listOrdered":
            case "blockQuote":
                {
                    ut[0] === "enter" ? lt++ : lt--,
                    nt = void 0;
                    break
                }
            case "lineEndingBlank":
                {
                    ut[0] === "enter" && (Ht && !nt && !lt && !Pt && (Pt = st),
                    nt = void 0);
                    break
                }
            case "linePrefix":
            case "listItemValue":
            case "listItemMarker":
            case "listItemPrefix":
            case "listItemPrefixWhitespace":
                break;
            default:
                nt = void 0
            }
            if (!lt && ut[0] === "enter" && ut[1].type === "listItemPrefix" || lt === -1 && ut[0] === "exit" && (ut[1].type === "listUnordered" || ut[1].type === "listOrdered")) {
                if (Ht) {
                    let Lt = st;
                    for (Ft = void 0; Lt--; ) {
                        const tn = le[Lt];
                        if (tn[1].type === "lineEnding" || tn[1].type === "lineEndingBlank") {
                            if (tn[0] === "exit")
                                continue;
                            Ft && (le[Ft][1].type = "lineEndingBlank",
                            et = !0),
                            tn[1].type = "lineEnding",
                            Ft = Lt
                        } else if (!(tn[1].type === "linePrefix" || tn[1].type === "blockQuotePrefix" || tn[1].type === "blockQuotePrefixWhitespace" || tn[1].type === "blockQuoteMarker" || tn[1].type === "listItemIndent"))
                            break
                    }
                    Pt && (!Ft || Pt < Ft) && (Ht._spread = !0),
                    Ht.end = Object.assign({}, Ft ? le[Ft][1].start : ut[1].end),
                    le.splice(Ft || st, 0, ["exit", Ht, ut[2]]),
                    st++,
                    He++
                }
                if (ut[1].type === "listItemPrefix") {
                    const Lt = {
                        type: "listItem",
                        _spread: !1,
                        start: Object.assign({}, ut[1].start),
                        end: void 0
                    };
                    Ht = Lt,
                    le.splice(st, 0, ["enter", Lt, ut[2]]),
                    st++,
                    He++,
                    Pt = void 0,
                    nt = !0
                }
            }
        }
        return le[ke][1]._spread = et,
        He
    }
    function o(le, ke) {
        return He;
        function He(st) {
            s.call(this, le(st), st),
            ke && ke.call(this, st)
        }
    }
    function a() {
        this.stack.push({
            type: "fragment",
            children: []
        })
    }
    function s(le, ke, He) {
        this.stack[this.stack.length - 1].children.push(le),
        this.stack.push(le),
        this.tokenStack.push([ke, He || void 0]),
        le.position = {
            start: rc(ke.start),
            end: void 0
        }
    }
    function c(le) {
        return ke;
        function ke(He) {
            le && le.call(this, He),
            u.call(this, He)
        }
    }
    function u(le, ke) {
        const He = this.stack.pop()
          , st = this.tokenStack.pop();
        if (st)
            st[0].type !== le.type && (ke ? ke.call(this, le, st[0]) : (st[1] || CB).call(this, le, st[0]));
        else
            throw new Error("Cannot close `" + le.type + "` (" + _m({
                start: le.start,
                end: le.end
            }) + "): its not open");
        He.position.end = rc(le.end)
    }
    function f() {
        return qA(this.stack.pop())
    }
    function h() {
        this.data.expectingFirstListItemValue = !0
    }
    function m(le) {
        if (this.data.expectingFirstListItemValue) {
            const ke = this.stack[this.stack.length - 2];
            ke.start = Number.parseInt(this.sliceSerialize(le), 10),
            this.data.expectingFirstListItemValue = void 0
        }
    }
    function y() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.lang = le
    }
    function b() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.meta = le
    }
    function v() {
        this.data.flowCodeInside || (this.buffer(),
        this.data.flowCodeInside = !0)
    }
    function S() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.value = le.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""),
        this.data.flowCodeInside = void 0
    }
    function C() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.value = le.replace(/(\r?\n|\r)$/g, "")
    }
    function w(le) {
        const ke = this.resume()
          , He = this.stack[this.stack.length - 1];
        He.label = ke,
        He.identifier = Ga(this.sliceSerialize(le)).toLowerCase()
    }
    function k() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.title = le
    }
    function T() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.url = le
    }
    function E(le) {
        const ke = this.stack[this.stack.length - 1];
        if (!ke.depth) {
            const He = this.sliceSerialize(le).length;
            ke.depth = He
        }
    }
    function P() {
        this.data.setextHeadingSlurpLineEnding = !0
    }
    function D(le) {
        const ke = this.stack[this.stack.length - 1];
        ke.depth = this.sliceSerialize(le).codePointAt(0) === 61 ? 1 : 2
    }
    function $() {
        this.data.setextHeadingSlurpLineEnding = void 0
    }
    function z(le) {
        const He = this.stack[this.stack.length - 1].children;
        let st = He[He.length - 1];
        (!st || st.type !== "text") && (st = Oe(),
        st.position = {
            start: rc(le.start),
            end: void 0
        },
        He.push(st)),
        this.stack.push(st)
    }
    function O(le) {
        const ke = this.stack.pop();
        ke.value += this.sliceSerialize(le),
        ke.position.end = rc(le.end)
    }
    function I(le) {
        const ke = this.stack[this.stack.length - 1];
        if (this.data.atHardBreak) {
            const He = ke.children[ke.children.length - 1];
            He.position.end = rc(le.end),
            this.data.atHardBreak = void 0;
            return
        }
        !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(ke.type) && (z.call(this, le),
        O.call(this, le))
    }
    function M() {
        this.data.atHardBreak = !0
    }
    function B() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.value = le
    }
    function L() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.value = le
    }
    function F() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.value = le
    }
    function j() {
        const le = this.stack[this.stack.length - 1];
        if (this.data.inReference) {
            const ke = this.data.referenceType || "shortcut";
            le.type += "Reference",
            le.referenceType = ke,
            delete le.url,
            delete le.title
        } else
            delete le.identifier,
            delete le.label;
        this.data.referenceType = void 0
    }
    function N() {
        const le = this.stack[this.stack.length - 1];
        if (this.data.inReference) {
            const ke = this.data.referenceType || "shortcut";
            le.type += "Reference",
            le.referenceType = ke,
            delete le.url,
            delete le.title
        } else
            delete le.identifier,
            delete le.label;
        this.data.referenceType = void 0
    }
    function H(le) {
        const ke = this.sliceSerialize(le)
          , He = this.stack[this.stack.length - 2];
        He.label = $we(ke),
        He.identifier = Ga(ke).toLowerCase()
    }
    function Z() {
        const le = this.stack[this.stack.length - 1]
          , ke = this.resume()
          , He = this.stack[this.stack.length - 1];
        if (this.data.inReference = !0,
        He.type === "link") {
            const st = le.children;
            He.children = st
        } else
            He.alt = ke
    }
    function q() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.url = le
    }
    function V() {
        const le = this.resume()
          , ke = this.stack[this.stack.length - 1];
        ke.title = le
    }
    function Y() {
        this.data.inReference = void 0
    }
    function W() {
        this.data.referenceType = "collapsed"
    }
    function te(le) {
        const ke = this.resume()
          , He = this.stack[this.stack.length - 1];
        He.label = ke,
        He.identifier = Ga(this.sliceSerialize(le)).toLowerCase(),
        this.data.referenceType = "full"
    }
    function K(le) {
        this.data.characterReferenceType = le.type
    }
    function ee(le) {
        const ke = this.sliceSerialize(le)
          , He = this.data.characterReferenceType;
        let st;
        He ? (st = z9(ke, He === "characterReferenceMarkerNumeric" ? 10 : 16),
        this.data.characterReferenceType = void 0) : st = WA(ke);
        const lt = this.stack[this.stack.length - 1];
        lt.value += st
    }
    function re(le) {
        const ke = this.stack.pop();
        ke.position.end = rc(le.end)
    }
    function ie(le) {
        O.call(this, le);
        const ke = this.stack[this.stack.length - 1];
        ke.url = this.sliceSerialize(le)
    }
    function J(le) {
        O.call(this, le);
        const ke = this.stack[this.stack.length - 1];
        ke.url = "mailto:" + this.sliceSerialize(le)
    }
    function oe() {
        return {
            type: "blockquote",
            children: []
        }
    }
    function we() {
        return {
            type: "code",
            lang: null,
            meta: null,
            value: ""
        }
    }
    function xe() {
        return {
            type: "inlineCode",
            value: ""
        }
    }
    function se() {
        return {
            type: "definition",
            identifier: "",
            label: null,
            title: null,
            url: ""
        }
    }
    function de() {
        return {
            type: "emphasis",
            children: []
        }
    }
    function Se() {
        return {
            type: "heading",
            depth: 0,
            children: []
        }
    }
    function Ce() {
        return {
            type: "break"
        }
    }
    function Ye() {
        return {
            type: "html",
            value: ""
        }
    }
    function ye() {
        return {
            type: "image",
            title: null,
            url: "",
            alt: null
        }
    }
    function Ke() {
        return {
            type: "link",
            title: null,
            url: "",
            children: []
        }
    }
    function X(le) {
        return {
            type: "list",
            ordered: le.type === "listOrdered",
            start: null,
            spread: le._spread,
            children: []
        }
    }
    function ce(le) {
        return {
            type: "listItem",
            spread: le._spread,
            checked: null,
            children: []
        }
    }
    function fe() {
        return {
            type: "paragraph",
            children: []
        }
    }
    function Xe() {
        return {
            type: "strong",
            children: []
        }
    }
    function Oe() {
        return {
            type: "text",
            value: ""
        }
    }
    function Re() {
        return {
            type: "thematicBreak"
        }
    }
}
function rc(e) {
    return {
        line: e.line,
        column: e.column,
        offset: e.offset
    }
}
function Q9(e, t) {
    let n = -1;
    for (; ++n < t.length; ) {
        const r = t[n];
        Array.isArray(r) ? Q9(e, r) : zwe(e, r)
    }
}
function zwe(e, t) {
    let n;
    for (n in t)
        if (Z9.call(t, n))
            switch (n) {
            case "canContainEols":
                {
                    const r = t[n];
                    r && e[n].push(...r);
                    break
                }
            case "transforms":
                {
                    const r = t[n];
                    r && e[n].push(...r);
                    break
                }
            case "enter":
            case "exit":
                {
                    const r = t[n];
                    r && Object.assign(e[n], r);
                    break
                }
            }
}
function CB(e, t) {
    throw e ? new Error("Cannot close `" + e.type + "` (" + _m({
        start: e.start,
        end: e.end
    }) + "): a different token (`" + t.type + "`, " + _m({
        start: t.start,
        end: t.end
    }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + _m({
        start: t.start,
        end: t.end
    }) + ") is still open")
}
function Fwe(e) {
    const t = this;
    t.parser = n;
    function n(r) {
        return jwe(r, {
            ...t.data("settings"),
            ...e,
            extensions: t.data("micromarkExtensions") || [],
            mdastExtensions: t.data("fromMarkdownExtensions") || []
        })
    }
}
function Nwe(e, t) {
    const n = {
        type: "element",
        tagName: "blockquote",
        properties: {},
        children: e.wrap(e.all(t), !0)
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
function Uwe(e, t) {
    const n = {
        type: "element",
        tagName: "br",
        properties: {},
        children: []
    };
    return e.patch(t, n),
    [e.applyData(t, n), {
        type: "text",
        value: `
`
    }]
}
function Vwe(e, t) {
    const n = t.value ? t.value + `
` : ""
      , r = {};
    t.lang && (r.className = ["language-" + t.lang]);
    let i = {
        type: "element",
        tagName: "code",
        properties: r,
        children: [{
            type: "text",
            value: n
        }]
    };
    return t.meta && (i.data = {
        meta: t.meta
    }),
    e.patch(t, i),
    i = e.applyData(t, i),
    i = {
        type: "element",
        tagName: "pre",
        properties: {},
        children: [i]
    },
    e.patch(t, i),
    i
}
function Hwe(e, t) {
    const n = {
        type: "element",
        tagName: "del",
        properties: {},
        children: e.all(t)
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
function qwe(e, t) {
    const n = {
        type: "element",
        tagName: "em",
        properties: {},
        children: e.all(t)
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
function Wwe(e, t) {
    const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-"
      , r = String(t.identifier).toUpperCase()
      , i = xh(r.toLowerCase())
      , o = e.footnoteOrder.indexOf(r);
    let a, s = e.footnoteCounts.get(r);
    s === void 0 ? (s = 0,
    e.footnoteOrder.push(r),
    a = e.footnoteOrder.length) : a = o + 1,
    s += 1,
    e.footnoteCounts.set(r, s);
    const c = {
        type: "element",
        tagName: "a",
        properties: {
            href: "#" + n + "fn-" + i,
            id: n + "fnref-" + i + (s > 1 ? "-" + s : ""),
            dataFootnoteRef: !0,
            ariaDescribedBy: ["footnote-label"]
        },
        children: [{
            type: "text",
            value: String(a)
        }]
    };
    e.patch(t, c);
    const u = {
        type: "element",
        tagName: "sup",
        properties: {},
        children: [c]
    };
    return e.patch(t, u),
    e.applyData(t, u)
}
function Gwe(e, t) {
    const n = {
        type: "element",
        tagName: "h" + t.depth,
        properties: {},
        children: e.all(t)
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
function Ywe(e, t) {
    if (e.options.allowDangerousHtml) {
        const n = {
            type: "raw",
            value: t.value
        };
        return e.patch(t, n),
        e.applyData(t, n)
    }
}
function K9(e, t) {
    const n = t.referenceType;
    let r = "]";
    if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"),
    t.type === "imageReference")
        return [{
            type: "text",
            value: "![" + t.alt + r
        }];
    const i = e.all(t)
      , o = i[0];
    o && o.type === "text" ? o.value = "[" + o.value : i.unshift({
        type: "text",
        value: "["
    });
    const a = i[i.length - 1];
    return a && a.type === "text" ? a.value += r : i.push({
        type: "text",
        value: r
    }),
    i
}
function Zwe(e, t) {
    const n = String(t.identifier).toUpperCase()
      , r = e.definitionById.get(n);
    if (!r)
        return K9(e, t);
    const i = {
        src: xh(r.url || ""),
        alt: t.alt
    };
    r.title !== null && r.title !== void 0 && (i.title = r.title);
    const o = {
        type: "element",
        tagName: "img",
        properties: i,
        children: []
    };
    return e.patch(t, o),
    e.applyData(t, o)
}
function Qwe(e, t) {
    const n = {
        src: xh(t.url)
    };
    t.alt !== null && t.alt !== void 0 && (n.alt = t.alt),
    t.title !== null && t.title !== void 0 && (n.title = t.title);
    const r = {
        type: "element",
        tagName: "img",
        properties: n,
        children: []
    };
    return e.patch(t, r),
    e.applyData(t, r)
}
function Kwe(e, t) {
    const n = {
        type: "text",
        value: t.value.replace(/\r?\n|\r/g, " ")
    };
    e.patch(t, n);
    const r = {
        type: "element",
        tagName: "code",
        properties: {},
        children: [n]
    };
    return e.patch(t, r),
    e.applyData(t, r)
}
function Xwe(e, t) {
    const n = String(t.identifier).toUpperCase()
      , r = e.definitionById.get(n);
    if (!r)
        return K9(e, t);
    const i = {
        href: xh(r.url || "")
    };
    r.title !== null && r.title !== void 0 && (i.title = r.title);
    const o = {
        type: "element",
        tagName: "a",
        properties: i,
        children: e.all(t)
    };
    return e.patch(t, o),
    e.applyData(t, o)
}
function Jwe(e, t) {
    const n = {
        href: xh(t.url)
    };
    t.title !== null && t.title !== void 0 && (n.title = t.title);
    const r = {
        type: "element",
        tagName: "a",
        properties: n,
        children: e.all(t)
    };
    return e.patch(t, r),
    e.applyData(t, r)
}
function eke(e, t, n) {
    const r = e.all(t)
      , i = n ? tke(n) : X9(t)
      , o = {}
      , a = [];
    if (typeof t.checked == "boolean") {
        const f = r[0];
        let h;
        f && f.type === "element" && f.tagName === "p" ? h = f : (h = {
            type: "element",
            tagName: "p",
            properties: {},
            children: []
        },
        r.unshift(h)),
        h.children.length > 0 && h.children.unshift({
            type: "text",
            value: " "
        }),
        h.children.unshift({
            type: "element",
            tagName: "input",
            properties: {
                type: "checkbox",
                checked: t.checked,
                disabled: !0
            },
            children: []
        }),
        o.className = ["task-list-item"]
    }
    let s = -1;
    for (; ++s < r.length; ) {
        const f = r[s];
        (i || s !== 0 || f.type !== "element" || f.tagName !== "p") && a.push({
            type: "text",
            value: `
`
        }),
        f.type === "element" && f.tagName === "p" && !i ? a.push(...f.children) : a.push(f)
    }
    const c = r[r.length - 1];
    c && (i || c.type !== "element" || c.tagName !== "p") && a.push({
        type: "text",
        value: `
`
    });
    const u = {
        type: "element",
        tagName: "li",
        properties: o,
        children: a
    };
    return e.patch(t, u),
    e.applyData(t, u)
}
function tke(e) {
    let t = !1;
    if (e.type === "list") {
        t = e.spread || !1;
        const n = e.children;
        let r = -1;
        for (; !t && ++r < n.length; )
            t = X9(n[r])
    }
    return t
}
function X9(e) {
    const t = e.spread;
    return t ?? e.children.length > 1
}
function nke(e, t) {
    const n = {}
      , r = e.all(t);
    let i = -1;
    for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
        const a = r[i];
        if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
            n.className = ["contains-task-list"];
            break
        }
    }
    const o = {
        type: "element",
        tagName: t.ordered ? "ol" : "ul",
        properties: n,
        children: e.wrap(r, !0)
    };
    return e.patch(t, o),
    e.applyData(t, o)
}
function rke(e, t) {
    const n = {
        type: "element",
        tagName: "p",
        properties: {},
        children: e.all(t)
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
function ike(e, t) {
    const n = {
        type: "root",
        children: e.wrap(e.all(t))
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
function oke(e, t) {
    const n = {
        type: "element",
        tagName: "strong",
        properties: {},
        children: e.all(t)
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
function ake(e, t) {
    const n = e.all(t)
      , r = n.shift()
      , i = [];
    if (r) {
        const a = {
            type: "element",
            tagName: "thead",
            properties: {},
            children: e.wrap([r], !0)
        };
        e.patch(t.children[0], a),
        i.push(a)
    }
    if (n.length > 0) {
        const a = {
            type: "element",
            tagName: "tbody",
            properties: {},
            children: e.wrap(n, !0)
        }
          , s = NA(t.children[1])
          , c = R9(t.children[t.children.length - 1]);
        s && c && (a.position = {
            start: s,
            end: c
        }),
        i.push(a)
    }
    const o = {
        type: "element",
        tagName: "table",
        properties: {},
        children: e.wrap(i, !0)
    };
    return e.patch(t, o),
    e.applyData(t, o)
}
function ske(e, t, n) {
    const r = n ? n.children : void 0
      , o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td"
      , a = n && n.type === "table" ? n.align : void 0
      , s = a ? a.length : t.children.length;
    let c = -1;
    const u = [];
    for (; ++c < s; ) {
        const h = t.children[c]
          , m = {}
          , y = a ? a[c] : void 0;
        y && (m.align = y);
        let b = {
            type: "element",
            tagName: o,
            properties: m,
            children: []
        };
        h && (b.children = e.all(h),
        e.patch(h, b),
        b = e.applyData(h, b)),
        u.push(b)
    }
    const f = {
        type: "element",
        tagName: "tr",
        properties: {},
        children: e.wrap(u, !0)
    };
    return e.patch(t, f),
    e.applyData(t, f)
}
function lke(e, t) {
    const n = {
        type: "element",
        tagName: "td",
        properties: {},
        children: e.all(t)
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
const wB = 9
  , kB = 32;
function cke(e) {
    const t = String(e)
      , n = /\r?\n|\r/g;
    let r = n.exec(t)
      , i = 0;
    const o = [];
    for (; r; )
        o.push(TB(t.slice(i, r.index), i > 0, !0), r[0]),
        i = r.index + r[0].length,
        r = n.exec(t);
    return o.push(TB(t.slice(i), i > 0, !1)),
    o.join("")
}
function TB(e, t, n) {
    let r = 0
      , i = e.length;
    if (t) {
        let o = e.codePointAt(r);
        for (; o === wB || o === kB; )
            r++,
            o = e.codePointAt(r)
    }
    if (n) {
        let o = e.codePointAt(i - 1);
        for (; o === wB || o === kB; )
            i--,
            o = e.codePointAt(i - 1)
    }
    return i > r ? e.slice(r, i) : ""
}
function uke(e, t) {
    const n = {
        type: "text",
        value: cke(String(t.value))
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
function dke(e, t) {
    const n = {
        type: "element",
        tagName: "hr",
        properties: {},
        children: []
    };
    return e.patch(t, n),
    e.applyData(t, n)
}
const fke = {
    blockquote: Nwe,
    break: Uwe,
    code: Vwe,
    delete: Hwe,
    emphasis: qwe,
    footnoteReference: Wwe,
    heading: Gwe,
    html: Ywe,
    imageReference: Zwe,
    image: Qwe,
    inlineCode: Kwe,
    linkReference: Xwe,
    link: Jwe,
    listItem: eke,
    list: nke,
    paragraph: rke,
    root: ike,
    strong: oke,
    table: ake,
    tableCell: lke,
    tableRow: ske,
    text: uke,
    thematicBreak: dke,
    toml: tx,
    yaml: tx,
    definition: tx,
    footnoteDefinition: tx
};
function tx() {}
const J9 = -1
  , $1 = 0
  , Am = 1
  , z0 = 2
  , YA = 3
  , ZA = 4
  , QA = 5
  , KA = 6
  , e8 = 7
  , t8 = 8
  , _B = typeof self == "object" ? self : globalThis
  , hke = (e, t) => {
    const n = (i, o) => (e.set(o, i),
    i)
      , r = i => {
        if (e.has(i))
            return e.get(i);
        const [o,a] = t[i];
        switch (o) {
        case $1:
        case J9:
            return n(a, i);
        case Am:
            {
                const s = n([], i);
                for (const c of a)
                    s.push(r(c));
                return s
            }
        case z0:
            {
                const s = n({}, i);
                for (const [c,u] of a)
                    s[r(c)] = r(u);
                return s
            }
        case YA:
            return n(new Date(a), i);
        case ZA:
            {
                const {source: s, flags: c} = a;
                return n(new RegExp(s,c), i)
            }
        case QA:
            {
                const s = n(new Map, i);
                for (const [c,u] of a)
                    s.set(r(c), r(u));
                return s
            }
        case KA:
            {
                const s = n(new Set, i);
                for (const c of a)
                    s.add(r(c));
                return s
            }
        case e8:
            {
                const {name: s, message: c} = a;
                return n(new _B[s](c), i)
            }
        case t8:
            return n(BigInt(a), i);
        case "BigInt":
            return n(Object(BigInt(a)), i);
        case "ArrayBuffer":
            return n(new Uint8Array(a).buffer, a);
        case "DataView":
            {
                const {buffer: s} = new Uint8Array(a);
                return n(new DataView(s), a)
            }
        }
        return n(new _B[o](a), i)
    }
    ;
    return r
}
  , EB = e => hke(new Map, e)(0)
  , Jd = ""
  , {toString: pke} = {}
  , {keys: mke} = Object
  , Dp = e => {
    const t = typeof e;
    if (t !== "object" || !e)
        return [$1, t];
    const n = pke.call(e).slice(8, -1);
    switch (n) {
    case "Array":
        return [Am, Jd];
    case "Object":
        return [z0, Jd];
    case "Date":
        return [YA, Jd];
    case "RegExp":
        return [ZA, Jd];
    case "Map":
        return [QA, Jd];
    case "Set":
        return [KA, Jd];
    case "DataView":
        return [Am, n]
    }
    return n.includes("Array") ? [Am, n] : n.includes("Error") ? [e8, n] : [z0, n]
}
  , nx = ([e,t]) => e === $1 && (t === "function" || t === "symbol")
  , gke = (e, t, n, r) => {
    const i = (a, s) => {
        const c = r.push(a) - 1;
        return n.set(s, c),
        c
    }
      , o = a => {
        if (n.has(a))
            return n.get(a);
        let[s,c] = Dp(a);
        switch (s) {
        case $1:
            {
                let f = a;
                switch (c) {
                case "bigint":
                    s = t8,
                    f = a.toString();
                    break;
                case "function":
                case "symbol":
                    if (e)
                        throw new TypeError("unable to serialize " + c);
                    f = null;
                    break;
                case "undefined":
                    return i([J9], a)
                }
                return i([s, f], a)
            }
        case Am:
            {
                if (c) {
                    let m = a;
                    return c === "DataView" ? m = new Uint8Array(a.buffer) : c === "ArrayBuffer" && (m = new Uint8Array(a)),
                    i([c, [...m]], a)
                }
                const f = []
                  , h = i([s, f], a);
                for (const m of a)
                    f.push(o(m));
                return h
            }
        case z0:
            {
                if (c)
                    switch (c) {
                    case "BigInt":
                        return i([c, a.toString()], a);
                    case "Boolean":
                    case "Number":
                    case "String":
                        return i([c, a.valueOf()], a)
                    }
                if (t && "toJSON"in a)
                    return o(a.toJSON());
                const f = []
                  , h = i([s, f], a);
                for (const m of mke(a))
                    (e || !nx(Dp(a[m]))) && f.push([o(m), o(a[m])]);
                return h
            }
        case YA:
            return i([s, a.toISOString()], a);
        case ZA:
            {
                const {source: f, flags: h} = a;
                return i([s, {
                    source: f,
                    flags: h
                }], a)
            }
        case QA:
            {
                const f = []
                  , h = i([s, f], a);
                for (const [m,y] of a)
                    (e || !(nx(Dp(m)) || nx(Dp(y)))) && f.push([o(m), o(y)]);
                return h
            }
        case KA:
            {
                const f = []
                  , h = i([s, f], a);
                for (const m of a)
                    (e || !nx(Dp(m))) && f.push(o(m));
                return h
            }
        }
        const {message: u} = a;
        return i([s, {
            name: c,
            message: u
        }], a)
    }
    ;
    return o
}
  , AB = (e, {json: t, lossy: n}={}) => {
    const r = [];
    return gke(!(t || n), !!t, new Map, r)(e),
    r
}
  , F0 = typeof structuredClone == "function" ? (e, t) => t && ("json"in t || "lossy"in t) ? EB(AB(e, t)) : structuredClone(e) : (e, t) => EB(AB(e, t));
function yke(e, t) {
    const n = [{
        type: "text",
        value: ""
    }];
    return t > 1 && n.push({
        type: "element",
        tagName: "sup",
        properties: {},
        children: [{
            type: "text",
            value: String(t)
        }]
    }),
    n
}
function bke(e, t) {
    return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "")
}
function xke(e) {
    const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-"
      , n = e.options.footnoteBackContent || yke
      , r = e.options.footnoteBackLabel || bke
      , i = e.options.footnoteLabel || "Footnotes"
      , o = e.options.footnoteLabelTagName || "h2"
      , a = e.options.footnoteLabelProperties || {
        className: ["sr-only"]
    }
      , s = [];
    let c = -1;
    for (; ++c < e.footnoteOrder.length; ) {
        const u = e.footnoteById.get(e.footnoteOrder[c]);
        if (!u)
            continue;
        const f = e.all(u)
          , h = String(u.identifier).toUpperCase()
          , m = xh(h.toLowerCase());
        let y = 0;
        const b = []
          , v = e.footnoteCounts.get(h);
        for (; v !== void 0 && ++y <= v; ) {
            b.length > 0 && b.push({
                type: "text",
                value: " "
            });
            let w = typeof n == "string" ? n : n(c, y);
            typeof w == "string" && (w = {
                type: "text",
                value: w
            }),
            b.push({
                type: "element",
                tagName: "a",
                properties: {
                    href: "#" + t + "fnref-" + m + (y > 1 ? "-" + y : ""),
                    dataFootnoteBackref: "",
                    ariaLabel: typeof r == "string" ? r : r(c, y),
                    className: ["data-footnote-backref"]
                },
                children: Array.isArray(w) ? w : [w]
            })
        }
        const S = f[f.length - 1];
        if (S && S.type === "element" && S.tagName === "p") {
            const w = S.children[S.children.length - 1];
            w && w.type === "text" ? w.value += " " : S.children.push({
                type: "text",
                value: " "
            }),
            S.children.push(...b)
        } else
            f.push(...b);
        const C = {
            type: "element",
            tagName: "li",
            properties: {
                id: t + "fn-" + m
            },
            children: e.wrap(f, !0)
        };
        e.patch(u, C),
        s.push(C)
    }
    if (s.length !== 0)
        return {
            type: "element",
            tagName: "section",
            properties: {
                dataFootnotes: !0,
                className: ["footnotes"]
            },
            children: [{
                type: "element",
                tagName: o,
                properties: {
                    ...F0(a),
                    id: "footnote-label"
                },
                children: [{
                    type: "text",
                    value: i
                }]
            }, {
                type: "text",
                value: `
`
            }, {
                type: "element",
                tagName: "ol",
                properties: {},
                children: e.wrap(s, !0)
            }, {
                type: "text",
                value: `
`
            }]
        }
}
const L1 = (function(e) {
    if (e == null)
        return wke;
    if (typeof e == "function")
        return j1(e);
    if (typeof e == "object")
        return Array.isArray(e) ? vke(e) : Ske(e);
    if (typeof e == "string")
        return Cke(e);
    throw new Error("Expected function, string, or object as test")
}
);
function vke(e) {
    const t = [];
    let n = -1;
    for (; ++n < e.length; )
        t[n] = L1(e[n]);
    return j1(r);
    function r(...i) {
        let o = -1;
        for (; ++o < t.length; )
            if (t[o].apply(this, i))
                return !0;
        return !1
    }
}
function Ske(e) {
    const t = e;
    return j1(n);
    function n(r) {
        const i = r;
        let o;
        for (o in e)
            if (i[o] !== t[o])
                return !1;
        return !0
    }
}
function Cke(e) {
    return j1(t);
    function t(n) {
        return n && n.type === e
    }
}
function j1(e) {
    return t;
    function t(n, r, i) {
        return !!(kke(n) && e.call(this, n, typeof r == "number" ? r : void 0, i || void 0))
    }
}
function wke() {
    return !0
}
function kke(e) {
    return e !== null && typeof e == "object" && "type"in e
}
const n8 = []
  , Tke = !0
  , HT = !1
  , _ke = "skip";
function r8(e, t, n, r) {
    let i;
    typeof t == "function" && typeof n != "function" ? (r = n,
    n = t) : i = t;
    const o = L1(i)
      , a = r ? -1 : 1;
    s(e, void 0, [])();
    function s(c, u, f) {
        const h = c && typeof c == "object" ? c : {};
        if (typeof h.type == "string") {
            const y = typeof h.tagName == "string" ? h.tagName : typeof h.name == "string" ? h.name : void 0;
            Object.defineProperty(m, "name", {
                value: "node (" + (c.type + (y ? "<" + y + ">" : "")) + ")"
            })
        }
        return m;
        function m() {
            let y = n8, b, v, S;
            if ((!t || o(c, u, f[f.length - 1] || void 0)) && (y = Eke(n(c, f)),
            y[0] === HT))
                return y;
            if ("children"in c && c.children) {
                const C = c;
                if (C.children && y[0] !== _ke)
                    for (v = (r ? C.children.length : -1) + a,
                    S = f.concat(C); v > -1 && v < C.children.length; ) {
                        const w = C.children[v];
                        if (b = s(w, v, S)(),
                        b[0] === HT)
                            return b;
                        v = typeof b[1] == "number" ? b[1] : v + a
                    }
            }
            return y
        }
    }
}
function Eke(e) {
    return Array.isArray(e) ? e : typeof e == "number" ? [Tke, e] : e == null ? n8 : [e]
}
function XA(e, t, n, r) {
    let i, o, a;
    typeof t == "function" && typeof n != "function" ? (o = void 0,
    a = t,
    i = n) : (o = t,
    a = n,
    i = r),
    r8(e, o, s, i);
    function s(c, u) {
        const f = u[u.length - 1]
          , h = f ? f.children.indexOf(c) : void 0;
        return a(c, h, f)
    }
}
const qT = {}.hasOwnProperty
  , Ake = {};
function Mke(e, t) {
    const n = t || Ake
      , r = new Map
      , i = new Map
      , o = new Map
      , a = {
        ...fke,
        ...n.handlers
    }
      , s = {
        all: u,
        applyData: Rke,
        definitionById: r,
        footnoteById: i,
        footnoteCounts: o,
        footnoteOrder: [],
        handlers: a,
        one: c,
        options: n,
        patch: Pke,
        wrap: Oke
    };
    return XA(e, function(f) {
        if (f.type === "definition" || f.type === "footnoteDefinition") {
            const h = f.type === "definition" ? r : i
              , m = String(f.identifier).toUpperCase();
            h.has(m) || h.set(m, f)
        }
    }),
    s;
    function c(f, h) {
        const m = f.type
          , y = s.handlers[m];
        if (qT.call(s.handlers, m) && y)
            return y(s, f, h);
        if (s.options.passThrough && s.options.passThrough.includes(m)) {
            if ("children"in f) {
                const {children: v, ...S} = f
                  , C = F0(S);
                return C.children = s.all(f),
                C
            }
            return F0(f)
        }
        return (s.options.unknownHandler || Dke)(s, f, h)
    }
    function u(f) {
        const h = [];
        if ("children"in f) {
            const m = f.children;
            let y = -1;
            for (; ++y < m.length; ) {
                const b = s.one(m[y], f);
                if (b) {
                    if (y && m[y - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = MB(b.value)),
                    !Array.isArray(b) && b.type === "element")) {
                        const v = b.children[0];
                        v && v.type === "text" && (v.value = MB(v.value))
                    }
                    Array.isArray(b) ? h.push(...b) : h.push(b)
                }
            }
        }
        return h
    }
}
function Pke(e, t) {
    e.position && (t.position = bSe(e))
}
function Rke(e, t) {
    let n = t;
    if (e && e.data) {
        const r = e.data.hName
          , i = e.data.hChildren
          , o = e.data.hProperties;
        if (typeof r == "string")
            if (n.type === "element")
                n.tagName = r;
            else {
                const a = "children"in n ? n.children : [n];
                n = {
                    type: "element",
                    tagName: r,
                    properties: {},
                    children: a
                }
            }
        n.type === "element" && o && Object.assign(n.properties, F0(o)),
        "children"in n && n.children && i !== null && i !== void 0 && (n.children = i)
    }
    return n
}
function Dke(e, t) {
    const n = t.data || {}
      , r = "value"in t && !(qT.call(n, "hProperties") || qT.call(n, "hChildren")) ? {
        type: "text",
        value: t.value
    } : {
        type: "element",
        tagName: "div",
        properties: {},
        children: e.all(t)
    };
    return e.patch(t, r),
    e.applyData(t, r)
}
function Oke(e, t) {
    const n = [];
    let r = -1;
    for (t && n.push({
        type: "text",
        value: `
`
    }); ++r < e.length; )
        r && n.push({
            type: "text",
            value: `
`
        }),
        n.push(e[r]);
    return t && e.length > 0 && n.push({
        type: "text",
        value: `
`
    }),
    n
}
function MB(e) {
    let t = 0
      , n = e.charCodeAt(t);
    for (; n === 9 || n === 32; )
        t++,
        n = e.charCodeAt(t);
    return e.slice(t)
}
function PB(e, t) {
    const n = Mke(e, t)
      , r = n.one(e, void 0)
      , i = xke(n)
      , o = Array.isArray(r) ? {
        type: "root",
        children: r
    } : r || {
        type: "root",
        children: []
    };
    return i && o.children.push({
        type: "text",
        value: `
`
    }, i),
    o
}
function Ike(e, t) {
    return e && "run"in e ? async function(n, r) {
        const i = PB(n, {
            file: r,
            ...t
        });
        await e.run(i, r)
    }
    : function(n, r) {
        return PB(n, {
            file: r,
            ...e || t
        })
    }
}
function RB(e) {
    if (e)
        throw e
}
var Bk, DB;
function $ke() {
    if (DB)
        return Bk;
    DB = 1;
    var e = Object.prototype.hasOwnProperty
      , t = Object.prototype.toString
      , n = Object.defineProperty
      , r = Object.getOwnPropertyDescriptor
      , i = function(u) {
        return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]"
    }
      , o = function(u) {
        if (!u || t.call(u) !== "[object Object]")
            return !1;
        var f = e.call(u, "constructor")
          , h = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf");
        if (u.constructor && !f && !h)
            return !1;
        var m;
        for (m in u)
            ;
        return typeof m > "u" || e.call(u, m)
    }
      , a = function(u, f) {
        n && f.name === "__proto__" ? n(u, f.name, {
            enumerable: !0,
            configurable: !0,
            value: f.newValue,
            writable: !0
        }) : u[f.name] = f.newValue
    }
      , s = function(u, f) {
        if (f === "__proto__")
            if (e.call(u, f)) {
                if (r)
                    return r(u, f).value
            } else
                return;
        return u[f]
    };
    return Bk = function c() {
        var u, f, h, m, y, b, v = arguments[0], S = 1, C = arguments.length, w = !1;
        for (typeof v == "boolean" && (w = v,
        v = arguments[1] || {},
        S = 2),
        (v == null || typeof v != "object" && typeof v != "function") && (v = {}); S < C; ++S)
            if (u = arguments[S],
            u != null)
                for (f in u)
                    h = s(v, f),
                    m = s(u, f),
                    v !== m && (w && m && (o(m) || (y = i(m))) ? (y ? (y = !1,
                    b = h && i(h) ? h : []) : b = h && o(h) ? h : {},
                    a(v, {
                        name: f,
                        newValue: c(w, b, m)
                    })) : typeof m < "u" && a(v, {
                        name: f,
                        newValue: m
                    }));
        return v
    }
    ,
    Bk
}
var Lke = $ke();
const zk = es(Lke);
function WT(e) {
    if (typeof e != "object" || e === null)
        return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
}
function jke() {
    const e = []
      , t = {
        run: n,
        use: r
    };
    return t;
    function n(...i) {
        let o = -1;
        const a = i.pop();
        if (typeof a != "function")
            throw new TypeError("Expected function as last argument, not " + a);
        s(null, ...i);
        function s(c, ...u) {
            const f = e[++o];
            let h = -1;
            if (c) {
                a(c);
                return
            }
            for (; ++h < i.length; )
                (u[h] === null || u[h] === void 0) && (u[h] = i[h]);
            i = u,
            f ? Bke(f, s)(...u) : a(null, ...u)
        }
    }
    function r(i) {
        if (typeof i != "function")
            throw new TypeError("Expected `middelware` to be a function, not " + i);
        return e.push(i),
        t
    }
}
function Bke(e, t) {
    let n;
    return r;
    function r(...a) {
        const s = e.length > a.length;
        let c;
        s && a.push(i);
        try {
            c = e.apply(this, a)
        } catch (u) {
            const f = u;
            if (s && n)
                throw f;
            return i(f)
        }
        s || (c && c.then && typeof c.then == "function" ? c.then(o, i) : c instanceof Error ? i(c) : o(c))
    }
    function i(a, ...s) {
        n || (n = !0,
        t(a, ...s))
    }
    function o(a) {
        i(null, a)
    }
}
const ms = {
    basename: zke,
    dirname: Fke,
    extname: Nke,
    join: Uke,
    sep: "/"
};
function zke(e, t) {
    if (t !== void 0 && typeof t != "string")
        throw new TypeError('"ext" argument must be a string');
    ty(e);
    let n = 0, r = -1, i = e.length, o;
    if (t === void 0 || t.length === 0 || t.length > e.length) {
        for (; i--; )
            if (e.codePointAt(i) === 47) {
                if (o) {
                    n = i + 1;
                    break
                }
            } else
                r < 0 && (o = !0,
                r = i + 1);
        return r < 0 ? "" : e.slice(n, r)
    }
    if (t === e)
        return "";
    let a = -1
      , s = t.length - 1;
    for (; i--; )
        if (e.codePointAt(i) === 47) {
            if (o) {
                n = i + 1;
                break
            }
        } else
            a < 0 && (o = !0,
            a = i + 1),
            s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (r = i) : (s = -1,
            r = a));
    return n === r ? r = a : r < 0 && (r = e.length),
    e.slice(n, r)
}
function Fke(e) {
    if (ty(e),
    e.length === 0)
        return ".";
    let t = -1, n = e.length, r;
    for (; --n; )
        if (e.codePointAt(n) === 47) {
            if (r) {
                t = n;
                break
            }
        } else
            r || (r = !0);
    return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t)
}
function Nke(e) {
    ty(e);
    let t = e.length, n = -1, r = 0, i = -1, o = 0, a;
    for (; t--; ) {
        const s = e.codePointAt(t);
        if (s === 47) {
            if (a) {
                r = t + 1;
                break
            }
            continue
        }
        n < 0 && (a = !0,
        n = t + 1),
        s === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1)
    }
    return i < 0 || n < 0 || o === 0 || o === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n)
}
function Uke(...e) {
    let t = -1, n;
    for (; ++t < e.length; )
        ty(e[t]),
        e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
    return n === void 0 ? "." : Vke(n)
}
function Vke(e) {
    ty(e);
    const t = e.codePointAt(0) === 47;
    let n = Hke(e, !t);
    return n.length === 0 && !t && (n = "."),
    n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"),
    t ? "/" + n : n
}
function Hke(e, t) {
    let n = "", r = 0, i = -1, o = 0, a = -1, s, c;
    for (; ++a <= e.length; ) {
        if (a < e.length)
            s = e.codePointAt(a);
        else {
            if (s === 47)
                break;
            s = 47
        }
        if (s === 47) {
            if (!(i === a - 1 || o === 1))
                if (i !== a - 1 && o === 2) {
                    if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
                        if (n.length > 2) {
                            if (c = n.lastIndexOf("/"),
                            c !== n.length - 1) {
                                c < 0 ? (n = "",
                                r = 0) : (n = n.slice(0, c),
                                r = n.length - 1 - n.lastIndexOf("/")),
                                i = a,
                                o = 0;
                                continue
                            }
                        } else if (n.length > 0) {
                            n = "",
                            r = 0,
                            i = a,
                            o = 0;
                            continue
                        }
                    }
                    t && (n = n.length > 0 ? n + "/.." : "..",
                    r = 2)
                } else
                    n.length > 0 ? n += "/" + e.slice(i + 1, a) : n = e.slice(i + 1, a),
                    r = a - i - 1;
            i = a,
            o = 0
        } else
            s === 46 && o > -1 ? o++ : o = -1
    }
    return n
}
function ty(e) {
    if (typeof e != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(e))
}
const qke = {
    cwd: Wke
};
function Wke() {
    return "/"
}
function GT(e) {
    return !!(e !== null && typeof e == "object" && "href"in e && e.href && "protocol"in e && e.protocol && e.auth === void 0)
}
function Gke(e) {
    if (typeof e == "string")
        e = new URL(e);
    else if (!GT(e)) {
        const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`");
        throw t.code = "ERR_INVALID_ARG_TYPE",
        t
    }
    if (e.protocol !== "file:") {
        const t = new TypeError("The URL must be of scheme file");
        throw t.code = "ERR_INVALID_URL_SCHEME",
        t
    }
    return Yke(e)
}
function Yke(e) {
    if (e.hostname !== "") {
        const r = new TypeError('File URL host must be "localhost" or empty on darwin');
        throw r.code = "ERR_INVALID_FILE_URL_HOST",
        r
    }
    const t = e.pathname;
    let n = -1;
    for (; ++n < t.length; )
        if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
            const r = t.codePointAt(n + 2);
            if (r === 70 || r === 102) {
                const i = new TypeError("File URL path must not include encoded / characters");
                throw i.code = "ERR_INVALID_FILE_URL_PATH",
                i
            }
        }
    return decodeURIComponent(t)
}
const Fk = ["history", "path", "basename", "stem", "extname", "dirname"];
class i8 {
    constructor(t) {
        let n;
        t ? GT(t) ? n = {
            path: t
        } : typeof t == "string" || Zke(t) ? n = {
            value: t
        } : n = t : n = {},
        this.cwd = "cwd"in n ? "" : qke.cwd(),
        this.data = {},
        this.history = [],
        this.messages = [],
        this.value,
        this.map,
        this.result,
        this.stored;
        let r = -1;
        for (; ++r < Fk.length; ) {
            const o = Fk[r];
            o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o])
        }
        let i;
        for (i in n)
            Fk.includes(i) || (this[i] = n[i])
    }
    get basename() {
        return typeof this.path == "string" ? ms.basename(this.path) : void 0
    }
    set basename(t) {
        Uk(t, "basename"),
        Nk(t, "basename"),
        this.path = ms.join(this.dirname || "", t)
    }
    get dirname() {
        return typeof this.path == "string" ? ms.dirname(this.path) : void 0
    }
    set dirname(t) {
        OB(this.basename, "dirname"),
        this.path = ms.join(t || "", this.basename)
    }
    get extname() {
        return typeof this.path == "string" ? ms.extname(this.path) : void 0
    }
    set extname(t) {
        if (Nk(t, "extname"),
        OB(this.dirname, "extname"),
        t) {
            if (t.codePointAt(0) !== 46)
                throw new Error("`extname` must start with `.`");
            if (t.includes(".", 1))
                throw new Error("`extname` cannot contain multiple dots")
        }
        this.path = ms.join(this.dirname, this.stem + (t || ""))
    }
    get path() {
        return this.history[this.history.length - 1]
    }
    set path(t) {
        GT(t) && (t = Gke(t)),
        Uk(t, "path"),
        this.path !== t && this.history.push(t)
    }
    get stem() {
        return typeof this.path == "string" ? ms.basename(this.path, this.extname) : void 0
    }
    set stem(t) {
        Uk(t, "stem"),
        Nk(t, "stem"),
        this.path = ms.join(this.dirname || "", t + (this.extname || ""))
    }
    fail(t, n, r) {
        const i = this.message(t, n, r);
        throw i.fatal = !0,
        i
    }
    info(t, n, r) {
        const i = this.message(t, n, r);
        return i.fatal = void 0,
        i
    }
    message(t, n, r) {
        const i = new Di(t,n,r);
        return this.path && (i.name = this.path + ":" + i.name,
        i.file = this.path),
        i.fatal = !1,
        this.messages.push(i),
        i
    }
    toString(t) {
        return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value)
    }
}
function Nk(e, t) {
    if (e && e.includes(ms.sep))
        throw new Error("`" + t + "` cannot be a path: did not expect `" + ms.sep + "`")
}
function Uk(e, t) {
    if (!e)
        throw new Error("`" + t + "` cannot be empty")
}
function OB(e, t) {
    if (!e)
        throw new Error("Setting `" + t + "` requires `path` to be set too")
}
function Zke(e) {
    return !!(e && typeof e == "object" && "byteLength"in e && "byteOffset"in e)
}
const Qke = (function(e) {
    const r = this.constructor.prototype
      , i = r[e]
      , o = function() {
        return i.apply(o, arguments)
    };
    return Object.setPrototypeOf(o, r),
    o
}
)
  , Kke = {}.hasOwnProperty;
class JA extends Qke {
    constructor() {
        super("copy"),
        this.Compiler = void 0,
        this.Parser = void 0,
        this.attachers = [],
        this.compiler = void 0,
        this.freezeIndex = -1,
        this.frozen = void 0,
        this.namespace = {},
        this.parser = void 0,
        this.transformers = jke()
    }
    copy() {
        const t = new JA;
        let n = -1;
        for (; ++n < this.attachers.length; ) {
            const r = this.attachers[n];
            t.use(...r)
        }
        return t.data(zk(!0, {}, this.namespace)),
        t
    }
    data(t, n) {
        return typeof t == "string" ? arguments.length === 2 ? (qk("data", this.frozen),
        this.namespace[t] = n,
        this) : Kke.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (qk("data", this.frozen),
        this.namespace = t,
        this) : this.namespace
    }
    freeze() {
        if (this.frozen)
            return this;
        const t = this;
        for (; ++this.freezeIndex < this.attachers.length; ) {
            const [n,...r] = this.attachers[this.freezeIndex];
            if (r[0] === !1)
                continue;
            r[0] === !0 && (r[0] = void 0);
            const i = n.call(t, ...r);
            typeof i == "function" && this.transformers.use(i)
        }
        return this.frozen = !0,
        this.freezeIndex = Number.POSITIVE_INFINITY,
        this
    }
    parse(t) {
        this.freeze();
        const n = rx(t)
          , r = this.parser || this.Parser;
        return Vk("parse", r),
        r(String(n), n)
    }
    process(t, n) {
        const r = this;
        return this.freeze(),
        Vk("process", this.parser || this.Parser),
        Hk("process", this.compiler || this.Compiler),
        n ? i(void 0, n) : new Promise(i);
        function i(o, a) {
            const s = rx(t)
              , c = r.parse(s);
            r.run(c, s, function(f, h, m) {
                if (f || !h || !m)
                    return u(f);
                const y = h
                  , b = r.stringify(y, m);
                e2e(b) ? m.value = b : m.result = b,
                u(f, m)
            });
            function u(f, h) {
                f || !h ? a(f) : o ? o(h) : n(void 0, h)
            }
        }
    }
    processSync(t) {
        let n = !1, r;
        return this.freeze(),
        Vk("processSync", this.parser || this.Parser),
        Hk("processSync", this.compiler || this.Compiler),
        this.process(t, i),
        $B("processSync", "process", n),
        r;
        function i(o, a) {
            n = !0,
            RB(o),
            r = a
        }
    }
    run(t, n, r) {
        IB(t),
        this.freeze();
        const i = this.transformers;
        return !r && typeof n == "function" && (r = n,
        n = void 0),
        r ? o(void 0, r) : new Promise(o);
        function o(a, s) {
            const c = rx(n);
            i.run(t, c, u);
            function u(f, h, m) {
                const y = h || t;
                f ? s(f) : a ? a(y) : r(void 0, y, m)
            }
        }
    }
    runSync(t, n) {
        let r = !1, i;
        return this.run(t, n, o),
        $B("runSync", "run", r),
        i;
        function o(a, s) {
            RB(a),
            i = s,
            r = !0
        }
    }
    stringify(t, n) {
        this.freeze();
        const r = rx(n)
          , i = this.compiler || this.Compiler;
        return Hk("stringify", i),
        IB(t),
        i(t, r)
    }
    use(t, ...n) {
        const r = this.attachers
          , i = this.namespace;
        if (qk("use", this.frozen),
        t != null)
            if (typeof t == "function")
                c(t, n);
            else if (typeof t == "object")
                Array.isArray(t) ? s(t) : a(t);
            else
                throw new TypeError("Expected usable value, not `" + t + "`");
        return this;
        function o(u) {
            if (typeof u == "function")
                c(u, []);
            else if (typeof u == "object")
                if (Array.isArray(u)) {
                    const [f,...h] = u;
                    c(f, h)
                } else
                    a(u);
            else
                throw new TypeError("Expected usable value, not `" + u + "`")
        }
        function a(u) {
            if (!("plugins"in u) && !("settings"in u))
                throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");
            s(u.plugins),
            u.settings && (i.settings = zk(!0, i.settings, u.settings))
        }
        function s(u) {
            let f = -1;
            if (u != null)
                if (Array.isArray(u))
                    for (; ++f < u.length; ) {
                        const h = u[f];
                        o(h)
                    }
                else
                    throw new TypeError("Expected a list of plugins, not `" + u + "`")
        }
        function c(u, f) {
            let h = -1
              , m = -1;
            for (; ++h < r.length; )
                if (r[h][0] === u) {
                    m = h;
                    break
                }
            if (m === -1)
                r.push([u, ...f]);
            else if (f.length > 0) {
                let[y,...b] = f;
                const v = r[m][1];
                WT(v) && WT(y) && (y = zk(!0, v, y)),
                r[m] = [u, y, ...b]
            }
        }
    }
}
const Xke = new JA().freeze();
function Vk(e, t) {
    if (typeof t != "function")
        throw new TypeError("Cannot `" + e + "` without `parser`")
}
function Hk(e, t) {
    if (typeof t != "function")
        throw new TypeError("Cannot `" + e + "` without `compiler`")
}
function qk(e, t) {
    if (t)
        throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")
}
function IB(e) {
    if (!WT(e) || typeof e.type != "string")
        throw new TypeError("Expected node, got `" + e + "`")
}
function $B(e, t, n) {
    if (!n)
        throw new Error("`" + e + "` finished async. Use `" + t + "` instead")
}
function rx(e) {
    return Jke(e) ? e : new i8(e)
}
function Jke(e) {
    return !!(e && typeof e == "object" && "message"in e && "messages"in e)
}
function e2e(e) {
    return typeof e == "string" || t2e(e)
}
function t2e(e) {
    return !!(e && typeof e == "object" && "byteLength"in e && "byteOffset"in e)
}
const n2e = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md"
  , LB = []
  , jB = {
    allowDangerousHtml: !0
}
  , r2e = /^(https?|ircs?|mailto|xmpp)$/i
  , i2e = [{
    from: "astPlugins",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "allowDangerousHtml",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
}, {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
}, {
    from: "className",
    id: "remove-classname"
}, {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
}, {
    from: "escapeHtml",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "includeElementIndex",
    id: "#remove-includeelementindex"
}, {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
}, {
    from: "linkTarget",
    id: "remove-linktarget"
}, {
    from: "plugins",
    id: "change-plugins-to-remarkplugins",
    to: "remarkPlugins"
}, {
    from: "rawSourcePos",
    id: "#remove-rawsourcepos"
}, {
    from: "renderers",
    id: "change-renderers-to-components",
    to: "components"
}, {
    from: "source",
    id: "change-source-to-children",
    to: "children"
}, {
    from: "sourcePos",
    id: "#remove-sourcepos"
}, {
    from: "transformImageUri",
    id: "#add-urltransform",
    to: "urlTransform"
}, {
    from: "transformLinkUri",
    id: "#add-urltransform",
    to: "urlTransform"
}];
function o8(e) {
    const t = o2e(e)
      , n = a2e(e);
    return s2e(t.runSync(t.parse(n), n), e)
}
function o2e(e) {
    const t = e.rehypePlugins || LB
      , n = e.remarkPlugins || LB
      , r = e.remarkRehypeOptions ? {
        ...e.remarkRehypeOptions,
        ...jB
    } : jB;
    return Xke().use(Fwe).use(n).use(Ike, r).use(t)
}
function a2e(e) {
    const t = e.children || ""
      , n = new i8;
    return typeof t == "string" && (n.value = t),
    n
}
function s2e(e, t) {
    const n = t.allowedElements
      , r = t.allowElement
      , i = t.components
      , o = t.disallowedElements
      , a = t.skipHtml
      , s = t.unwrapDisallowed
      , c = t.urlTransform || l2e;
    for (const f of i2e)
        Object.hasOwn(t, f.from) && ("" + f.from + (f.to ? "use `" + f.to + "` instead" : "remove it") + n2e + f.id,
        void 0);
    return XA(e, u),
    wSe(e, {
        Fragment: g.Fragment,
        components: i,
        ignoreInvalidStyle: !0,
        jsx: g.jsx,
        jsxs: g.jsxs,
        passKeys: !0,
        passNode: !0
    });
    function u(f, h, m) {
        if (f.type === "raw" && m && typeof h == "number")
            return a ? m.children.splice(h, 1) : m.children[h] = {
                type: "text",
                value: f.value
            },
            h;
        if (f.type === "element") {
            let y;
            for (y in $k)
                if (Object.hasOwn($k, y) && Object.hasOwn(f.properties, y)) {
                    const b = f.properties[y]
                      , v = $k[y];
                    (v === null || v.includes(f.tagName)) && (f.properties[y] = c(String(b || ""), y, f))
                }
        }
        if (f.type === "element") {
            let y = n ? !n.includes(f.tagName) : o ? o.includes(f.tagName) : !1;
            if (!y && r && typeof h == "number" && (y = !r(f, h, m)),
            y && m && typeof h == "number")
                return s && f.children ? m.children.splice(h, 1, ...f.children) : m.children.splice(h, 1),
                h
        }
    }
}
function l2e(e) {
    const t = e.indexOf(":")
      , n = e.indexOf("?")
      , r = e.indexOf("#")
      , i = e.indexOf("/");
    return t === -1 || i !== -1 && t > i || n !== -1 && t > n || r !== -1 && t > r || r2e.test(e.slice(0, t)) ? e : ""
}
const c2e = "modulepreload"
  , u2e = function(e) {
    return "/" + e
}
  , BB = {}
  , qn = function(t, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
        let c = function(u) {
            return Promise.all(u.map(f => Promise.resolve(f).then(h => ({
                status: "fulfilled",
                value: h
            }), h => ({
                status: "rejected",
                reason: h
            }))))
        };
        document.getElementsByTagName("link");
        const a = document.querySelector("meta[property=csp-nonce]")
          , s = a?.nonce || a?.getAttribute("nonce");
        i = c(n.map(u => {
            if (u = u2e(u),
            u in BB)
                return;
            BB[u] = !0;
            const f = u.endsWith(".css")
              , h = f ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${u}"]${h}`))
                return;
            const m = document.createElement("link");
            if (m.rel = f ? "stylesheet" : c2e,
            f || (m.as = "script"),
            m.crossOrigin = "",
            m.href = u,
            s && m.setAttribute("nonce", s),
            document.head.appendChild(m),
            f)
                return new Promise( (y, b) => {
                    m.addEventListener("load", y),
                    m.addEventListener("error", () => b(new Error(`Unable to preload CSS for ${u}`)))
                }
                )
        }
        ))
    }
    function o(a) {
        const s = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (s.payload = a,
        window.dispatchEvent(s),
        !s.defaultPrevented)
            throw a
    }
    return i.then(a => {
        for (const s of a || [])
            s.status === "rejected" && o(s.reason);
        return t().catch(o)
    }
    )
};
var zB = {
    name: "mermaid",
    version: "11.12.0",
    description: "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
    type: "module",
    module: "./dist/mermaid.core.mjs",
    types: "./dist/mermaid.d.ts",
    exports: {
        ".": {
            types: "./dist/mermaid.d.ts",
            import: "./dist/mermaid.core.mjs",
            default: "./dist/mermaid.core.mjs"
        },
        "./*": "./*"
    },
    keywords: ["diagram", "markdown", "flowchart", "sequence diagram", "gantt", "class diagram", "git graph", "mindmap", "packet diagram", "c4 diagram", "er diagram", "pie chart", "pie diagram", "quadrant chart", "requirement diagram", "graph"],
    scripts: {
        clean: "rimraf dist",
        dev: "pnpm -w dev",
        "docs:code": "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
        "docs:build": "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
        "docs:verify": "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
        "docs:pre:vitepress": "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
        "docs:build:vitepress": "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
        "docs:dev": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
        "docs:dev:docker": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
        "docs:serve": "pnpm docs:build:vitepress && vitepress serve src/vitepress",
        "docs:spellcheck": 'cspell "src/docs/**/*.md"',
        "docs:release-version": "tsx scripts/update-release-version.mts",
        "docs:verify-version": "tsx scripts/update-release-version.mts --verify",
        "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
        "types:verify-config": "tsx scripts/create-types-from-json-schema.mts --verify",
        checkCircle: "npx madge --circular ./src",
        prepublishOnly: "pnpm docs:verify-version"
    },
    repository: {
        type: "git",
        url: "https://github.com/mermaid-js/mermaid"
    },
    author: "Knut Sveidqvist",
    license: "MIT",
    standard: {
        ignore: ["**/parser/*.js", "dist/**/*.js", "cypress/**/*.js"],
        globals: ["page"]
    },
    dependencies: {
        "@braintree/sanitize-url": "^7.1.1",
        "@iconify/utils": "^3.0.1",
        "@mermaid-js/parser": "workspace:^",
        "@types/d3": "^7.4.3",
        cytoscape: "^3.29.3",
        "cytoscape-cose-bilkent": "^4.1.0",
        "cytoscape-fcose": "^2.2.0",
        d3: "^7.9.0",
        "d3-sankey": "^0.12.3",
        "dagre-d3-es": "7.0.11",
        dayjs: "^1.11.18",
        dompurify: "^3.2.5",
        katex: "^0.16.22",
        khroma: "^2.1.0",
        "lodash-es": "^4.17.21",
        marked: "^16.2.1",
        roughjs: "^4.6.6",
        stylis: "^4.3.6",
        "ts-dedent": "^2.2.0",
        uuid: "^11.1.0"
    },
    devDependencies: {
        "@adobe/jsonschema2md": "^8.0.5",
        "@iconify/types": "^2.0.0",
        "@types/cytoscape": "^3.21.9",
        "@types/cytoscape-fcose": "^2.2.4",
        "@types/d3-sankey": "^0.12.4",
        "@types/d3-scale": "^4.0.9",
        "@types/d3-scale-chromatic": "^3.1.0",
        "@types/d3-selection": "^3.0.11",
        "@types/d3-shape": "^3.1.7",
        "@types/jsdom": "^21.1.7",
        "@types/katex": "^0.16.7",
        "@types/lodash-es": "^4.17.12",
        "@types/micromatch": "^4.0.9",
        "@types/stylis": "^4.2.7",
        "@types/uuid": "^10.0.0",
        ajv: "^8.17.1",
        canvas: "^3.1.2",
        chokidar: "3.6.0",
        concurrently: "^9.1.2",
        "csstree-validator": "^4.0.1",
        globby: "^14.1.0",
        jison: "^0.4.18",
        "js-base64": "^3.7.8",
        jsdom: "^26.1.0",
        "json-schema-to-typescript": "^15.0.4",
        micromatch: "^4.0.8",
        "path-browserify": "^1.0.1",
        prettier: "^3.5.3",
        remark: "^15.0.1",
        "remark-frontmatter": "^5.0.0",
        "remark-gfm": "^4.0.1",
        rimraf: "^6.0.1",
        "start-server-and-test": "^2.0.13",
        "type-fest": "^4.35.0",
        typedoc: "^0.28.12",
        "typedoc-plugin-markdown": "^4.8.1",
        typescript: "~5.7.3",
        "unist-util-flatmap": "^1.0.0",
        "unist-util-visit": "^5.0.0",
        vitepress: "^1.6.4",
        "vitepress-plugin-search": "1.0.4-alpha.22"
    },
    files: ["dist/", "README.md"],
    publishConfig: {
        access: "public"
    }
}, zx = {
    exports: {}
}, d2e = zx.exports, FB;
function f2e() {
    return FB || (FB = 1,
    (function(e, t) {
        (function(n, r) {
            e.exports = r()
        }
        )(d2e, (function() {
            var n = 1e3
              , r = 6e4
              , i = 36e5
              , o = "millisecond"
              , a = "second"
              , s = "minute"
              , c = "hour"
              , u = "day"
              , f = "week"
              , h = "month"
              , m = "quarter"
              , y = "year"
              , b = "date"
              , v = "Invalid Date"
              , S = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
              , C = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
              , w = {
                name: "en",
                weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                ordinal: function(L) {
                    var F = ["th", "st", "nd", "rd"]
                      , j = L % 100;
                    return "[" + L + (F[(j - 20) % 10] || F[j] || F[0]) + "]"
                }
            }
              , k = function(L, F, j) {
                var N = String(L);
                return !N || N.length >= F ? L : "" + Array(F + 1 - N.length).join(j) + L
            }
              , T = {
                s: k,
                z: function(L) {
                    var F = -L.utcOffset()
                      , j = Math.abs(F)
                      , N = Math.floor(j / 60)
                      , H = j % 60;
                    return (F <= 0 ? "+" : "-") + k(N, 2, "0") + ":" + k(H, 2, "0")
                },
                m: function L(F, j) {
                    if (F.date() < j.date())
                        return -L(j, F);
                    var N = 12 * (j.year() - F.year()) + (j.month() - F.month())
                      , H = F.clone().add(N, h)
                      , Z = j - H < 0
                      , q = F.clone().add(N + (Z ? -1 : 1), h);
                    return +(-(N + (j - H) / (Z ? H - q : q - H)) || 0)
                },
                a: function(L) {
                    return L < 0 ? Math.ceil(L) || 0 : Math.floor(L)
                },
                p: function(L) {
                    return {
                        M: h,
                        y,
                        w: f,
                        d: u,
                        D: b,
                        h: c,
                        m: s,
                        s: a,
                        ms: o,
                        Q: m
                    }[L] || String(L || "").toLowerCase().replace(/s$/, "")
                },
                u: function(L) {
                    return L === void 0
                }
            }
              , E = "en"
              , P = {};
            P[E] = w;
            var D = "$isDayjsObject"
              , $ = function(L) {
                return L instanceof M || !(!L || !L[D])
            }
              , z = function L(F, j, N) {
                var H;
                if (!F)
                    return E;
                if (typeof F == "string") {
                    var Z = F.toLowerCase();
                    P[Z] && (H = Z),
                    j && (P[Z] = j,
                    H = Z);
                    var q = F.split("-");
                    if (!H && q.length > 1)
                        return L(q[0])
                } else {
                    var V = F.name;
                    P[V] = F,
                    H = V
                }
                return !N && H && (E = H),
                H || !N && E
            }
              , O = function(L, F) {
                if ($(L))
                    return L.clone();
                var j = typeof F == "object" ? F : {};
                return j.date = L,
                j.args = arguments,
                new M(j)
            }
              , I = T;
            I.l = z,
            I.i = $,
            I.w = function(L, F) {
                return O(L, {
                    locale: F.$L,
                    utc: F.$u,
                    x: F.$x,
                    $offset: F.$offset
                })
            }
            ;
            var M = (function() {
                function L(j) {
                    this.$L = z(j.locale, null, !0),
                    this.parse(j),
                    this.$x = this.$x || j.x || {},
                    this[D] = !0
                }
                var F = L.prototype;
                return F.parse = function(j) {
                    this.$d = (function(N) {
                        var H = N.date
                          , Z = N.utc;
                        if (H === null)
                            return new Date(NaN);
                        if (I.u(H))
                            return new Date;
                        if (H instanceof Date)
                            return new Date(H);
                        if (typeof H == "string" && !/Z$/i.test(H)) {
                            var q = H.match(S);
                            if (q) {
                                var V = q[2] - 1 || 0
                                  , Y = (q[7] || "0").substring(0, 3);
                                return Z ? new Date(Date.UTC(q[1], V, q[3] || 1, q[4] || 0, q[5] || 0, q[6] || 0, Y)) : new Date(q[1],V,q[3] || 1,q[4] || 0,q[5] || 0,q[6] || 0,Y)
                            }
                        }
                        return new Date(H)
                    }
                    )(j),
                    this.init()
                }
                ,
                F.init = function() {
                    var j = this.$d;
                    this.$y = j.getFullYear(),
                    this.$M = j.getMonth(),
                    this.$D = j.getDate(),
                    this.$W = j.getDay(),
                    this.$H = j.getHours(),
                    this.$m = j.getMinutes(),
                    this.$s = j.getSeconds(),
                    this.$ms = j.getMilliseconds()
                }
                ,
                F.$utils = function() {
                    return I
                }
                ,
                F.isValid = function() {
                    return this.$d.toString() !== v
                }
                ,
                F.isSame = function(j, N) {
                    var H = O(j);
                    return this.startOf(N) <= H && H <= this.endOf(N)
                }
                ,
                F.isAfter = function(j, N) {
                    return O(j) < this.startOf(N)
                }
                ,
                F.isBefore = function(j, N) {
                    return this.endOf(N) < O(j)
                }
                ,
                F.$g = function(j, N, H) {
                    return I.u(j) ? this[N] : this.set(H, j)
                }
                ,
                F.unix = function() {
                    return Math.floor(this.valueOf() / 1e3)
                }
                ,
                F.valueOf = function() {
                    return this.$d.getTime()
                }
                ,
                F.startOf = function(j, N) {
                    var H = this
                      , Z = !!I.u(N) || N
                      , q = I.p(j)
                      , V = function(J, oe) {
                        var we = I.w(H.$u ? Date.UTC(H.$y, oe, J) : new Date(H.$y,oe,J), H);
                        return Z ? we : we.endOf(u)
                    }
                      , Y = function(J, oe) {
                        return I.w(H.toDate()[J].apply(H.toDate("s"), (Z ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(oe)), H)
                    }
                      , W = this.$W
                      , te = this.$M
                      , K = this.$D
                      , ee = "set" + (this.$u ? "UTC" : "");
                    switch (q) {
                    case y:
                        return Z ? V(1, 0) : V(31, 11);
                    case h:
                        return Z ? V(1, te) : V(0, te + 1);
                    case f:
                        var re = this.$locale().weekStart || 0
                          , ie = (W < re ? W + 7 : W) - re;
                        return V(Z ? K - ie : K + (6 - ie), te);
                    case u:
                    case b:
                        return Y(ee + "Hours", 0);
                    case c:
                        return Y(ee + "Minutes", 1);
                    case s:
                        return Y(ee + "Seconds", 2);
                    case a:
                        return Y(ee + "Milliseconds", 3);
                    default:
                        return this.clone()
                    }
                }
                ,
                F.endOf = function(j) {
                    return this.startOf(j, !1)
                }
                ,
                F.$set = function(j, N) {
                    var H, Z = I.p(j), q = "set" + (this.$u ? "UTC" : ""), V = (H = {},
                    H[u] = q + "Date",
                    H[b] = q + "Date",
                    H[h] = q + "Month",
                    H[y] = q + "FullYear",
                    H[c] = q + "Hours",
                    H[s] = q + "Minutes",
                    H[a] = q + "Seconds",
                    H[o] = q + "Milliseconds",
                    H)[Z], Y = Z === u ? this.$D + (N - this.$W) : N;
                    if (Z === h || Z === y) {
                        var W = this.clone().set(b, 1);
                        W.$d[V](Y),
                        W.init(),
                        this.$d = W.set(b, Math.min(this.$D, W.daysInMonth())).$d
                    } else
                        V && this.$d[V](Y);
                    return this.init(),
                    this
                }
                ,
                F.set = function(j, N) {
                    return this.clone().$set(j, N)
                }
                ,
                F.get = function(j) {
                    return this[I.p(j)]()
                }
                ,
                F.add = function(j, N) {
                    var H, Z = this;
                    j = Number(j);
                    var q = I.p(N)
                      , V = function(te) {
                        var K = O(Z);
                        return I.w(K.date(K.date() + Math.round(te * j)), Z)
                    };
                    if (q === h)
                        return this.set(h, this.$M + j);
                    if (q === y)
                        return this.set(y, this.$y + j);
                    if (q === u)
                        return V(1);
                    if (q === f)
                        return V(7);
                    var Y = (H = {},
                    H[s] = r,
                    H[c] = i,
                    H[a] = n,
                    H)[q] || 1
                      , W = this.$d.getTime() + j * Y;
                    return I.w(W, this)
                }
                ,
                F.subtract = function(j, N) {
                    return this.add(-1 * j, N)
                }
                ,
                F.format = function(j) {
                    var N = this
                      , H = this.$locale();
                    if (!this.isValid())
                        return H.invalidDate || v;
                    var Z = j || "YYYY-MM-DDTHH:mm:ssZ"
                      , q = I.z(this)
                      , V = this.$H
                      , Y = this.$m
                      , W = this.$M
                      , te = H.weekdays
                      , K = H.months
                      , ee = H.meridiem
                      , re = function(oe, we, xe, se) {
                        return oe && (oe[we] || oe(N, Z)) || xe[we].slice(0, se)
                    }
                      , ie = function(oe) {
                        return I.s(V % 12 || 12, oe, "0")
                    }
                      , J = ee || function(oe, we, xe) {
                        var se = oe < 12 ? "AM" : "PM";
                        return xe ? se.toLowerCase() : se
                    }
                    ;
                    return Z.replace(C, (function(oe, we) {
                        return we || (function(xe) {
                            switch (xe) {
                            case "YY":
                                return String(N.$y).slice(-2);
                            case "YYYY":
                                return I.s(N.$y, 4, "0");
                            case "M":
                                return W + 1;
                            case "MM":
                                return I.s(W + 1, 2, "0");
                            case "MMM":
                                return re(H.monthsShort, W, K, 3);
                            case "MMMM":
                                return re(K, W);
                            case "D":
                                return N.$D;
                            case "DD":
                                return I.s(N.$D, 2, "0");
                            case "d":
                                return String(N.$W);
                            case "dd":
                                return re(H.weekdaysMin, N.$W, te, 2);
                            case "ddd":
                                return re(H.weekdaysShort, N.$W, te, 3);
                            case "dddd":
                                return te[N.$W];
                            case "H":
                                return String(V);
                            case "HH":
                                return I.s(V, 2, "0");
                            case "h":
                                return ie(1);
                            case "hh":
                                return ie(2);
                            case "a":
                                return J(V, Y, !0);
                            case "A":
                                return J(V, Y, !1);
                            case "m":
                                return String(Y);
                            case "mm":
                                return I.s(Y, 2, "0");
                            case "s":
                                return String(N.$s);
                            case "ss":
                                return I.s(N.$s, 2, "0");
                            case "SSS":
                                return I.s(N.$ms, 3, "0");
                            case "Z":
                                return q
                            }
                            return null
                        }
                        )(oe) || q.replace(":", "")
                    }
                    ))
                }
                ,
                F.utcOffset = function() {
                    return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                }
                ,
                F.diff = function(j, N, H) {
                    var Z, q = this, V = I.p(N), Y = O(j), W = (Y.utcOffset() - this.utcOffset()) * r, te = this - Y, K = function() {
                        return I.m(q, Y)
                    };
                    switch (V) {
                    case y:
                        Z = K() / 12;
                        break;
                    case h:
                        Z = K();
                        break;
                    case m:
                        Z = K() / 3;
                        break;
                    case f:
                        Z = (te - W) / 6048e5;
                        break;
                    case u:
                        Z = (te - W) / 864e5;
                        break;
                    case c:
                        Z = te / i;
                        break;
                    case s:
                        Z = te / r;
                        break;
                    case a:
                        Z = te / n;
                        break;
                    default:
                        Z = te
                    }
                    return H ? Z : I.a(Z)
                }
                ,
                F.daysInMonth = function() {
                    return this.endOf(h).$D
                }
                ,
                F.$locale = function() {
                    return P[this.$L]
                }
                ,
                F.locale = function(j, N) {
                    if (!j)
                        return this.$L;
                    var H = this.clone()
                      , Z = z(j, N, !0);
                    return Z && (H.$L = Z),
                    H
                }
                ,
                F.clone = function() {
                    return I.w(this.$d, this)
                }
                ,
                F.toDate = function() {
                    return new Date(this.valueOf())
                }
                ,
                F.toJSON = function() {
                    return this.isValid() ? this.toISOString() : null
                }
                ,
                F.toISOString = function() {
                    return this.$d.toISOString()
                }
                ,
                F.toString = function() {
                    return this.$d.toUTCString()
                }
                ,
                L
            }
            )()
              , B = M.prototype;
            return O.prototype = B,
            [["$ms", o], ["$s", a], ["$m", s], ["$H", c], ["$W", u], ["$M", h], ["$y", y], ["$D", b]].forEach((function(L) {
                B[L[1]] = function(F) {
                    return this.$g(F, L[0], L[1])
                }
            }
            )),
            O.extend = function(L, F) {
                return L.$i || (L(F, M, O),
                L.$i = !0),
                O
            }
            ,
            O.locale = z,
            O.isDayjs = $,
            O.unix = function(L) {
                return O(1e3 * L)
            }
            ,
            O.en = P[E],
            O.Ls = P,
            O.p = {},
            O
        }
        ))
    }
    )(zx)),
    zx.exports
}
var h2e = f2e();
const Gr = es(h2e);
var a8 = Object.defineProperty
  , U = (e, t) => a8(e, "name", {
    value: t,
    configurable: !0
})
  , p2e = (e, t) => {
    for (var n in t)
        a8(e, n, {
            get: t[n],
            enumerable: !0
        })
}
  , ll = {
    trace: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4,
    fatal: 5
}
  , Qe = {
    trace: U( (...e) => {}
    , "trace"),
    debug: U( (...e) => {}
    , "debug"),
    info: U( (...e) => {}
    , "info"),
    warn: U( (...e) => {}
    , "warn"),
    error: U( (...e) => {}
    , "error"),
    fatal: U( (...e) => {}
    , "fatal")
}
  , eM = U(function(e="fatal") {
    let t = ll.fatal;
    typeof e == "string" ? e.toLowerCase()in ll && (t = ll[e]) : typeof e == "number" && (t = e),
    Qe.trace = () => {}
    ,
    Qe.debug = () => {}
    ,
    Qe.info = () => {}
    ,
    Qe.warn = () => {}
    ,
    Qe.error = () => {}
    ,
    Qe.fatal = () => {}
    ,
    t <= ll.fatal && (Qe.fatal = console.error ? console.error.bind(console, ua("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", ua("FATAL"))),
    t <= ll.error && (Qe.error = console.error ? console.error.bind(console, ua("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", ua("ERROR"))),
    t <= ll.warn && (Qe.warn = console.warn ? console.warn.bind(console, ua("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", ua("WARN"))),
    t <= ll.info && (Qe.info = console.info ? console.info.bind(console, ua("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", ua("INFO"))),
    t <= ll.debug && (Qe.debug = console.debug ? console.debug.bind(console, ua("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", ua("DEBUG"))),
    t <= ll.trace && (Qe.trace = console.debug ? console.debug.bind(console, ua("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", ua("TRACE")))
}, "setLogLevel")
  , ua = U(e => `%c${Gr().format("ss.SSS")} : ${e} : `, "format");
const Fx = {
    min: {
        r: 0,
        g: 0,
        b: 0,
        s: 0,
        l: 0,
        a: 0
    },
    max: {
        r: 255,
        g: 255,
        b: 255,
        h: 360,
        s: 100,
        l: 100,
        a: 1
    },
    clamp: {
        r: e => e >= 255 ? 255 : e < 0 ? 0 : e,
        g: e => e >= 255 ? 255 : e < 0 ? 0 : e,
        b: e => e >= 255 ? 255 : e < 0 ? 0 : e,
        h: e => e % 360,
        s: e => e >= 100 ? 100 : e < 0 ? 0 : e,
        l: e => e >= 100 ? 100 : e < 0 ? 0 : e,
        a: e => e >= 1 ? 1 : e < 0 ? 0 : e
    },
    toLinear: e => {
        const t = e / 255;
        return e > .03928 ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92
    }
    ,
    hue2rgb: (e, t, n) => (n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e),
    hsl2rgb: ({h: e, s: t, l: n}, r) => {
        if (!t)
            return n * 2.55;
        e /= 360,
        t /= 100,
        n /= 100;
        const i = n < .5 ? n * (1 + t) : n + t - n * t
          , o = 2 * n - i;
        switch (r) {
        case "r":
            return Fx.hue2rgb(o, i, e + 1 / 3) * 255;
        case "g":
            return Fx.hue2rgb(o, i, e) * 255;
        case "b":
            return Fx.hue2rgb(o, i, e - 1 / 3) * 255
        }
    }
    ,
    rgb2hsl: ({r: e, g: t, b: n}, r) => {
        e /= 255,
        t /= 255,
        n /= 255;
        const i = Math.max(e, t, n)
          , o = Math.min(e, t, n)
          , a = (i + o) / 2;
        if (r === "l")
            return a * 100;
        if (i === o)
            return 0;
        const s = i - o
          , c = a > .5 ? s / (2 - i - o) : s / (i + o);
        if (r === "s")
            return c * 100;
        switch (i) {
        case e:
            return ((t - n) / s + (t < n ? 6 : 0)) * 60;
        case t:
            return ((n - e) / s + 2) * 60;
        case n:
            return ((e - t) / s + 4) * 60;
        default:
            return -1
        }
    }
}
  , m2e = {
    clamp: (e, t, n) => t > n ? Math.min(t, Math.max(n, e)) : Math.min(n, Math.max(t, e)),
    round: e => Math.round(e * 1e10) / 1e10
}
  , g2e = {
    dec2hex: e => {
        const t = Math.round(e).toString(16);
        return t.length > 1 ? t : `0${t}`
    }
}
  , Yt = {
    channel: Fx,
    lang: m2e,
    unit: g2e
}
  , ic = {};
for (let e = 0; e <= 255; e++)
    ic[e] = Yt.unit.dec2hex(e);
const Ti = {
    ALL: 0,
    RGB: 1,
    HSL: 2
};
class y2e {
    constructor() {
        this.type = Ti.ALL
    }
    get() {
        return this.type
    }
    set(t) {
        if (this.type && this.type !== t)
            throw new Error("Cannot change both RGB and HSL channels at the same time");
        this.type = t
    }
    reset() {
        this.type = Ti.ALL
    }
    is(t) {
        return this.type === t
    }
}
class b2e {
    constructor(t, n) {
        this.color = n,
        this.changed = !1,
        this.data = t,
        this.type = new y2e
    }
    set(t, n) {
        return this.color = n,
        this.changed = !1,
        this.data = t,
        this.type.type = Ti.ALL,
        this
    }
    _ensureHSL() {
        const t = this.data
          , {h: n, s: r, l: i} = t;
        n === void 0 && (t.h = Yt.channel.rgb2hsl(t, "h")),
        r === void 0 && (t.s = Yt.channel.rgb2hsl(t, "s")),
        i === void 0 && (t.l = Yt.channel.rgb2hsl(t, "l"))
    }
    _ensureRGB() {
        const t = this.data
          , {r: n, g: r, b: i} = t;
        n === void 0 && (t.r = Yt.channel.hsl2rgb(t, "r")),
        r === void 0 && (t.g = Yt.channel.hsl2rgb(t, "g")),
        i === void 0 && (t.b = Yt.channel.hsl2rgb(t, "b"))
    }
    get r() {
        const t = this.data
          , n = t.r;
        return !this.type.is(Ti.HSL) && n !== void 0 ? n : (this._ensureHSL(),
        Yt.channel.hsl2rgb(t, "r"))
    }
    get g() {
        const t = this.data
          , n = t.g;
        return !this.type.is(Ti.HSL) && n !== void 0 ? n : (this._ensureHSL(),
        Yt.channel.hsl2rgb(t, "g"))
    }
    get b() {
        const t = this.data
          , n = t.b;
        return !this.type.is(Ti.HSL) && n !== void 0 ? n : (this._ensureHSL(),
        Yt.channel.hsl2rgb(t, "b"))
    }
    get h() {
        const t = this.data
          , n = t.h;
        return !this.type.is(Ti.RGB) && n !== void 0 ? n : (this._ensureRGB(),
        Yt.channel.rgb2hsl(t, "h"))
    }
    get s() {
        const t = this.data
          , n = t.s;
        return !this.type.is(Ti.RGB) && n !== void 0 ? n : (this._ensureRGB(),
        Yt.channel.rgb2hsl(t, "s"))
    }
    get l() {
        const t = this.data
          , n = t.l;
        return !this.type.is(Ti.RGB) && n !== void 0 ? n : (this._ensureRGB(),
        Yt.channel.rgb2hsl(t, "l"))
    }
    get a() {
        return this.data.a
    }
    set r(t) {
        this.type.set(Ti.RGB),
        this.changed = !0,
        this.data.r = t
    }
    set g(t) {
        this.type.set(Ti.RGB),
        this.changed = !0,
        this.data.g = t
    }
    set b(t) {
        this.type.set(Ti.RGB),
        this.changed = !0,
        this.data.b = t
    }
    set h(t) {
        this.type.set(Ti.HSL),
        this.changed = !0,
        this.data.h = t
    }
    set s(t) {
        this.type.set(Ti.HSL),
        this.changed = !0,
        this.data.s = t
    }
    set l(t) {
        this.type.set(Ti.HSL),
        this.changed = !0,
        this.data.l = t
    }
    set a(t) {
        this.changed = !0,
        this.data.a = t
    }
}
const B1 = new b2e({
    r: 0,
    g: 0,
    b: 0,
    a: 0
},"transparent")
  , _f = {
    re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
    parse: e => {
        if (e.charCodeAt(0) !== 35)
            return;
        const t = e.match(_f.re);
        if (!t)
            return;
        const n = t[1]
          , r = parseInt(n, 16)
          , i = n.length
          , o = i % 4 === 0
          , a = i > 4
          , s = a ? 1 : 17
          , c = a ? 8 : 4
          , u = o ? 0 : -1
          , f = a ? 255 : 15;
        return B1.set({
            r: (r >> c * (u + 3) & f) * s,
            g: (r >> c * (u + 2) & f) * s,
            b: (r >> c * (u + 1) & f) * s,
            a: o ? (r & f) * s / 255 : 1
        }, e)
    }
    ,
    stringify: e => {
        const {r: t, g: n, b: r, a: i} = e;
        return i < 1 ? `#${ic[Math.round(t)]}${ic[Math.round(n)]}${ic[Math.round(r)]}${ic[Math.round(i * 255)]}` : `#${ic[Math.round(t)]}${ic[Math.round(n)]}${ic[Math.round(r)]}`
    }
}
  , ku = {
    re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
    hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
    _hue2deg: e => {
        const t = e.match(ku.hueRe);
        if (t) {
            const [,n,r] = t;
            switch (r) {
            case "grad":
                return Yt.channel.clamp.h(parseFloat(n) * .9);
            case "rad":
                return Yt.channel.clamp.h(parseFloat(n) * 180 / Math.PI);
            case "turn":
                return Yt.channel.clamp.h(parseFloat(n) * 360)
            }
        }
        return Yt.channel.clamp.h(parseFloat(e))
    }
    ,
    parse: e => {
        const t = e.charCodeAt(0);
        if (t !== 104 && t !== 72)
            return;
        const n = e.match(ku.re);
        if (!n)
            return;
        const [,r,i,o,a,s] = n;
        return B1.set({
            h: ku._hue2deg(r),
            s: Yt.channel.clamp.s(parseFloat(i)),
            l: Yt.channel.clamp.l(parseFloat(o)),
            a: a ? Yt.channel.clamp.a(s ? parseFloat(a) / 100 : parseFloat(a)) : 1
        }, e)
    }
    ,
    stringify: e => {
        const {h: t, s: n, l: r, a: i} = e;
        return i < 1 ? `hsla(${Yt.lang.round(t)}, ${Yt.lang.round(n)}%, ${Yt.lang.round(r)}%, ${i})` : `hsl(${Yt.lang.round(t)}, ${Yt.lang.round(n)}%, ${Yt.lang.round(r)}%)`
    }
}
  , Mm = {
    colors: {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyanaqua: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        transparent: "#00000000",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
    },
    parse: e => {
        e = e.toLowerCase();
        const t = Mm.colors[e];
        if (t)
            return _f.parse(t)
    }
    ,
    stringify: e => {
        const t = _f.stringify(e);
        for (const n in Mm.colors)
            if (Mm.colors[n] === t)
                return n
    }
}
  , tm = {
    re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
    parse: e => {
        const t = e.charCodeAt(0);
        if (t !== 114 && t !== 82)
            return;
        const n = e.match(tm.re);
        if (!n)
            return;
        const [,r,i,o,a,s,c,u,f] = n;
        return B1.set({
            r: Yt.channel.clamp.r(i ? parseFloat(r) * 2.55 : parseFloat(r)),
            g: Yt.channel.clamp.g(a ? parseFloat(o) * 2.55 : parseFloat(o)),
            b: Yt.channel.clamp.b(c ? parseFloat(s) * 2.55 : parseFloat(s)),
            a: u ? Yt.channel.clamp.a(f ? parseFloat(u) / 100 : parseFloat(u)) : 1
        }, e)
    }
    ,
    stringify: e => {
        const {r: t, g: n, b: r, a: i} = e;
        return i < 1 ? `rgba(${Yt.lang.round(t)}, ${Yt.lang.round(n)}, ${Yt.lang.round(r)}, ${Yt.lang.round(i)})` : `rgb(${Yt.lang.round(t)}, ${Yt.lang.round(n)}, ${Yt.lang.round(r)})`
    }
}
  , As = {
    format: {
        keyword: Mm,
        hex: _f,
        rgb: tm,
        rgba: tm,
        hsl: ku,
        hsla: ku
    },
    parse: e => {
        if (typeof e != "string")
            return e;
        const t = _f.parse(e) || tm.parse(e) || ku.parse(e) || Mm.parse(e);
        if (t)
            return t;
        throw new Error(`Unsupported color format: "${e}"`)
    }
    ,
    stringify: e => !e.changed && e.color ? e.color : e.type.is(Ti.HSL) || e.data.r === void 0 ? ku.stringify(e) : e.a < 1 || !Number.isInteger(e.r) || !Number.isInteger(e.g) || !Number.isInteger(e.b) ? tm.stringify(e) : _f.stringify(e)
}
  , s8 = (e, t) => {
    const n = As.parse(e);
    for (const r in t)
        n[r] = Yt.channel.clamp[r](t[r]);
    return As.stringify(n)
}
  , Pm = (e, t, n=0, r=1) => {
    if (typeof e != "number")
        return s8(e, {
            a: t
        });
    const i = B1.set({
        r: Yt.channel.clamp.r(e),
        g: Yt.channel.clamp.g(t),
        b: Yt.channel.clamp.b(n),
        a: Yt.channel.clamp.a(r)
    });
    return As.stringify(i)
}
  , x2e = e => {
    const {r: t, g: n, b: r} = As.parse(e)
      , i = .2126 * Yt.channel.toLinear(t) + .7152 * Yt.channel.toLinear(n) + .0722 * Yt.channel.toLinear(r);
    return Yt.lang.round(i)
}
  , v2e = e => x2e(e) >= .5
  , ny = e => !v2e(e)
  , l8 = (e, t, n) => {
    const r = As.parse(e)
      , i = r[t]
      , o = Yt.channel.clamp[t](i + n);
    return i !== o && (r[t] = o),
    As.stringify(r)
}
  , St = (e, t) => l8(e, "l", t)
  , Ot = (e, t) => l8(e, "l", -t)
  , ve = (e, t) => {
    const n = As.parse(e)
      , r = {};
    for (const i in t)
        t[i] && (r[i] = n[i] + t[i]);
    return s8(e, r)
}
  , S2e = (e, t, n=50) => {
    const {r, g: i, b: o, a} = As.parse(e)
      , {r: s, g: c, b: u, a: f} = As.parse(t)
      , h = n / 100
      , m = h * 2 - 1
      , y = a - f
      , v = ((m * y === -1 ? m : (m + y) / (1 + m * y)) + 1) / 2
      , S = 1 - v
      , C = r * v + s * S
      , w = i * v + c * S
      , k = o * v + u * S
      , T = a * h + f * (1 - h);
    return Pm(C, w, k, T)
}
  , ht = (e, t=100) => {
    const n = As.parse(e);
    return n.r = 255 - n.r,
    n.g = 255 - n.g,
    n.b = 255 - n.b,
    S2e(n, e, t)
}
;
/*! @license DOMPurify 3.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.0/LICENSE */
const {entries: c8, setPrototypeOf: NB, isFrozen: C2e, getPrototypeOf: w2e, getOwnPropertyDescriptor: k2e} = Object;
let {freeze: Yi, seal: wa, create: YT} = Object
  , {apply: ZT, construct: QT} = typeof Reflect < "u" && Reflect;
Yi || (Yi = function(t) {
    return t
}
);
wa || (wa = function(t) {
    return t
}
);
ZT || (ZT = function(t, n) {
    for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
        i[o - 2] = arguments[o];
    return t.apply(n, i)
}
);
QT || (QT = function(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
        r[i - 1] = arguments[i];
    return new t(...r)
}
);
const ix = Zi(Array.prototype.forEach)
  , T2e = Zi(Array.prototype.lastIndexOf)
  , UB = Zi(Array.prototype.pop)
  , Op = Zi(Array.prototype.push)
  , _2e = Zi(Array.prototype.splice)
  , Nx = Zi(String.prototype.toLowerCase)
  , Wk = Zi(String.prototype.toString)
  , Gk = Zi(String.prototype.match)
  , Ip = Zi(String.prototype.replace)
  , E2e = Zi(String.prototype.indexOf)
  , A2e = Zi(String.prototype.trim)
  , $a = Zi(Object.prototype.hasOwnProperty)
  , Li = Zi(RegExp.prototype.test)
  , $p = M2e(TypeError);
function Zi(e) {
    return function(t) {
        t instanceof RegExp && (t.lastIndex = 0);
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
            r[i - 1] = arguments[i];
        return ZT(e, t, r)
    }
}
function M2e(e) {
    return function() {
        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
            n[r] = arguments[r];
        return QT(e, n)
    }
}
function mn(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Nx;
    NB && NB(e, null);
    let r = t.length;
    for (; r--; ) {
        let i = t[r];
        if (typeof i == "string") {
            const o = n(i);
            o !== i && (C2e(t) || (t[r] = o),
            i = o)
        }
        e[i] = !0
    }
    return e
}
function P2e(e) {
    for (let t = 0; t < e.length; t++)
        $a(e, t) || (e[t] = null);
    return e
}
function dl(e) {
    const t = YT(null);
    for (const [n,r] of c8(e))
        $a(e, n) && (Array.isArray(r) ? t[n] = P2e(r) : r && typeof r == "object" && r.constructor === Object ? t[n] = dl(r) : t[n] = r);
    return t
}
function Lp(e, t) {
    for (; e !== null; ) {
        const r = k2e(e, t);
        if (r) {
            if (r.get)
                return Zi(r.get);
            if (typeof r.value == "function")
                return Zi(r.value)
        }
        e = w2e(e)
    }
    function n() {
        return null
    }
    return n
}
const VB = Yi(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"])
  , Yk = Yi(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"])
  , Zk = Yi(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"])
  , R2e = Yi(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"])
  , Qk = Yi(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"])
  , D2e = Yi(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"])
  , HB = Yi(["#text"])
  , qB = Yi(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"])
  , Kk = Yi(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"])
  , WB = Yi(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"])
  , ox = Yi(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"])
  , O2e = wa(/\{\{[\w\W]*|[\w\W]*\}\}/gm)
  , I2e = wa(/<%[\w\W]*|[\w\W]*%>/gm)
  , $2e = wa(/\$\{[\w\W]*/gm)
  , L2e = wa(/^data-[\-\w.\u00B7-\uFFFF]+$/)
  , j2e = wa(/^aria-[\-\w]+$/)
  , u8 = wa(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i)
  , B2e = wa(/^(?:\w+script|data):/i)
  , z2e = wa(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g)
  , d8 = wa(/^html$/i)
  , F2e = wa(/^[a-z][.\w]*(-[.\w]+)+$/i);
var GB = Object.freeze({
    __proto__: null,
    ARIA_ATTR: j2e,
    ATTR_WHITESPACE: z2e,
    CUSTOM_ELEMENT: F2e,
    DATA_ATTR: L2e,
    DOCTYPE_NAME: d8,
    ERB_EXPR: I2e,
    IS_ALLOWED_URI: u8,
    IS_SCRIPT_OR_DATA: B2e,
    MUSTACHE_EXPR: O2e,
    TMPLIT_EXPR: $2e
});
const jp = {
    element: 1,
    text: 3,
    progressingInstruction: 7,
    comment: 8,
    document: 9
}
  , N2e = function() {
    return typeof window > "u" ? null : window
}
  , U2e = function(t, n) {
    if (typeof t != "object" || typeof t.createPolicy != "function")
        return null;
    let r = null;
    const i = "data-tt-policy-suffix";
    n && n.hasAttribute(i) && (r = n.getAttribute(i));
    const o = "dompurify" + (r ? "#" + r : "");
    try {
        return t.createPolicy(o, {
            createHTML(a) {
                return a
            },
            createScriptURL(a) {
                return a
            }
        })
    } catch {
        return console.warn("TrustedTypes policy " + o + " could not be created."),
        null
    }
}
  , YB = function() {
    return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
    }
};
function f8() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : N2e();
    const t = me => f8(me);
    if (t.version = "3.3.0",
    t.removed = [],
    !e || !e.document || e.document.nodeType !== jp.document || !e.Element)
        return t.isSupported = !1,
        t;
    let {document: n} = e;
    const r = n
      , i = r.currentScript
      , {DocumentFragment: o, HTMLTemplateElement: a, Node: s, Element: c, NodeFilter: u, NamedNodeMap: f=e.NamedNodeMap || e.MozNamedAttrMap, HTMLFormElement: h, DOMParser: m, trustedTypes: y} = e
      , b = c.prototype
      , v = Lp(b, "cloneNode")
      , S = Lp(b, "remove")
      , C = Lp(b, "nextSibling")
      , w = Lp(b, "childNodes")
      , k = Lp(b, "parentNode");
    if (typeof a == "function") {
        const me = n.createElement("template");
        me.content && me.content.ownerDocument && (n = me.content.ownerDocument)
    }
    let T, E = "";
    const {implementation: P, createNodeIterator: D, createDocumentFragment: $, getElementsByTagName: z} = n
      , {importNode: O} = r;
    let I = YB();
    t.isSupported = typeof c8 == "function" && typeof k == "function" && P && P.createHTMLDocument !== void 0;
    const {MUSTACHE_EXPR: M, ERB_EXPR: B, TMPLIT_EXPR: L, DATA_ATTR: F, ARIA_ATTR: j, IS_SCRIPT_OR_DATA: N, ATTR_WHITESPACE: H, CUSTOM_ELEMENT: Z} = GB;
    let {IS_ALLOWED_URI: q} = GB
      , V = null;
    const Y = mn({}, [...VB, ...Yk, ...Zk, ...Qk, ...HB]);
    let W = null;
    const te = mn({}, [...qB, ...Kk, ...WB, ...ox]);
    let K = Object.seal(YT(null, {
        tagNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        attributeNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1
        }
    }))
      , ee = null
      , re = null;
    const ie = Object.seal(YT(null, {
        tagCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        },
        attributeCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
        }
    }));
    let J = !0
      , oe = !0
      , we = !1
      , xe = !0
      , se = !1
      , de = !0
      , Se = !1
      , Ce = !1
      , Ye = !1
      , ye = !1
      , Ke = !1
      , X = !1
      , ce = !0
      , fe = !1;
    const Xe = "user-content-";
    let Oe = !0
      , Re = !1
      , le = {}
      , ke = null;
    const He = mn({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let st = null;
    const lt = mn({}, ["audio", "video", "img", "source", "image", "track"]);
    let et = null;
    const Ht = mn({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"])
      , Ft = "http://www.w3.org/1998/Math/MathML"
      , Pt = "http://www.w3.org/2000/svg"
      , nt = "http://www.w3.org/1999/xhtml";
    let ut = nt
      , Lt = !1
      , tn = null;
    const Xt = mn({}, [Ft, Pt, nt], Wk);
    let Mn = mn({}, ["mi", "mo", "mn", "ms", "mtext"])
      , Pn = mn({}, ["annotation-xml"]);
    const wn = mn({}, ["title", "style", "font", "a", "script"]);
    let Kn = null;
    const vr = ["application/xhtml+xml", "text/html"]
      , mr = "text/html";
    let kn = null
      , At = null;
    const nr = n.createElement("form")
      , he = function(ne) {
        return ne instanceof RegExp || ne instanceof Function
    }
      , Le = function() {
        let ne = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(At && At === ne)) {
            if ((!ne || typeof ne != "object") && (ne = {}),
            ne = dl(ne),
            Kn = vr.indexOf(ne.PARSER_MEDIA_TYPE) === -1 ? mr : ne.PARSER_MEDIA_TYPE,
            kn = Kn === "application/xhtml+xml" ? Wk : Nx,
            V = $a(ne, "ALLOWED_TAGS") ? mn({}, ne.ALLOWED_TAGS, kn) : Y,
            W = $a(ne, "ALLOWED_ATTR") ? mn({}, ne.ALLOWED_ATTR, kn) : te,
            tn = $a(ne, "ALLOWED_NAMESPACES") ? mn({}, ne.ALLOWED_NAMESPACES, Wk) : Xt,
            et = $a(ne, "ADD_URI_SAFE_ATTR") ? mn(dl(Ht), ne.ADD_URI_SAFE_ATTR, kn) : Ht,
            st = $a(ne, "ADD_DATA_URI_TAGS") ? mn(dl(lt), ne.ADD_DATA_URI_TAGS, kn) : lt,
            ke = $a(ne, "FORBID_CONTENTS") ? mn({}, ne.FORBID_CONTENTS, kn) : He,
            ee = $a(ne, "FORBID_TAGS") ? mn({}, ne.FORBID_TAGS, kn) : dl({}),
            re = $a(ne, "FORBID_ATTR") ? mn({}, ne.FORBID_ATTR, kn) : dl({}),
            le = $a(ne, "USE_PROFILES") ? ne.USE_PROFILES : !1,
            J = ne.ALLOW_ARIA_ATTR !== !1,
            oe = ne.ALLOW_DATA_ATTR !== !1,
            we = ne.ALLOW_UNKNOWN_PROTOCOLS || !1,
            xe = ne.ALLOW_SELF_CLOSE_IN_ATTR !== !1,
            se = ne.SAFE_FOR_TEMPLATES || !1,
            de = ne.SAFE_FOR_XML !== !1,
            Se = ne.WHOLE_DOCUMENT || !1,
            ye = ne.RETURN_DOM || !1,
            Ke = ne.RETURN_DOM_FRAGMENT || !1,
            X = ne.RETURN_TRUSTED_TYPE || !1,
            Ye = ne.FORCE_BODY || !1,
            ce = ne.SANITIZE_DOM !== !1,
            fe = ne.SANITIZE_NAMED_PROPS || !1,
            Oe = ne.KEEP_CONTENT !== !1,
            Re = ne.IN_PLACE || !1,
            q = ne.ALLOWED_URI_REGEXP || u8,
            ut = ne.NAMESPACE || nt,
            Mn = ne.MATHML_TEXT_INTEGRATION_POINTS || Mn,
            Pn = ne.HTML_INTEGRATION_POINTS || Pn,
            K = ne.CUSTOM_ELEMENT_HANDLING || {},
            ne.CUSTOM_ELEMENT_HANDLING && he(ne.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (K.tagNameCheck = ne.CUSTOM_ELEMENT_HANDLING.tagNameCheck),
            ne.CUSTOM_ELEMENT_HANDLING && he(ne.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (K.attributeNameCheck = ne.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),
            ne.CUSTOM_ELEMENT_HANDLING && typeof ne.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (K.allowCustomizedBuiltInElements = ne.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),
            se && (oe = !1),
            Ke && (ye = !0),
            le && (V = mn({}, HB),
            W = [],
            le.html === !0 && (mn(V, VB),
            mn(W, qB)),
            le.svg === !0 && (mn(V, Yk),
            mn(W, Kk),
            mn(W, ox)),
            le.svgFilters === !0 && (mn(V, Zk),
            mn(W, Kk),
            mn(W, ox)),
            le.mathMl === !0 && (mn(V, Qk),
            mn(W, WB),
            mn(W, ox))),
            ne.ADD_TAGS && (typeof ne.ADD_TAGS == "function" ? ie.tagCheck = ne.ADD_TAGS : (V === Y && (V = dl(V)),
            mn(V, ne.ADD_TAGS, kn))),
            ne.ADD_ATTR && (typeof ne.ADD_ATTR == "function" ? ie.attributeCheck = ne.ADD_ATTR : (W === te && (W = dl(W)),
            mn(W, ne.ADD_ATTR, kn))),
            ne.ADD_URI_SAFE_ATTR && mn(et, ne.ADD_URI_SAFE_ATTR, kn),
            ne.FORBID_CONTENTS && (ke === He && (ke = dl(ke)),
            mn(ke, ne.FORBID_CONTENTS, kn)),
            Oe && (V["#text"] = !0),
            Se && mn(V, ["html", "head", "body"]),
            V.table && (mn(V, ["tbody"]),
            delete ee.tbody),
            ne.TRUSTED_TYPES_POLICY) {
                if (typeof ne.TRUSTED_TYPES_POLICY.createHTML != "function")
                    throw $p('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
                if (typeof ne.TRUSTED_TYPES_POLICY.createScriptURL != "function")
                    throw $p('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
                T = ne.TRUSTED_TYPES_POLICY,
                E = T.createHTML("")
            } else
                T === void 0 && (T = U2e(y, i)),
                T !== null && typeof E == "string" && (E = T.createHTML(""));
            Yi && Yi(ne),
            At = ne
        }
    }
      , it = mn({}, [...Yk, ...Zk, ...R2e])
      , Je = mn({}, [...Qk, ...D2e])
      , Jt = function(ne) {
        let De = k(ne);
        (!De || !De.tagName) && (De = {
            namespaceURI: ut,
            tagName: "template"
        });
        const Ze = Nx(ne.tagName)
          , Wt = Nx(De.tagName);
        return tn[ne.namespaceURI] ? ne.namespaceURI === Pt ? De.namespaceURI === nt ? Ze === "svg" : De.namespaceURI === Ft ? Ze === "svg" && (Wt === "annotation-xml" || Mn[Wt]) : !!it[Ze] : ne.namespaceURI === Ft ? De.namespaceURI === nt ? Ze === "math" : De.namespaceURI === Pt ? Ze === "math" && Pn[Wt] : !!Je[Ze] : ne.namespaceURI === nt ? De.namespaceURI === Pt && !Pn[Wt] || De.namespaceURI === Ft && !Mn[Wt] ? !1 : !Je[Ze] && (wn[Ze] || !it[Ze]) : !!(Kn === "application/xhtml+xml" && tn[ne.namespaceURI]) : !1
    }
      , qt = function(ne) {
        Op(t.removed, {
            element: ne
        });
        try {
            k(ne).removeChild(ne)
        } catch {
            S(ne)
        }
    }
      , dn = function(ne, De) {
        try {
            Op(t.removed, {
                attribute: De.getAttributeNode(ne),
                from: De
            })
        } catch {
            Op(t.removed, {
                attribute: null,
                from: De
            })
        }
        if (De.removeAttribute(ne),
        ne === "is")
            if (ye || Ke)
                try {
                    qt(De)
                } catch {}
            else
                try {
                    De.setAttribute(ne, "")
                } catch {}
    }
      , Ir = function(ne) {
        let De = null
          , Ze = null;
        if (Ye)
            ne = "<remove></remove>" + ne;
        else {
            const Nt = Gk(ne, /^[\r\n\t ]+/);
            Ze = Nt && Nt[0]
        }
        Kn === "application/xhtml+xml" && ut === nt && (ne = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ne + "</body></html>");
        const Wt = T ? T.createHTML(ne) : ne;
        if (ut === nt)
            try {
                De = new m().parseFromString(Wt, Kn)
            } catch {}
        if (!De || !De.documentElement) {
            De = P.createDocument(ut, "template", null);
            try {
                De.documentElement.innerHTML = Lt ? E : Wt
            } catch {}
        }
        const Zt = De.body || De.documentElement;
        return ne && Ze && Zt.insertBefore(n.createTextNode(Ze), Zt.childNodes[0] || null),
        ut === nt ? z.call(De, Se ? "html" : "body")[0] : Se ? De.documentElement : Zt
    }
      , Ki = function(ne) {
        return D.call(ne.ownerDocument || ne, ne, u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION, null)
    }
      , Tr = function(ne) {
        return ne instanceof h && (typeof ne.nodeName != "string" || typeof ne.textContent != "string" || typeof ne.removeChild != "function" || !(ne.attributes instanceof f) || typeof ne.removeAttribute != "function" || typeof ne.setAttribute != "function" || typeof ne.namespaceURI != "string" || typeof ne.insertBefore != "function" || typeof ne.hasChildNodes != "function")
    }
      , ln = function(ne) {
        return typeof s == "function" && ne instanceof s
    };
    function en(me, ne, De) {
        ix(me, Ze => {
            Ze.call(t, ne, De, At)
        }
        )
    }
    const si = function(ne) {
        let De = null;
        if (en(I.beforeSanitizeElements, ne, null),
        Tr(ne))
            return qt(ne),
            !0;
        const Ze = kn(ne.nodeName);
        if (en(I.uponSanitizeElement, ne, {
            tagName: Ze,
            allowedTags: V
        }),
        de && ne.hasChildNodes() && !ln(ne.firstElementChild) && Li(/<[/\w!]/g, ne.innerHTML) && Li(/<[/\w!]/g, ne.textContent) || ne.nodeType === jp.progressingInstruction || de && ne.nodeType === jp.comment && Li(/<[/\w]/g, ne.data))
            return qt(ne),
            !0;
        if (!(ie.tagCheck instanceof Function && ie.tagCheck(Ze)) && (!V[Ze] || ee[Ze])) {
            if (!ee[Ze] && os(Ze) && (K.tagNameCheck instanceof RegExp && Li(K.tagNameCheck, Ze) || K.tagNameCheck instanceof Function && K.tagNameCheck(Ze)))
                return !1;
            if (Oe && !ke[Ze]) {
                const Wt = k(ne) || ne.parentNode
                  , Zt = w(ne) || ne.childNodes;
                if (Zt && Wt) {
                    const Nt = Zt.length;
                    for (let _r = Nt - 1; _r >= 0; --_r) {
                        const Ii = v(Zt[_r], !0);
                        Ii.__removalCount = (ne.__removalCount || 0) + 1,
                        Wt.insertBefore(Ii, C(ne))
                    }
                }
            }
            return qt(ne),
            !0
        }
        return ne instanceof c && !Jt(ne) || (Ze === "noscript" || Ze === "noembed" || Ze === "noframes") && Li(/<\/no(script|embed|frames)/i, ne.innerHTML) ? (qt(ne),
        !0) : (se && ne.nodeType === jp.text && (De = ne.textContent,
        ix([M, B, L], Wt => {
            De = Ip(De, Wt, " ")
        }
        ),
        ne.textContent !== De && (Op(t.removed, {
            element: ne.cloneNode()
        }),
        ne.textContent = De)),
        en(I.afterSanitizeElements, ne, null),
        !1)
    }
      , is = function(ne, De, Ze) {
        if (ce && (De === "id" || De === "name") && (Ze in n || Ze in nr))
            return !1;
        if (!(oe && !re[De] && Li(F, De))) {
            if (!(J && Li(j, De))) {
                if (!(ie.attributeCheck instanceof Function && ie.attributeCheck(De, ne))) {
                    if (!W[De] || re[De]) {
                        if (!(os(ne) && (K.tagNameCheck instanceof RegExp && Li(K.tagNameCheck, ne) || K.tagNameCheck instanceof Function && K.tagNameCheck(ne)) && (K.attributeNameCheck instanceof RegExp && Li(K.attributeNameCheck, De) || K.attributeNameCheck instanceof Function && K.attributeNameCheck(De, ne)) || De === "is" && K.allowCustomizedBuiltInElements && (K.tagNameCheck instanceof RegExp && Li(K.tagNameCheck, Ze) || K.tagNameCheck instanceof Function && K.tagNameCheck(Ze))))
                            return !1
                    } else if (!et[De]) {
                        if (!Li(q, Ip(Ze, H, ""))) {
                            if (!((De === "src" || De === "xlink:href" || De === "href") && ne !== "script" && E2e(Ze, "data:") === 0 && st[ne])) {
                                if (!(we && !Li(N, Ip(Ze, H, "")))) {
                                    if (Ze)
                                        return !1
                                }
                            }
                        }
                    }
                }
            }
        }
        return !0
    }
      , os = function(ne) {
        return ne !== "annotation-xml" && Gk(ne, Z)
    }
      , zs = function(ne) {
        en(I.beforeSanitizeAttributes, ne, null);
        const {attributes: De} = ne;
        if (!De || Tr(ne))
            return;
        const Ze = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: W,
            forceKeepAttr: void 0
        };
        let Wt = De.length;
        for (; Wt--; ) {
            const Zt = De[Wt]
              , {name: Nt, namespaceURI: _r, value: Ii} = Zt
              , ui = kn(Nt)
              , Mo = Ii;
            let Bt = Nt === "value" ? Mo : A2e(Mo);
            if (Ze.attrName = ui,
            Ze.attrValue = Bt,
            Ze.keepAttr = !0,
            Ze.forceKeepAttr = void 0,
            en(I.uponSanitizeAttribute, ne, Ze),
            Bt = Ze.attrValue,
            fe && (ui === "id" || ui === "name") && (dn(Nt, ne),
            Bt = Xe + Bt),
            de && Li(/((--!?|])>)|<\/(style|title|textarea)/i, Bt)) {
                dn(Nt, ne);
                continue
            }
            if (ui === "attributename" && Gk(Bt, "href")) {
                dn(Nt, ne);
                continue
            }
            if (Ze.forceKeepAttr)
                continue;
            if (!Ze.keepAttr) {
                dn(Nt, ne);
                continue
            }
            if (!xe && Li(/\/>/i, Bt)) {
                dn(Nt, ne);
                continue
            }
            se && ix([M, B, L], Ji => {
                Bt = Ip(Bt, Ji, " ")
            }
            );
            const Xi = kn(ne.nodeName);
            if (!is(Xi, ui, Bt)) {
                dn(Nt, ne);
                continue
            }
            if (T && typeof y == "object" && typeof y.getAttributeType == "function" && !_r)
                switch (y.getAttributeType(Xi, ui)) {
                case "TrustedHTML":
                    {
                        Bt = T.createHTML(Bt);
                        break
                    }
                case "TrustedScriptURL":
                    {
                        Bt = T.createScriptURL(Bt);
                        break
                    }
                }
            if (Bt !== Mo)
                try {
                    _r ? ne.setAttributeNS(_r, Nt, Bt) : ne.setAttribute(Nt, Bt),
                    Tr(ne) ? qt(ne) : UB(t.removed)
                } catch {
                    dn(Nt, ne)
                }
        }
        en(I.afterSanitizeAttributes, ne, null)
    }
      , Fe = function me(ne) {
        let De = null;
        const Ze = Ki(ne);
        for (en(I.beforeSanitizeShadowDOM, ne, null); De = Ze.nextNode(); )
            en(I.uponSanitizeShadowNode, De, null),
            si(De),
            zs(De),
            De.content instanceof o && me(De.content);
        en(I.afterSanitizeShadowDOM, ne, null)
    };
    return t.sanitize = function(me) {
        let ne = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , De = null
          , Ze = null
          , Wt = null
          , Zt = null;
        if (Lt = !me,
        Lt && (me = "<!-->"),
        typeof me != "string" && !ln(me))
            if (typeof me.toString == "function") {
                if (me = me.toString(),
                typeof me != "string")
                    throw $p("dirty is not a string, aborting")
            } else
                throw $p("toString is not a function");
        if (!t.isSupported)
            return me;
        if (Ce || Le(ne),
        t.removed = [],
        typeof me == "string" && (Re = !1),
        Re) {
            if (me.nodeName) {
                const Ii = kn(me.nodeName);
                if (!V[Ii] || ee[Ii])
                    throw $p("root node is forbidden and cannot be sanitized in-place")
            }
        } else if (me instanceof s)
            De = Ir("<!---->"),
            Ze = De.ownerDocument.importNode(me, !0),
            Ze.nodeType === jp.element && Ze.nodeName === "BODY" || Ze.nodeName === "HTML" ? De = Ze : De.appendChild(Ze);
        else {
            if (!ye && !se && !Se && me.indexOf("<") === -1)
                return T && X ? T.createHTML(me) : me;
            if (De = Ir(me),
            !De)
                return ye ? null : X ? E : ""
        }
        De && Ye && qt(De.firstChild);
        const Nt = Ki(Re ? me : De);
        for (; Wt = Nt.nextNode(); )
            si(Wt),
            zs(Wt),
            Wt.content instanceof o && Fe(Wt.content);
        if (Re)
            return me;
        if (ye) {
            if (Ke)
                for (Zt = $.call(De.ownerDocument); De.firstChild; )
                    Zt.appendChild(De.firstChild);
            else
                Zt = De;
            return (W.shadowroot || W.shadowrootmode) && (Zt = O.call(r, Zt, !0)),
            Zt
        }
        let _r = Se ? De.outerHTML : De.innerHTML;
        return Se && V["!doctype"] && De.ownerDocument && De.ownerDocument.doctype && De.ownerDocument.doctype.name && Li(d8, De.ownerDocument.doctype.name) && (_r = "<!DOCTYPE " + De.ownerDocument.doctype.name + `>
` + _r),
        se && ix([M, B, L], Ii => {
            _r = Ip(_r, Ii, " ")
        }
        ),
        T && X ? T.createHTML(_r) : _r
    }
    ,
    t.setConfig = function() {
        let me = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Le(me),
        Ce = !0
    }
    ,
    t.clearConfig = function() {
        At = null,
        Ce = !1
    }
    ,
    t.isValidAttribute = function(me, ne, De) {
        At || Le({});
        const Ze = kn(me)
          , Wt = kn(ne);
        return is(Ze, Wt, De)
    }
    ,
    t.addHook = function(me, ne) {
        typeof ne == "function" && Op(I[me], ne)
    }
    ,
    t.removeHook = function(me, ne) {
        if (ne !== void 0) {
            const De = T2e(I[me], ne);
            return De === -1 ? void 0 : _2e(I[me], De, 1)[0]
        }
        return UB(I[me])
    }
    ,
    t.removeHooks = function(me) {
        I[me] = []
    }
    ,
    t.removeAllHooks = function() {
        I = YB()
    }
    ,
    t
}
var Xf = f8(), h8 = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s, Rm = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, V2e = /\s*%%.*\n/gm, Df, p8 = (Df = class extends Error {
    constructor(t) {
        super(t),
        this.name = "UnknownDiagramError"
    }
}
,
U(Df, "UnknownDiagramError"),
Df), Yu = {}, tM = U(function(e, t) {
    e = e.replace(h8, "").replace(Rm, "").replace(V2e, `
`);
    for (const [n,{detector: r}] of Object.entries(Yu))
        if (r(e, t))
            return n;
    throw new p8(`No diagram type detected matching given configuration for text: ${e}`)
}, "detectType"), KT = U( (...e) => {
    for (const {id: t, detector: n, loader: r} of e)
        m8(t, n, r)
}
, "registerLazyLoadedDiagrams"), m8 = U( (e, t, n) => {
    Yu[e] && Qe.warn(`Detector with key ${e} already exists. Overwriting.`),
    Yu[e] = {
        detector: t,
        loader: n
    },
    Qe.debug(`Detector with key ${e} added${n ? " with loader" : ""}`)
}
, "addDetector"), H2e = U(e => Yu[e].loader, "getDiagramLoader"), XT = U( (e, t, {depth: n=2, clobber: r=!1}={}) => {
    const i = {
        depth: n,
        clobber: r
    };
    return Array.isArray(t) && !Array.isArray(e) ? (t.forEach(o => XT(e, o, i)),
    e) : Array.isArray(t) && Array.isArray(e) ? (t.forEach(o => {
        e.includes(o) || e.push(o)
    }
    ),
    e) : e === void 0 || n <= 0 ? e != null && typeof e == "object" && typeof t == "object" ? Object.assign(e, t) : t : (t !== void 0 && typeof e == "object" && typeof t == "object" && Object.keys(t).forEach(o => {
        typeof t[o] == "object" && (e[o] === void 0 || typeof e[o] == "object") ? (e[o] === void 0 && (e[o] = Array.isArray(t[o]) ? [] : {}),
        e[o] = XT(e[o], t[o], {
            depth: n - 1,
            clobber: r
        })) : (r || typeof e[o] != "object" && typeof t[o] != "object") && (e[o] = t[o])
    }
    ),
    e)
}
, "assignWithDepth"), ri = XT, z1 = "#ffffff", F1 = "#f2f2f2", Ui = U( (e, t) => t ? ve(e, {
    s: -40,
    l: 10
}) : ve(e, {
    s: -40,
    l: -10
}), "mkBorder"), Of, q2e = (Of = class {
    constructor() {
        this.background = "#f4f4f4",
        this.primaryColor = "#fff4dd",
        this.noteBkgColor = "#fff5ad",
        this.noteTextColor = "#333",
        this.THEME_COLOR_LIMIT = 12,
        this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif',
        this.fontSize = "16px"
    }
    updateColors() {
        if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"),
        this.secondaryColor = this.secondaryColor || ve(this.primaryColor, {
            h: -120
        }),
        this.tertiaryColor = this.tertiaryColor || ve(this.primaryColor, {
            h: 180,
            l: 5
        }),
        this.primaryBorderColor = this.primaryBorderColor || Ui(this.primaryColor, this.darkMode),
        this.secondaryBorderColor = this.secondaryBorderColor || Ui(this.secondaryColor, this.darkMode),
        this.tertiaryBorderColor = this.tertiaryBorderColor || Ui(this.tertiaryColor, this.darkMode),
        this.noteBorderColor = this.noteBorderColor || Ui(this.noteBkgColor, this.darkMode),
        this.noteBkgColor = this.noteBkgColor || "#fff5ad",
        this.noteTextColor = this.noteTextColor || "#333",
        this.secondaryTextColor = this.secondaryTextColor || ht(this.secondaryColor),
        this.tertiaryTextColor = this.tertiaryTextColor || ht(this.tertiaryColor),
        this.lineColor = this.lineColor || ht(this.background),
        this.arrowheadColor = this.arrowheadColor || ht(this.background),
        this.textColor = this.textColor || this.primaryTextColor,
        this.border2 = this.border2 || this.tertiaryBorderColor,
        this.nodeBkg = this.nodeBkg || this.primaryColor,
        this.mainBkg = this.mainBkg || this.primaryColor,
        this.nodeBorder = this.nodeBorder || this.primaryBorderColor,
        this.clusterBkg = this.clusterBkg || this.tertiaryColor,
        this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor,
        this.defaultLinkColor = this.defaultLinkColor || this.lineColor,
        this.titleColor = this.titleColor || this.tertiaryTextColor,
        this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? Ot(this.secondaryColor, 30) : this.secondaryColor),
        this.nodeTextColor = this.nodeTextColor || this.primaryTextColor,
        this.actorBorder = this.actorBorder || this.primaryBorderColor,
        this.actorBkg = this.actorBkg || this.mainBkg,
        this.actorTextColor = this.actorTextColor || this.primaryTextColor,
        this.actorLineColor = this.actorLineColor || this.actorBorder,
        this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg,
        this.signalColor = this.signalColor || this.textColor,
        this.signalTextColor = this.signalTextColor || this.textColor,
        this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder,
        this.labelTextColor = this.labelTextColor || this.actorTextColor,
        this.loopTextColor = this.loopTextColor || this.actorTextColor,
        this.activationBorderColor = this.activationBorderColor || Ot(this.secondaryColor, 10),
        this.activationBkgColor = this.activationBkgColor || this.secondaryColor,
        this.sequenceNumberColor = this.sequenceNumberColor || ht(this.lineColor),
        this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor,
        this.altSectionBkgColor = this.altSectionBkgColor || "white",
        this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor,
        this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor,
        this.excludeBkgColor = this.excludeBkgColor || "#eeeeee",
        this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor,
        this.taskBkgColor = this.taskBkgColor || this.primaryColor,
        this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor,
        this.activeTaskBkgColor = this.activeTaskBkgColor || St(this.primaryColor, 23),
        this.gridColor = this.gridColor || "lightgrey",
        this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey",
        this.doneTaskBorderColor = this.doneTaskBorderColor || "grey",
        this.critBorderColor = this.critBorderColor || "#ff8888",
        this.critBkgColor = this.critBkgColor || "red",
        this.todayLineColor = this.todayLineColor || "red",
        this.vertLineColor = this.vertLineColor || "navy",
        this.taskTextColor = this.taskTextColor || this.textColor,
        this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor,
        this.taskTextLightColor = this.taskTextLightColor || this.textColor,
        this.taskTextColor = this.taskTextColor || this.primaryTextColor,
        this.taskTextDarkColor = this.taskTextDarkColor || this.textColor,
        this.taskTextClickableColor = this.taskTextClickableColor || "#003163",
        this.personBorder = this.personBorder || this.primaryBorderColor,
        this.personBkg = this.personBkg || this.mainBkg,
        this.darkMode ? (this.rowOdd = this.rowOdd || Ot(this.mainBkg, 5) || "#ffffff",
        this.rowEven = this.rowEven || Ot(this.mainBkg, 10)) : (this.rowOdd = this.rowOdd || St(this.mainBkg, 75) || "#ffffff",
        this.rowEven = this.rowEven || St(this.mainBkg, 5)),
        this.transitionColor = this.transitionColor || this.lineColor,
        this.transitionLabelColor = this.transitionLabelColor || this.textColor,
        this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor,
        this.stateBkg = this.stateBkg || this.mainBkg,
        this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg,
        this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor,
        this.altBackground = this.altBackground || this.tertiaryColor,
        this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg,
        this.compositeBorder = this.compositeBorder || this.nodeBorder,
        this.innerEndBackground = this.nodeBorder,
        this.errorBkgColor = this.errorBkgColor || this.tertiaryColor,
        this.errorTextColor = this.errorTextColor || this.tertiaryTextColor,
        this.transitionColor = this.transitionColor || this.lineColor,
        this.specialStateColor = this.lineColor,
        this.cScale0 = this.cScale0 || this.primaryColor,
        this.cScale1 = this.cScale1 || this.secondaryColor,
        this.cScale2 = this.cScale2 || this.tertiaryColor,
        this.cScale3 = this.cScale3 || ve(this.primaryColor, {
            h: 30
        }),
        this.cScale4 = this.cScale4 || ve(this.primaryColor, {
            h: 60
        }),
        this.cScale5 = this.cScale5 || ve(this.primaryColor, {
            h: 90
        }),
        this.cScale6 = this.cScale6 || ve(this.primaryColor, {
            h: 120
        }),
        this.cScale7 = this.cScale7 || ve(this.primaryColor, {
            h: 150
        }),
        this.cScale8 = this.cScale8 || ve(this.primaryColor, {
            h: 210,
            l: 150
        }),
        this.cScale9 = this.cScale9 || ve(this.primaryColor, {
            h: 270
        }),
        this.cScale10 = this.cScale10 || ve(this.primaryColor, {
            h: 300
        }),
        this.cScale11 = this.cScale11 || ve(this.primaryColor, {
            h: 330
        }),
        this.darkMode)
            for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
                this["cScale" + n] = Ot(this["cScale" + n], 75);
        else
            for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
                this["cScale" + n] = Ot(this["cScale" + n], 25);
        for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
            this["cScaleInv" + n] = this["cScaleInv" + n] || ht(this["cScale" + n]);
        for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
            this.darkMode ? this["cScalePeer" + n] = this["cScalePeer" + n] || St(this["cScale" + n], 10) : this["cScalePeer" + n] = this["cScalePeer" + n] || Ot(this["cScale" + n], 10);
        this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
        for (let n = 0; n < this.THEME_COLOR_LIMIT; n++)
            this["cScaleLabel" + n] = this["cScaleLabel" + n] || this.scaleLabelColor;
        const t = this.darkMode ? -4 : -1;
        for (let n = 0; n < 5; n++)
            this["surface" + n] = this["surface" + n] || ve(this.mainBkg, {
                h: 180,
                s: -15,
                l: t * (5 + n * 3)
            }),
            this["surfacePeer" + n] = this["surfacePeer" + n] || ve(this.mainBkg, {
                h: 180,
                s: -15,
                l: t * (8 + n * 3)
            });
        this.classText = this.classText || this.textColor,
        this.fillType0 = this.fillType0 || this.primaryColor,
        this.fillType1 = this.fillType1 || this.secondaryColor,
        this.fillType2 = this.fillType2 || ve(this.primaryColor, {
            h: 64
        }),
        this.fillType3 = this.fillType3 || ve(this.secondaryColor, {
            h: 64
        }),
        this.fillType4 = this.fillType4 || ve(this.primaryColor, {
            h: -64
        }),
        this.fillType5 = this.fillType5 || ve(this.secondaryColor, {
            h: -64
        }),
        this.fillType6 = this.fillType6 || ve(this.primaryColor, {
            h: 128
        }),
        this.fillType7 = this.fillType7 || ve(this.secondaryColor, {
            h: 128
        }),
        this.pie1 = this.pie1 || this.primaryColor,
        this.pie2 = this.pie2 || this.secondaryColor,
        this.pie3 = this.pie3 || this.tertiaryColor,
        this.pie4 = this.pie4 || ve(this.primaryColor, {
            l: -10
        }),
        this.pie5 = this.pie5 || ve(this.secondaryColor, {
            l: -10
        }),
        this.pie6 = this.pie6 || ve(this.tertiaryColor, {
            l: -10
        }),
        this.pie7 = this.pie7 || ve(this.primaryColor, {
            h: 60,
            l: -10
        }),
        this.pie8 = this.pie8 || ve(this.primaryColor, {
            h: -60,
            l: -10
        }),
        this.pie9 = this.pie9 || ve(this.primaryColor, {
            h: 120,
            l: 0
        }),
        this.pie10 = this.pie10 || ve(this.primaryColor, {
            h: 60,
            l: -20
        }),
        this.pie11 = this.pie11 || ve(this.primaryColor, {
            h: -60,
            l: -20
        }),
        this.pie12 = this.pie12 || ve(this.primaryColor, {
            h: 120,
            l: -10
        }),
        this.pieTitleTextSize = this.pieTitleTextSize || "25px",
        this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor,
        this.pieSectionTextSize = this.pieSectionTextSize || "17px",
        this.pieSectionTextColor = this.pieSectionTextColor || this.textColor,
        this.pieLegendTextSize = this.pieLegendTextSize || "17px",
        this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor,
        this.pieStrokeColor = this.pieStrokeColor || "black",
        this.pieStrokeWidth = this.pieStrokeWidth || "2px",
        this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px",
        this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black",
        this.pieOpacity = this.pieOpacity || "0.7",
        this.radar = {
            axisColor: this.radar?.axisColor || this.lineColor,
            axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
            axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
            curveOpacity: this.radar?.curveOpacity || .5,
            curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
            graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
            graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
            graticuleOpacity: this.radar?.graticuleOpacity || .3,
            legendBoxSize: this.radar?.legendBoxSize || 12,
            legendFontSize: this.radar?.legendFontSize || 12
        },
        this.archEdgeColor = this.archEdgeColor || "#777",
        this.archEdgeArrowColor = this.archEdgeArrowColor || "#777",
        this.archEdgeWidth = this.archEdgeWidth || "3",
        this.archGroupBorderColor = this.archGroupBorderColor || "#000",
        this.archGroupBorderWidth = this.archGroupBorderWidth || "2px",
        this.quadrant1Fill = this.quadrant1Fill || this.primaryColor,
        this.quadrant2Fill = this.quadrant2Fill || ve(this.primaryColor, {
            r: 5,
            g: 5,
            b: 5
        }),
        this.quadrant3Fill = this.quadrant3Fill || ve(this.primaryColor, {
            r: 10,
            g: 10,
            b: 10
        }),
        this.quadrant4Fill = this.quadrant4Fill || ve(this.primaryColor, {
            r: 15,
            g: 15,
            b: 15
        }),
        this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor,
        this.quadrant2TextFill = this.quadrant2TextFill || ve(this.primaryTextColor, {
            r: -5,
            g: -5,
            b: -5
        }),
        this.quadrant3TextFill = this.quadrant3TextFill || ve(this.primaryTextColor, {
            r: -10,
            g: -10,
            b: -10
        }),
        this.quadrant4TextFill = this.quadrant4TextFill || ve(this.primaryTextColor, {
            r: -15,
            g: -15,
            b: -15
        }),
        this.quadrantPointFill = this.quadrantPointFill || ny(this.quadrant1Fill) ? St(this.quadrant1Fill) : Ot(this.quadrant1Fill),
        this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor,
        this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor,
        this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor,
        this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor,
        this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
        },
        this.requirementBackground = this.requirementBackground || this.primaryColor,
        this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor,
        this.requirementBorderSize = this.requirementBorderSize || "1",
        this.requirementTextColor = this.requirementTextColor || this.primaryTextColor,
        this.relationColor = this.relationColor || this.lineColor,
        this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Ot(this.secondaryColor, 30) : this.secondaryColor),
        this.relationLabelColor = this.relationLabelColor || this.actorTextColor,
        this.git0 = this.git0 || this.primaryColor,
        this.git1 = this.git1 || this.secondaryColor,
        this.git2 = this.git2 || this.tertiaryColor,
        this.git3 = this.git3 || ve(this.primaryColor, {
            h: -30
        }),
        this.git4 = this.git4 || ve(this.primaryColor, {
            h: -60
        }),
        this.git5 = this.git5 || ve(this.primaryColor, {
            h: -90
        }),
        this.git6 = this.git6 || ve(this.primaryColor, {
            h: 60
        }),
        this.git7 = this.git7 || ve(this.primaryColor, {
            h: 120
        }),
        this.darkMode ? (this.git0 = St(this.git0, 25),
        this.git1 = St(this.git1, 25),
        this.git2 = St(this.git2, 25),
        this.git3 = St(this.git3, 25),
        this.git4 = St(this.git4, 25),
        this.git5 = St(this.git5, 25),
        this.git6 = St(this.git6, 25),
        this.git7 = St(this.git7, 25)) : (this.git0 = Ot(this.git0, 25),
        this.git1 = Ot(this.git1, 25),
        this.git2 = Ot(this.git2, 25),
        this.git3 = Ot(this.git3, 25),
        this.git4 = Ot(this.git4, 25),
        this.git5 = Ot(this.git5, 25),
        this.git6 = Ot(this.git6, 25),
        this.git7 = Ot(this.git7, 25)),
        this.gitInv0 = this.gitInv0 || ht(this.git0),
        this.gitInv1 = this.gitInv1 || ht(this.git1),
        this.gitInv2 = this.gitInv2 || ht(this.git2),
        this.gitInv3 = this.gitInv3 || ht(this.git3),
        this.gitInv4 = this.gitInv4 || ht(this.git4),
        this.gitInv5 = this.gitInv5 || ht(this.git5),
        this.gitInv6 = this.gitInv6 || ht(this.git6),
        this.gitInv7 = this.gitInv7 || ht(this.git7),
        this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor),
        this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor,
        this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor,
        this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor,
        this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor,
        this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor,
        this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor,
        this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor,
        this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor,
        this.tagLabelColor = this.tagLabelColor || this.primaryTextColor,
        this.tagLabelBackground = this.tagLabelBackground || this.primaryColor,
        this.tagLabelBorder = this.tagBorder || this.primaryBorderColor,
        this.tagLabelFontSize = this.tagLabelFontSize || "10px",
        this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor,
        this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor,
        this.commitLabelFontSize = this.commitLabelFontSize || "10px",
        this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || z1,
        this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || F1
    }
    calculate(t) {
        if (typeof t != "object") {
            this.updateColors();
            return
        }
        const n = Object.keys(t);
        n.forEach(r => {
            this[r] = t[r]
        }
        ),
        this.updateColors(),
        n.forEach(r => {
            this[r] = t[r]
        }
        )
    }
}
,
U(Of, "Theme"),
Of), W2e = U(e => {
    const t = new q2e;
    return t.calculate(e),
    t
}
, "getThemeVariables"), If, G2e = (If = class {
    constructor() {
        this.background = "#333",
        this.primaryColor = "#1f2020",
        this.secondaryColor = St(this.primaryColor, 16),
        this.tertiaryColor = ve(this.primaryColor, {
            h: -160
        }),
        this.primaryBorderColor = ht(this.background),
        this.secondaryBorderColor = Ui(this.secondaryColor, this.darkMode),
        this.tertiaryBorderColor = Ui(this.tertiaryColor, this.darkMode),
        this.primaryTextColor = ht(this.primaryColor),
        this.secondaryTextColor = ht(this.secondaryColor),
        this.tertiaryTextColor = ht(this.tertiaryColor),
        this.lineColor = ht(this.background),
        this.textColor = ht(this.background),
        this.mainBkg = "#1f2020",
        this.secondBkg = "calculated",
        this.mainContrastColor = "lightgrey",
        this.darkTextColor = St(ht("#323D47"), 10),
        this.lineColor = "calculated",
        this.border1 = "#ccc",
        this.border2 = Pm(255, 255, 255, .25),
        this.arrowheadColor = "calculated",
        this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif',
        this.fontSize = "16px",
        this.labelBackground = "#181818",
        this.textColor = "#ccc",
        this.THEME_COLOR_LIMIT = 12,
        this.nodeBkg = "calculated",
        this.nodeBorder = "calculated",
        this.clusterBkg = "calculated",
        this.clusterBorder = "calculated",
        this.defaultLinkColor = "calculated",
        this.titleColor = "#F9FFFE",
        this.edgeLabelBackground = "calculated",
        this.actorBorder = "calculated",
        this.actorBkg = "calculated",
        this.actorTextColor = "calculated",
        this.actorLineColor = "calculated",
        this.signalColor = "calculated",
        this.signalTextColor = "calculated",
        this.labelBoxBkgColor = "calculated",
        this.labelBoxBorderColor = "calculated",
        this.labelTextColor = "calculated",
        this.loopTextColor = "calculated",
        this.noteBorderColor = "calculated",
        this.noteBkgColor = "#fff5ad",
        this.noteTextColor = "calculated",
        this.activationBorderColor = "calculated",
        this.activationBkgColor = "calculated",
        this.sequenceNumberColor = "black",
        this.sectionBkgColor = Ot("#EAE8D9", 30),
        this.altSectionBkgColor = "calculated",
        this.sectionBkgColor2 = "#EAE8D9",
        this.excludeBkgColor = Ot(this.sectionBkgColor, 10),
        this.taskBorderColor = Pm(255, 255, 255, 70),
        this.taskBkgColor = "calculated",
        this.taskTextColor = "calculated",
        this.taskTextLightColor = "calculated",
        this.taskTextOutsideColor = "calculated",
        this.taskTextClickableColor = "#003163",
        this.activeTaskBorderColor = Pm(255, 255, 255, 50),
        this.activeTaskBkgColor = "#81B1DB",
        this.gridColor = "calculated",
        this.doneTaskBkgColor = "calculated",
        this.doneTaskBorderColor = "grey",
        this.critBorderColor = "#E83737",
        this.critBkgColor = "#E83737",
        this.taskTextDarkColor = "calculated",
        this.todayLineColor = "#DB5757",
        this.vertLineColor = "#00BFFF",
        this.personBorder = this.primaryBorderColor,
        this.personBkg = this.mainBkg,
        this.archEdgeColor = "calculated",
        this.archEdgeArrowColor = "calculated",
        this.archEdgeWidth = "3",
        this.archGroupBorderColor = this.primaryBorderColor,
        this.archGroupBorderWidth = "2px",
        this.rowOdd = this.rowOdd || St(this.mainBkg, 5) || "#ffffff",
        this.rowEven = this.rowEven || Ot(this.mainBkg, 10),
        this.labelColor = "calculated",
        this.errorBkgColor = "#a44141",
        this.errorTextColor = "#ddd"
    }
    updateColors() {
        this.secondBkg = St(this.mainBkg, 16),
        this.lineColor = this.mainContrastColor,
        this.arrowheadColor = this.mainContrastColor,
        this.nodeBkg = this.mainBkg,
        this.nodeBorder = this.border1,
        this.clusterBkg = this.secondBkg,
        this.clusterBorder = this.border2,
        this.defaultLinkColor = this.lineColor,
        this.edgeLabelBackground = St(this.labelBackground, 25),
        this.actorBorder = this.border1,
        this.actorBkg = this.mainBkg,
        this.actorTextColor = this.mainContrastColor,
        this.actorLineColor = this.actorBorder,
        this.signalColor = this.mainContrastColor,
        this.signalTextColor = this.mainContrastColor,
        this.labelBoxBkgColor = this.actorBkg,
        this.labelBoxBorderColor = this.actorBorder,
        this.labelTextColor = this.mainContrastColor,
        this.loopTextColor = this.mainContrastColor,
        this.noteBorderColor = this.secondaryBorderColor,
        this.noteBkgColor = this.secondBkg,
        this.noteTextColor = this.secondaryTextColor,
        this.activationBorderColor = this.border1,
        this.activationBkgColor = this.secondBkg,
        this.altSectionBkgColor = this.background,
        this.taskBkgColor = St(this.mainBkg, 23),
        this.taskTextColor = this.darkTextColor,
        this.taskTextLightColor = this.mainContrastColor,
        this.taskTextOutsideColor = this.taskTextLightColor,
        this.gridColor = this.mainContrastColor,
        this.doneTaskBkgColor = this.mainContrastColor,
        this.taskTextDarkColor = this.darkTextColor,
        this.archEdgeColor = this.lineColor,
        this.archEdgeArrowColor = this.lineColor,
        this.transitionColor = this.transitionColor || this.lineColor,
        this.transitionLabelColor = this.transitionLabelColor || this.textColor,
        this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor,
        this.stateBkg = this.stateBkg || this.mainBkg,
        this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg,
        this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor,
        this.altBackground = this.altBackground || "#555",
        this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg,
        this.compositeBorder = this.compositeBorder || this.nodeBorder,
        this.innerEndBackground = this.primaryBorderColor,
        this.specialStateColor = "#f4f4f4",
        this.errorBkgColor = this.errorBkgColor || this.tertiaryColor,
        this.errorTextColor = this.errorTextColor || this.tertiaryTextColor,
        this.fillType0 = this.primaryColor,
        this.fillType1 = this.secondaryColor,
        this.fillType2 = ve(this.primaryColor, {
            h: 64
        }),
        this.fillType3 = ve(this.secondaryColor, {
            h: 64
        }),
        this.fillType4 = ve(this.primaryColor, {
            h: -64
        }),
        this.fillType5 = ve(this.secondaryColor, {
            h: -64
        }),
        this.fillType6 = ve(this.primaryColor, {
            h: 128
        }),
        this.fillType7 = ve(this.secondaryColor, {
            h: 128
        }),
        this.cScale1 = this.cScale1 || "#0b0000",
        this.cScale2 = this.cScale2 || "#4d1037",
        this.cScale3 = this.cScale3 || "#3f5258",
        this.cScale4 = this.cScale4 || "#4f2f1b",
        this.cScale5 = this.cScale5 || "#6e0a0a",
        this.cScale6 = this.cScale6 || "#3b0048",
        this.cScale7 = this.cScale7 || "#995a01",
        this.cScale8 = this.cScale8 || "#154706",
        this.cScale9 = this.cScale9 || "#161722",
        this.cScale10 = this.cScale10 || "#00296f",
        this.cScale11 = this.cScale11 || "#01629c",
        this.cScale12 = this.cScale12 || "#010029",
        this.cScale0 = this.cScale0 || this.primaryColor,
        this.cScale1 = this.cScale1 || this.secondaryColor,
        this.cScale2 = this.cScale2 || this.tertiaryColor,
        this.cScale3 = this.cScale3 || ve(this.primaryColor, {
            h: 30
        }),
        this.cScale4 = this.cScale4 || ve(this.primaryColor, {
            h: 60
        }),
        this.cScale5 = this.cScale5 || ve(this.primaryColor, {
            h: 90
        }),
        this.cScale6 = this.cScale6 || ve(this.primaryColor, {
            h: 120
        }),
        this.cScale7 = this.cScale7 || ve(this.primaryColor, {
            h: 150
        }),
        this.cScale8 = this.cScale8 || ve(this.primaryColor, {
            h: 210
        }),
        this.cScale9 = this.cScale9 || ve(this.primaryColor, {
            h: 270
        }),
        this.cScale10 = this.cScale10 || ve(this.primaryColor, {
            h: 300
        }),
        this.cScale11 = this.cScale11 || ve(this.primaryColor, {
            h: 330
        });
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleInv" + t] = this["cScaleInv" + t] || ht(this["cScale" + t]);
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScalePeer" + t] = this["cScalePeer" + t] || St(this["cScale" + t], 10);
        for (let t = 0; t < 5; t++)
            this["surface" + t] = this["surface" + t] || ve(this.mainBkg, {
                h: 30,
                s: -30,
                l: -(-10 + t * 4)
            }),
            this["surfacePeer" + t] = this["surfacePeer" + t] || ve(this.mainBkg, {
                h: 30,
                s: -30,
                l: -(-7 + t * 4)
            });
        this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["pie" + t] = this["cScale" + t];
        this.pieTitleTextSize = this.pieTitleTextSize || "25px",
        this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor,
        this.pieSectionTextSize = this.pieSectionTextSize || "17px",
        this.pieSectionTextColor = this.pieSectionTextColor || this.textColor,
        this.pieLegendTextSize = this.pieLegendTextSize || "17px",
        this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor,
        this.pieStrokeColor = this.pieStrokeColor || "black",
        this.pieStrokeWidth = this.pieStrokeWidth || "2px",
        this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px",
        this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black",
        this.pieOpacity = this.pieOpacity || "0.7",
        this.quadrant1Fill = this.quadrant1Fill || this.primaryColor,
        this.quadrant2Fill = this.quadrant2Fill || ve(this.primaryColor, {
            r: 5,
            g: 5,
            b: 5
        }),
        this.quadrant3Fill = this.quadrant3Fill || ve(this.primaryColor, {
            r: 10,
            g: 10,
            b: 10
        }),
        this.quadrant4Fill = this.quadrant4Fill || ve(this.primaryColor, {
            r: 15,
            g: 15,
            b: 15
        }),
        this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor,
        this.quadrant2TextFill = this.quadrant2TextFill || ve(this.primaryTextColor, {
            r: -5,
            g: -5,
            b: -5
        }),
        this.quadrant3TextFill = this.quadrant3TextFill || ve(this.primaryTextColor, {
            r: -10,
            g: -10,
            b: -10
        }),
        this.quadrant4TextFill = this.quadrant4TextFill || ve(this.primaryTextColor, {
            r: -15,
            g: -15,
            b: -15
        }),
        this.quadrantPointFill = this.quadrantPointFill || ny(this.quadrant1Fill) ? St(this.quadrant1Fill) : Ot(this.quadrant1Fill),
        this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor,
        this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor,
        this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor,
        this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor,
        this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
        },
        this.packet = {
            startByteColor: this.primaryTextColor,
            endByteColor: this.primaryTextColor,
            labelColor: this.primaryTextColor,
            titleColor: this.primaryTextColor,
            blockStrokeColor: this.primaryTextColor,
            blockFillColor: this.background
        },
        this.radar = {
            axisColor: this.radar?.axisColor || this.lineColor,
            axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
            axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
            curveOpacity: this.radar?.curveOpacity || .5,
            curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
            graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
            graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
            graticuleOpacity: this.radar?.graticuleOpacity || .3,
            legendBoxSize: this.radar?.legendBoxSize || 12,
            legendFontSize: this.radar?.legendFontSize || 12
        },
        this.classText = this.primaryTextColor,
        this.requirementBackground = this.requirementBackground || this.primaryColor,
        this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor,
        this.requirementBorderSize = this.requirementBorderSize || "1",
        this.requirementTextColor = this.requirementTextColor || this.primaryTextColor,
        this.relationColor = this.relationColor || this.lineColor,
        this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Ot(this.secondaryColor, 30) : this.secondaryColor),
        this.relationLabelColor = this.relationLabelColor || this.actorTextColor,
        this.git0 = St(this.secondaryColor, 20),
        this.git1 = St(this.pie2 || this.secondaryColor, 20),
        this.git2 = St(this.pie3 || this.tertiaryColor, 20),
        this.git3 = St(this.pie4 || ve(this.primaryColor, {
            h: -30
        }), 20),
        this.git4 = St(this.pie5 || ve(this.primaryColor, {
            h: -60
        }), 20),
        this.git5 = St(this.pie6 || ve(this.primaryColor, {
            h: -90
        }), 10),
        this.git6 = St(this.pie7 || ve(this.primaryColor, {
            h: 60
        }), 10),
        this.git7 = St(this.pie8 || ve(this.primaryColor, {
            h: 120
        }), 20),
        this.gitInv0 = this.gitInv0 || ht(this.git0),
        this.gitInv1 = this.gitInv1 || ht(this.git1),
        this.gitInv2 = this.gitInv2 || ht(this.git2),
        this.gitInv3 = this.gitInv3 || ht(this.git3),
        this.gitInv4 = this.gitInv4 || ht(this.git4),
        this.gitInv5 = this.gitInv5 || ht(this.git5),
        this.gitInv6 = this.gitInv6 || ht(this.git6),
        this.gitInv7 = this.gitInv7 || ht(this.git7),
        this.gitBranchLabel0 = this.gitBranchLabel0 || ht(this.labelTextColor),
        this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor,
        this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor,
        this.gitBranchLabel3 = this.gitBranchLabel3 || ht(this.labelTextColor),
        this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor,
        this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor,
        this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor,
        this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor,
        this.tagLabelColor = this.tagLabelColor || this.primaryTextColor,
        this.tagLabelBackground = this.tagLabelBackground || this.primaryColor,
        this.tagLabelBorder = this.tagBorder || this.primaryBorderColor,
        this.tagLabelFontSize = this.tagLabelFontSize || "10px",
        this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor,
        this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor,
        this.commitLabelFontSize = this.commitLabelFontSize || "10px",
        this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || St(this.background, 12),
        this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || St(this.background, 2),
        this.nodeBorder = this.nodeBorder || "#999"
    }
    calculate(t) {
        if (typeof t != "object") {
            this.updateColors();
            return
        }
        const n = Object.keys(t);
        n.forEach(r => {
            this[r] = t[r]
        }
        ),
        this.updateColors(),
        n.forEach(r => {
            this[r] = t[r]
        }
        )
    }
}
,
U(If, "Theme"),
If), Y2e = U(e => {
    const t = new G2e;
    return t.calculate(e),
    t
}
, "getThemeVariables"), $f, Z2e = ($f = class {
    constructor() {
        this.background = "#f4f4f4",
        this.primaryColor = "#ECECFF",
        this.secondaryColor = ve(this.primaryColor, {
            h: 120
        }),
        this.secondaryColor = "#ffffde",
        this.tertiaryColor = ve(this.primaryColor, {
            h: -160
        }),
        this.primaryBorderColor = Ui(this.primaryColor, this.darkMode),
        this.secondaryBorderColor = Ui(this.secondaryColor, this.darkMode),
        this.tertiaryBorderColor = Ui(this.tertiaryColor, this.darkMode),
        this.primaryTextColor = ht(this.primaryColor),
        this.secondaryTextColor = ht(this.secondaryColor),
        this.tertiaryTextColor = ht(this.tertiaryColor),
        this.lineColor = ht(this.background),
        this.textColor = ht(this.background),
        this.background = "white",
        this.mainBkg = "#ECECFF",
        this.secondBkg = "#ffffde",
        this.lineColor = "#333333",
        this.border1 = "#9370DB",
        this.border2 = "#aaaa33",
        this.arrowheadColor = "#333333",
        this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif',
        this.fontSize = "16px",
        this.labelBackground = "rgba(232,232,232, 0.8)",
        this.textColor = "#333",
        this.THEME_COLOR_LIMIT = 12,
        this.nodeBkg = "calculated",
        this.nodeBorder = "calculated",
        this.clusterBkg = "calculated",
        this.clusterBorder = "calculated",
        this.defaultLinkColor = "calculated",
        this.titleColor = "calculated",
        this.edgeLabelBackground = "calculated",
        this.actorBorder = "calculated",
        this.actorBkg = "calculated",
        this.actorTextColor = "black",
        this.actorLineColor = "calculated",
        this.signalColor = "calculated",
        this.signalTextColor = "calculated",
        this.labelBoxBkgColor = "calculated",
        this.labelBoxBorderColor = "calculated",
        this.labelTextColor = "calculated",
        this.loopTextColor = "calculated",
        this.noteBorderColor = "calculated",
        this.noteBkgColor = "#fff5ad",
        this.noteTextColor = "calculated",
        this.activationBorderColor = "#666",
        this.activationBkgColor = "#f4f4f4",
        this.sequenceNumberColor = "white",
        this.sectionBkgColor = "calculated",
        this.altSectionBkgColor = "calculated",
        this.sectionBkgColor2 = "calculated",
        this.excludeBkgColor = "#eeeeee",
        this.taskBorderColor = "calculated",
        this.taskBkgColor = "calculated",
        this.taskTextLightColor = "calculated",
        this.taskTextColor = this.taskTextLightColor,
        this.taskTextDarkColor = "calculated",
        this.taskTextOutsideColor = this.taskTextDarkColor,
        this.taskTextClickableColor = "calculated",
        this.activeTaskBorderColor = "calculated",
        this.activeTaskBkgColor = "calculated",
        this.gridColor = "calculated",
        this.doneTaskBkgColor = "calculated",
        this.doneTaskBorderColor = "calculated",
        this.critBorderColor = "calculated",
        this.critBkgColor = "calculated",
        this.todayLineColor = "calculated",
        this.vertLineColor = "calculated",
        this.sectionBkgColor = Pm(102, 102, 255, .49),
        this.altSectionBkgColor = "white",
        this.sectionBkgColor2 = "#fff400",
        this.taskBorderColor = "#534fbc",
        this.taskBkgColor = "#8a90dd",
        this.taskTextLightColor = "white",
        this.taskTextColor = "calculated",
        this.taskTextDarkColor = "black",
        this.taskTextOutsideColor = "calculated",
        this.taskTextClickableColor = "#003163",
        this.activeTaskBorderColor = "#534fbc",
        this.activeTaskBkgColor = "#bfc7ff",
        this.gridColor = "lightgrey",
        this.doneTaskBkgColor = "lightgrey",
        this.doneTaskBorderColor = "grey",
        this.critBorderColor = "#ff8888",
        this.critBkgColor = "red",
        this.todayLineColor = "red",
        this.vertLineColor = "navy",
        this.personBorder = this.primaryBorderColor,
        this.personBkg = this.mainBkg,
        this.archEdgeColor = "calculated",
        this.archEdgeArrowColor = "calculated",
        this.archEdgeWidth = "3",
        this.archGroupBorderColor = this.primaryBorderColor,
        this.archGroupBorderWidth = "2px",
        this.rowOdd = "calculated",
        this.rowEven = "calculated",
        this.labelColor = "black",
        this.errorBkgColor = "#552222",
        this.errorTextColor = "#552222",
        this.updateColors()
    }
    updateColors() {
        this.cScale0 = this.cScale0 || this.primaryColor,
        this.cScale1 = this.cScale1 || this.secondaryColor,
        this.cScale2 = this.cScale2 || this.tertiaryColor,
        this.cScale3 = this.cScale3 || ve(this.primaryColor, {
            h: 30
        }),
        this.cScale4 = this.cScale4 || ve(this.primaryColor, {
            h: 60
        }),
        this.cScale5 = this.cScale5 || ve(this.primaryColor, {
            h: 90
        }),
        this.cScale6 = this.cScale6 || ve(this.primaryColor, {
            h: 120
        }),
        this.cScale7 = this.cScale7 || ve(this.primaryColor, {
            h: 150
        }),
        this.cScale8 = this.cScale8 || ve(this.primaryColor, {
            h: 210
        }),
        this.cScale9 = this.cScale9 || ve(this.primaryColor, {
            h: 270
        }),
        this.cScale10 = this.cScale10 || ve(this.primaryColor, {
            h: 300
        }),
        this.cScale11 = this.cScale11 || ve(this.primaryColor, {
            h: 330
        }),
        this.cScalePeer1 = this.cScalePeer1 || Ot(this.secondaryColor, 45),
        this.cScalePeer2 = this.cScalePeer2 || Ot(this.tertiaryColor, 40);
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScale" + t] = Ot(this["cScale" + t], 10),
            this["cScalePeer" + t] = this["cScalePeer" + t] || Ot(this["cScale" + t], 25);
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleInv" + t] = this["cScaleInv" + t] || ve(this["cScale" + t], {
                h: 180
            });
        for (let t = 0; t < 5; t++)
            this["surface" + t] = this["surface" + t] || ve(this.mainBkg, {
                h: 30,
                l: -(5 + t * 5)
            }),
            this["surfacePeer" + t] = this["surfacePeer" + t] || ve(this.mainBkg, {
                h: 30,
                l: -(7 + t * 5)
            });
        if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor,
        this.labelTextColor !== "calculated") {
            this.cScaleLabel0 = this.cScaleLabel0 || ht(this.labelTextColor),
            this.cScaleLabel3 = this.cScaleLabel3 || ht(this.labelTextColor);
            for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
                this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.labelTextColor
        }
        this.nodeBkg = this.mainBkg,
        this.nodeBorder = this.border1,
        this.clusterBkg = this.secondBkg,
        this.clusterBorder = this.border2,
        this.defaultLinkColor = this.lineColor,
        this.titleColor = this.textColor,
        this.edgeLabelBackground = this.labelBackground,
        this.actorBorder = St(this.border1, 23),
        this.actorBkg = this.mainBkg,
        this.labelBoxBkgColor = this.actorBkg,
        this.signalColor = this.textColor,
        this.signalTextColor = this.textColor,
        this.labelBoxBorderColor = this.actorBorder,
        this.labelTextColor = this.actorTextColor,
        this.loopTextColor = this.actorTextColor,
        this.noteBorderColor = this.border2,
        this.noteTextColor = this.actorTextColor,
        this.actorLineColor = this.actorBorder,
        this.taskTextColor = this.taskTextLightColor,
        this.taskTextOutsideColor = this.taskTextDarkColor,
        this.archEdgeColor = this.lineColor,
        this.archEdgeArrowColor = this.lineColor,
        this.rowOdd = this.rowOdd || St(this.primaryColor, 75) || "#ffffff",
        this.rowEven = this.rowEven || St(this.primaryColor, 1),
        this.transitionColor = this.transitionColor || this.lineColor,
        this.transitionLabelColor = this.transitionLabelColor || this.textColor,
        this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor,
        this.stateBkg = this.stateBkg || this.mainBkg,
        this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg,
        this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor,
        this.altBackground = this.altBackground || "#f0f0f0",
        this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg,
        this.compositeBorder = this.compositeBorder || this.nodeBorder,
        this.innerEndBackground = this.nodeBorder,
        this.specialStateColor = this.lineColor,
        this.errorBkgColor = this.errorBkgColor || this.tertiaryColor,
        this.errorTextColor = this.errorTextColor || this.tertiaryTextColor,
        this.transitionColor = this.transitionColor || this.lineColor,
        this.classText = this.primaryTextColor,
        this.fillType0 = this.primaryColor,
        this.fillType1 = this.secondaryColor,
        this.fillType2 = ve(this.primaryColor, {
            h: 64
        }),
        this.fillType3 = ve(this.secondaryColor, {
            h: 64
        }),
        this.fillType4 = ve(this.primaryColor, {
            h: -64
        }),
        this.fillType5 = ve(this.secondaryColor, {
            h: -64
        }),
        this.fillType6 = ve(this.primaryColor, {
            h: 128
        }),
        this.fillType7 = ve(this.secondaryColor, {
            h: 128
        }),
        this.pie1 = this.pie1 || this.primaryColor,
        this.pie2 = this.pie2 || this.secondaryColor,
        this.pie3 = this.pie3 || ve(this.tertiaryColor, {
            l: -40
        }),
        this.pie4 = this.pie4 || ve(this.primaryColor, {
            l: -10
        }),
        this.pie5 = this.pie5 || ve(this.secondaryColor, {
            l: -30
        }),
        this.pie6 = this.pie6 || ve(this.tertiaryColor, {
            l: -20
        }),
        this.pie7 = this.pie7 || ve(this.primaryColor, {
            h: 60,
            l: -20
        }),
        this.pie8 = this.pie8 || ve(this.primaryColor, {
            h: -60,
            l: -40
        }),
        this.pie9 = this.pie9 || ve(this.primaryColor, {
            h: 120,
            l: -40
        }),
        this.pie10 = this.pie10 || ve(this.primaryColor, {
            h: 60,
            l: -40
        }),
        this.pie11 = this.pie11 || ve(this.primaryColor, {
            h: -90,
            l: -40
        }),
        this.pie12 = this.pie12 || ve(this.primaryColor, {
            h: 120,
            l: -30
        }),
        this.pieTitleTextSize = this.pieTitleTextSize || "25px",
        this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor,
        this.pieSectionTextSize = this.pieSectionTextSize || "17px",
        this.pieSectionTextColor = this.pieSectionTextColor || this.textColor,
        this.pieLegendTextSize = this.pieLegendTextSize || "17px",
        this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor,
        this.pieStrokeColor = this.pieStrokeColor || "black",
        this.pieStrokeWidth = this.pieStrokeWidth || "2px",
        this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px",
        this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black",
        this.pieOpacity = this.pieOpacity || "0.7",
        this.quadrant1Fill = this.quadrant1Fill || this.primaryColor,
        this.quadrant2Fill = this.quadrant2Fill || ve(this.primaryColor, {
            r: 5,
            g: 5,
            b: 5
        }),
        this.quadrant3Fill = this.quadrant3Fill || ve(this.primaryColor, {
            r: 10,
            g: 10,
            b: 10
        }),
        this.quadrant4Fill = this.quadrant4Fill || ve(this.primaryColor, {
            r: 15,
            g: 15,
            b: 15
        }),
        this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor,
        this.quadrant2TextFill = this.quadrant2TextFill || ve(this.primaryTextColor, {
            r: -5,
            g: -5,
            b: -5
        }),
        this.quadrant3TextFill = this.quadrant3TextFill || ve(this.primaryTextColor, {
            r: -10,
            g: -10,
            b: -10
        }),
        this.quadrant4TextFill = this.quadrant4TextFill || ve(this.primaryTextColor, {
            r: -15,
            g: -15,
            b: -15
        }),
        this.quadrantPointFill = this.quadrantPointFill || ny(this.quadrant1Fill) ? St(this.quadrant1Fill) : Ot(this.quadrant1Fill),
        this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor,
        this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor,
        this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor,
        this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor,
        this.radar = {
            axisColor: this.radar?.axisColor || this.lineColor,
            axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
            axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
            curveOpacity: this.radar?.curveOpacity || .5,
            curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
            graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
            graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
            graticuleOpacity: this.radar?.graticuleOpacity || .3,
            legendBoxSize: this.radar?.legendBoxSize || 12,
            legendFontSize: this.radar?.legendFontSize || 12
        },
        this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
        },
        this.requirementBackground = this.requirementBackground || this.primaryColor,
        this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor,
        this.requirementBorderSize = this.requirementBorderSize || "1",
        this.requirementTextColor = this.requirementTextColor || this.primaryTextColor,
        this.relationColor = this.relationColor || this.lineColor,
        this.relationLabelBackground = this.relationLabelBackground || this.labelBackground,
        this.relationLabelColor = this.relationLabelColor || this.actorTextColor,
        this.git0 = this.git0 || this.primaryColor,
        this.git1 = this.git1 || this.secondaryColor,
        this.git2 = this.git2 || this.tertiaryColor,
        this.git3 = this.git3 || ve(this.primaryColor, {
            h: -30
        }),
        this.git4 = this.git4 || ve(this.primaryColor, {
            h: -60
        }),
        this.git5 = this.git5 || ve(this.primaryColor, {
            h: -90
        }),
        this.git6 = this.git6 || ve(this.primaryColor, {
            h: 60
        }),
        this.git7 = this.git7 || ve(this.primaryColor, {
            h: 120
        }),
        this.darkMode ? (this.git0 = St(this.git0, 25),
        this.git1 = St(this.git1, 25),
        this.git2 = St(this.git2, 25),
        this.git3 = St(this.git3, 25),
        this.git4 = St(this.git4, 25),
        this.git5 = St(this.git5, 25),
        this.git6 = St(this.git6, 25),
        this.git7 = St(this.git7, 25)) : (this.git0 = Ot(this.git0, 25),
        this.git1 = Ot(this.git1, 25),
        this.git2 = Ot(this.git2, 25),
        this.git3 = Ot(this.git3, 25),
        this.git4 = Ot(this.git4, 25),
        this.git5 = Ot(this.git5, 25),
        this.git6 = Ot(this.git6, 25),
        this.git7 = Ot(this.git7, 25)),
        this.gitInv0 = this.gitInv0 || Ot(ht(this.git0), 25),
        this.gitInv1 = this.gitInv1 || ht(this.git1),
        this.gitInv2 = this.gitInv2 || ht(this.git2),
        this.gitInv3 = this.gitInv3 || ht(this.git3),
        this.gitInv4 = this.gitInv4 || ht(this.git4),
        this.gitInv5 = this.gitInv5 || ht(this.git5),
        this.gitInv6 = this.gitInv6 || ht(this.git6),
        this.gitInv7 = this.gitInv7 || ht(this.git7),
        this.gitBranchLabel0 = this.gitBranchLabel0 || ht(this.labelTextColor),
        this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor,
        this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor,
        this.gitBranchLabel3 = this.gitBranchLabel3 || ht(this.labelTextColor),
        this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor,
        this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor,
        this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor,
        this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor,
        this.tagLabelColor = this.tagLabelColor || this.primaryTextColor,
        this.tagLabelBackground = this.tagLabelBackground || this.primaryColor,
        this.tagLabelBorder = this.tagBorder || this.primaryBorderColor,
        this.tagLabelFontSize = this.tagLabelFontSize || "10px",
        this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor,
        this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor,
        this.commitLabelFontSize = this.commitLabelFontSize || "10px",
        this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || z1,
        this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || F1
    }
    calculate(t) {
        if (Object.keys(this).forEach(r => {
            this[r] === "calculated" && (this[r] = void 0)
        }
        ),
        typeof t != "object") {
            this.updateColors();
            return
        }
        const n = Object.keys(t);
        n.forEach(r => {
            this[r] = t[r]
        }
        ),
        this.updateColors(),
        n.forEach(r => {
            this[r] = t[r]
        }
        )
    }
}
,
U($f, "Theme"),
$f), Q2e = U(e => {
    const t = new Z2e;
    return t.calculate(e),
    t
}
, "getThemeVariables"), Lf, K2e = (Lf = class {
    constructor() {
        this.background = "#f4f4f4",
        this.primaryColor = "#cde498",
        this.secondaryColor = "#cdffb2",
        this.background = "white",
        this.mainBkg = "#cde498",
        this.secondBkg = "#cdffb2",
        this.lineColor = "green",
        this.border1 = "#13540c",
        this.border2 = "#6eaa49",
        this.arrowheadColor = "green",
        this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif',
        this.fontSize = "16px",
        this.tertiaryColor = St("#cde498", 10),
        this.primaryBorderColor = Ui(this.primaryColor, this.darkMode),
        this.secondaryBorderColor = Ui(this.secondaryColor, this.darkMode),
        this.tertiaryBorderColor = Ui(this.tertiaryColor, this.darkMode),
        this.primaryTextColor = ht(this.primaryColor),
        this.secondaryTextColor = ht(this.secondaryColor),
        this.tertiaryTextColor = ht(this.primaryColor),
        this.lineColor = ht(this.background),
        this.textColor = ht(this.background),
        this.THEME_COLOR_LIMIT = 12,
        this.nodeBkg = "calculated",
        this.nodeBorder = "calculated",
        this.clusterBkg = "calculated",
        this.clusterBorder = "calculated",
        this.defaultLinkColor = "calculated",
        this.titleColor = "#333",
        this.edgeLabelBackground = "#e8e8e8",
        this.actorBorder = "calculated",
        this.actorBkg = "calculated",
        this.actorTextColor = "black",
        this.actorLineColor = "calculated",
        this.signalColor = "#333",
        this.signalTextColor = "#333",
        this.labelBoxBkgColor = "calculated",
        this.labelBoxBorderColor = "#326932",
        this.labelTextColor = "calculated",
        this.loopTextColor = "calculated",
        this.noteBorderColor = "calculated",
        this.noteBkgColor = "#fff5ad",
        this.noteTextColor = "calculated",
        this.activationBorderColor = "#666",
        this.activationBkgColor = "#f4f4f4",
        this.sequenceNumberColor = "white",
        this.sectionBkgColor = "#6eaa49",
        this.altSectionBkgColor = "white",
        this.sectionBkgColor2 = "#6eaa49",
        this.excludeBkgColor = "#eeeeee",
        this.taskBorderColor = "calculated",
        this.taskBkgColor = "#487e3a",
        this.taskTextLightColor = "white",
        this.taskTextColor = "calculated",
        this.taskTextDarkColor = "black",
        this.taskTextOutsideColor = "calculated",
        this.taskTextClickableColor = "#003163",
        this.activeTaskBorderColor = "calculated",
        this.activeTaskBkgColor = "calculated",
        this.gridColor = "lightgrey",
        this.doneTaskBkgColor = "lightgrey",
        this.doneTaskBorderColor = "grey",
        this.critBorderColor = "#ff8888",
        this.critBkgColor = "red",
        this.todayLineColor = "red",
        this.vertLineColor = "#00BFFF",
        this.personBorder = this.primaryBorderColor,
        this.personBkg = this.mainBkg,
        this.archEdgeColor = "calculated",
        this.archEdgeArrowColor = "calculated",
        this.archEdgeWidth = "3",
        this.archGroupBorderColor = this.primaryBorderColor,
        this.archGroupBorderWidth = "2px",
        this.labelColor = "black",
        this.errorBkgColor = "#552222",
        this.errorTextColor = "#552222"
    }
    updateColors() {
        this.actorBorder = Ot(this.mainBkg, 20),
        this.actorBkg = this.mainBkg,
        this.labelBoxBkgColor = this.actorBkg,
        this.labelTextColor = this.actorTextColor,
        this.loopTextColor = this.actorTextColor,
        this.noteBorderColor = this.border2,
        this.noteTextColor = this.actorTextColor,
        this.actorLineColor = this.actorBorder,
        this.cScale0 = this.cScale0 || this.primaryColor,
        this.cScale1 = this.cScale1 || this.secondaryColor,
        this.cScale2 = this.cScale2 || this.tertiaryColor,
        this.cScale3 = this.cScale3 || ve(this.primaryColor, {
            h: 30
        }),
        this.cScale4 = this.cScale4 || ve(this.primaryColor, {
            h: 60
        }),
        this.cScale5 = this.cScale5 || ve(this.primaryColor, {
            h: 90
        }),
        this.cScale6 = this.cScale6 || ve(this.primaryColor, {
            h: 120
        }),
        this.cScale7 = this.cScale7 || ve(this.primaryColor, {
            h: 150
        }),
        this.cScale8 = this.cScale8 || ve(this.primaryColor, {
            h: 210
        }),
        this.cScale9 = this.cScale9 || ve(this.primaryColor, {
            h: 270
        }),
        this.cScale10 = this.cScale10 || ve(this.primaryColor, {
            h: 300
        }),
        this.cScale11 = this.cScale11 || ve(this.primaryColor, {
            h: 330
        }),
        this.cScalePeer1 = this.cScalePeer1 || Ot(this.secondaryColor, 45),
        this.cScalePeer2 = this.cScalePeer2 || Ot(this.tertiaryColor, 40);
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScale" + t] = Ot(this["cScale" + t], 10),
            this["cScalePeer" + t] = this["cScalePeer" + t] || Ot(this["cScale" + t], 25);
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleInv" + t] = this["cScaleInv" + t] || ve(this["cScale" + t], {
                h: 180
            });
        this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
        for (let t = 0; t < 5; t++)
            this["surface" + t] = this["surface" + t] || ve(this.mainBkg, {
                h: 30,
                s: -30,
                l: -(5 + t * 5)
            }),
            this["surfacePeer" + t] = this["surfacePeer" + t] || ve(this.mainBkg, {
                h: 30,
                s: -30,
                l: -(8 + t * 5)
            });
        this.nodeBkg = this.mainBkg,
        this.nodeBorder = this.border1,
        this.clusterBkg = this.secondBkg,
        this.clusterBorder = this.border2,
        this.defaultLinkColor = this.lineColor,
        this.taskBorderColor = this.border1,
        this.taskTextColor = this.taskTextLightColor,
        this.taskTextOutsideColor = this.taskTextDarkColor,
        this.activeTaskBorderColor = this.taskBorderColor,
        this.activeTaskBkgColor = this.mainBkg,
        this.archEdgeColor = this.lineColor,
        this.archEdgeArrowColor = this.lineColor,
        this.rowOdd = this.rowOdd || St(this.mainBkg, 75) || "#ffffff",
        this.rowEven = this.rowEven || St(this.mainBkg, 20),
        this.transitionColor = this.transitionColor || this.lineColor,
        this.transitionLabelColor = this.transitionLabelColor || this.textColor,
        this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor,
        this.stateBkg = this.stateBkg || this.mainBkg,
        this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg,
        this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor,
        this.altBackground = this.altBackground || "#f0f0f0",
        this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg,
        this.compositeBorder = this.compositeBorder || this.nodeBorder,
        this.innerEndBackground = this.primaryBorderColor,
        this.specialStateColor = this.lineColor,
        this.errorBkgColor = this.errorBkgColor || this.tertiaryColor,
        this.errorTextColor = this.errorTextColor || this.tertiaryTextColor,
        this.transitionColor = this.transitionColor || this.lineColor,
        this.classText = this.primaryTextColor,
        this.fillType0 = this.primaryColor,
        this.fillType1 = this.secondaryColor,
        this.fillType2 = ve(this.primaryColor, {
            h: 64
        }),
        this.fillType3 = ve(this.secondaryColor, {
            h: 64
        }),
        this.fillType4 = ve(this.primaryColor, {
            h: -64
        }),
        this.fillType5 = ve(this.secondaryColor, {
            h: -64
        }),
        this.fillType6 = ve(this.primaryColor, {
            h: 128
        }),
        this.fillType7 = ve(this.secondaryColor, {
            h: 128
        }),
        this.pie1 = this.pie1 || this.primaryColor,
        this.pie2 = this.pie2 || this.secondaryColor,
        this.pie3 = this.pie3 || this.tertiaryColor,
        this.pie4 = this.pie4 || ve(this.primaryColor, {
            l: -30
        }),
        this.pie5 = this.pie5 || ve(this.secondaryColor, {
            l: -30
        }),
        this.pie6 = this.pie6 || ve(this.tertiaryColor, {
            h: 40,
            l: -40
        }),
        this.pie7 = this.pie7 || ve(this.primaryColor, {
            h: 60,
            l: -10
        }),
        this.pie8 = this.pie8 || ve(this.primaryColor, {
            h: -60,
            l: -10
        }),
        this.pie9 = this.pie9 || ve(this.primaryColor, {
            h: 120,
            l: 0
        }),
        this.pie10 = this.pie10 || ve(this.primaryColor, {
            h: 60,
            l: -50
        }),
        this.pie11 = this.pie11 || ve(this.primaryColor, {
            h: -60,
            l: -50
        }),
        this.pie12 = this.pie12 || ve(this.primaryColor, {
            h: 120,
            l: -50
        }),
        this.pieTitleTextSize = this.pieTitleTextSize || "25px",
        this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor,
        this.pieSectionTextSize = this.pieSectionTextSize || "17px",
        this.pieSectionTextColor = this.pieSectionTextColor || this.textColor,
        this.pieLegendTextSize = this.pieLegendTextSize || "17px",
        this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor,
        this.pieStrokeColor = this.pieStrokeColor || "black",
        this.pieStrokeWidth = this.pieStrokeWidth || "2px",
        this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px",
        this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black",
        this.pieOpacity = this.pieOpacity || "0.7",
        this.quadrant1Fill = this.quadrant1Fill || this.primaryColor,
        this.quadrant2Fill = this.quadrant2Fill || ve(this.primaryColor, {
            r: 5,
            g: 5,
            b: 5
        }),
        this.quadrant3Fill = this.quadrant3Fill || ve(this.primaryColor, {
            r: 10,
            g: 10,
            b: 10
        }),
        this.quadrant4Fill = this.quadrant4Fill || ve(this.primaryColor, {
            r: 15,
            g: 15,
            b: 15
        }),
        this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor,
        this.quadrant2TextFill = this.quadrant2TextFill || ve(this.primaryTextColor, {
            r: -5,
            g: -5,
            b: -5
        }),
        this.quadrant3TextFill = this.quadrant3TextFill || ve(this.primaryTextColor, {
            r: -10,
            g: -10,
            b: -10
        }),
        this.quadrant4TextFill = this.quadrant4TextFill || ve(this.primaryTextColor, {
            r: -15,
            g: -15,
            b: -15
        }),
        this.quadrantPointFill = this.quadrantPointFill || ny(this.quadrant1Fill) ? St(this.quadrant1Fill) : Ot(this.quadrant1Fill),
        this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor,
        this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor,
        this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor,
        this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor,
        this.packet = {
            startByteColor: this.primaryTextColor,
            endByteColor: this.primaryTextColor,
            labelColor: this.primaryTextColor,
            titleColor: this.primaryTextColor,
            blockStrokeColor: this.primaryTextColor,
            blockFillColor: this.mainBkg
        },
        this.radar = {
            axisColor: this.radar?.axisColor || this.lineColor,
            axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
            axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
            curveOpacity: this.radar?.curveOpacity || .5,
            curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
            graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
            graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
            graticuleOpacity: this.radar?.graticuleOpacity || .3,
            legendBoxSize: this.radar?.legendBoxSize || 12,
            legendFontSize: this.radar?.legendFontSize || 12
        },
        this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
        },
        this.requirementBackground = this.requirementBackground || this.primaryColor,
        this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor,
        this.requirementBorderSize = this.requirementBorderSize || "1",
        this.requirementTextColor = this.requirementTextColor || this.primaryTextColor,
        this.relationColor = this.relationColor || this.lineColor,
        this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground,
        this.relationLabelColor = this.relationLabelColor || this.actorTextColor,
        this.git0 = this.git0 || this.primaryColor,
        this.git1 = this.git1 || this.secondaryColor,
        this.git2 = this.git2 || this.tertiaryColor,
        this.git3 = this.git3 || ve(this.primaryColor, {
            h: -30
        }),
        this.git4 = this.git4 || ve(this.primaryColor, {
            h: -60
        }),
        this.git5 = this.git5 || ve(this.primaryColor, {
            h: -90
        }),
        this.git6 = this.git6 || ve(this.primaryColor, {
            h: 60
        }),
        this.git7 = this.git7 || ve(this.primaryColor, {
            h: 120
        }),
        this.darkMode ? (this.git0 = St(this.git0, 25),
        this.git1 = St(this.git1, 25),
        this.git2 = St(this.git2, 25),
        this.git3 = St(this.git3, 25),
        this.git4 = St(this.git4, 25),
        this.git5 = St(this.git5, 25),
        this.git6 = St(this.git6, 25),
        this.git7 = St(this.git7, 25)) : (this.git0 = Ot(this.git0, 25),
        this.git1 = Ot(this.git1, 25),
        this.git2 = Ot(this.git2, 25),
        this.git3 = Ot(this.git3, 25),
        this.git4 = Ot(this.git4, 25),
        this.git5 = Ot(this.git5, 25),
        this.git6 = Ot(this.git6, 25),
        this.git7 = Ot(this.git7, 25)),
        this.gitInv0 = this.gitInv0 || ht(this.git0),
        this.gitInv1 = this.gitInv1 || ht(this.git1),
        this.gitInv2 = this.gitInv2 || ht(this.git2),
        this.gitInv3 = this.gitInv3 || ht(this.git3),
        this.gitInv4 = this.gitInv4 || ht(this.git4),
        this.gitInv5 = this.gitInv5 || ht(this.git5),
        this.gitInv6 = this.gitInv6 || ht(this.git6),
        this.gitInv7 = this.gitInv7 || ht(this.git7),
        this.gitBranchLabel0 = this.gitBranchLabel0 || ht(this.labelTextColor),
        this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor,
        this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor,
        this.gitBranchLabel3 = this.gitBranchLabel3 || ht(this.labelTextColor),
        this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor,
        this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor,
        this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor,
        this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor,
        this.tagLabelColor = this.tagLabelColor || this.primaryTextColor,
        this.tagLabelBackground = this.tagLabelBackground || this.primaryColor,
        this.tagLabelBorder = this.tagBorder || this.primaryBorderColor,
        this.tagLabelFontSize = this.tagLabelFontSize || "10px",
        this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor,
        this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor,
        this.commitLabelFontSize = this.commitLabelFontSize || "10px",
        this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || z1,
        this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || F1
    }
    calculate(t) {
        if (typeof t != "object") {
            this.updateColors();
            return
        }
        const n = Object.keys(t);
        n.forEach(r => {
            this[r] = t[r]
        }
        ),
        this.updateColors(),
        n.forEach(r => {
            this[r] = t[r]
        }
        )
    }
}
,
U(Lf, "Theme"),
Lf), X2e = U(e => {
    const t = new K2e;
    return t.calculate(e),
    t
}
, "getThemeVariables"), jf, J2e = (jf = class {
    constructor() {
        this.primaryColor = "#eee",
        this.contrast = "#707070",
        this.secondaryColor = St(this.contrast, 55),
        this.background = "#ffffff",
        this.tertiaryColor = ve(this.primaryColor, {
            h: -160
        }),
        this.primaryBorderColor = Ui(this.primaryColor, this.darkMode),
        this.secondaryBorderColor = Ui(this.secondaryColor, this.darkMode),
        this.tertiaryBorderColor = Ui(this.tertiaryColor, this.darkMode),
        this.primaryTextColor = ht(this.primaryColor),
        this.secondaryTextColor = ht(this.secondaryColor),
        this.tertiaryTextColor = ht(this.tertiaryColor),
        this.lineColor = ht(this.background),
        this.textColor = ht(this.background),
        this.mainBkg = "#eee",
        this.secondBkg = "calculated",
        this.lineColor = "#666",
        this.border1 = "#999",
        this.border2 = "calculated",
        this.note = "#ffa",
        this.text = "#333",
        this.critical = "#d42",
        this.done = "#bbb",
        this.arrowheadColor = "#333333",
        this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif',
        this.fontSize = "16px",
        this.THEME_COLOR_LIMIT = 12,
        this.nodeBkg = "calculated",
        this.nodeBorder = "calculated",
        this.clusterBkg = "calculated",
        this.clusterBorder = "calculated",
        this.defaultLinkColor = "calculated",
        this.titleColor = "calculated",
        this.edgeLabelBackground = "white",
        this.actorBorder = "calculated",
        this.actorBkg = "calculated",
        this.actorTextColor = "calculated",
        this.actorLineColor = this.actorBorder,
        this.signalColor = "calculated",
        this.signalTextColor = "calculated",
        this.labelBoxBkgColor = "calculated",
        this.labelBoxBorderColor = "calculated",
        this.labelTextColor = "calculated",
        this.loopTextColor = "calculated",
        this.noteBorderColor = "calculated",
        this.noteBkgColor = "calculated",
        this.noteTextColor = "calculated",
        this.activationBorderColor = "#666",
        this.activationBkgColor = "#f4f4f4",
        this.sequenceNumberColor = "white",
        this.sectionBkgColor = "calculated",
        this.altSectionBkgColor = "white",
        this.sectionBkgColor2 = "calculated",
        this.excludeBkgColor = "#eeeeee",
        this.taskBorderColor = "calculated",
        this.taskBkgColor = "calculated",
        this.taskTextLightColor = "white",
        this.taskTextColor = "calculated",
        this.taskTextDarkColor = "calculated",
        this.taskTextOutsideColor = "calculated",
        this.taskTextClickableColor = "#003163",
        this.activeTaskBorderColor = "calculated",
        this.activeTaskBkgColor = "calculated",
        this.gridColor = "calculated",
        this.doneTaskBkgColor = "calculated",
        this.doneTaskBorderColor = "calculated",
        this.critBkgColor = "calculated",
        this.critBorderColor = "calculated",
        this.todayLineColor = "calculated",
        this.vertLineColor = "calculated",
        this.personBorder = this.primaryBorderColor,
        this.personBkg = this.mainBkg,
        this.archEdgeColor = "calculated",
        this.archEdgeArrowColor = "calculated",
        this.archEdgeWidth = "3",
        this.archGroupBorderColor = this.primaryBorderColor,
        this.archGroupBorderWidth = "2px",
        this.rowOdd = this.rowOdd || St(this.mainBkg, 75) || "#ffffff",
        this.rowEven = this.rowEven || "#f4f4f4",
        this.labelColor = "black",
        this.errorBkgColor = "#552222",
        this.errorTextColor = "#552222"
    }
    updateColors() {
        this.secondBkg = St(this.contrast, 55),
        this.border2 = this.contrast,
        this.actorBorder = St(this.border1, 23),
        this.actorBkg = this.mainBkg,
        this.actorTextColor = this.text,
        this.actorLineColor = this.actorBorder,
        this.signalColor = this.text,
        this.signalTextColor = this.text,
        this.labelBoxBkgColor = this.actorBkg,
        this.labelBoxBorderColor = this.actorBorder,
        this.labelTextColor = this.text,
        this.loopTextColor = this.text,
        this.noteBorderColor = "#999",
        this.noteBkgColor = "#666",
        this.noteTextColor = "#fff",
        this.cScale0 = this.cScale0 || "#555",
        this.cScale1 = this.cScale1 || "#F4F4F4",
        this.cScale2 = this.cScale2 || "#555",
        this.cScale3 = this.cScale3 || "#BBB",
        this.cScale4 = this.cScale4 || "#777",
        this.cScale5 = this.cScale5 || "#999",
        this.cScale6 = this.cScale6 || "#DDD",
        this.cScale7 = this.cScale7 || "#FFF",
        this.cScale8 = this.cScale8 || "#DDD",
        this.cScale9 = this.cScale9 || "#BBB",
        this.cScale10 = this.cScale10 || "#999",
        this.cScale11 = this.cScale11 || "#777";
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleInv" + t] = this["cScaleInv" + t] || ht(this["cScale" + t]);
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this.darkMode ? this["cScalePeer" + t] = this["cScalePeer" + t] || St(this["cScale" + t], 10) : this["cScalePeer" + t] = this["cScalePeer" + t] || Ot(this["cScale" + t], 10);
        this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor),
        this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1,
        this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
        for (let t = 0; t < 5; t++)
            this["surface" + t] = this["surface" + t] || ve(this.mainBkg, {
                l: -(5 + t * 5)
            }),
            this["surfacePeer" + t] = this["surfacePeer" + t] || ve(this.mainBkg, {
                l: -(8 + t * 5)
            });
        this.nodeBkg = this.mainBkg,
        this.nodeBorder = this.border1,
        this.clusterBkg = this.secondBkg,
        this.clusterBorder = this.border2,
        this.defaultLinkColor = this.lineColor,
        this.titleColor = this.text,
        this.sectionBkgColor = St(this.contrast, 30),
        this.sectionBkgColor2 = St(this.contrast, 30),
        this.taskBorderColor = Ot(this.contrast, 10),
        this.taskBkgColor = this.contrast,
        this.taskTextColor = this.taskTextLightColor,
        this.taskTextDarkColor = this.text,
        this.taskTextOutsideColor = this.taskTextDarkColor,
        this.activeTaskBorderColor = this.taskBorderColor,
        this.activeTaskBkgColor = this.mainBkg,
        this.gridColor = St(this.border1, 30),
        this.doneTaskBkgColor = this.done,
        this.doneTaskBorderColor = this.lineColor,
        this.critBkgColor = this.critical,
        this.critBorderColor = Ot(this.critBkgColor, 10),
        this.todayLineColor = this.critBkgColor,
        this.vertLineColor = this.critBkgColor,
        this.archEdgeColor = this.lineColor,
        this.archEdgeArrowColor = this.lineColor,
        this.transitionColor = this.transitionColor || "#000",
        this.transitionLabelColor = this.transitionLabelColor || this.textColor,
        this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor,
        this.stateBkg = this.stateBkg || this.mainBkg,
        this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg,
        this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor,
        this.altBackground = this.altBackground || "#f4f4f4",
        this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg,
        this.stateBorder = this.stateBorder || "#000",
        this.innerEndBackground = this.primaryBorderColor,
        this.specialStateColor = "#222",
        this.errorBkgColor = this.errorBkgColor || this.tertiaryColor,
        this.errorTextColor = this.errorTextColor || this.tertiaryTextColor,
        this.classText = this.primaryTextColor,
        this.fillType0 = this.primaryColor,
        this.fillType1 = this.secondaryColor,
        this.fillType2 = ve(this.primaryColor, {
            h: 64
        }),
        this.fillType3 = ve(this.secondaryColor, {
            h: 64
        }),
        this.fillType4 = ve(this.primaryColor, {
            h: -64
        }),
        this.fillType5 = ve(this.secondaryColor, {
            h: -64
        }),
        this.fillType6 = ve(this.primaryColor, {
            h: 128
        }),
        this.fillType7 = ve(this.secondaryColor, {
            h: 128
        });
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["pie" + t] = this["cScale" + t];
        this.pie12 = this.pie0,
        this.pieTitleTextSize = this.pieTitleTextSize || "25px",
        this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor,
        this.pieSectionTextSize = this.pieSectionTextSize || "17px",
        this.pieSectionTextColor = this.pieSectionTextColor || this.textColor,
        this.pieLegendTextSize = this.pieLegendTextSize || "17px",
        this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor,
        this.pieStrokeColor = this.pieStrokeColor || "black",
        this.pieStrokeWidth = this.pieStrokeWidth || "2px",
        this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px",
        this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black",
        this.pieOpacity = this.pieOpacity || "0.7",
        this.quadrant1Fill = this.quadrant1Fill || this.primaryColor,
        this.quadrant2Fill = this.quadrant2Fill || ve(this.primaryColor, {
            r: 5,
            g: 5,
            b: 5
        }),
        this.quadrant3Fill = this.quadrant3Fill || ve(this.primaryColor, {
            r: 10,
            g: 10,
            b: 10
        }),
        this.quadrant4Fill = this.quadrant4Fill || ve(this.primaryColor, {
            r: 15,
            g: 15,
            b: 15
        }),
        this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor,
        this.quadrant2TextFill = this.quadrant2TextFill || ve(this.primaryTextColor, {
            r: -5,
            g: -5,
            b: -5
        }),
        this.quadrant3TextFill = this.quadrant3TextFill || ve(this.primaryTextColor, {
            r: -10,
            g: -10,
            b: -10
        }),
        this.quadrant4TextFill = this.quadrant4TextFill || ve(this.primaryTextColor, {
            r: -15,
            g: -15,
            b: -15
        }),
        this.quadrantPointFill = this.quadrantPointFill || ny(this.quadrant1Fill) ? St(this.quadrant1Fill) : Ot(this.quadrant1Fill),
        this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor,
        this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor,
        this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor,
        this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor,
        this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor,
        this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
        },
        this.radar = {
            axisColor: this.radar?.axisColor || this.lineColor,
            axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
            axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
            curveOpacity: this.radar?.curveOpacity || .5,
            curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
            graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
            graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
            graticuleOpacity: this.radar?.graticuleOpacity || .3,
            legendBoxSize: this.radar?.legendBoxSize || 12,
            legendFontSize: this.radar?.legendFontSize || 12
        },
        this.requirementBackground = this.requirementBackground || this.primaryColor,
        this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor,
        this.requirementBorderSize = this.requirementBorderSize || "1",
        this.requirementTextColor = this.requirementTextColor || this.primaryTextColor,
        this.relationColor = this.relationColor || this.lineColor,
        this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground,
        this.relationLabelColor = this.relationLabelColor || this.actorTextColor,
        this.git0 = Ot(this.pie1, 25) || this.primaryColor,
        this.git1 = this.pie2 || this.secondaryColor,
        this.git2 = this.pie3 || this.tertiaryColor,
        this.git3 = this.pie4 || ve(this.primaryColor, {
            h: -30
        }),
        this.git4 = this.pie5 || ve(this.primaryColor, {
            h: -60
        }),
        this.git5 = this.pie6 || ve(this.primaryColor, {
            h: -90
        }),
        this.git6 = this.pie7 || ve(this.primaryColor, {
            h: 60
        }),
        this.git7 = this.pie8 || ve(this.primaryColor, {
            h: 120
        }),
        this.gitInv0 = this.gitInv0 || ht(this.git0),
        this.gitInv1 = this.gitInv1 || ht(this.git1),
        this.gitInv2 = this.gitInv2 || ht(this.git2),
        this.gitInv3 = this.gitInv3 || ht(this.git3),
        this.gitInv4 = this.gitInv4 || ht(this.git4),
        this.gitInv5 = this.gitInv5 || ht(this.git5),
        this.gitInv6 = this.gitInv6 || ht(this.git6),
        this.gitInv7 = this.gitInv7 || ht(this.git7),
        this.branchLabelColor = this.branchLabelColor || this.labelTextColor,
        this.gitBranchLabel0 = this.branchLabelColor,
        this.gitBranchLabel1 = "white",
        this.gitBranchLabel2 = this.branchLabelColor,
        this.gitBranchLabel3 = "white",
        this.gitBranchLabel4 = this.branchLabelColor,
        this.gitBranchLabel5 = this.branchLabelColor,
        this.gitBranchLabel6 = this.branchLabelColor,
        this.gitBranchLabel7 = this.branchLabelColor,
        this.tagLabelColor = this.tagLabelColor || this.primaryTextColor,
        this.tagLabelBackground = this.tagLabelBackground || this.primaryColor,
        this.tagLabelBorder = this.tagBorder || this.primaryBorderColor,
        this.tagLabelFontSize = this.tagLabelFontSize || "10px",
        this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor,
        this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor,
        this.commitLabelFontSize = this.commitLabelFontSize || "10px",
        this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || z1,
        this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || F1
    }
    calculate(t) {
        if (typeof t != "object") {
            this.updateColors();
            return
        }
        const n = Object.keys(t);
        n.forEach(r => {
            this[r] = t[r]
        }
        ),
        this.updateColors(),
        n.forEach(r => {
            this[r] = t[r]
        }
        )
    }
}
,
U(jf, "Theme"),
jf), eTe = U(e => {
    const t = new J2e;
    return t.calculate(e),
    t
}
, "getThemeVariables"), xl = {
    base: {
        getThemeVariables: W2e
    },
    dark: {
        getThemeVariables: Y2e
    },
    default: {
        getThemeVariables: Q2e
    },
    forest: {
        getThemeVariables: X2e
    },
    neutral: {
        getThemeVariables: eTe
    }
}, fs = {
    flowchart: {
        useMaxWidth: !0,
        titleTopMargin: 25,
        subGraphTitleMargin: {
            top: 0,
            bottom: 0
        },
        diagramPadding: 8,
        htmlLabels: !0,
        nodeSpacing: 50,
        rankSpacing: 50,
        curve: "basis",
        padding: 15,
        defaultRenderer: "dagre-wrapper",
        wrappingWidth: 200,
        inheritDir: !1
    },
    sequence: {
        useMaxWidth: !0,
        hideUnusedParticipants: !1,
        activationWidth: 10,
        diagramMarginX: 50,
        diagramMarginY: 10,
        actorMargin: 50,
        width: 150,
        height: 65,
        boxMargin: 10,
        boxTextMargin: 5,
        noteMargin: 10,
        messageMargin: 35,
        messageAlign: "center",
        mirrorActors: !0,
        forceMenus: !1,
        bottomMarginAdj: 1,
        rightAngles: !1,
        showSequenceNumbers: !1,
        actorFontSize: 14,
        actorFontFamily: '"Open Sans", sans-serif',
        actorFontWeight: 400,
        noteFontSize: 14,
        noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
        noteFontWeight: 400,
        noteAlign: "center",
        messageFontSize: 16,
        messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
        messageFontWeight: 400,
        wrap: !1,
        wrapPadding: 10,
        labelBoxWidth: 50,
        labelBoxHeight: 20
    },
    gantt: {
        useMaxWidth: !0,
        titleTopMargin: 25,
        barHeight: 20,
        barGap: 4,
        topPadding: 50,
        rightPadding: 75,
        leftPadding: 75,
        gridLineStartPadding: 35,
        fontSize: 11,
        sectionFontSize: 11,
        numberSectionStyles: 4,
        axisFormat: "%Y-%m-%d",
        topAxis: !1,
        displayMode: "",
        weekday: "sunday"
    },
    journey: {
        useMaxWidth: !0,
        diagramMarginX: 50,
        diagramMarginY: 10,
        leftMargin: 150,
        maxLabelWidth: 360,
        width: 150,
        height: 50,
        boxMargin: 10,
        boxTextMargin: 5,
        noteMargin: 10,
        messageMargin: 35,
        messageAlign: "center",
        bottomMarginAdj: 1,
        rightAngles: !1,
        taskFontSize: 14,
        taskFontFamily: '"Open Sans", sans-serif',
        taskMargin: 50,
        activationWidth: 10,
        textPlacement: "fo",
        actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
        sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
        sectionColours: ["#fff"],
        titleColor: "",
        titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
        titleFontSize: "4ex"
    },
    class: {
        useMaxWidth: !0,
        titleTopMargin: 25,
        arrowMarkerAbsolute: !1,
        dividerMargin: 10,
        padding: 5,
        textHeight: 10,
        defaultRenderer: "dagre-wrapper",
        htmlLabels: !1,
        hideEmptyMembersBox: !1
    },
    state: {
        useMaxWidth: !0,
        titleTopMargin: 25,
        dividerMargin: 10,
        sizeUnit: 5,
        padding: 8,
        textHeight: 10,
        titleShift: -15,
        noteMargin: 10,
        forkWidth: 70,
        forkHeight: 7,
        miniPadding: 2,
        fontSizeFactor: 5.02,
        fontSize: 24,
        labelHeight: 16,
        edgeLengthFactor: "20",
        compositTitleSize: 35,
        radius: 5,
        defaultRenderer: "dagre-wrapper"
    },
    er: {
        useMaxWidth: !0,
        titleTopMargin: 25,
        diagramPadding: 20,
        layoutDirection: "TB",
        minEntityWidth: 100,
        minEntityHeight: 75,
        entityPadding: 15,
        nodeSpacing: 140,
        rankSpacing: 80,
        stroke: "gray",
        fill: "honeydew",
        fontSize: 12
    },
    pie: {
        useMaxWidth: !0,
        textPosition: .75
    },
    quadrantChart: {
        useMaxWidth: !0,
        chartWidth: 500,
        chartHeight: 500,
        titleFontSize: 20,
        titlePadding: 10,
        quadrantPadding: 5,
        xAxisLabelPadding: 5,
        yAxisLabelPadding: 5,
        xAxisLabelFontSize: 16,
        yAxisLabelFontSize: 16,
        quadrantLabelFontSize: 16,
        quadrantTextTopPadding: 5,
        pointTextPadding: 5,
        pointLabelFontSize: 12,
        pointRadius: 5,
        xAxisPosition: "top",
        yAxisPosition: "left",
        quadrantInternalBorderStrokeWidth: 1,
        quadrantExternalBorderStrokeWidth: 2
    },
    xyChart: {
        useMaxWidth: !0,
        width: 700,
        height: 500,
        titleFontSize: 20,
        titlePadding: 10,
        showDataLabel: !1,
        showTitle: !0,
        xAxis: {
            $ref: "#/$defs/XYChartAxisConfig",
            showLabel: !0,
            labelFontSize: 14,
            labelPadding: 5,
            showTitle: !0,
            titleFontSize: 16,
            titlePadding: 5,
            showTick: !0,
            tickLength: 5,
            tickWidth: 2,
            showAxisLine: !0,
            axisLineWidth: 2
        },
        yAxis: {
            $ref: "#/$defs/XYChartAxisConfig",
            showLabel: !0,
            labelFontSize: 14,
            labelPadding: 5,
            showTitle: !0,
            titleFontSize: 16,
            titlePadding: 5,
            showTick: !0,
            tickLength: 5,
            tickWidth: 2,
            showAxisLine: !0,
            axisLineWidth: 2
        },
        chartOrientation: "vertical",
        plotReservedSpacePercent: 50
    },
    requirement: {
        useMaxWidth: !0,
        rect_fill: "#f9f9f9",
        text_color: "#333",
        rect_border_size: "0.5px",
        rect_border_color: "#bbb",
        rect_min_width: 200,
        rect_min_height: 200,
        fontSize: 14,
        rect_padding: 10,
        line_height: 20
    },
    mindmap: {
        useMaxWidth: !0,
        padding: 10,
        maxNodeWidth: 200,
        layoutAlgorithm: "cose-bilkent"
    },
    kanban: {
        useMaxWidth: !0,
        padding: 8,
        sectionWidth: 200,
        ticketBaseUrl: ""
    },
    timeline: {
        useMaxWidth: !0,
        diagramMarginX: 50,
        diagramMarginY: 10,
        leftMargin: 150,
        width: 150,
        height: 50,
        boxMargin: 10,
        boxTextMargin: 5,
        noteMargin: 10,
        messageMargin: 35,
        messageAlign: "center",
        bottomMarginAdj: 1,
        rightAngles: !1,
        taskFontSize: 14,
        taskFontFamily: '"Open Sans", sans-serif',
        taskMargin: 50,
        activationWidth: 10,
        textPlacement: "fo",
        actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
        sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
        sectionColours: ["#fff"],
        disableMulticolor: !1
    },
    gitGraph: {
        useMaxWidth: !0,
        titleTopMargin: 25,
        diagramPadding: 8,
        nodeLabel: {
            width: 75,
            height: 100,
            x: -25,
            y: 0
        },
        mainBranchName: "main",
        mainBranchOrder: 0,
        showCommitLabel: !0,
        showBranches: !0,
        rotateCommitLabel: !0,
        parallelCommits: !1,
        arrowMarkerAbsolute: !1
    },
    c4: {
        useMaxWidth: !0,
        diagramMarginX: 50,
        diagramMarginY: 10,
        c4ShapeMargin: 50,
        c4ShapePadding: 20,
        width: 216,
        height: 60,
        boxMargin: 10,
        c4ShapeInRow: 4,
        nextLinePaddingX: 0,
        c4BoundaryInRow: 2,
        personFontSize: 14,
        personFontFamily: '"Open Sans", sans-serif',
        personFontWeight: "normal",
        external_personFontSize: 14,
        external_personFontFamily: '"Open Sans", sans-serif',
        external_personFontWeight: "normal",
        systemFontSize: 14,
        systemFontFamily: '"Open Sans", sans-serif',
        systemFontWeight: "normal",
        external_systemFontSize: 14,
        external_systemFontFamily: '"Open Sans", sans-serif',
        external_systemFontWeight: "normal",
        system_dbFontSize: 14,
        system_dbFontFamily: '"Open Sans", sans-serif',
        system_dbFontWeight: "normal",
        external_system_dbFontSize: 14,
        external_system_dbFontFamily: '"Open Sans", sans-serif',
        external_system_dbFontWeight: "normal",
        system_queueFontSize: 14,
        system_queueFontFamily: '"Open Sans", sans-serif',
        system_queueFontWeight: "normal",
        external_system_queueFontSize: 14,
        external_system_queueFontFamily: '"Open Sans", sans-serif',
        external_system_queueFontWeight: "normal",
        boundaryFontSize: 14,
        boundaryFontFamily: '"Open Sans", sans-serif',
        boundaryFontWeight: "normal",
        messageFontSize: 12,
        messageFontFamily: '"Open Sans", sans-serif',
        messageFontWeight: "normal",
        containerFontSize: 14,
        containerFontFamily: '"Open Sans", sans-serif',
        containerFontWeight: "normal",
        external_containerFontSize: 14,
        external_containerFontFamily: '"Open Sans", sans-serif',
        external_containerFontWeight: "normal",
        container_dbFontSize: 14,
        container_dbFontFamily: '"Open Sans", sans-serif',
        container_dbFontWeight: "normal",
        external_container_dbFontSize: 14,
        external_container_dbFontFamily: '"Open Sans", sans-serif',
        external_container_dbFontWeight: "normal",
        container_queueFontSize: 14,
        container_queueFontFamily: '"Open Sans", sans-serif',
        container_queueFontWeight: "normal",
        external_container_queueFontSize: 14,
        external_container_queueFontFamily: '"Open Sans", sans-serif',
        external_container_queueFontWeight: "normal",
        componentFontSize: 14,
        componentFontFamily: '"Open Sans", sans-serif',
        componentFontWeight: "normal",
        external_componentFontSize: 14,
        external_componentFontFamily: '"Open Sans", sans-serif',
        external_componentFontWeight: "normal",
        component_dbFontSize: 14,
        component_dbFontFamily: '"Open Sans", sans-serif',
        component_dbFontWeight: "normal",
        external_component_dbFontSize: 14,
        external_component_dbFontFamily: '"Open Sans", sans-serif',
        external_component_dbFontWeight: "normal",
        component_queueFontSize: 14,
        component_queueFontFamily: '"Open Sans", sans-serif',
        component_queueFontWeight: "normal",
        external_component_queueFontSize: 14,
        external_component_queueFontFamily: '"Open Sans", sans-serif',
        external_component_queueFontWeight: "normal",
        wrap: !0,
        wrapPadding: 10,
        person_bg_color: "#08427B",
        person_border_color: "#073B6F",
        external_person_bg_color: "#686868",
        external_person_border_color: "#8A8A8A",
        system_bg_color: "#1168BD",
        system_border_color: "#3C7FC0",
        system_db_bg_color: "#1168BD",
        system_db_border_color: "#3C7FC0",
        system_queue_bg_color: "#1168BD",
        system_queue_border_color: "#3C7FC0",
        external_system_bg_color: "#999999",
        external_system_border_color: "#8A8A8A",
        external_system_db_bg_color: "#999999",
        external_system_db_border_color: "#8A8A8A",
        external_system_queue_bg_color: "#999999",
        external_system_queue_border_color: "#8A8A8A",
        container_bg_color: "#438DD5",
        container_border_color: "#3C7FC0",
        container_db_bg_color: "#438DD5",
        container_db_border_color: "#3C7FC0",
        container_queue_bg_color: "#438DD5",
        container_queue_border_color: "#3C7FC0",
        external_container_bg_color: "#B3B3B3",
        external_container_border_color: "#A6A6A6",
        external_container_db_bg_color: "#B3B3B3",
        external_container_db_border_color: "#A6A6A6",
        external_container_queue_bg_color: "#B3B3B3",
        external_container_queue_border_color: "#A6A6A6",
        component_bg_color: "#85BBF0",
        component_border_color: "#78A8D8",
        component_db_bg_color: "#85BBF0",
        component_db_border_color: "#78A8D8",
        component_queue_bg_color: "#85BBF0",
        component_queue_border_color: "#78A8D8",
        external_component_bg_color: "#CCCCCC",
        external_component_border_color: "#BFBFBF",
        external_component_db_bg_color: "#CCCCCC",
        external_component_db_border_color: "#BFBFBF",
        external_component_queue_bg_color: "#CCCCCC",
        external_component_queue_border_color: "#BFBFBF"
    },
    sankey: {
        useMaxWidth: !0,
        width: 600,
        height: 400,
        linkColor: "gradient",
        nodeAlignment: "justify",
        showValues: !0,
        prefix: "",
        suffix: ""
    },
    block: {
        useMaxWidth: !0,
        padding: 8
    },
    packet: {
        useMaxWidth: !0,
        rowHeight: 32,
        bitWidth: 32,
        bitsPerRow: 32,
        showBits: !0,
        paddingX: 5,
        paddingY: 5
    },
    architecture: {
        useMaxWidth: !0,
        padding: 40,
        iconSize: 80,
        fontSize: 16
    },
    radar: {
        useMaxWidth: !0,
        width: 600,
        height: 600,
        marginTop: 50,
        marginRight: 50,
        marginBottom: 50,
        marginLeft: 50,
        axisScaleFactor: 1,
        axisLabelFactor: 1.05,
        curveTension: .17
    },
    theme: "default",
    look: "classic",
    handDrawnSeed: 0,
    layout: "dagre",
    maxTextSize: 5e4,
    maxEdges: 500,
    darkMode: !1,
    fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
    logLevel: 5,
    securityLevel: "strict",
    startOnLoad: !0,
    arrowMarkerAbsolute: !1,
    secure: ["secure", "securityLevel", "startOnLoad", "maxTextSize", "suppressErrorRendering", "maxEdges"],
    legacyMathML: !1,
    forceLegacyMathML: !1,
    deterministicIds: !1,
    fontSize: 16,
    markdownAutoWrap: !0,
    suppressErrorRendering: !1
}, g8 = {
    ...fs,
    deterministicIDSeed: void 0,
    elk: {
        mergeEdges: !1,
        nodePlacementStrategy: "BRANDES_KOEPF",
        forceNodeModelOrder: !1,
        considerModelOrder: "NODES_AND_EDGES"
    },
    themeCSS: void 0,
    themeVariables: xl.default.getThemeVariables(),
    sequence: {
        ...fs.sequence,
        messageFont: U(function() {
            return {
                fontFamily: this.messageFontFamily,
                fontSize: this.messageFontSize,
                fontWeight: this.messageFontWeight
            }
        }, "messageFont"),
        noteFont: U(function() {
            return {
                fontFamily: this.noteFontFamily,
                fontSize: this.noteFontSize,
                fontWeight: this.noteFontWeight
            }
        }, "noteFont"),
        actorFont: U(function() {
            return {
                fontFamily: this.actorFontFamily,
                fontSize: this.actorFontSize,
                fontWeight: this.actorFontWeight
            }
        }, "actorFont")
    },
    class: {
        hideEmptyMembersBox: !1
    },
    gantt: {
        ...fs.gantt,
        tickInterval: void 0,
        useWidth: void 0
    },
    c4: {
        ...fs.c4,
        useWidth: void 0,
        personFont: U(function() {
            return {
                fontFamily: this.personFontFamily,
                fontSize: this.personFontSize,
                fontWeight: this.personFontWeight
            }
        }, "personFont"),
        flowchart: {
            ...fs.flowchart,
            inheritDir: !1
        },
        external_personFont: U(function() {
            return {
                fontFamily: this.external_personFontFamily,
                fontSize: this.external_personFontSize,
                fontWeight: this.external_personFontWeight
            }
        }, "external_personFont"),
        systemFont: U(function() {
            return {
                fontFamily: this.systemFontFamily,
                fontSize: this.systemFontSize,
                fontWeight: this.systemFontWeight
            }
        }, "systemFont"),
        external_systemFont: U(function() {
            return {
                fontFamily: this.external_systemFontFamily,
                fontSize: this.external_systemFontSize,
                fontWeight: this.external_systemFontWeight
            }
        }, "external_systemFont"),
        system_dbFont: U(function() {
            return {
                fontFamily: this.system_dbFontFamily,
                fontSize: this.system_dbFontSize,
                fontWeight: this.system_dbFontWeight
            }
        }, "system_dbFont"),
        external_system_dbFont: U(function() {
            return {
                fontFamily: this.external_system_dbFontFamily,
                fontSize: this.external_system_dbFontSize,
                fontWeight: this.external_system_dbFontWeight
            }
        }, "external_system_dbFont"),
        system_queueFont: U(function() {
            return {
                fontFamily: this.system_queueFontFamily,
                fontSize: this.system_queueFontSize,
                fontWeight: this.system_queueFontWeight
            }
        }, "system_queueFont"),
        external_system_queueFont: U(function() {
            return {
                fontFamily: this.external_system_queueFontFamily,
                fontSize: this.external_system_queueFontSize,
                fontWeight: this.external_system_queueFontWeight
            }
        }, "external_system_queueFont"),
        containerFont: U(function() {
            return {
                fontFamily: this.containerFontFamily,
                fontSize: this.containerFontSize,
                fontWeight: this.containerFontWeight
            }
        }, "containerFont"),
        external_containerFont: U(function() {
            return {
                fontFamily: this.external_containerFontFamily,
                fontSize: this.external_containerFontSize,
                fontWeight: this.external_containerFontWeight
            }
        }, "external_containerFont"),
        container_dbFont: U(function() {
            return {
                fontFamily: this.container_dbFontFamily,
                fontSize: this.container_dbFontSize,
                fontWeight: this.container_dbFontWeight
            }
        }, "container_dbFont"),
        external_container_dbFont: U(function() {
            return {
                fontFamily: this.external_container_dbFontFamily,
                fontSize: this.external_container_dbFontSize,
                fontWeight: this.external_container_dbFontWeight
            }
        }, "external_container_dbFont"),
        container_queueFont: U(function() {
            return {
                fontFamily: this.container_queueFontFamily,
                fontSize: this.container_queueFontSize,
                fontWeight: this.container_queueFontWeight
            }
        }, "container_queueFont"),
        external_container_queueFont: U(function() {
            return {
                fontFamily: this.external_container_queueFontFamily,
                fontSize: this.external_container_queueFontSize,
                fontWeight: this.external_container_queueFontWeight
            }
        }, "external_container_queueFont"),
        componentFont: U(function() {
            return {
                fontFamily: this.componentFontFamily,
                fontSize: this.componentFontSize,
                fontWeight: this.componentFontWeight
            }
        }, "componentFont"),
        external_componentFont: U(function() {
            return {
                fontFamily: this.external_componentFontFamily,
                fontSize: this.external_componentFontSize,
                fontWeight: this.external_componentFontWeight
            }
        }, "external_componentFont"),
        component_dbFont: U(function() {
            return {
                fontFamily: this.component_dbFontFamily,
                fontSize: this.component_dbFontSize,
                fontWeight: this.component_dbFontWeight
            }
        }, "component_dbFont"),
        external_component_dbFont: U(function() {
            return {
                fontFamily: this.external_component_dbFontFamily,
                fontSize: this.external_component_dbFontSize,
                fontWeight: this.external_component_dbFontWeight
            }
        }, "external_component_dbFont"),
        component_queueFont: U(function() {
            return {
                fontFamily: this.component_queueFontFamily,
                fontSize: this.component_queueFontSize,
                fontWeight: this.component_queueFontWeight
            }
        }, "component_queueFont"),
        external_component_queueFont: U(function() {
            return {
                fontFamily: this.external_component_queueFontFamily,
                fontSize: this.external_component_queueFontSize,
                fontWeight: this.external_component_queueFontWeight
            }
        }, "external_component_queueFont"),
        boundaryFont: U(function() {
            return {
                fontFamily: this.boundaryFontFamily,
                fontSize: this.boundaryFontSize,
                fontWeight: this.boundaryFontWeight
            }
        }, "boundaryFont"),
        messageFont: U(function() {
            return {
                fontFamily: this.messageFontFamily,
                fontSize: this.messageFontSize,
                fontWeight: this.messageFontWeight
            }
        }, "messageFont")
    },
    pie: {
        ...fs.pie,
        useWidth: 984
    },
    xyChart: {
        ...fs.xyChart,
        useWidth: void 0
    },
    requirement: {
        ...fs.requirement,
        useWidth: void 0
    },
    packet: {
        ...fs.packet
    },
    radar: {
        ...fs.radar
    },
    treemap: {
        useMaxWidth: !0,
        padding: 10,
        diagramPadding: 8,
        showValues: !0,
        nodeWidth: 100,
        nodeHeight: 40,
        borderWidth: 1,
        valueFontSize: 12,
        labelFontSize: 14,
        valueFormat: ","
    }
}, y8 = U( (e, t="") => Object.keys(e).reduce( (n, r) => Array.isArray(e[r]) ? n : typeof e[r] == "object" && e[r] !== null ? [...n, t + r, ...y8(e[r], "")] : [...n, t + r], []), "keyify"), tTe = new Set(y8(g8, "")), b8 = g8, N0 = U(e => {
    if (Qe.debug("sanitizeDirective called with", e),
    !(typeof e != "object" || e == null)) {
        if (Array.isArray(e)) {
            e.forEach(t => N0(t));
            return
        }
        for (const t of Object.keys(e)) {
            if (Qe.debug("Checking key", t),
            t.startsWith("__") || t.includes("proto") || t.includes("constr") || !tTe.has(t) || e[t] == null) {
                Qe.debug("sanitize deleting key: ", t),
                delete e[t];
                continue
            }
            if (typeof e[t] == "object") {
                Qe.debug("sanitizing object", t),
                N0(e[t]);
                continue
            }
            const n = ["themeCSS", "fontFamily", "altFontFamily"];
            for (const r of n)
                t.includes(r) && (Qe.debug("sanitizing css option", t),
                e[t] = nTe(e[t]))
        }
        if (e.themeVariables)
            for (const t of Object.keys(e.themeVariables)) {
                const n = e.themeVariables[t];
                n?.match && !n.match(/^[\d "#%(),.;A-Za-z]+$/) && (e.themeVariables[t] = "")
            }
        Qe.debug("After sanitization", e)
    }
}
, "sanitizeDirective"), nTe = U(e => {
    let t = 0
      , n = 0;
    for (const r of e) {
        if (t < n)
            return "{ /* ERROR: Unbalanced CSS */ }";
        r === "{" ? t++ : r === "}" && n++
    }
    return t !== n ? "{ /* ERROR: Unbalanced CSS */ }" : e
}
, "sanitizeCss"), Jf = Object.freeze(b8), fo = ri({}, Jf), U0, Zu = [], Dm = ri({}, Jf), N1 = U( (e, t) => {
    let n = ri({}, e)
      , r = {};
    for (const i of t)
        S8(i),
        r = ri(r, i);
    if (n = ri(n, r),
    r.theme && r.theme in xl) {
        const i = ri({}, U0)
          , o = ri(i.themeVariables || {}, r.themeVariables);
        n.theme && n.theme in xl && (n.themeVariables = xl[n.theme].getThemeVariables(o))
    }
    return Dm = n,
    C8(Dm),
    Dm
}
, "updateCurrentConfig"), rTe = U(e => (fo = ri({}, Jf),
fo = ri(fo, e),
e.theme && xl[e.theme] && (fo.themeVariables = xl[e.theme].getThemeVariables(e.themeVariables)),
N1(fo, Zu),
fo), "setSiteConfig"), iTe = U(e => {
    U0 = ri({}, e)
}
, "saveConfigFromInitialize"), oTe = U(e => (fo = ri(fo, e),
N1(fo, Zu),
fo), "updateSiteConfig"), x8 = U( () => ri({}, fo), "getSiteConfig"), v8 = U(e => (C8(e),
ri(Dm, e),
Mi()), "setConfig"), Mi = U( () => ri({}, Dm), "getConfig"), S8 = U(e => {
    e && (["secure", ...fo.secure ?? []].forEach(t => {
        Object.hasOwn(e, t) && (Qe.debug(`Denied attempt to modify a secure key ${t}`, e[t]),
        delete e[t])
    }
    ),
    Object.keys(e).forEach(t => {
        t.startsWith("__") && delete e[t]
    }
    ),
    Object.keys(e).forEach(t => {
        typeof e[t] == "string" && (e[t].includes("<") || e[t].includes(">") || e[t].includes("url(data:")) && delete e[t],
        typeof e[t] == "object" && S8(e[t])
    }
    ))
}
, "sanitize"), aTe = U(e => {
    N0(e),
    e.fontFamily && !e.themeVariables?.fontFamily && (e.themeVariables = {
        ...e.themeVariables,
        fontFamily: e.fontFamily
    }),
    Zu.push(e),
    N1(fo, Zu)
}
, "addDirective"), V0 = U( (e=fo) => {
    Zu = [],
    N1(e, Zu)
}
, "reset"), sTe = {
    LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
}, ZB = {}, lTe = U(e => {
    ZB[e] || (Qe.warn(sTe[e]),
    ZB[e] = !0)
}
, "issueWarning"), C8 = U(e => {
    e && (e.lazyLoadedDiagrams || e.loadExternalDiagramsAtStartup) && lTe("LAZY_LOAD_DEPRECATED")
}
, "checkConfig"), VUe = U( () => {
    let e = {};
    U0 && (e = ri(e, U0));
    for (const t of Zu)
        e = ri(e, t);
    return e
}
, "getUserDefinedConfig"), ry = /<br\s*\/?>/gi, cTe = U(e => e ? T8(e).replace(/\\n/g, "#br#").split("#br#") : [""], "getRows"), uTe = ( () => {
    let e = !1;
    return () => {
        e || (w8(),
        e = !0)
    }
}
)();
function w8() {
    const e = "data-temp-href-target";
    Xf.addHook("beforeSanitizeAttributes", t => {
        t.tagName === "A" && t.hasAttribute("target") && t.setAttribute(e, t.getAttribute("target") ?? "")
    }
    ),
    Xf.addHook("afterSanitizeAttributes", t => {
        t.tagName === "A" && t.hasAttribute(e) && (t.setAttribute("target", t.getAttribute(e) ?? ""),
        t.removeAttribute(e),
        t.getAttribute("target") === "_blank" && t.setAttribute("rel", "noopener"))
    }
    )
}
U(w8, "setupDompurifyHooks");
var k8 = U(e => (uTe(),
Xf.sanitize(e)), "removeScript")
  , QB = U( (e, t) => {
    if (t.flowchart?.htmlLabels !== !1) {
        const n = t.securityLevel;
        n === "antiscript" || n === "strict" ? e = k8(e) : n !== "loose" && (e = T8(e),
        e = e.replace(/</g, "&lt;").replace(/>/g, "&gt;"),
        e = e.replace(/=/g, "&equals;"),
        e = pTe(e))
    }
    return e
}
, "sanitizeMore")
  , ka = U( (e, t) => e && (t.dompurifyConfig ? e = Xf.sanitize(QB(e, t), t.dompurifyConfig).toString() : e = Xf.sanitize(QB(e, t), {
    FORBID_TAGS: ["style"]
}).toString(),
e), "sanitizeText")
  , dTe = U( (e, t) => typeof e == "string" ? ka(e, t) : e.flat().map(n => ka(n, t)), "sanitizeTextOrArray")
  , fTe = U(e => ry.test(e), "hasBreaks")
  , hTe = U(e => e.split(ry), "splitBreaks")
  , pTe = U(e => e.replace(/#br#/g, "<br/>"), "placeholderToBreak")
  , T8 = U(e => e.replace(ry, "#br#"), "breakToPlaceholder")
  , mTe = U(e => {
    let t = "";
    return e && (t = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search,
    t = CSS.escape(t)),
    t
}
, "getUrl")
  , oi = U(e => !(e === !1 || ["false", "null", "0"].includes(String(e).trim().toLowerCase())), "evaluate")
  , gTe = U(function(...e) {
    const t = e.filter(n => !isNaN(n));
    return Math.max(...t)
}, "getMax")
  , yTe = U(function(...e) {
    const t = e.filter(n => !isNaN(n));
    return Math.min(...t)
}, "getMin")
  , KB = U(function(e) {
    const t = e.split(/(,)/)
      , n = [];
    for (let r = 0; r < t.length; r++) {
        let i = t[r];
        if (i === "," && r > 0 && r + 1 < t.length) {
            const o = t[r - 1]
              , a = t[r + 1];
            bTe(o, a) && (i = o + "," + a,
            r++,
            n.pop())
        }
        n.push(xTe(i))
    }
    return n.join("")
}, "parseGenericTypes")
  , JT = U( (e, t) => Math.max(0, e.split(t).length - 1), "countOccurrence")
  , bTe = U( (e, t) => {
    const n = JT(e, "~")
      , r = JT(t, "~");
    return n === 1 && r === 1
}
, "shouldCombineSets")
  , xTe = U(e => {
    const t = JT(e, "~");
    let n = !1;
    if (t <= 1)
        return e;
    t % 2 !== 0 && e.startsWith("~") && (e = e.substring(1),
    n = !0);
    const r = [...e];
    let i = r.indexOf("~")
      , o = r.lastIndexOf("~");
    for (; i !== -1 && o !== -1 && i !== o; )
        r[i] = "<",
        r[o] = ">",
        i = r.indexOf("~"),
        o = r.lastIndexOf("~");
    return n && r.unshift("~"),
    r.join("")
}
, "processSet")
  , XB = U( () => window.MathMLElement !== void 0, "isMathMLSupported")
  , e_ = /\$\$(.*)\$\$/g
  , eh = U(e => (e.match(e_)?.length ?? 0) > 0, "hasKatex")
  , HUe = U(async (e, t) => {
    const n = document.createElement("div");
    n.innerHTML = await nM(e, t),
    n.id = "katex-temp",
    n.style.visibility = "hidden",
    n.style.position = "absolute",
    n.style.top = "0",
    document.querySelector("body")?.insertAdjacentElement("beforeend", n);
    const i = {
        width: n.clientWidth,
        height: n.clientHeight
    };
    return n.remove(),
    i
}
, "calculateMathMLDimensions")
  , vTe = U(async (e, t) => {
    if (!eh(e))
        return e;
    if (!(XB() || t.legacyMathML || t.forceLegacyMathML))
        return e.replace(e_, "MathML is unsupported in this environment.");
    {
        const {default: n} = await qn(async () => {
            const {default: i} = await import("./katex-qrhCpa0F.js");
            return {
                default: i
            }
        }
        , [])
          , r = t.forceLegacyMathML || !XB() && t.legacyMathML ? "htmlAndMathml" : "mathml";
        return e.split(ry).map(i => eh(i) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${i}</div>` : `<div>${i}</div>`).join("").replace(e_, (i, o) => n.renderToString(o, {
            throwOnError: !0,
            displayMode: !0,
            output: r
        }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, ""))
    }
}
, "renderKatexUnsanitized")
  , nM = U(async (e, t) => ka(await vTe(e, t), t), "renderKatexSanitized")
  , vh = {
    getRows: cTe,
    sanitizeText: ka,
    sanitizeTextOrArray: dTe,
    hasBreaks: fTe,
    splitBreaks: hTe,
    lineBreakRegex: ry,
    removeScript: k8,
    getUrl: mTe,
    evaluate: oi,
    getMax: gTe,
    getMin: yTe
}
  , STe = U(function(e, t) {
    for (let n of t)
        e.attr(n[0], n[1])
}, "d3Attrs")
  , CTe = U(function(e, t, n) {
    let r = new Map;
    return n ? (r.set("width", "100%"),
    r.set("style", `max-width: ${t}px;`)) : (r.set("height", e),
    r.set("width", t)),
    r
}, "calculateSvgSizeAttrs")
  , _8 = U(function(e, t, n, r) {
    const i = CTe(t, n, r);
    STe(e, i)
}, "configureSvgSize")
  , wTe = U(function(e, t, n, r) {
    const i = t.node().getBBox()
      , o = i.width
      , a = i.height;
    Qe.info(`SVG bounds: ${o}x${a}`, i);
    let s = 0
      , c = 0;
    Qe.info(`Graph bounds: ${s}x${c}`, e),
    s = o + n * 2,
    c = a + n * 2,
    Qe.info(`Calculated bounds: ${s}x${c}`),
    _8(t, c, s, r);
    const u = `${i.x - n} ${i.y - n} ${i.width + 2 * n} ${i.height + 2 * n}`;
    t.attr("viewBox", u)
}, "setupGraphViewbox")
  , Ux = {}
  , kTe = U( (e, t, n) => {
    let r = "";
    return e in Ux && Ux[e] ? r = Ux[e](n) : Qe.warn(`No theme found for ${e}`),
    ` & {
    font-family: ${n.fontFamily};
    font-size: ${n.fontSize};
    fill: ${n.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${n.errorBkgColor};
  }
  & .error-text {
    fill: ${n.errorTextColor};
    stroke: ${n.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${n.lineColor};
    stroke: ${n.lineColor};
  }
  & .marker.cross {
    stroke: ${n.lineColor};
  }

  & svg {
    font-family: ${n.fontFamily};
    font-size: ${n.fontSize};
  }
   & p {
    margin: 0
   }

  ${r}

  ${t}
`
}
, "getStyles")
  , TTe = U( (e, t) => {
    t !== void 0 && (Ux[e] = t)
}
, "addStylesForDiagram")
  , _Te = kTe
  , E8 = {};
p2e(E8, {
    clear: () => ETe,
    getAccDescription: () => RTe,
    getAccTitle: () => MTe,
    getDiagramTitle: () => OTe,
    setAccDescription: () => PTe,
    setAccTitle: () => ATe,
    setDiagramTitle: () => DTe
});
var rM = "", iM = "", oM = "", aM = U(e => ka(e, Mi()), "sanitizeText"), ETe = U( () => {
    rM = "",
    oM = "",
    iM = ""
}
, "clear"), ATe = U(e => {
    rM = aM(e).replace(/^\s+/g, "")
}
, "setAccTitle"), MTe = U( () => rM, "getAccTitle"), PTe = U(e => {
    oM = aM(e).replace(/\n\s+/g, `
`)
}
, "setAccDescription"), RTe = U( () => oM, "getAccDescription"), DTe = U(e => {
    iM = aM(e)
}
, "setDiagramTitle"), OTe = U( () => iM, "getDiagramTitle"), JB = Qe, ITe = eM, Vn = Mi, qUe = v8, WUe = Jf, sM = U(e => ka(e, Vn()), "sanitizeText"), $Te = wTe, LTe = U( () => E8, "getCommonDb"), H0 = {}, q0 = U( (e, t, n) => {
    H0[e] && JB.warn(`Diagram with id ${e} already registered. Overwriting.`),
    H0[e] = t,
    n && m8(e, n),
    TTe(e, t.styles),
    t.injectUtils?.(JB, ITe, Vn, sM, $Te, LTe(), () => {}
    )
}
, "registerDiagram"), t_ = U(e => {
    if (e in H0)
        return H0[e];
    throw new jTe(e)
}
, "getDiagram"), Bf, jTe = (Bf = class extends Error {
    constructor(t) {
        super(`Diagram ${t} not found.`)
    }
}
,
U(Bf, "DiagramNotFoundError"),
Bf), BTe = {
    value: () => {}
};
function A8() {
    for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
        if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
            throw new Error("illegal type: " + r);
        n[r] = []
    }
    return new Vx(n)
}
function Vx(e) {
    this._ = e
}
function zTe(e, t) {
    return e.trim().split(/^|\s+/).map(function(n) {
        var r = ""
          , i = n.indexOf(".");
        if (i >= 0 && (r = n.slice(i + 1),
        n = n.slice(0, i)),
        n && !t.hasOwnProperty(n))
            throw new Error("unknown type: " + n);
        return {
            type: n,
            name: r
        }
    })
}
Vx.prototype = A8.prototype = {
    constructor: Vx,
    on: function(e, t) {
        var n = this._, r = zTe(e + "", n), i, o = -1, a = r.length;
        if (arguments.length < 2) {
            for (; ++o < a; )
                if ((i = (e = r[o]).type) && (i = FTe(n[i], e.name)))
                    return i;
            return
        }
        if (t != null && typeof t != "function")
            throw new Error("invalid callback: " + t);
        for (; ++o < a; )
            if (i = (e = r[o]).type)
                n[i] = ez(n[i], e.name, t);
            else if (t == null)
                for (i in n)
                    n[i] = ez(n[i], e.name, null);
        return this
    },
    copy: function() {
        var e = {}
          , t = this._;
        for (var n in t)
            e[n] = t[n].slice();
        return new Vx(e)
    },
    call: function(e, t) {
        if ((i = arguments.length - 2) > 0)
            for (var n = new Array(i), r = 0, i, o; r < i; ++r)
                n[r] = arguments[r + 2];
        if (!this._.hasOwnProperty(e))
            throw new Error("unknown type: " + e);
        for (o = this._[e],
        r = 0,
        i = o.length; r < i; ++r)
            o[r].value.apply(t, n)
    },
    apply: function(e, t, n) {
        if (!this._.hasOwnProperty(e))
            throw new Error("unknown type: " + e);
        for (var r = this._[e], i = 0, o = r.length; i < o; ++i)
            r[i].value.apply(t, n)
    }
};
function FTe(e, t) {
    for (var n = 0, r = e.length, i; n < r; ++n)
        if ((i = e[n]).name === t)
            return i.value
}
function ez(e, t, n) {
    for (var r = 0, i = e.length; r < i; ++r)
        if (e[r].name === t) {
            e[r] = BTe,
            e = e.slice(0, r).concat(e.slice(r + 1));
            break
        }
    return n != null && e.push({
        name: t,
        value: n
    }),
    e
}
var n_ = "http://www.w3.org/1999/xhtml";
const tz = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: n_,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
};
function U1(e) {
    var t = e += ""
      , n = t.indexOf(":");
    return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)),
    tz.hasOwnProperty(t) ? {
        space: tz[t],
        local: e
    } : e
}
function NTe(e) {
    return function() {
        var t = this.ownerDocument
          , n = this.namespaceURI;
        return n === n_ && t.documentElement.namespaceURI === n_ ? t.createElement(e) : t.createElementNS(n, e)
    }
}
function UTe(e) {
    return function() {
        return this.ownerDocument.createElementNS(e.space, e.local)
    }
}
function M8(e) {
    var t = U1(e);
    return (t.local ? UTe : NTe)(t)
}
function VTe() {}
function lM(e) {
    return e == null ? VTe : function() {
        return this.querySelector(e)
    }
}
function HTe(e) {
    typeof e != "function" && (e = lM(e));
    for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
        for (var o = t[i], a = o.length, s = r[i] = new Array(a), c, u, f = 0; f < a; ++f)
            (c = o[f]) && (u = e.call(c, c.__data__, f, o)) && ("__data__"in c && (u.__data__ = c.__data__),
            s[f] = u);
    return new Ko(r,this._parents)
}
function qTe(e) {
    return e == null ? [] : Array.isArray(e) ? e : Array.from(e)
}
function WTe() {
    return []
}
function P8(e) {
    return e == null ? WTe : function() {
        return this.querySelectorAll(e)
    }
}
function GTe(e) {
    return function() {
        return qTe(e.apply(this, arguments))
    }
}
function YTe(e) {
    typeof e == "function" ? e = GTe(e) : e = P8(e);
    for (var t = this._groups, n = t.length, r = [], i = [], o = 0; o < n; ++o)
        for (var a = t[o], s = a.length, c, u = 0; u < s; ++u)
            (c = a[u]) && (r.push(e.call(c, c.__data__, u, a)),
            i.push(c));
    return new Ko(r,i)
}
function R8(e) {
    return function() {
        return this.matches(e)
    }
}
function D8(e) {
    return function(t) {
        return t.matches(e)
    }
}
var ZTe = Array.prototype.find;
function QTe(e) {
    return function() {
        return ZTe.call(this.children, e)
    }
}
function KTe() {
    return this.firstElementChild
}
function XTe(e) {
    return this.select(e == null ? KTe : QTe(typeof e == "function" ? e : D8(e)))
}
var JTe = Array.prototype.filter;
function e_e() {
    return Array.from(this.children)
}
function t_e(e) {
    return function() {
        return JTe.call(this.children, e)
    }
}
function n_e(e) {
    return this.selectAll(e == null ? e_e : t_e(typeof e == "function" ? e : D8(e)))
}
function r_e(e) {
    typeof e != "function" && (e = R8(e));
    for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
        for (var o = t[i], a = o.length, s = r[i] = [], c, u = 0; u < a; ++u)
            (c = o[u]) && e.call(c, c.__data__, u, o) && s.push(c);
    return new Ko(r,this._parents)
}
function O8(e) {
    return new Array(e.length)
}
function i_e() {
    return new Ko(this._enter || this._groups.map(O8),this._parents)
}
function W0(e, t) {
    this.ownerDocument = e.ownerDocument,
    this.namespaceURI = e.namespaceURI,
    this._next = null,
    this._parent = e,
    this.__data__ = t
}
W0.prototype = {
    constructor: W0,
    appendChild: function(e) {
        return this._parent.insertBefore(e, this._next)
    },
    insertBefore: function(e, t) {
        return this._parent.insertBefore(e, t)
    },
    querySelector: function(e) {
        return this._parent.querySelector(e)
    },
    querySelectorAll: function(e) {
        return this._parent.querySelectorAll(e)
    }
};
function o_e(e) {
    return function() {
        return e
    }
}
function a_e(e, t, n, r, i, o) {
    for (var a = 0, s, c = t.length, u = o.length; a < u; ++a)
        (s = t[a]) ? (s.__data__ = o[a],
        r[a] = s) : n[a] = new W0(e,o[a]);
    for (; a < c; ++a)
        (s = t[a]) && (i[a] = s)
}
function s_e(e, t, n, r, i, o, a) {
    var s, c, u = new Map, f = t.length, h = o.length, m = new Array(f), y;
    for (s = 0; s < f; ++s)
        (c = t[s]) && (m[s] = y = a.call(c, c.__data__, s, t) + "",
        u.has(y) ? i[s] = c : u.set(y, c));
    for (s = 0; s < h; ++s)
        y = a.call(e, o[s], s, o) + "",
        (c = u.get(y)) ? (r[s] = c,
        c.__data__ = o[s],
        u.delete(y)) : n[s] = new W0(e,o[s]);
    for (s = 0; s < f; ++s)
        (c = t[s]) && u.get(m[s]) === c && (i[s] = c)
}
function l_e(e) {
    return e.__data__
}
function c_e(e, t) {
    if (!arguments.length)
        return Array.from(this, l_e);
    var n = t ? s_e : a_e
      , r = this._parents
      , i = this._groups;
    typeof e != "function" && (e = o_e(e));
    for (var o = i.length, a = new Array(o), s = new Array(o), c = new Array(o), u = 0; u < o; ++u) {
        var f = r[u]
          , h = i[u]
          , m = h.length
          , y = u_e(e.call(f, f && f.__data__, u, r))
          , b = y.length
          , v = s[u] = new Array(b)
          , S = a[u] = new Array(b)
          , C = c[u] = new Array(m);
        n(f, h, v, S, C, y, t);
        for (var w = 0, k = 0, T, E; w < b; ++w)
            if (T = v[w]) {
                for (w >= k && (k = w + 1); !(E = S[k]) && ++k < b; )
                    ;
                T._next = E || null
            }
    }
    return a = new Ko(a,r),
    a._enter = s,
    a._exit = c,
    a
}
function u_e(e) {
    return typeof e == "object" && "length"in e ? e : Array.from(e)
}
function d_e() {
    return new Ko(this._exit || this._groups.map(O8),this._parents)
}
function f_e(e, t, n) {
    var r = this.enter()
      , i = this
      , o = this.exit();
    return typeof e == "function" ? (r = e(r),
    r && (r = r.selection())) : r = r.append(e + ""),
    t != null && (i = t(i),
    i && (i = i.selection())),
    n == null ? o.remove() : n(o),
    r && i ? r.merge(i).order() : i
}
function h_e(e) {
    for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, o = r.length, a = Math.min(i, o), s = new Array(i), c = 0; c < a; ++c)
        for (var u = n[c], f = r[c], h = u.length, m = s[c] = new Array(h), y, b = 0; b < h; ++b)
            (y = u[b] || f[b]) && (m[b] = y);
    for (; c < i; ++c)
        s[c] = n[c];
    return new Ko(s,this._parents)
}
function p_e() {
    for (var e = this._groups, t = -1, n = e.length; ++t < n; )
        for (var r = e[t], i = r.length - 1, o = r[i], a; --i >= 0; )
            (a = r[i]) && (o && a.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(a, o),
            o = a);
    return this
}
function m_e(e) {
    e || (e = g_e);
    function t(h, m) {
        return h && m ? e(h.__data__, m.__data__) : !h - !m
    }
    for (var n = this._groups, r = n.length, i = new Array(r), o = 0; o < r; ++o) {
        for (var a = n[o], s = a.length, c = i[o] = new Array(s), u, f = 0; f < s; ++f)
            (u = a[f]) && (c[f] = u);
        c.sort(t)
    }
    return new Ko(i,this._parents).order()
}
function g_e(e, t) {
    return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
}
function y_e() {
    var e = arguments[0];
    return arguments[0] = this,
    e.apply(null, arguments),
    this
}
function b_e() {
    return Array.from(this)
}
function x_e() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
        for (var r = e[t], i = 0, o = r.length; i < o; ++i) {
            var a = r[i];
            if (a)
                return a
        }
    return null
}
function v_e() {
    let e = 0;
    for (const t of this)
        ++e;
    return e
}
function S_e() {
    return !this.node()
}
function C_e(e) {
    for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
        for (var i = t[n], o = 0, a = i.length, s; o < a; ++o)
            (s = i[o]) && e.call(s, s.__data__, o, i);
    return this
}
function w_e(e) {
    return function() {
        this.removeAttribute(e)
    }
}
function k_e(e) {
    return function() {
        this.removeAttributeNS(e.space, e.local)
    }
}
function T_e(e, t) {
    return function() {
        this.setAttribute(e, t)
    }
}
function __e(e, t) {
    return function() {
        this.setAttributeNS(e.space, e.local, t)
    }
}
function E_e(e, t) {
    return function() {
        var n = t.apply(this, arguments);
        n == null ? this.removeAttribute(e) : this.setAttribute(e, n)
    }
}
function A_e(e, t) {
    return function() {
        var n = t.apply(this, arguments);
        n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n)
    }
}
function M_e(e, t) {
    var n = U1(e);
    if (arguments.length < 2) {
        var r = this.node();
        return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n)
    }
    return this.each((t == null ? n.local ? k_e : w_e : typeof t == "function" ? n.local ? A_e : E_e : n.local ? __e : T_e)(n, t))
}
function I8(e) {
    return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView
}
function P_e(e) {
    return function() {
        this.style.removeProperty(e)
    }
}
function R_e(e, t, n) {
    return function() {
        this.style.setProperty(e, t, n)
    }
}
function D_e(e, t, n) {
    return function() {
        var r = t.apply(this, arguments);
        r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n)
    }
}
function O_e(e, t, n) {
    return arguments.length > 1 ? this.each((t == null ? P_e : typeof t == "function" ? D_e : R_e)(e, t, n ?? "")) : th(this.node(), e)
}
function th(e, t) {
    return e.style.getPropertyValue(t) || I8(e).getComputedStyle(e, null).getPropertyValue(t)
}
function I_e(e) {
    return function() {
        delete this[e]
    }
}
function $_e(e, t) {
    return function() {
        this[e] = t
    }
}
function L_e(e, t) {
    return function() {
        var n = t.apply(this, arguments);
        n == null ? delete this[e] : this[e] = n
    }
}
function j_e(e, t) {
    return arguments.length > 1 ? this.each((t == null ? I_e : typeof t == "function" ? L_e : $_e)(e, t)) : this.node()[e]
}
function $8(e) {
    return e.trim().split(/^|\s+/)
}
function cM(e) {
    return e.classList || new L8(e)
}
function L8(e) {
    this._node = e,
    this._names = $8(e.getAttribute("class") || "")
}
L8.prototype = {
    add: function(e) {
        var t = this._names.indexOf(e);
        t < 0 && (this._names.push(e),
        this._node.setAttribute("class", this._names.join(" ")))
    },
    remove: function(e) {
        var t = this._names.indexOf(e);
        t >= 0 && (this._names.splice(t, 1),
        this._node.setAttribute("class", this._names.join(" ")))
    },
    contains: function(e) {
        return this._names.indexOf(e) >= 0
    }
};
function j8(e, t) {
    for (var n = cM(e), r = -1, i = t.length; ++r < i; )
        n.add(t[r])
}
function B8(e, t) {
    for (var n = cM(e), r = -1, i = t.length; ++r < i; )
        n.remove(t[r])
}
function B_e(e) {
    return function() {
        j8(this, e)
    }
}
function z_e(e) {
    return function() {
        B8(this, e)
    }
}
function F_e(e, t) {
    return function() {
        (t.apply(this, arguments) ? j8 : B8)(this, e)
    }
}
function N_e(e, t) {
    var n = $8(e + "");
    if (arguments.length < 2) {
        for (var r = cM(this.node()), i = -1, o = n.length; ++i < o; )
            if (!r.contains(n[i]))
                return !1;
        return !0
    }
    return this.each((typeof t == "function" ? F_e : t ? B_e : z_e)(n, t))
}
function U_e() {
    this.textContent = ""
}
function V_e(e) {
    return function() {
        this.textContent = e
    }
}
function H_e(e) {
    return function() {
        var t = e.apply(this, arguments);
        this.textContent = t ?? ""
    }
}
function q_e(e) {
    return arguments.length ? this.each(e == null ? U_e : (typeof e == "function" ? H_e : V_e)(e)) : this.node().textContent
}
function W_e() {
    this.innerHTML = ""
}
function G_e(e) {
    return function() {
        this.innerHTML = e
    }
}
function Y_e(e) {
    return function() {
        var t = e.apply(this, arguments);
        this.innerHTML = t ?? ""
    }
}
function Z_e(e) {
    return arguments.length ? this.each(e == null ? W_e : (typeof e == "function" ? Y_e : G_e)(e)) : this.node().innerHTML
}
function Q_e() {
    this.nextSibling && this.parentNode.appendChild(this)
}
function K_e() {
    return this.each(Q_e)
}
function X_e() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
}
function J_e() {
    return this.each(X_e)
}
function eEe(e) {
    var t = typeof e == "function" ? e : M8(e);
    return this.select(function() {
        return this.appendChild(t.apply(this, arguments))
    })
}
function tEe() {
    return null
}
function nEe(e, t) {
    var n = typeof e == "function" ? e : M8(e)
      , r = t == null ? tEe : typeof t == "function" ? t : lM(t);
    return this.select(function() {
        return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null)
    })
}
function rEe() {
    var e = this.parentNode;
    e && e.removeChild(this)
}
function iEe() {
    return this.each(rEe)
}
function oEe() {
    var e = this.cloneNode(!1)
      , t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e
}
function aEe() {
    var e = this.cloneNode(!0)
      , t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e
}
function sEe(e) {
    return this.select(e ? aEe : oEe)
}
function lEe(e) {
    return arguments.length ? this.property("__data__", e) : this.node().__data__
}
function cEe(e) {
    return function(t) {
        e.call(this, t, this.__data__)
    }
}
function uEe(e) {
    return e.trim().split(/^|\s+/).map(function(t) {
        var n = ""
          , r = t.indexOf(".");
        return r >= 0 && (n = t.slice(r + 1),
        t = t.slice(0, r)),
        {
            type: t,
            name: n
        }
    })
}
function dEe(e) {
    return function() {
        var t = this.__on;
        if (t) {
            for (var n = 0, r = -1, i = t.length, o; n < i; ++n)
                o = t[n],
                (!e.type || o.type === e.type) && o.name === e.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++r] = o;
            ++r ? t.length = r : delete this.__on
        }
    }
}
function fEe(e, t, n) {
    return function() {
        var r = this.__on, i, o = cEe(t);
        if (r) {
            for (var a = 0, s = r.length; a < s; ++a)
                if ((i = r[a]).type === e.type && i.name === e.name) {
                    this.removeEventListener(i.type, i.listener, i.options),
                    this.addEventListener(i.type, i.listener = o, i.options = n),
                    i.value = t;
                    return
                }
        }
        this.addEventListener(e.type, o, n),
        i = {
            type: e.type,
            name: e.name,
            value: t,
            listener: o,
            options: n
        },
        r ? r.push(i) : this.__on = [i]
    }
}
function hEe(e, t, n) {
    var r = uEe(e + ""), i, o = r.length, a;
    if (arguments.length < 2) {
        var s = this.node().__on;
        if (s) {
            for (var c = 0, u = s.length, f; c < u; ++c)
                for (i = 0,
                f = s[c]; i < o; ++i)
                    if ((a = r[i]).type === f.type && a.name === f.name)
                        return f.value
        }
        return
    }
    for (s = t ? fEe : dEe,
    i = 0; i < o; ++i)
        this.each(s(r[i], t, n));
    return this
}
function z8(e, t, n) {
    var r = I8(e)
      , i = r.CustomEvent;
    typeof i == "function" ? i = new i(t,n) : (i = r.document.createEvent("Event"),
    n ? (i.initEvent(t, n.bubbles, n.cancelable),
    i.detail = n.detail) : i.initEvent(t, !1, !1)),
    e.dispatchEvent(i)
}
function pEe(e, t) {
    return function() {
        return z8(this, e, t)
    }
}
function mEe(e, t) {
    return function() {
        return z8(this, e, t.apply(this, arguments))
    }
}
function gEe(e, t) {
    return this.each((typeof t == "function" ? mEe : pEe)(e, t))
}
function *yEe() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
        for (var r = e[t], i = 0, o = r.length, a; i < o; ++i)
            (a = r[i]) && (yield a)
}
var F8 = [null];
function Ko(e, t) {
    this._groups = e,
    this._parents = t
}
function iy() {
    return new Ko([[document.documentElement]],F8)
}
function bEe() {
    return this
}
Ko.prototype = iy.prototype = {
    constructor: Ko,
    select: HTe,
    selectAll: YTe,
    selectChild: XTe,
    selectChildren: n_e,
    filter: r_e,
    data: c_e,
    enter: i_e,
    exit: d_e,
    join: f_e,
    merge: h_e,
    selection: bEe,
    order: p_e,
    sort: m_e,
    call: y_e,
    nodes: b_e,
    node: x_e,
    size: v_e,
    empty: S_e,
    each: C_e,
    attr: M_e,
    style: O_e,
    property: j_e,
    classed: N_e,
    text: q_e,
    html: Z_e,
    raise: K_e,
    lower: J_e,
    append: eEe,
    insert: nEe,
    remove: iEe,
    clone: sEe,
    datum: lEe,
    on: hEe,
    dispatch: gEe,
    [Symbol.iterator]: yEe
};
function En(e) {
    return typeof e == "string" ? new Ko([[document.querySelector(e)]],[document.documentElement]) : new Ko([[e]],F8)
}
function uM(e, t, n) {
    e.prototype = t.prototype = n,
    n.constructor = e
}
function N8(e, t) {
    var n = Object.create(e.prototype);
    for (var r in t)
        n[r] = t[r];
    return n
}
function oy() {}
var og = .7
  , G0 = 1 / og
  , Ef = "\\s*([+-]?\\d+)\\s*"
  , ag = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*"
  , ws = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*"
  , xEe = /^#([0-9a-f]{3,8})$/
  , vEe = new RegExp(`^rgb\\(${Ef},${Ef},${Ef}\\)$`)
  , SEe = new RegExp(`^rgb\\(${ws},${ws},${ws}\\)$`)
  , CEe = new RegExp(`^rgba\\(${Ef},${Ef},${Ef},${ag}\\)$`)
  , wEe = new RegExp(`^rgba\\(${ws},${ws},${ws},${ag}\\)$`)
  , kEe = new RegExp(`^hsl\\(${ag},${ws},${ws}\\)$`)
  , TEe = new RegExp(`^hsla\\(${ag},${ws},${ws},${ag}\\)$`)
  , nz = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
};
uM(oy, sg, {
    copy(e) {
        return Object.assign(new this.constructor, this, e)
    },
    displayable() {
        return this.rgb().displayable()
    },
    hex: rz,
    formatHex: rz,
    formatHex8: _Ee,
    formatHsl: EEe,
    formatRgb: iz,
    toString: iz
});
function rz() {
    return this.rgb().formatHex()
}
function _Ee() {
    return this.rgb().formatHex8()
}
function EEe() {
    return U8(this).formatHsl()
}
function iz() {
    return this.rgb().formatRgb()
}
function sg(e) {
    var t, n;
    return e = (e + "").trim().toLowerCase(),
    (t = xEe.exec(e)) ? (n = t[1].length,
    t = parseInt(t[1], 16),
    n === 6 ? oz(t) : n === 3 ? new mo(t >> 8 & 15 | t >> 4 & 240,t >> 4 & 15 | t & 240,(t & 15) << 4 | t & 15,1) : n === 8 ? ax(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? ax(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = vEe.exec(e)) ? new mo(t[1],t[2],t[3],1) : (t = SEe.exec(e)) ? new mo(t[1] * 255 / 100,t[2] * 255 / 100,t[3] * 255 / 100,1) : (t = CEe.exec(e)) ? ax(t[1], t[2], t[3], t[4]) : (t = wEe.exec(e)) ? ax(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = kEe.exec(e)) ? lz(t[1], t[2] / 100, t[3] / 100, 1) : (t = TEe.exec(e)) ? lz(t[1], t[2] / 100, t[3] / 100, t[4]) : nz.hasOwnProperty(e) ? oz(nz[e]) : e === "transparent" ? new mo(NaN,NaN,NaN,0) : null
}
function oz(e) {
    return new mo(e >> 16 & 255,e >> 8 & 255,e & 255,1)
}
function ax(e, t, n, r) {
    return r <= 0 && (e = t = n = NaN),
    new mo(e,t,n,r)
}
function AEe(e) {
    return e instanceof oy || (e = sg(e)),
    e ? (e = e.rgb(),
    new mo(e.r,e.g,e.b,e.opacity)) : new mo
}
function r_(e, t, n, r) {
    return arguments.length === 1 ? AEe(e) : new mo(e,t,n,r ?? 1)
}
function mo(e, t, n, r) {
    this.r = +e,
    this.g = +t,
    this.b = +n,
    this.opacity = +r
}
uM(mo, r_, N8(oy, {
    brighter(e) {
        return e = e == null ? G0 : Math.pow(G0, e),
        new mo(this.r * e,this.g * e,this.b * e,this.opacity)
    },
    darker(e) {
        return e = e == null ? og : Math.pow(og, e),
        new mo(this.r * e,this.g * e,this.b * e,this.opacity)
    },
    rgb() {
        return this
    },
    clamp() {
        return new mo(Ou(this.r),Ou(this.g),Ou(this.b),Y0(this.opacity))
    },
    displayable() {
        return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
    },
    hex: az,
    formatHex: az,
    formatHex8: MEe,
    formatRgb: sz,
    toString: sz
}));
function az() {
    return `#${Tu(this.r)}${Tu(this.g)}${Tu(this.b)}`
}
function MEe() {
    return `#${Tu(this.r)}${Tu(this.g)}${Tu(this.b)}${Tu((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
}
function sz() {
    const e = Y0(this.opacity);
    return `${e === 1 ? "rgb(" : "rgba("}${Ou(this.r)}, ${Ou(this.g)}, ${Ou(this.b)}${e === 1 ? ")" : `, ${e})`}`
}
function Y0(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
}
function Ou(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0))
}
function Tu(e) {
    return e = Ou(e),
    (e < 16 ? "0" : "") + e.toString(16)
}
function lz(e, t, n, r) {
    return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN),
    new Fa(e,t,n,r)
}
function U8(e) {
    if (e instanceof Fa)
        return new Fa(e.h,e.s,e.l,e.opacity);
    if (e instanceof oy || (e = sg(e)),
    !e)
        return new Fa;
    if (e instanceof Fa)
        return e;
    e = e.rgb();
    var t = e.r / 255
      , n = e.g / 255
      , r = e.b / 255
      , i = Math.min(t, n, r)
      , o = Math.max(t, n, r)
      , a = NaN
      , s = o - i
      , c = (o + i) / 2;
    return s ? (t === o ? a = (n - r) / s + (n < r) * 6 : n === o ? a = (r - t) / s + 2 : a = (t - n) / s + 4,
    s /= c < .5 ? o + i : 2 - o - i,
    a *= 60) : s = c > 0 && c < 1 ? 0 : a,
    new Fa(a,s,c,e.opacity)
}
function PEe(e, t, n, r) {
    return arguments.length === 1 ? U8(e) : new Fa(e,t,n,r ?? 1)
}
function Fa(e, t, n, r) {
    this.h = +e,
    this.s = +t,
    this.l = +n,
    this.opacity = +r
}
uM(Fa, PEe, N8(oy, {
    brighter(e) {
        return e = e == null ? G0 : Math.pow(G0, e),
        new Fa(this.h,this.s,this.l * e,this.opacity)
    },
    darker(e) {
        return e = e == null ? og : Math.pow(og, e),
        new Fa(this.h,this.s,this.l * e,this.opacity)
    },
    rgb() {
        var e = this.h % 360 + (this.h < 0) * 360
          , t = isNaN(e) || isNaN(this.s) ? 0 : this.s
          , n = this.l
          , r = n + (n < .5 ? n : 1 - n) * t
          , i = 2 * n - r;
        return new mo(Xk(e >= 240 ? e - 240 : e + 120, i, r),Xk(e, i, r),Xk(e < 120 ? e + 240 : e - 120, i, r),this.opacity)
    },
    clamp() {
        return new Fa(cz(this.h),sx(this.s),sx(this.l),Y0(this.opacity))
    },
    displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
    },
    formatHsl() {
        const e = Y0(this.opacity);
        return `${e === 1 ? "hsl(" : "hsla("}${cz(this.h)}, ${sx(this.s) * 100}%, ${sx(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`
    }
}));
function cz(e) {
    return e = (e || 0) % 360,
    e < 0 ? e + 360 : e
}
function sx(e) {
    return Math.max(0, Math.min(1, e || 0))
}
function Xk(e, t, n) {
    return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255
}
const dM = e => () => e;
function V8(e, t) {
    return function(n) {
        return e + n * t
    }
}
function REe(e, t, n) {
    return e = Math.pow(e, n),
    t = Math.pow(t, n) - e,
    n = 1 / n,
    function(r) {
        return Math.pow(e + r * t, n)
    }
}
function GUe(e, t) {
    var n = t - e;
    return n ? V8(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : dM(isNaN(e) ? t : e)
}
function DEe(e) {
    return (e = +e) == 1 ? H8 : function(t, n) {
        return n - t ? REe(t, n, e) : dM(isNaN(t) ? n : t)
    }
}
function H8(e, t) {
    var n = t - e;
    return n ? V8(e, n) : dM(isNaN(e) ? t : e)
}
const uz = (function e(t) {
    var n = DEe(t);
    function r(i, o) {
        var a = n((i = r_(i)).r, (o = r_(o)).r)
          , s = n(i.g, o.g)
          , c = n(i.b, o.b)
          , u = H8(i.opacity, o.opacity);
        return function(f) {
            return i.r = a(f),
            i.g = s(f),
            i.b = c(f),
            i.opacity = u(f),
            i + ""
        }
    }
    return r.gamma = e,
    r
}
)(1);
function oc(e, t) {
    return e = +e,
    t = +t,
    function(n) {
        return e * (1 - n) + t * n
    }
}
var i_ = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g
  , Jk = new RegExp(i_.source,"g");
function OEe(e) {
    return function() {
        return e
    }
}
function IEe(e) {
    return function(t) {
        return e(t) + ""
    }
}
function $Ee(e, t) {
    var n = i_.lastIndex = Jk.lastIndex = 0, r, i, o, a = -1, s = [], c = [];
    for (e = e + "",
    t = t + ""; (r = i_.exec(e)) && (i = Jk.exec(t)); )
        (o = i.index) > n && (o = t.slice(n, o),
        s[a] ? s[a] += o : s[++a] = o),
        (r = r[0]) === (i = i[0]) ? s[a] ? s[a] += i : s[++a] = i : (s[++a] = null,
        c.push({
            i: a,
            x: oc(r, i)
        })),
        n = Jk.lastIndex;
    return n < t.length && (o = t.slice(n),
    s[a] ? s[a] += o : s[++a] = o),
    s.length < 2 ? c[0] ? IEe(c[0].x) : OEe(t) : (t = c.length,
    function(u) {
        for (var f = 0, h; f < t; ++f)
            s[(h = c[f]).i] = h.x(u);
        return s.join("")
    }
    )
}
var dz = 180 / Math.PI
  , o_ = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
};
function q8(e, t, n, r, i, o) {
    var a, s, c;
    return (a = Math.sqrt(e * e + t * t)) && (e /= a,
    t /= a),
    (c = e * n + t * r) && (n -= e * c,
    r -= t * c),
    (s = Math.sqrt(n * n + r * r)) && (n /= s,
    r /= s,
    c /= s),
    e * r < t * n && (e = -e,
    t = -t,
    c = -c,
    a = -a),
    {
        translateX: i,
        translateY: o,
        rotate: Math.atan2(t, e) * dz,
        skewX: Math.atan(c) * dz,
        scaleX: a,
        scaleY: s
    }
}
var lx;
function LEe(e) {
    const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
    return t.isIdentity ? o_ : q8(t.a, t.b, t.c, t.d, t.e, t.f)
}
function jEe(e) {
    return e == null || (lx || (lx = document.createElementNS("http://www.w3.org/2000/svg", "g")),
    lx.setAttribute("transform", e),
    !(e = lx.transform.baseVal.consolidate())) ? o_ : (e = e.matrix,
    q8(e.a, e.b, e.c, e.d, e.e, e.f))
}
function W8(e, t, n, r) {
    function i(u) {
        return u.length ? u.pop() + " " : ""
    }
    function o(u, f, h, m, y, b) {
        if (u !== h || f !== m) {
            var v = y.push("translate(", null, t, null, n);
            b.push({
                i: v - 4,
                x: oc(u, h)
            }, {
                i: v - 2,
                x: oc(f, m)
            })
        } else
            (h || m) && y.push("translate(" + h + t + m + n)
    }
    function a(u, f, h, m) {
        u !== f ? (u - f > 180 ? f += 360 : f - u > 180 && (u += 360),
        m.push({
            i: h.push(i(h) + "rotate(", null, r) - 2,
            x: oc(u, f)
        })) : f && h.push(i(h) + "rotate(" + f + r)
    }
    function s(u, f, h, m) {
        u !== f ? m.push({
            i: h.push(i(h) + "skewX(", null, r) - 2,
            x: oc(u, f)
        }) : f && h.push(i(h) + "skewX(" + f + r)
    }
    function c(u, f, h, m, y, b) {
        if (u !== h || f !== m) {
            var v = y.push(i(y) + "scale(", null, ",", null, ")");
            b.push({
                i: v - 4,
                x: oc(u, h)
            }, {
                i: v - 2,
                x: oc(f, m)
            })
        } else
            (h !== 1 || m !== 1) && y.push(i(y) + "scale(" + h + "," + m + ")")
    }
    return function(u, f) {
        var h = []
          , m = [];
        return u = e(u),
        f = e(f),
        o(u.translateX, u.translateY, f.translateX, f.translateY, h, m),
        a(u.rotate, f.rotate, h, m),
        s(u.skewX, f.skewX, h, m),
        c(u.scaleX, u.scaleY, f.scaleX, f.scaleY, h, m),
        u = f = null,
        function(y) {
            for (var b = -1, v = m.length, S; ++b < v; )
                h[(S = m[b]).i] = S.x(y);
            return h.join("")
        }
    }
}
var BEe = W8(LEe, "px, ", "px)", "deg)"), zEe = W8(jEe, ", ", ")", ")"), nh = 0, nm = 0, Bp = 0, G8 = 1e3, Z0, rm, Q0 = 0, Qu = 0, V1 = 0, lg = typeof performance == "object" && performance.now ? performance : Date, Y8 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
    setTimeout(e, 17)
}
;
function fM() {
    return Qu || (Y8(FEe),
    Qu = lg.now() + V1)
}
function FEe() {
    Qu = 0
}
function K0() {
    this._call = this._time = this._next = null
}
K0.prototype = Z8.prototype = {
    constructor: K0,
    restart: function(e, t, n) {
        if (typeof e != "function")
            throw new TypeError("callback is not a function");
        n = (n == null ? fM() : +n) + (t == null ? 0 : +t),
        !this._next && rm !== this && (rm ? rm._next = this : Z0 = this,
        rm = this),
        this._call = e,
        this._time = n,
        a_()
    },
    stop: function() {
        this._call && (this._call = null,
        this._time = 1 / 0,
        a_())
    }
};
function Z8(e, t, n) {
    var r = new K0;
    return r.restart(e, t, n),
    r
}
function NEe() {
    fM(),
    ++nh;
    for (var e = Z0, t; e; )
        (t = Qu - e._time) >= 0 && e._call.call(void 0, t),
        e = e._next;
    --nh
}
function fz() {
    Qu = (Q0 = lg.now()) + V1,
    nh = nm = 0;
    try {
        NEe()
    } finally {
        nh = 0,
        VEe(),
        Qu = 0
    }
}
function UEe() {
    var e = lg.now()
      , t = e - Q0;
    t > G8 && (V1 -= t,
    Q0 = e)
}
function VEe() {
    for (var e, t = Z0, n, r = 1 / 0; t; )
        t._call ? (r > t._time && (r = t._time),
        e = t,
        t = t._next) : (n = t._next,
        t._next = null,
        t = e ? e._next = n : Z0 = n);
    rm = e,
    a_(r)
}
function a_(e) {
    if (!nh) {
        nm && (nm = clearTimeout(nm));
        var t = e - Qu;
        t > 24 ? (e < 1 / 0 && (nm = setTimeout(fz, e - lg.now() - V1)),
        Bp && (Bp = clearInterval(Bp))) : (Bp || (Q0 = lg.now(),
        Bp = setInterval(UEe, G8)),
        nh = 1,
        Y8(fz))
    }
}
function hz(e, t, n) {
    var r = new K0;
    return t = t == null ? 0 : +t,
    r.restart(i => {
        r.stop(),
        e(i + t)
    }
    , t, n),
    r
}
var HEe = A8("start", "end", "cancel", "interrupt")
  , qEe = []
  , Q8 = 0
  , pz = 1
  , s_ = 2
  , Hx = 3
  , mz = 4
  , l_ = 5
  , qx = 6;
function H1(e, t, n, r, i, o) {
    var a = e.__transition;
    if (!a)
        e.__transition = {};
    else if (n in a)
        return;
    WEe(e, n, {
        name: t,
        index: r,
        group: i,
        on: HEe,
        tween: qEe,
        time: o.time,
        delay: o.delay,
        duration: o.duration,
        ease: o.ease,
        timer: null,
        state: Q8
    })
}
function hM(e, t) {
    var n = rs(e, t);
    if (n.state > Q8)
        throw new Error("too late; already scheduled");
    return n
}
function Ls(e, t) {
    var n = rs(e, t);
    if (n.state > Hx)
        throw new Error("too late; already running");
    return n
}
function rs(e, t) {
    var n = e.__transition;
    if (!n || !(n = n[t]))
        throw new Error("transition not found");
    return n
}
function WEe(e, t, n) {
    var r = e.__transition, i;
    r[t] = n,
    n.timer = Z8(o, 0, n.time);
    function o(u) {
        n.state = pz,
        n.timer.restart(a, n.delay, n.time),
        n.delay <= u && a(u - n.delay)
    }
    function a(u) {
        var f, h, m, y;
        if (n.state !== pz)
            return c();
        for (f in r)
            if (y = r[f],
            y.name === n.name) {
                if (y.state === Hx)
                    return hz(a);
                y.state === mz ? (y.state = qx,
                y.timer.stop(),
                y.on.call("interrupt", e, e.__data__, y.index, y.group),
                delete r[f]) : +f < t && (y.state = qx,
                y.timer.stop(),
                y.on.call("cancel", e, e.__data__, y.index, y.group),
                delete r[f])
            }
        if (hz(function() {
            n.state === Hx && (n.state = mz,
            n.timer.restart(s, n.delay, n.time),
            s(u))
        }),
        n.state = s_,
        n.on.call("start", e, e.__data__, n.index, n.group),
        n.state === s_) {
            for (n.state = Hx,
            i = new Array(m = n.tween.length),
            f = 0,
            h = -1; f < m; ++f)
                (y = n.tween[f].value.call(e, e.__data__, n.index, n.group)) && (i[++h] = y);
            i.length = h + 1
        }
    }
    function s(u) {
        for (var f = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(c),
        n.state = l_,
        1), h = -1, m = i.length; ++h < m; )
            i[h].call(e, f);
        n.state === l_ && (n.on.call("end", e, e.__data__, n.index, n.group),
        c())
    }
    function c() {
        n.state = qx,
        n.timer.stop(),
        delete r[t];
        for (var u in r)
            return;
        delete e.__transition
    }
}
function GEe(e, t) {
    var n = e.__transition, r, i, o = !0, a;
    if (n) {
        t = t == null ? null : t + "";
        for (a in n) {
            if ((r = n[a]).name !== t) {
                o = !1;
                continue
            }
            i = r.state > s_ && r.state < l_,
            r.state = qx,
            r.timer.stop(),
            r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group),
            delete n[a]
        }
        o && delete e.__transition
    }
}
function YEe(e) {
    return this.each(function() {
        GEe(this, e)
    })
}
function ZEe(e, t) {
    var n, r;
    return function() {
        var i = Ls(this, e)
          , o = i.tween;
        if (o !== n) {
            r = n = o;
            for (var a = 0, s = r.length; a < s; ++a)
                if (r[a].name === t) {
                    r = r.slice(),
                    r.splice(a, 1);
                    break
                }
        }
        i.tween = r
    }
}
function QEe(e, t, n) {
    var r, i;
    if (typeof n != "function")
        throw new Error;
    return function() {
        var o = Ls(this, e)
          , a = o.tween;
        if (a !== r) {
            i = (r = a).slice();
            for (var s = {
                name: t,
                value: n
            }, c = 0, u = i.length; c < u; ++c)
                if (i[c].name === t) {
                    i[c] = s;
                    break
                }
            c === u && i.push(s)
        }
        o.tween = i
    }
}
function KEe(e, t) {
    var n = this._id;
    if (e += "",
    arguments.length < 2) {
        for (var r = rs(this.node(), n).tween, i = 0, o = r.length, a; i < o; ++i)
            if ((a = r[i]).name === e)
                return a.value;
        return null
    }
    return this.each((t == null ? ZEe : QEe)(n, e, t))
}
function pM(e, t, n) {
    var r = e._id;
    return e.each(function() {
        var i = Ls(this, r);
        (i.value || (i.value = {}))[t] = n.apply(this, arguments)
    }),
    function(i) {
        return rs(i, r).value[t]
    }
}
function K8(e, t) {
    var n;
    return (typeof t == "number" ? oc : t instanceof sg ? uz : (n = sg(t)) ? (t = n,
    uz) : $Ee)(e, t)
}
function XEe(e) {
    return function() {
        this.removeAttribute(e)
    }
}
function JEe(e) {
    return function() {
        this.removeAttributeNS(e.space, e.local)
    }
}
function eAe(e, t, n) {
    var r, i = n + "", o;
    return function() {
        var a = this.getAttribute(e);
        return a === i ? null : a === r ? o : o = t(r = a, n)
    }
}
function tAe(e, t, n) {
    var r, i = n + "", o;
    return function() {
        var a = this.getAttributeNS(e.space, e.local);
        return a === i ? null : a === r ? o : o = t(r = a, n)
    }
}
function nAe(e, t, n) {
    var r, i, o;
    return function() {
        var a, s = n(this), c;
        return s == null ? void this.removeAttribute(e) : (a = this.getAttribute(e),
        c = s + "",
        a === c ? null : a === r && c === i ? o : (i = c,
        o = t(r = a, s)))
    }
}
function rAe(e, t, n) {
    var r, i, o;
    return function() {
        var a, s = n(this), c;
        return s == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local),
        c = s + "",
        a === c ? null : a === r && c === i ? o : (i = c,
        o = t(r = a, s)))
    }
}
function iAe(e, t) {
    var n = U1(e)
      , r = n === "transform" ? zEe : K8;
    return this.attrTween(e, typeof t == "function" ? (n.local ? rAe : nAe)(n, r, pM(this, "attr." + e, t)) : t == null ? (n.local ? JEe : XEe)(n) : (n.local ? tAe : eAe)(n, r, t))
}
function oAe(e, t) {
    return function(n) {
        this.setAttribute(e, t.call(this, n))
    }
}
function aAe(e, t) {
    return function(n) {
        this.setAttributeNS(e.space, e.local, t.call(this, n))
    }
}
function sAe(e, t) {
    var n, r;
    function i() {
        var o = t.apply(this, arguments);
        return o !== r && (n = (r = o) && aAe(e, o)),
        n
    }
    return i._value = t,
    i
}
function lAe(e, t) {
    var n, r;
    function i() {
        var o = t.apply(this, arguments);
        return o !== r && (n = (r = o) && oAe(e, o)),
        n
    }
    return i._value = t,
    i
}
function cAe(e, t) {
    var n = "attr." + e;
    if (arguments.length < 2)
        return (n = this.tween(n)) && n._value;
    if (t == null)
        return this.tween(n, null);
    if (typeof t != "function")
        throw new Error;
    var r = U1(e);
    return this.tween(n, (r.local ? sAe : lAe)(r, t))
}
function uAe(e, t) {
    return function() {
        hM(this, e).delay = +t.apply(this, arguments)
    }
}
function dAe(e, t) {
    return t = +t,
    function() {
        hM(this, e).delay = t
    }
}
function fAe(e) {
    var t = this._id;
    return arguments.length ? this.each((typeof e == "function" ? uAe : dAe)(t, e)) : rs(this.node(), t).delay
}
function hAe(e, t) {
    return function() {
        Ls(this, e).duration = +t.apply(this, arguments)
    }
}
function pAe(e, t) {
    return t = +t,
    function() {
        Ls(this, e).duration = t
    }
}
function mAe(e) {
    var t = this._id;
    return arguments.length ? this.each((typeof e == "function" ? hAe : pAe)(t, e)) : rs(this.node(), t).duration
}
function gAe(e, t) {
    if (typeof t != "function")
        throw new Error;
    return function() {
        Ls(this, e).ease = t
    }
}
function yAe(e) {
    var t = this._id;
    return arguments.length ? this.each(gAe(t, e)) : rs(this.node(), t).ease
}
function bAe(e, t) {
    return function() {
        var n = t.apply(this, arguments);
        if (typeof n != "function")
            throw new Error;
        Ls(this, e).ease = n
    }
}
function xAe(e) {
    if (typeof e != "function")
        throw new Error;
    return this.each(bAe(this._id, e))
}
function vAe(e) {
    typeof e != "function" && (e = R8(e));
    for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
        for (var o = t[i], a = o.length, s = r[i] = [], c, u = 0; u < a; ++u)
            (c = o[u]) && e.call(c, c.__data__, u, o) && s.push(c);
    return new Tl(r,this._parents,this._name,this._id)
}
function SAe(e) {
    if (e._id !== this._id)
        throw new Error;
    for (var t = this._groups, n = e._groups, r = t.length, i = n.length, o = Math.min(r, i), a = new Array(r), s = 0; s < o; ++s)
        for (var c = t[s], u = n[s], f = c.length, h = a[s] = new Array(f), m, y = 0; y < f; ++y)
            (m = c[y] || u[y]) && (h[y] = m);
    for (; s < r; ++s)
        a[s] = t[s];
    return new Tl(a,this._parents,this._name,this._id)
}
function CAe(e) {
    return (e + "").trim().split(/^|\s+/).every(function(t) {
        var n = t.indexOf(".");
        return n >= 0 && (t = t.slice(0, n)),
        !t || t === "start"
    })
}
function wAe(e, t, n) {
    var r, i, o = CAe(t) ? hM : Ls;
    return function() {
        var a = o(this, e)
          , s = a.on;
        s !== r && (i = (r = s).copy()).on(t, n),
        a.on = i
    }
}
function kAe(e, t) {
    var n = this._id;
    return arguments.length < 2 ? rs(this.node(), n).on.on(e) : this.each(wAe(n, e, t))
}
function TAe(e) {
    return function() {
        var t = this.parentNode;
        for (var n in this.__transition)
            if (+n !== e)
                return;
        t && t.removeChild(this)
    }
}
function _Ae() {
    return this.on("end.remove", TAe(this._id))
}
function EAe(e) {
    var t = this._name
      , n = this._id;
    typeof e != "function" && (e = lM(e));
    for (var r = this._groups, i = r.length, o = new Array(i), a = 0; a < i; ++a)
        for (var s = r[a], c = s.length, u = o[a] = new Array(c), f, h, m = 0; m < c; ++m)
            (f = s[m]) && (h = e.call(f, f.__data__, m, s)) && ("__data__"in f && (h.__data__ = f.__data__),
            u[m] = h,
            H1(u[m], t, n, m, u, rs(f, n)));
    return new Tl(o,this._parents,t,n)
}
function AAe(e) {
    var t = this._name
      , n = this._id;
    typeof e != "function" && (e = P8(e));
    for (var r = this._groups, i = r.length, o = [], a = [], s = 0; s < i; ++s)
        for (var c = r[s], u = c.length, f, h = 0; h < u; ++h)
            if (f = c[h]) {
                for (var m = e.call(f, f.__data__, h, c), y, b = rs(f, n), v = 0, S = m.length; v < S; ++v)
                    (y = m[v]) && H1(y, t, n, v, m, b);
                o.push(m),
                a.push(f)
            }
    return new Tl(o,a,t,n)
}
var MAe = iy.prototype.constructor;
function PAe() {
    return new MAe(this._groups,this._parents)
}
function RAe(e, t) {
    var n, r, i;
    return function() {
        var o = th(this, e)
          , a = (this.style.removeProperty(e),
        th(this, e));
        return o === a ? null : o === n && a === r ? i : i = t(n = o, r = a)
    }
}
function X8(e) {
    return function() {
        this.style.removeProperty(e)
    }
}
function DAe(e, t, n) {
    var r, i = n + "", o;
    return function() {
        var a = th(this, e);
        return a === i ? null : a === r ? o : o = t(r = a, n)
    }
}
function OAe(e, t, n) {
    var r, i, o;
    return function() {
        var a = th(this, e)
          , s = n(this)
          , c = s + "";
        return s == null && (c = s = (this.style.removeProperty(e),
        th(this, e))),
        a === c ? null : a === r && c === i ? o : (i = c,
        o = t(r = a, s))
    }
}
function IAe(e, t) {
    var n, r, i, o = "style." + t, a = "end." + o, s;
    return function() {
        var c = Ls(this, e)
          , u = c.on
          , f = c.value[o] == null ? s || (s = X8(t)) : void 0;
        (u !== n || i !== f) && (r = (n = u).copy()).on(a, i = f),
        c.on = r
    }
}
function $Ae(e, t, n) {
    var r = (e += "") == "transform" ? BEe : K8;
    return t == null ? this.styleTween(e, RAe(e, r)).on("end.style." + e, X8(e)) : typeof t == "function" ? this.styleTween(e, OAe(e, r, pM(this, "style." + e, t))).each(IAe(this._id, e)) : this.styleTween(e, DAe(e, r, t), n).on("end.style." + e, null)
}
function LAe(e, t, n) {
    return function(r) {
        this.style.setProperty(e, t.call(this, r), n)
    }
}
function jAe(e, t, n) {
    var r, i;
    function o() {
        var a = t.apply(this, arguments);
        return a !== i && (r = (i = a) && LAe(e, a, n)),
        r
    }
    return o._value = t,
    o
}
function BAe(e, t, n) {
    var r = "style." + (e += "");
    if (arguments.length < 2)
        return (r = this.tween(r)) && r._value;
    if (t == null)
        return this.tween(r, null);
    if (typeof t != "function")
        throw new Error;
    return this.tween(r, jAe(e, t, n ?? ""))
}
function zAe(e) {
    return function() {
        this.textContent = e
    }
}
function FAe(e) {
    return function() {
        var t = e(this);
        this.textContent = t ?? ""
    }
}
function NAe(e) {
    return this.tween("text", typeof e == "function" ? FAe(pM(this, "text", e)) : zAe(e == null ? "" : e + ""))
}
function UAe(e) {
    return function(t) {
        this.textContent = e.call(this, t)
    }
}
function VAe(e) {
    var t, n;
    function r() {
        var i = e.apply(this, arguments);
        return i !== n && (t = (n = i) && UAe(i)),
        t
    }
    return r._value = e,
    r
}
function HAe(e) {
    var t = "text";
    if (arguments.length < 1)
        return (t = this.tween(t)) && t._value;
    if (e == null)
        return this.tween(t, null);
    if (typeof e != "function")
        throw new Error;
    return this.tween(t, VAe(e))
}
function qAe() {
    for (var e = this._name, t = this._id, n = J8(), r = this._groups, i = r.length, o = 0; o < i; ++o)
        for (var a = r[o], s = a.length, c, u = 0; u < s; ++u)
            if (c = a[u]) {
                var f = rs(c, t);
                H1(c, e, n, u, a, {
                    time: f.time + f.delay + f.duration,
                    delay: 0,
                    duration: f.duration,
                    ease: f.ease
                })
            }
    return new Tl(r,this._parents,e,n)
}
function WAe() {
    var e, t, n = this, r = n._id, i = n.size();
    return new Promise(function(o, a) {
        var s = {
            value: a
        }
          , c = {
            value: function() {
                --i === 0 && o()
            }
        };
        n.each(function() {
            var u = Ls(this, r)
              , f = u.on;
            f !== e && (t = (e = f).copy(),
            t._.cancel.push(s),
            t._.interrupt.push(s),
            t._.end.push(c)),
            u.on = t
        }),
        i === 0 && o()
    }
    )
}
var GAe = 0;
function Tl(e, t, n, r) {
    this._groups = e,
    this._parents = t,
    this._name = n,
    this._id = r
}
function J8() {
    return ++GAe
}
var cl = iy.prototype;
Tl.prototype = {
    constructor: Tl,
    select: EAe,
    selectAll: AAe,
    selectChild: cl.selectChild,
    selectChildren: cl.selectChildren,
    filter: vAe,
    merge: SAe,
    selection: PAe,
    transition: qAe,
    call: cl.call,
    nodes: cl.nodes,
    node: cl.node,
    size: cl.size,
    empty: cl.empty,
    each: cl.each,
    on: kAe,
    attr: iAe,
    attrTween: cAe,
    style: $Ae,
    styleTween: BAe,
    text: NAe,
    textTween: HAe,
    remove: _Ae,
    tween: KEe,
    delay: fAe,
    duration: mAe,
    ease: yAe,
    easeVarying: xAe,
    end: WAe,
    [Symbol.iterator]: cl[Symbol.iterator]
};
function YAe(e) {
    return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2
}
var ZAe = {
    time: null,
    delay: 0,
    duration: 250,
    ease: YAe
};
function QAe(e, t) {
    for (var n; !(n = e.__transition) || !(n = n[t]); )
        if (!(e = e.parentNode))
            throw new Error(`transition ${t} not found`);
    return n
}
function KAe(e) {
    var t, n;
    e instanceof Tl ? (t = e._id,
    e = e._name) : (t = J8(),
    (n = ZAe).time = fM(),
    e = e == null ? null : e + "");
    for (var r = this._groups, i = r.length, o = 0; o < i; ++o)
        for (var a = r[o], s = a.length, c, u = 0; u < s; ++u)
            (c = a[u]) && H1(c, e, t, u, a, n || QAe(c, t));
    return new Tl(r,this._parents,e,t)
}
iy.prototype.interrupt = YEe;
iy.prototype.transition = KAe;
const c_ = Math.PI
  , u_ = 2 * c_
  , pu = 1e-6
  , XAe = u_ - pu;
function eU(e) {
    this._ += e[0];
    for (let t = 1, n = e.length; t < n; ++t)
        this._ += arguments[t] + e[t]
}
function JAe(e) {
    let t = Math.floor(e);
    if (!(t >= 0))
        throw new Error(`invalid digits: ${e}`);
    if (t > 15)
        return eU;
    const n = 10 ** t;
    return function(r) {
        this._ += r[0];
        for (let i = 1, o = r.length; i < o; ++i)
            this._ += Math.round(arguments[i] * n) / n + r[i]
    }
}
class eMe {
    constructor(t) {
        this._x0 = this._y0 = this._x1 = this._y1 = null,
        this._ = "",
        this._append = t == null ? eU : JAe(t)
    }
    moveTo(t, n) {
        this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`
    }
    closePath() {
        this._x1 !== null && (this._x1 = this._x0,
        this._y1 = this._y0,
        this._append`Z`)
    }
    lineTo(t, n) {
        this._append`L${this._x1 = +t},${this._y1 = +n}`
    }
    quadraticCurveTo(t, n, r, i) {
        this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`
    }
    bezierCurveTo(t, n, r, i, o, a) {
        this._append`C${+t},${+n},${+r},${+i},${this._x1 = +o},${this._y1 = +a}`
    }
    arcTo(t, n, r, i, o) {
        if (t = +t,
        n = +n,
        r = +r,
        i = +i,
        o = +o,
        o < 0)
            throw new Error(`negative radius: ${o}`);
        let a = this._x1
          , s = this._y1
          , c = r - t
          , u = i - n
          , f = a - t
          , h = s - n
          , m = f * f + h * h;
        if (this._x1 === null)
            this._append`M${this._x1 = t},${this._y1 = n}`;
        else if (m > pu)
            if (!(Math.abs(h * c - u * f) > pu) || !o)
                this._append`L${this._x1 = t},${this._y1 = n}`;
            else {
                let y = r - a
                  , b = i - s
                  , v = c * c + u * u
                  , S = y * y + b * b
                  , C = Math.sqrt(v)
                  , w = Math.sqrt(m)
                  , k = o * Math.tan((c_ - Math.acos((v + m - S) / (2 * C * w))) / 2)
                  , T = k / w
                  , E = k / C;
                Math.abs(T - 1) > pu && this._append`L${t + T * f},${n + T * h}`,
                this._append`A${o},${o},0,0,${+(h * y > f * b)},${this._x1 = t + E * c},${this._y1 = n + E * u}`
            }
    }
    arc(t, n, r, i, o, a) {
        if (t = +t,
        n = +n,
        r = +r,
        a = !!a,
        r < 0)
            throw new Error(`negative radius: ${r}`);
        let s = r * Math.cos(i)
          , c = r * Math.sin(i)
          , u = t + s
          , f = n + c
          , h = 1 ^ a
          , m = a ? i - o : o - i;
        this._x1 === null ? this._append`M${u},${f}` : (Math.abs(this._x1 - u) > pu || Math.abs(this._y1 - f) > pu) && this._append`L${u},${f}`,
        r && (m < 0 && (m = m % u_ + u_),
        m > XAe ? this._append`A${r},${r},0,1,${h},${t - s},${n - c}A${r},${r},0,1,${h},${this._x1 = u},${this._y1 = f}` : m > pu && this._append`A${r},${r},0,${+(m >= c_)},${h},${this._x1 = t + r * Math.cos(o)},${this._y1 = n + r * Math.sin(o)}`)
    }
    rect(t, n, r, i) {
        this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`
    }
    toString() {
        return this._
    }
}
function ef(e) {
    return function() {
        return e
    }
}
const YUe = Math.abs
  , ZUe = Math.atan2
  , QUe = Math.cos
  , KUe = Math.max
  , XUe = Math.min
  , JUe = Math.sin
  , eVe = Math.sqrt
  , gz = 1e-12
  , mM = Math.PI
  , yz = mM / 2
  , tVe = 2 * mM;
function nVe(e) {
    return e > 1 ? 0 : e < -1 ? mM : Math.acos(e)
}
function rVe(e) {
    return e >= 1 ? yz : e <= -1 ? -yz : Math.asin(e)
}
function tMe(e) {
    let t = 3;
    return e.digits = function(n) {
        if (!arguments.length)
            return t;
        if (n == null)
            t = null;
        else {
            const r = Math.floor(n);
            if (!(r >= 0))
                throw new RangeError(`invalid digits: ${n}`);
            t = r
        }
        return e
    }
    ,
    () => new eMe(t)
}
function nMe(e) {
    return typeof e == "object" && "length"in e ? e : Array.from(e)
}
function tU(e) {
    this._context = e
}
tU.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._point = 0
    },
    lineEnd: function() {
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(),
        this._line = 1 - this._line
    },
    point: function(e, t) {
        switch (e = +e,
        t = +t,
        this._point) {
        case 0:
            this._point = 1,
            this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
            break;
        case 1:
            this._point = 2;
        default:
            this._context.lineTo(e, t);
            break
        }
    }
};
function X0(e) {
    return new tU(e)
}
function rMe(e) {
    return e[0]
}
function iMe(e) {
    return e[1]
}
function oMe(e, t) {
    var n = ef(!0)
      , r = null
      , i = X0
      , o = null
      , a = tMe(s);
    e = typeof e == "function" ? e : e === void 0 ? rMe : ef(e),
    t = typeof t == "function" ? t : t === void 0 ? iMe : ef(t);
    function s(c) {
        var u, f = (c = nMe(c)).length, h, m = !1, y;
        for (r == null && (o = i(y = a())),
        u = 0; u <= f; ++u)
            !(u < f && n(h = c[u], u, c)) === m && ((m = !m) ? o.lineStart() : o.lineEnd()),
            m && o.point(+e(h, u, c), +t(h, u, c));
        if (y)
            return o = null,
            y + "" || null
    }
    return s.x = function(c) {
        return arguments.length ? (e = typeof c == "function" ? c : ef(+c),
        s) : e
    }
    ,
    s.y = function(c) {
        return arguments.length ? (t = typeof c == "function" ? c : ef(+c),
        s) : t
    }
    ,
    s.defined = function(c) {
        return arguments.length ? (n = typeof c == "function" ? c : ef(!!c),
        s) : n
    }
    ,
    s.curve = function(c) {
        return arguments.length ? (i = c,
        r != null && (o = i(r)),
        s) : i
    }
    ,
    s.context = function(c) {
        return arguments.length ? (c == null ? r = o = null : o = i(r = c),
        s) : r
    }
    ,
    s
}
class nU {
    constructor(t, n) {
        this._context = t,
        this._x = n
    }
    areaStart() {
        this._line = 0
    }
    areaEnd() {
        this._line = NaN
    }
    lineStart() {
        this._point = 0
    }
    lineEnd() {
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(),
        this._line = 1 - this._line
    }
    point(t, n) {
        switch (t = +t,
        n = +n,
        this._point) {
        case 0:
            {
                this._point = 1,
                this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
                break
            }
        case 1:
            this._point = 2;
        default:
            {
                this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
                break
            }
        }
        this._x0 = t,
        this._y0 = n
    }
}
function rU(e) {
    return new nU(e,!0)
}
function iU(e) {
    return new nU(e,!1)
}
function wc() {}
function J0(e, t, n) {
    e._context.bezierCurveTo((2 * e._x0 + e._x1) / 3, (2 * e._y0 + e._y1) / 3, (e._x0 + 2 * e._x1) / 3, (e._y0 + 2 * e._y1) / 3, (e._x0 + 4 * e._x1 + t) / 6, (e._y0 + 4 * e._y1 + n) / 6)
}
function q1(e) {
    this._context = e
}
q1.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN,
        this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
        case 3:
            J0(this, this._x1, this._y1);
        case 2:
            this._context.lineTo(this._x1, this._y1);
            break
        }
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(),
        this._line = 1 - this._line
    },
    point: function(e, t) {
        switch (e = +e,
        t = +t,
        this._point) {
        case 0:
            this._point = 1,
            this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
            break;
        case 1:
            this._point = 2;
            break;
        case 2:
            this._point = 3,
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        default:
            J0(this, e, t);
            break
        }
        this._x0 = this._x1,
        this._x1 = e,
        this._y0 = this._y1,
        this._y1 = t
    }
};
function Wx(e) {
    return new q1(e)
}
function oU(e) {
    this._context = e
}
oU.prototype = {
    areaStart: wc,
    areaEnd: wc,
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN,
        this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
        case 1:
            {
                this._context.moveTo(this._x2, this._y2),
                this._context.closePath();
                break
            }
        case 2:
            {
                this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3),
                this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3),
                this._context.closePath();
                break
            }
        case 3:
            {
                this.point(this._x2, this._y2),
                this.point(this._x3, this._y3),
                this.point(this._x4, this._y4);
                break
            }
        }
    },
    point: function(e, t) {
        switch (e = +e,
        t = +t,
        this._point) {
        case 0:
            this._point = 1,
            this._x2 = e,
            this._y2 = t;
            break;
        case 1:
            this._point = 2,
            this._x3 = e,
            this._y3 = t;
            break;
        case 2:
            this._point = 3,
            this._x4 = e,
            this._y4 = t,
            this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
            break;
        default:
            J0(this, e, t);
            break
        }
        this._x0 = this._x1,
        this._x1 = e,
        this._y0 = this._y1,
        this._y1 = t
    }
};
function aMe(e) {
    return new oU(e)
}
function aU(e) {
    this._context = e
}
aU.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN,
        this._point = 0
    },
    lineEnd: function() {
        (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(),
        this._line = 1 - this._line
    },
    point: function(e, t) {
        switch (e = +e,
        t = +t,
        this._point) {
        case 0:
            this._point = 1;
            break;
        case 1:
            this._point = 2;
            break;
        case 2:
            this._point = 3;
            var n = (this._x0 + 4 * this._x1 + e) / 6
              , r = (this._y0 + 4 * this._y1 + t) / 6;
            this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
            break;
        case 3:
            this._point = 4;
        default:
            J0(this, e, t);
            break
        }
        this._x0 = this._x1,
        this._x1 = e,
        this._y0 = this._y1,
        this._y1 = t
    }
};
function sMe(e) {
    return new aU(e)
}
function sU(e, t) {
    this._basis = new q1(e),
    this._beta = t
}
sU.prototype = {
    lineStart: function() {
        this._x = [],
        this._y = [],
        this._basis.lineStart()
    },
    lineEnd: function() {
        var e = this._x
          , t = this._y
          , n = e.length - 1;
        if (n > 0)
            for (var r = e[0], i = t[0], o = e[n] - r, a = t[n] - i, s = -1, c; ++s <= n; )
                c = s / n,
                this._basis.point(this._beta * e[s] + (1 - this._beta) * (r + c * o), this._beta * t[s] + (1 - this._beta) * (i + c * a));
        this._x = this._y = null,
        this._basis.lineEnd()
    },
    point: function(e, t) {
        this._x.push(+e),
        this._y.push(+t)
    }
};
const lMe = (function e(t) {
    function n(r) {
        return t === 1 ? new q1(r) : new sU(r,t)
    }
    return n.beta = function(r) {
        return e(+r)
    }
    ,
    n
}
)(.85);
function ev(e, t, n) {
    e._context.bezierCurveTo(e._x1 + e._k * (e._x2 - e._x0), e._y1 + e._k * (e._y2 - e._y0), e._x2 + e._k * (e._x1 - t), e._y2 + e._k * (e._y1 - n), e._x2, e._y2)
}
function gM(e, t) {
    this._context = e,
    this._k = (1 - t) / 6
}
gM.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN,
        this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
        case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
        case 3:
            ev(this, this._x1, this._y1);
            break
        }
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(),
        this._line = 1 - this._line
    },
    point: function(e, t) {
        switch (e = +e,
        t = +t,
        this._point) {
        case 0:
            this._point = 1,
            this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
            break;
        case 1:
            this._point = 2,
            this._x1 = e,
            this._y1 = t;
            break;
        case 2:
            this._point = 3;
        default:
            ev(this, e, t);
            break
        }
        this._x0 = this._x1,
        this._x1 = this._x2,
        this._x2 = e,
        this._y0 = this._y1,
        this._y1 = this._y2,
        this._y2 = t
    }
};
const lU = (function e(t) {
    function n(r) {
        return new gM(r,t)
    }
    return n.tension = function(r) {
        return e(+r)
    }
    ,
    n
}
)(0);
function yM(e, t) {
    this._context = e,
    this._k = (1 - t) / 6
}
yM.prototype = {
    areaStart: wc,
    areaEnd: wc,
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN,
        this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
        case 1:
            {
                this._context.moveTo(this._x3, this._y3),
                this._context.closePath();
                break
            }
        case 2:
            {
                this._context.lineTo(this._x3, this._y3),
                this._context.closePath();
                break
            }
        case 3:
            {
                this.point(this._x3, this._y3),
                this.point(this._x4, this._y4),
                this.point(this._x5, this._y5);
                break
            }
        }
    },
    point: function(e, t) {
        switch (e = +e,
        t = +t,
        this._point) {
        case 0:
            this._point = 1,
            this._x3 = e,
            this._y3 = t;
            break;
        case 1:
            this._point = 2,
            this._context.moveTo(this._x4 = e, this._y4 = t);
            break;
        case 2:
            this._point = 3,
            this._x5 = e,
            this._y5 = t;
            break;
        default:
            ev(this, e, t);
            break
        }
        this._x0 = this._x1,
        this._x1 = this._x2,
        this._x2 = e,
        this._y0 = this._y1,
        this._y1 = this._y2,
        this._y2 = t
    }
};
const cMe = (function e(t) {
    function n(r) {
        return new yM(r,t)
    }
    return n.tension = function(r) {
        return e(+r)
    }
    ,
    n
}
)(0);
function bM(e, t) {
    this._context = e,
    this._k = (1 - t) / 6
}
bM.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN,
        this._point = 0
    },
    lineEnd: function() {
        (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(),
        this._line = 1 - this._line
    },
    point: function(e, t) {
        switch (e = +e,
        t = +t,
        this._point) {
        case 0:
            this._point = 1;
            break;
        case 1:
            this._point = 2;
            break;
        case 2:
            this._point = 3,
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
        case 3:
            this._point = 4;
        default:
            ev(this, e, t);
            break
        }
        this._x0 = this._x1,
        this._x1 = this._x2,
        this._x2 = e,
        this._y0 = this._y1,
        this._y1 = this._y2,
        this._y2 = t
    }
};
const uMe = (function e(t) {
    function n(r) {
        return new bM(r,t)
    }
    return n.tension = function(r) {
        return e(+r)
    }
    ,
    n
}
)(0);
function xM(e, t, n) {
    var r = e._x1
      , i = e._y1
      , o = e._x2
      , a = e._y2;
    if (e._l01_a > gz) {
        var s = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a
          , c = 3 * e._l01_a * (e._l01_a + e._l12_a);
        r = (r * s - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / c,
        i = (i * s - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / c
    }
    if (e._l23_a > gz) {
        var u = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a
          , f = 3 * e._l23_a * (e._l23_a + e._l12_a);
        o = (o * u + e._x1 * e._l23_2a - t * e._l12_2a) / f,
        a = (a * u + e._y1 * e._l23_2a - n * e._l12_2a) / f
    }
    e._context.bezierCurveTo(r, i, o, a, e._x2, e._y2)
}
function cU(e, t) {
    this._context = e,
    this._alpha = t
}
cU.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN,
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
        case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
        case 3:
            this.point(this._x2, this._y2);
            break
        }
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(),
        this._line = 1 - this._line
    },
    point: function(e, t) {
        if (e = +e,
        t = +t,
        this._point) {
            var n = this._x2 - e
              , r = this._y2 - t;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha))
        }
        switch (this._point) {
        case 0:
            this._point = 1,
            this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
            break;
        case 1:
            this._point = 2;
            break;
        case 2:
            this._point = 3;
        default:
            xM(this, e, t);
            break
        }
        this._l01_a = this._l12_a,
        this._l12_a = this._l23_a,
        this._l01_2a = this._l12_2a,
        this._l12_2a = this._l23_2a,
        this._x0 = this._x1,
        this._x1 = this._x2,
        this._x2 = e,
        this._y0 = this._y1,
        this._y1 = this._y2,
        this._y2 = t
    }
};
const uU = (function e(t) {
    function n(r) {
        return t ? new cU(r,t) : new gM(r,0)
    }
    return n.alpha = function(r) {
        return e(+r)
    }
    ,
    n
}
)(.5);
function dU(e, t) {
    this._context = e,
    this._alpha = t
}
dU.prototype = {
    areaStart: wc,
    areaEnd: wc,
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN,
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
        case 1:
            {
                this._context.moveTo(this._x3, this._y3),
                this._context.closePath();
                break
            }
        case 2:
            {
                this._context.lineTo(this._x3, this._y3),
                this._context.closePath();
                break
            }
        case 3:
            {
                this.point(this._x3, this._y3),
                this.point(this._x4, this._y4),
                this.point(this._x5, this._y5);
                break
            }
        }
    },
    point: function(e, t) {
        if (e = +e,
        t = +t,
        this._point) {
            var n = this._x2 - e
              , r = this._y2 - t;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha))
        }
        switch (this._point) {
        case 0:
            this._point = 1,
            this._x3 = e,
            this._y3 = t;
            break;
        case 1:
            this._point = 2,
            this._context.moveTo(this._x4 = e, this._y4 = t);
            break;
        case 2:
            this._point = 3,
            this._x5 = e,
            this._y5 = t;
            break;
        default:
            xM(this, e, t);
            break
        }
        this._l01_a = this._l12_a,
        this._l12_a = this._l23_a,
        this._l01_2a = this._l12_2a,
        this._l12_2a = this._l23_2a,
        this._x0 = this._x1,
        this._x1 = this._x2,
        this._x2 = e,
        this._y0 = this._y1,
        this._y1 = this._y2,
        this._y2 = t
    }
};
const dMe = (function e(t) {
    function n(r) {
        return t ? new dU(r,t) : new yM(r,0)
    }
    return n.alpha = function(r) {
        return e(+r)
    }
    ,
    n
}
)(.5);
function fU(e, t) {
    this._context = e,
    this._alpha = t
}
fU.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN,
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
    },
    lineEnd: function() {
        (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(),
        this._line = 1 - this._line
    },
    point: function(e, t) {
        if (e = +e,
        t = +t,
        this._point) {
            var n = this._x2 - e
              , r = this._y2 - t;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha))
        }
        switch (this._point) {
        case 0:
            this._point = 1;
            break;
        case 1:
            this._point = 2;
            break;
        case 2:
            this._point = 3,
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
        case 3:
            this._point = 4;
        default:
            xM(this, e, t);
            break
        }
        this._l01_a = this._l12_a,
        this._l12_a = this._l23_a,
        this._l01_2a = this._l12_2a,
        this._l12_2a = this._l23_2a,
        this._x0 = this._x1,
        this._x1 = this._x2,
        this._x2 = e,
        this._y0 = this._y1,
        this._y1 = this._y2,
        this._y2 = t
    }
};
const fMe = (function e(t) {
    function n(r) {
        return t ? new fU(r,t) : new bM(r,0)
    }
    return n.alpha = function(r) {
        return e(+r)
    }
    ,
    n
}
)(.5);
function hU(e) {
    this._context = e
}
hU.prototype = {
    areaStart: wc,
    areaEnd: wc,
    lineStart: function() {
        this._point = 0
    },
    lineEnd: function() {
        this._point && this._context.closePath()
    },
    point: function(e, t) {
        e = +e,
        t = +t,
        this._point ? this._context.lineTo(e, t) : (this._point = 1,
        this._context.moveTo(e, t))
    }
};
function hMe(e) {
    return new hU(e)
}
function bz(e) {
    return e < 0 ? -1 : 1
}
function xz(e, t, n) {
    var r = e._x1 - e._x0
      , i = t - e._x1
      , o = (e._y1 - e._y0) / (r || i < 0 && -0)
      , a = (n - e._y1) / (i || r < 0 && -0)
      , s = (o * i + a * r) / (r + i);
    return (bz(o) + bz(a)) * Math.min(Math.abs(o), Math.abs(a), .5 * Math.abs(s)) || 0
}
function vz(e, t) {
    var n = e._x1 - e._x0;
    return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t
}
function e2(e, t, n) {
    var r = e._x0
      , i = e._y0
      , o = e._x1
      , a = e._y1
      , s = (o - r) / 3;
    e._context.bezierCurveTo(r + s, i + s * t, o - s, a - s * n, o, a)
}
function tv(e) {
    this._context = e
}
tv.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN,
        this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
        case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        case 3:
            e2(this, this._t0, vz(this, this._t0));
            break
        }
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(),
        this._line = 1 - this._line
    },
    point: function(e, t) {
        var n = NaN;
        if (e = +e,
        t = +t,
        !(e === this._x1 && t === this._y1)) {
            switch (this._point) {
            case 0:
                this._point = 1,
                this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3,
                e2(this, vz(this, n = xz(this, e, t)), n);
                break;
            default:
                e2(this, this._t0, n = xz(this, e, t));
                break
            }
            this._x0 = this._x1,
            this._x1 = e,
            this._y0 = this._y1,
            this._y1 = t,
            this._t0 = n
        }
    }
};
function pU(e) {
    this._context = new mU(e)
}
(pU.prototype = Object.create(tv.prototype)).point = function(e, t) {
    tv.prototype.point.call(this, t, e)
}
;
function mU(e) {
    this._context = e
}
mU.prototype = {
    moveTo: function(e, t) {
        this._context.moveTo(t, e)
    },
    closePath: function() {
        this._context.closePath()
    },
    lineTo: function(e, t) {
        this._context.lineTo(t, e)
    },
    bezierCurveTo: function(e, t, n, r, i, o) {
        this._context.bezierCurveTo(t, e, r, n, o, i)
    }
};
function gU(e) {
    return new tv(e)
}
function yU(e) {
    return new pU(e)
}
function bU(e) {
    this._context = e
}
bU.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x = [],
        this._y = []
    },
    lineEnd: function() {
        var e = this._x
          , t = this._y
          , n = e.length;
        if (n)
            if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]),
            n === 2)
                this._context.lineTo(e[1], t[1]);
            else
                for (var r = Sz(e), i = Sz(t), o = 0, a = 1; a < n; ++o,
                ++a)
                    this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[a], t[a]);
        (this._line || this._line !== 0 && n === 1) && this._context.closePath(),
        this._line = 1 - this._line,
        this._x = this._y = null
    },
    point: function(e, t) {
        this._x.push(+e),
        this._y.push(+t)
    }
};
function Sz(e) {
    var t, n = e.length - 1, r, i = new Array(n), o = new Array(n), a = new Array(n);
    for (i[0] = 0,
    o[0] = 2,
    a[0] = e[0] + 2 * e[1],
    t = 1; t < n - 1; ++t)
        i[t] = 1,
        o[t] = 4,
        a[t] = 4 * e[t] + 2 * e[t + 1];
    for (i[n - 1] = 2,
    o[n - 1] = 7,
    a[n - 1] = 8 * e[n - 1] + e[n],
    t = 1; t < n; ++t)
        r = i[t] / o[t - 1],
        o[t] -= r,
        a[t] -= r * a[t - 1];
    for (i[n - 1] = a[n - 1] / o[n - 1],
    t = n - 2; t >= 0; --t)
        i[t] = (a[t] - i[t + 1]) / o[t];
    for (o[n - 1] = (e[n] + i[n - 1]) / 2,
    t = 0; t < n - 1; ++t)
        o[t] = 2 * e[t + 1] - i[t + 1];
    return [i, o]
}
function xU(e) {
    return new bU(e)
}
function W1(e, t) {
    this._context = e,
    this._t = t
}
W1.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x = this._y = NaN,
        this._point = 0
    },
    lineEnd: function() {
        0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y),
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(),
        this._line >= 0 && (this._t = 1 - this._t,
        this._line = 1 - this._line)
    },
    point: function(e, t) {
        switch (e = +e,
        t = +t,
        this._point) {
        case 0:
            this._point = 1,
            this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
            break;
        case 1:
            this._point = 2;
        default:
            {
                if (this._t <= 0)
                    this._context.lineTo(this._x, t),
                    this._context.lineTo(e, t);
                else {
                    var n = this._x * (1 - this._t) + e * this._t;
                    this._context.lineTo(n, this._y),
                    this._context.lineTo(n, t)
                }
                break
            }
        }
        this._x = e,
        this._y = t
    }
};
function vU(e) {
    return new W1(e,.5)
}
function SU(e) {
    return new W1(e,0)
}
function CU(e) {
    return new W1(e,1)
}
function im(e, t, n) {
    this.k = e,
    this.x = t,
    this.y = n
}
im.prototype = {
    constructor: im,
    scale: function(e) {
        return e === 1 ? this : new im(this.k * e,this.x,this.y)
    },
    translate: function(e, t) {
        return e === 0 & t === 0 ? this : new im(this.k,this.x + this.k * e,this.y + this.k * t)
    },
    apply: function(e) {
        return [e[0] * this.k + this.x, e[1] * this.k + this.y]
    },
    applyX: function(e) {
        return e * this.k + this.x
    },
    applyY: function(e) {
        return e * this.k + this.y
    },
    invert: function(e) {
        return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k]
    },
    invertX: function(e) {
        return (e - this.x) / this.k
    },
    invertY: function(e) {
        return (e - this.y) / this.k
    },
    rescaleX: function(e) {
        return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e))
    },
    rescaleY: function(e) {
        return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e))
    },
    toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
    }
};
im.prototype;
var pMe = U(e => {
    const {securityLevel: t} = Vn();
    let n = En("body");
    if (t === "sandbox") {
        const o = En(`#i${e}`).node()?.contentDocument ?? document;
        n = En(o.body)
    }
    return n.select(`#${e}`)
}
, "selectSvgElement");
function vM(e) {
    return typeof e > "u" || e === null
}
U(vM, "isNothing");
function wU(e) {
    return typeof e == "object" && e !== null
}
U(wU, "isObject");
function kU(e) {
    return Array.isArray(e) ? e : vM(e) ? [] : [e]
}
U(kU, "toArray");
function TU(e, t) {
    var n, r, i, o;
    if (t)
        for (o = Object.keys(t),
        n = 0,
        r = o.length; n < r; n += 1)
            i = o[n],
            e[i] = t[i];
    return e
}
U(TU, "extend");
function _U(e, t) {
    var n = "", r;
    for (r = 0; r < t; r += 1)
        n += e;
    return n
}
U(_U, "repeat");
function EU(e) {
    return e === 0 && Number.NEGATIVE_INFINITY === 1 / e
}
U(EU, "isNegativeZero");
var mMe = vM
  , gMe = wU
  , yMe = kU
  , bMe = _U
  , xMe = EU
  , vMe = TU
  , ii = {
    isNothing: mMe,
    isObject: gMe,
    toArray: yMe,
    repeat: bMe,
    isNegativeZero: xMe,
    extend: vMe
};
function SM(e, t) {
    var n = ""
      , r = e.reason || "(unknown reason)";
    return e.mark ? (e.mark.name && (n += 'in "' + e.mark.name + '" '),
    n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")",
    !t && e.mark.snippet && (n += `

` + e.mark.snippet),
    r + " " + n) : r
}
U(SM, "formatError");
function rh(e, t) {
    Error.call(this),
    this.name = "YAMLException",
    this.reason = e,
    this.mark = t,
    this.message = SM(this, !1),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || ""
}
U(rh, "YAMLException$1");
rh.prototype = Object.create(Error.prototype);
rh.prototype.constructor = rh;
rh.prototype.toString = U(function(t) {
    return this.name + ": " + SM(this, t)
}, "toString");
var ho = rh;
function Gx(e, t, n, r, i) {
    var o = ""
      , a = ""
      , s = Math.floor(i / 2) - 1;
    return r - t > s && (o = " ... ",
    t = r - s + o.length),
    n - r > s && (a = " ...",
    n = r + s - a.length),
    {
        str: o + e.slice(t, n).replace(/\t/g, "") + a,
        pos: r - t + o.length
    }
}
U(Gx, "getLine");
function Yx(e, t) {
    return ii.repeat(" ", t - e.length) + e
}
U(Yx, "padStart");
function AU(e, t) {
    if (t = Object.create(t || null),
    !e.buffer)
        return null;
    t.maxLength || (t.maxLength = 79),
    typeof t.indent != "number" && (t.indent = 1),
    typeof t.linesBefore != "number" && (t.linesBefore = 3),
    typeof t.linesAfter != "number" && (t.linesAfter = 2);
    for (var n = /\r?\n|\r|\0/g, r = [0], i = [], o, a = -1; o = n.exec(e.buffer); )
        i.push(o.index),
        r.push(o.index + o[0].length),
        e.position <= o.index && a < 0 && (a = r.length - 2);
    a < 0 && (a = r.length - 1);
    var s = "", c, u, f = Math.min(e.line + t.linesAfter, i.length).toString().length, h = t.maxLength - (t.indent + f + 3);
    for (c = 1; c <= t.linesBefore && !(a - c < 0); c++)
        u = Gx(e.buffer, r[a - c], i[a - c], e.position - (r[a] - r[a - c]), h),
        s = ii.repeat(" ", t.indent) + Yx((e.line - c + 1).toString(), f) + " | " + u.str + `
` + s;
    for (u = Gx(e.buffer, r[a], i[a], e.position, h),
    s += ii.repeat(" ", t.indent) + Yx((e.line + 1).toString(), f) + " | " + u.str + `
`,
    s += ii.repeat("-", t.indent + f + 3 + u.pos) + `^
`,
    c = 1; c <= t.linesAfter && !(a + c >= i.length); c++)
        u = Gx(e.buffer, r[a + c], i[a + c], e.position - (r[a] - r[a + c]), h),
        s += ii.repeat(" ", t.indent) + Yx((e.line + c + 1).toString(), f) + " | " + u.str + `
`;
    return s.replace(/\n$/, "")
}
U(AU, "makeSnippet");
var SMe = AU
  , CMe = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"]
  , wMe = ["scalar", "sequence", "mapping"];
function MU(e) {
    var t = {};
    return e !== null && Object.keys(e).forEach(function(n) {
        e[n].forEach(function(r) {
            t[String(r)] = n
        })
    }),
    t
}
U(MU, "compileStyleAliases");
function PU(e, t) {
    if (t = t || {},
    Object.keys(t).forEach(function(n) {
        if (CMe.indexOf(n) === -1)
            throw new ho('Unknown option "' + n + '" is met in definition of "' + e + '" YAML type.')
    }),
    this.options = t,
    this.tag = e,
    this.kind = t.kind || null,
    this.resolve = t.resolve || function() {
        return !0
    }
    ,
    this.construct = t.construct || function(n) {
        return n
    }
    ,
    this.instanceOf = t.instanceOf || null,
    this.predicate = t.predicate || null,
    this.represent = t.represent || null,
    this.representName = t.representName || null,
    this.defaultStyle = t.defaultStyle || null,
    this.multi = t.multi || !1,
    this.styleAliases = MU(t.styleAliases || null),
    wMe.indexOf(this.kind) === -1)
        throw new ho('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.')
}
U(PU, "Type$1");
var Pi = PU;
function d_(e, t) {
    var n = [];
    return e[t].forEach(function(r) {
        var i = n.length;
        n.forEach(function(o, a) {
            o.tag === r.tag && o.kind === r.kind && o.multi === r.multi && (i = a)
        }),
        n[i] = r
    }),
    n
}
U(d_, "compileList");
function RU() {
    var e = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
            scalar: [],
            sequence: [],
            mapping: [],
            fallback: []
        }
    }, t, n;
    function r(i) {
        i.multi ? (e.multi[i.kind].push(i),
        e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i
    }
    for (U(r, "collectType"),
    t = 0,
    n = arguments.length; t < n; t += 1)
        arguments[t].forEach(r);
    return e
}
U(RU, "compileMap");
function nv(e) {
    return this.extend(e)
}
U(nv, "Schema$1");
nv.prototype.extend = U(function(t) {
    var n = []
      , r = [];
    if (t instanceof Pi)
        r.push(t);
    else if (Array.isArray(t))
        r = r.concat(t);
    else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
        t.implicit && (n = n.concat(t.implicit)),
        t.explicit && (r = r.concat(t.explicit));
    else
        throw new ho("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    n.forEach(function(o) {
        if (!(o instanceof Pi))
            throw new ho("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        if (o.loadKind && o.loadKind !== "scalar")
            throw new ho("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        if (o.multi)
            throw new ho("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.")
    }),
    r.forEach(function(o) {
        if (!(o instanceof Pi))
            throw new ho("Specified list of YAML types (or a single Type object) contains a non-Type object.")
    });
    var i = Object.create(nv.prototype);
    return i.implicit = (this.implicit || []).concat(n),
    i.explicit = (this.explicit || []).concat(r),
    i.compiledImplicit = d_(i, "implicit"),
    i.compiledExplicit = d_(i, "explicit"),
    i.compiledTypeMap = RU(i.compiledImplicit, i.compiledExplicit),
    i
}, "extend");
var kMe = nv
  , TMe = new Pi("tag:yaml.org,2002:str",{
    kind: "scalar",
    construct: U(function(e) {
        return e !== null ? e : ""
    }, "construct")
})
  , _Me = new Pi("tag:yaml.org,2002:seq",{
    kind: "sequence",
    construct: U(function(e) {
        return e !== null ? e : []
    }, "construct")
})
  , EMe = new Pi("tag:yaml.org,2002:map",{
    kind: "mapping",
    construct: U(function(e) {
        return e !== null ? e : {}
    }, "construct")
})
  , AMe = new kMe({
    explicit: [TMe, _Me, EMe]
});
function DU(e) {
    if (e === null)
        return !0;
    var t = e.length;
    return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL")
}
U(DU, "resolveYamlNull");
function OU() {
    return null
}
U(OU, "constructYamlNull");
function IU(e) {
    return e === null
}
U(IU, "isNull");
var MMe = new Pi("tag:yaml.org,2002:null",{
    kind: "scalar",
    resolve: DU,
    construct: OU,
    predicate: IU,
    represent: {
        canonical: U(function() {
            return "~"
        }, "canonical"),
        lowercase: U(function() {
            return "null"
        }, "lowercase"),
        uppercase: U(function() {
            return "NULL"
        }, "uppercase"),
        camelcase: U(function() {
            return "Null"
        }, "camelcase"),
        empty: U(function() {
            return ""
        }, "empty")
    },
    defaultStyle: "lowercase"
});
function $U(e) {
    if (e === null)
        return !1;
    var t = e.length;
    return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE")
}
U($U, "resolveYamlBoolean");
function LU(e) {
    return e === "true" || e === "True" || e === "TRUE"
}
U(LU, "constructYamlBoolean");
function jU(e) {
    return Object.prototype.toString.call(e) === "[object Boolean]"
}
U(jU, "isBoolean");
var PMe = new Pi("tag:yaml.org,2002:bool",{
    kind: "scalar",
    resolve: $U,
    construct: LU,
    predicate: jU,
    represent: {
        lowercase: U(function(e) {
            return e ? "true" : "false"
        }, "lowercase"),
        uppercase: U(function(e) {
            return e ? "TRUE" : "FALSE"
        }, "uppercase"),
        camelcase: U(function(e) {
            return e ? "True" : "False"
        }, "camelcase")
    },
    defaultStyle: "lowercase"
});
function BU(e) {
    return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102
}
U(BU, "isHexCode");
function zU(e) {
    return 48 <= e && e <= 55
}
U(zU, "isOctCode");
function FU(e) {
    return 48 <= e && e <= 57
}
U(FU, "isDecCode");
function NU(e) {
    if (e === null)
        return !1;
    var t = e.length, n = 0, r = !1, i;
    if (!t)
        return !1;
    if (i = e[n],
    (i === "-" || i === "+") && (i = e[++n]),
    i === "0") {
        if (n + 1 === t)
            return !0;
        if (i = e[++n],
        i === "b") {
            for (n++; n < t; n++)
                if (i = e[n],
                i !== "_") {
                    if (i !== "0" && i !== "1")
                        return !1;
                    r = !0
                }
            return r && i !== "_"
        }
        if (i === "x") {
            for (n++; n < t; n++)
                if (i = e[n],
                i !== "_") {
                    if (!BU(e.charCodeAt(n)))
                        return !1;
                    r = !0
                }
            return r && i !== "_"
        }
        if (i === "o") {
            for (n++; n < t; n++)
                if (i = e[n],
                i !== "_") {
                    if (!zU(e.charCodeAt(n)))
                        return !1;
                    r = !0
                }
            return r && i !== "_"
        }
    }
    if (i === "_")
        return !1;
    for (; n < t; n++)
        if (i = e[n],
        i !== "_") {
            if (!FU(e.charCodeAt(n)))
                return !1;
            r = !0
        }
    return !(!r || i === "_")
}
U(NU, "resolveYamlInteger");
function UU(e) {
    var t = e, n = 1, r;
    if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")),
    r = t[0],
    (r === "-" || r === "+") && (r === "-" && (n = -1),
    t = t.slice(1),
    r = t[0]),
    t === "0")
        return 0;
    if (r === "0") {
        if (t[1] === "b")
            return n * parseInt(t.slice(2), 2);
        if (t[1] === "x")
            return n * parseInt(t.slice(2), 16);
        if (t[1] === "o")
            return n * parseInt(t.slice(2), 8)
    }
    return n * parseInt(t, 10)
}
U(UU, "constructYamlInteger");
function VU(e) {
    return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !ii.isNegativeZero(e)
}
U(VU, "isInteger");
var RMe = new Pi("tag:yaml.org,2002:int",{
    kind: "scalar",
    resolve: NU,
    construct: UU,
    predicate: VU,
    represent: {
        binary: U(function(e) {
            return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1)
        }, "binary"),
        octal: U(function(e) {
            return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1)
        }, "octal"),
        decimal: U(function(e) {
            return e.toString(10)
        }, "decimal"),
        hexadecimal: U(function(e) {
            return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1)
        }, "hexadecimal")
    },
    defaultStyle: "decimal",
    styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
    }
})
  , DMe = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function HU(e) {
    return !(e === null || !DMe.test(e) || e[e.length - 1] === "_")
}
U(HU, "resolveYamlFloat");
function qU(e) {
    var t, n;
    return t = e.replace(/_/g, "").toLowerCase(),
    n = t[0] === "-" ? -1 : 1,
    "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)),
    t === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : n * parseFloat(t, 10)
}
U(qU, "constructYamlFloat");
var OMe = /^[-+]?[0-9]+e/;
function WU(e, t) {
    var n;
    if (isNaN(e))
        switch (t) {
        case "lowercase":
            return ".nan";
        case "uppercase":
            return ".NAN";
        case "camelcase":
            return ".NaN"
        }
    else if (Number.POSITIVE_INFINITY === e)
        switch (t) {
        case "lowercase":
            return ".inf";
        case "uppercase":
            return ".INF";
        case "camelcase":
            return ".Inf"
        }
    else if (Number.NEGATIVE_INFINITY === e)
        switch (t) {
        case "lowercase":
            return "-.inf";
        case "uppercase":
            return "-.INF";
        case "camelcase":
            return "-.Inf"
        }
    else if (ii.isNegativeZero(e))
        return "-0.0";
    return n = e.toString(10),
    OMe.test(n) ? n.replace("e", ".e") : n
}
U(WU, "representYamlFloat");
function GU(e) {
    return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || ii.isNegativeZero(e))
}
U(GU, "isFloat");
var IMe = new Pi("tag:yaml.org,2002:float",{
    kind: "scalar",
    resolve: HU,
    construct: qU,
    predicate: GU,
    represent: WU,
    defaultStyle: "lowercase"
})
  , YU = AMe.extend({
    implicit: [MMe, PMe, RMe, IMe]
})
  , $Me = YU
  , ZU = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$")
  , QU = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function KU(e) {
    return e === null ? !1 : ZU.exec(e) !== null || QU.exec(e) !== null
}
U(KU, "resolveYamlTimestamp");
function XU(e) {
    var t, n, r, i, o, a, s, c = 0, u = null, f, h, m;
    if (t = ZU.exec(e),
    t === null && (t = QU.exec(e)),
    t === null)
        throw new Error("Date resolve error");
    if (n = +t[1],
    r = +t[2] - 1,
    i = +t[3],
    !t[4])
        return new Date(Date.UTC(n, r, i));
    if (o = +t[4],
    a = +t[5],
    s = +t[6],
    t[7]) {
        for (c = t[7].slice(0, 3); c.length < 3; )
            c += "0";
        c = +c
    }
    return t[9] && (f = +t[10],
    h = +(t[11] || 0),
    u = (f * 60 + h) * 6e4,
    t[9] === "-" && (u = -u)),
    m = new Date(Date.UTC(n, r, i, o, a, s, c)),
    u && m.setTime(m.getTime() - u),
    m
}
U(XU, "constructYamlTimestamp");
function JU(e) {
    return e.toISOString()
}
U(JU, "representYamlTimestamp");
var LMe = new Pi("tag:yaml.org,2002:timestamp",{
    kind: "scalar",
    resolve: KU,
    construct: XU,
    instanceOf: Date,
    represent: JU
});
function eV(e) {
    return e === "<<" || e === null
}
U(eV, "resolveYamlMerge");
var jMe = new Pi("tag:yaml.org,2002:merge",{
    kind: "scalar",
    resolve: eV
})
  , CM = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function tV(e) {
    if (e === null)
        return !1;
    var t, n, r = 0, i = e.length, o = CM;
    for (n = 0; n < i; n++)
        if (t = o.indexOf(e.charAt(n)),
        !(t > 64)) {
            if (t < 0)
                return !1;
            r += 6
        }
    return r % 8 === 0
}
U(tV, "resolveYamlBinary");
function nV(e) {
    var t, n, r = e.replace(/[\r\n=]/g, ""), i = r.length, o = CM, a = 0, s = [];
    for (t = 0; t < i; t++)
        t % 4 === 0 && t && (s.push(a >> 16 & 255),
        s.push(a >> 8 & 255),
        s.push(a & 255)),
        a = a << 6 | o.indexOf(r.charAt(t));
    return n = i % 4 * 6,
    n === 0 ? (s.push(a >> 16 & 255),
    s.push(a >> 8 & 255),
    s.push(a & 255)) : n === 18 ? (s.push(a >> 10 & 255),
    s.push(a >> 2 & 255)) : n === 12 && s.push(a >> 4 & 255),
    new Uint8Array(s)
}
U(nV, "constructYamlBinary");
function rV(e) {
    var t = "", n = 0, r, i, o = e.length, a = CM;
    for (r = 0; r < o; r++)
        r % 3 === 0 && r && (t += a[n >> 18 & 63],
        t += a[n >> 12 & 63],
        t += a[n >> 6 & 63],
        t += a[n & 63]),
        n = (n << 8) + e[r];
    return i = o % 3,
    i === 0 ? (t += a[n >> 18 & 63],
    t += a[n >> 12 & 63],
    t += a[n >> 6 & 63],
    t += a[n & 63]) : i === 2 ? (t += a[n >> 10 & 63],
    t += a[n >> 4 & 63],
    t += a[n << 2 & 63],
    t += a[64]) : i === 1 && (t += a[n >> 2 & 63],
    t += a[n << 4 & 63],
    t += a[64],
    t += a[64]),
    t
}
U(rV, "representYamlBinary");
function iV(e) {
    return Object.prototype.toString.call(e) === "[object Uint8Array]"
}
U(iV, "isBinary");
var BMe = new Pi("tag:yaml.org,2002:binary",{
    kind: "scalar",
    resolve: tV,
    construct: nV,
    predicate: iV,
    represent: rV
})
  , zMe = Object.prototype.hasOwnProperty
  , FMe = Object.prototype.toString;
function oV(e) {
    if (e === null)
        return !0;
    var t = [], n, r, i, o, a, s = e;
    for (n = 0,
    r = s.length; n < r; n += 1) {
        if (i = s[n],
        a = !1,
        FMe.call(i) !== "[object Object]")
            return !1;
        for (o in i)
            if (zMe.call(i, o))
                if (!a)
                    a = !0;
                else
                    return !1;
        if (!a)
            return !1;
        if (t.indexOf(o) === -1)
            t.push(o);
        else
            return !1
    }
    return !0
}
U(oV, "resolveYamlOmap");
function aV(e) {
    return e !== null ? e : []
}
U(aV, "constructYamlOmap");
var NMe = new Pi("tag:yaml.org,2002:omap",{
    kind: "sequence",
    resolve: oV,
    construct: aV
})
  , UMe = Object.prototype.toString;
function sV(e) {
    if (e === null)
        return !0;
    var t, n, r, i, o, a = e;
    for (o = new Array(a.length),
    t = 0,
    n = a.length; t < n; t += 1) {
        if (r = a[t],
        UMe.call(r) !== "[object Object]" || (i = Object.keys(r),
        i.length !== 1))
            return !1;
        o[t] = [i[0], r[i[0]]]
    }
    return !0
}
U(sV, "resolveYamlPairs");
function lV(e) {
    if (e === null)
        return [];
    var t, n, r, i, o, a = e;
    for (o = new Array(a.length),
    t = 0,
    n = a.length; t < n; t += 1)
        r = a[t],
        i = Object.keys(r),
        o[t] = [i[0], r[i[0]]];
    return o
}
U(lV, "constructYamlPairs");
var VMe = new Pi("tag:yaml.org,2002:pairs",{
    kind: "sequence",
    resolve: sV,
    construct: lV
})
  , HMe = Object.prototype.hasOwnProperty;
function cV(e) {
    if (e === null)
        return !0;
    var t, n = e;
    for (t in n)
        if (HMe.call(n, t) && n[t] !== null)
            return !1;
    return !0
}
U(cV, "resolveYamlSet");
function uV(e) {
    return e !== null ? e : {}
}
U(uV, "constructYamlSet");
var qMe = new Pi("tag:yaml.org,2002:set",{
    kind: "mapping",
    resolve: cV,
    construct: uV
})
  , dV = $Me.extend({
    implicit: [LMe, jMe],
    explicit: [BMe, NMe, VMe, qMe]
})
  , kc = Object.prototype.hasOwnProperty
  , rv = 1
  , fV = 2
  , hV = 3
  , iv = 4
  , t2 = 1
  , WMe = 2
  , Cz = 3
  , GMe = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
  , YMe = /[\x85\u2028\u2029]/
  , ZMe = /[,\[\]\{\}]/
  , pV = /^(?:!|!!|![a-z\-]+!)$/i
  , mV = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function f_(e) {
    return Object.prototype.toString.call(e)
}
U(f_, "_class");
function Ya(e) {
    return e === 10 || e === 13
}
U(Ya, "is_EOL");
function mc(e) {
    return e === 9 || e === 32
}
U(mc, "is_WHITE_SPACE");
function Vi(e) {
    return e === 9 || e === 32 || e === 10 || e === 13
}
U(Vi, "is_WS_OR_EOL");
function _u(e) {
    return e === 44 || e === 91 || e === 93 || e === 123 || e === 125
}
U(_u, "is_FLOW_INDICATOR");
function gV(e) {
    var t;
    return 48 <= e && e <= 57 ? e - 48 : (t = e | 32,
    97 <= t && t <= 102 ? t - 97 + 10 : -1)
}
U(gV, "fromHexCode");
function yV(e) {
    return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0
}
U(yV, "escapedHexLen");
function bV(e) {
    return 48 <= e && e <= 57 ? e - 48 : -1
}
U(bV, "fromDecimalCode");
function h_(e) {
    return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? "" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : ""
}
U(h_, "simpleEscapeSequence");
function xV(e) {
    return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode((e - 65536 >> 10) + 55296, (e - 65536 & 1023) + 56320)
}
U(xV, "charFromCodepoint");
var vV = new Array(256)
  , SV = new Array(256);
for (au = 0; au < 256; au++)
    vV[au] = h_(au) ? 1 : 0,
    SV[au] = h_(au);
var au;
function CV(e, t) {
    this.input = e,
    this.filename = t.filename || null,
    this.schema = t.schema || dV,
    this.onWarning = t.onWarning || null,
    this.legacy = t.legacy || !1,
    this.json = t.json || !1,
    this.listener = t.listener || null,
    this.implicitTypes = this.schema.compiledImplicit,
    this.typeMap = this.schema.compiledTypeMap,
    this.length = e.length,
    this.position = 0,
    this.line = 0,
    this.lineStart = 0,
    this.lineIndent = 0,
    this.firstTabInLine = -1,
    this.documents = []
}
U(CV, "State$1");
function wM(e, t) {
    var n = {
        name: e.filename,
        buffer: e.input.slice(0, -1),
        position: e.position,
        line: e.line,
        column: e.position - e.lineStart
    };
    return n.snippet = SMe(n),
    new ho(t,n)
}
U(wM, "generateError");
function Rt(e, t) {
    throw wM(e, t)
}
U(Rt, "throwError");
function cg(e, t) {
    e.onWarning && e.onWarning.call(null, wM(e, t))
}
U(cg, "throwWarning");
var wz = {
    YAML: U(function(t, n, r) {
        var i, o, a;
        t.version !== null && Rt(t, "duplication of %YAML directive"),
        r.length !== 1 && Rt(t, "YAML directive accepts exactly one argument"),
        i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]),
        i === null && Rt(t, "ill-formed argument of the YAML directive"),
        o = parseInt(i[1], 10),
        a = parseInt(i[2], 10),
        o !== 1 && Rt(t, "unacceptable YAML version of the document"),
        t.version = r[0],
        t.checkLineBreaks = a < 2,
        a !== 1 && a !== 2 && cg(t, "unsupported YAML version of the document")
    }, "handleYamlDirective"),
    TAG: U(function(t, n, r) {
        var i, o;
        r.length !== 2 && Rt(t, "TAG directive accepts exactly two arguments"),
        i = r[0],
        o = r[1],
        pV.test(i) || Rt(t, "ill-formed tag handle (first argument) of the TAG directive"),
        kc.call(t.tagMap, i) && Rt(t, 'there is a previously declared suffix for "' + i + '" tag handle'),
        mV.test(o) || Rt(t, "ill-formed tag prefix (second argument) of the TAG directive");
        try {
            o = decodeURIComponent(o)
        } catch {
            Rt(t, "tag prefix is malformed: " + o)
        }
        t.tagMap[i] = o
    }, "handleTagDirective")
};
function vl(e, t, n, r) {
    var i, o, a, s;
    if (t < n) {
        if (s = e.input.slice(t, n),
        r)
            for (i = 0,
            o = s.length; i < o; i += 1)
                a = s.charCodeAt(i),
                a === 9 || 32 <= a && a <= 1114111 || Rt(e, "expected valid JSON character");
        else
            GMe.test(s) && Rt(e, "the stream contains non-printable characters");
        e.result += s
    }
}
U(vl, "captureSegment");
function p_(e, t, n, r) {
    var i, o, a, s;
    for (ii.isObject(n) || Rt(e, "cannot merge mappings; the provided source object is unacceptable"),
    i = Object.keys(n),
    a = 0,
    s = i.length; a < s; a += 1)
        o = i[a],
        kc.call(t, o) || (t[o] = n[o],
        r[o] = !0)
}
U(p_, "mergeMappings");
function Eu(e, t, n, r, i, o, a, s, c) {
    var u, f;
    if (Array.isArray(i))
        for (i = Array.prototype.slice.call(i),
        u = 0,
        f = i.length; u < f; u += 1)
            Array.isArray(i[u]) && Rt(e, "nested arrays are not supported inside keys"),
            typeof i == "object" && f_(i[u]) === "[object Object]" && (i[u] = "[object Object]");
    if (typeof i == "object" && f_(i) === "[object Object]" && (i = "[object Object]"),
    i = String(i),
    t === null && (t = {}),
    r === "tag:yaml.org,2002:merge")
        if (Array.isArray(o))
            for (u = 0,
            f = o.length; u < f; u += 1)
                p_(e, t, o[u], n);
        else
            p_(e, t, o, n);
    else
        !e.json && !kc.call(n, i) && kc.call(t, i) && (e.line = a || e.line,
        e.lineStart = s || e.lineStart,
        e.position = c || e.position,
        Rt(e, "duplicated mapping key")),
        i === "__proto__" ? Object.defineProperty(t, i, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: o
        }) : t[i] = o,
        delete n[i];
    return t
}
U(Eu, "storeMappingPair");
function G1(e) {
    var t;
    t = e.input.charCodeAt(e.position),
    t === 10 ? e.position++ : t === 13 ? (e.position++,
    e.input.charCodeAt(e.position) === 10 && e.position++) : Rt(e, "a line break is expected"),
    e.line += 1,
    e.lineStart = e.position,
    e.firstTabInLine = -1
}
U(G1, "readLineBreak");
function Br(e, t, n) {
    for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
        for (; mc(i); )
            i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position),
            i = e.input.charCodeAt(++e.position);
        if (t && i === 35)
            do
                i = e.input.charCodeAt(++e.position);
            while (i !== 10 && i !== 13 && i !== 0);
        if (Ya(i))
            for (G1(e),
            i = e.input.charCodeAt(e.position),
            r++,
            e.lineIndent = 0; i === 32; )
                e.lineIndent++,
                i = e.input.charCodeAt(++e.position);
        else
            break
    }
    return n !== -1 && r !== 0 && e.lineIndent < n && cg(e, "deficient indentation"),
    r
}
U(Br, "skipSeparationSpace");
function ay(e) {
    var t = e.position, n;
    return n = e.input.charCodeAt(t),
    !!((n === 45 || n === 46) && n === e.input.charCodeAt(t + 1) && n === e.input.charCodeAt(t + 2) && (t += 3,
    n = e.input.charCodeAt(t),
    n === 0 || Vi(n)))
}
U(ay, "testDocumentSeparator");
function Y1(e, t) {
    t === 1 ? e.result += " " : t > 1 && (e.result += ii.repeat(`
`, t - 1))
}
U(Y1, "writeFoldedLines");
function wV(e, t, n) {
    var r, i, o, a, s, c, u, f, h = e.kind, m = e.result, y;
    if (y = e.input.charCodeAt(e.position),
    Vi(y) || _u(y) || y === 35 || y === 38 || y === 42 || y === 33 || y === 124 || y === 62 || y === 39 || y === 34 || y === 37 || y === 64 || y === 96 || (y === 63 || y === 45) && (i = e.input.charCodeAt(e.position + 1),
    Vi(i) || n && _u(i)))
        return !1;
    for (e.kind = "scalar",
    e.result = "",
    o = a = e.position,
    s = !1; y !== 0; ) {
        if (y === 58) {
            if (i = e.input.charCodeAt(e.position + 1),
            Vi(i) || n && _u(i))
                break
        } else if (y === 35) {
            if (r = e.input.charCodeAt(e.position - 1),
            Vi(r))
                break
        } else {
            if (e.position === e.lineStart && ay(e) || n && _u(y))
                break;
            if (Ya(y))
                if (c = e.line,
                u = e.lineStart,
                f = e.lineIndent,
                Br(e, !1, -1),
                e.lineIndent >= t) {
                    s = !0,
                    y = e.input.charCodeAt(e.position);
                    continue
                } else {
                    e.position = a,
                    e.line = c,
                    e.lineStart = u,
                    e.lineIndent = f;
                    break
                }
        }
        s && (vl(e, o, a, !1),
        Y1(e, e.line - c),
        o = a = e.position,
        s = !1),
        mc(y) || (a = e.position + 1),
        y = e.input.charCodeAt(++e.position)
    }
    return vl(e, o, a, !1),
    e.result ? !0 : (e.kind = h,
    e.result = m,
    !1)
}
U(wV, "readPlainScalar");
function kV(e, t) {
    var n, r, i;
    if (n = e.input.charCodeAt(e.position),
    n !== 39)
        return !1;
    for (e.kind = "scalar",
    e.result = "",
    e.position++,
    r = i = e.position; (n = e.input.charCodeAt(e.position)) !== 0; )
        if (n === 39)
            if (vl(e, r, e.position, !0),
            n = e.input.charCodeAt(++e.position),
            n === 39)
                r = e.position,
                e.position++,
                i = e.position;
            else
                return !0;
        else
            Ya(n) ? (vl(e, r, i, !0),
            Y1(e, Br(e, !1, t)),
            r = i = e.position) : e.position === e.lineStart && ay(e) ? Rt(e, "unexpected end of the document within a single quoted scalar") : (e.position++,
            i = e.position);
    Rt(e, "unexpected end of the stream within a single quoted scalar")
}
U(kV, "readSingleQuotedScalar");
function TV(e, t) {
    var n, r, i, o, a, s;
    if (s = e.input.charCodeAt(e.position),
    s !== 34)
        return !1;
    for (e.kind = "scalar",
    e.result = "",
    e.position++,
    n = r = e.position; (s = e.input.charCodeAt(e.position)) !== 0; ) {
        if (s === 34)
            return vl(e, n, e.position, !0),
            e.position++,
            !0;
        if (s === 92) {
            if (vl(e, n, e.position, !0),
            s = e.input.charCodeAt(++e.position),
            Ya(s))
                Br(e, !1, t);
            else if (s < 256 && vV[s])
                e.result += SV[s],
                e.position++;
            else if ((a = yV(s)) > 0) {
                for (i = a,
                o = 0; i > 0; i--)
                    s = e.input.charCodeAt(++e.position),
                    (a = gV(s)) >= 0 ? o = (o << 4) + a : Rt(e, "expected hexadecimal character");
                e.result += xV(o),
                e.position++
            } else
                Rt(e, "unknown escape sequence");
            n = r = e.position
        } else
            Ya(s) ? (vl(e, n, r, !0),
            Y1(e, Br(e, !1, t)),
            n = r = e.position) : e.position === e.lineStart && ay(e) ? Rt(e, "unexpected end of the document within a double quoted scalar") : (e.position++,
            r = e.position)
    }
    Rt(e, "unexpected end of the stream within a double quoted scalar")
}
U(TV, "readDoubleQuotedScalar");
function _V(e, t) {
    var n = !0, r, i, o, a = e.tag, s, c = e.anchor, u, f, h, m, y, b = Object.create(null), v, S, C, w;
    if (w = e.input.charCodeAt(e.position),
    w === 91)
        f = 93,
        y = !1,
        s = [];
    else if (w === 123)
        f = 125,
        y = !0,
        s = {};
    else
        return !1;
    for (e.anchor !== null && (e.anchorMap[e.anchor] = s),
    w = e.input.charCodeAt(++e.position); w !== 0; ) {
        if (Br(e, !0, t),
        w = e.input.charCodeAt(e.position),
        w === f)
            return e.position++,
            e.tag = a,
            e.anchor = c,
            e.kind = y ? "mapping" : "sequence",
            e.result = s,
            !0;
        n ? w === 44 && Rt(e, "expected the node content, but found ','") : Rt(e, "missed comma between flow collection entries"),
        S = v = C = null,
        h = m = !1,
        w === 63 && (u = e.input.charCodeAt(e.position + 1),
        Vi(u) && (h = m = !0,
        e.position++,
        Br(e, !0, t))),
        r = e.line,
        i = e.lineStart,
        o = e.position,
        Ku(e, t, rv, !1, !0),
        S = e.tag,
        v = e.result,
        Br(e, !0, t),
        w = e.input.charCodeAt(e.position),
        (m || e.line === r) && w === 58 && (h = !0,
        w = e.input.charCodeAt(++e.position),
        Br(e, !0, t),
        Ku(e, t, rv, !1, !0),
        C = e.result),
        y ? Eu(e, s, b, S, v, C, r, i, o) : h ? s.push(Eu(e, null, b, S, v, C, r, i, o)) : s.push(v),
        Br(e, !0, t),
        w = e.input.charCodeAt(e.position),
        w === 44 ? (n = !0,
        w = e.input.charCodeAt(++e.position)) : n = !1
    }
    Rt(e, "unexpected end of the stream within a flow collection")
}
U(_V, "readFlowCollection");
function EV(e, t) {
    var n, r, i = t2, o = !1, a = !1, s = t, c = 0, u = !1, f, h;
    if (h = e.input.charCodeAt(e.position),
    h === 124)
        r = !1;
    else if (h === 62)
        r = !0;
    else
        return !1;
    for (e.kind = "scalar",
    e.result = ""; h !== 0; )
        if (h = e.input.charCodeAt(++e.position),
        h === 43 || h === 45)
            t2 === i ? i = h === 43 ? Cz : WMe : Rt(e, "repeat of a chomping mode identifier");
        else if ((f = bV(h)) >= 0)
            f === 0 ? Rt(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : a ? Rt(e, "repeat of an indentation width identifier") : (s = t + f - 1,
            a = !0);
        else
            break;
    if (mc(h)) {
        do
            h = e.input.charCodeAt(++e.position);
        while (mc(h));
        if (h === 35)
            do
                h = e.input.charCodeAt(++e.position);
            while (!Ya(h) && h !== 0)
    }
    for (; h !== 0; ) {
        for (G1(e),
        e.lineIndent = 0,
        h = e.input.charCodeAt(e.position); (!a || e.lineIndent < s) && h === 32; )
            e.lineIndent++,
            h = e.input.charCodeAt(++e.position);
        if (!a && e.lineIndent > s && (s = e.lineIndent),
        Ya(h)) {
            c++;
            continue
        }
        if (e.lineIndent < s) {
            i === Cz ? e.result += ii.repeat(`
`, o ? 1 + c : c) : i === t2 && o && (e.result += `
`);
            break
        }
        for (r ? mc(h) ? (u = !0,
        e.result += ii.repeat(`
`, o ? 1 + c : c)) : u ? (u = !1,
        e.result += ii.repeat(`
`, c + 1)) : c === 0 ? o && (e.result += " ") : e.result += ii.repeat(`
`, c) : e.result += ii.repeat(`
`, o ? 1 + c : c),
        o = !0,
        a = !0,
        c = 0,
        n = e.position; !Ya(h) && h !== 0; )
            h = e.input.charCodeAt(++e.position);
        vl(e, n, e.position, !1)
    }
    return !0
}
U(EV, "readBlockScalar");
function m_(e, t) {
    var n, r = e.tag, i = e.anchor, o = [], a, s = !1, c;
    if (e.firstTabInLine !== -1)
        return !1;
    for (e.anchor !== null && (e.anchorMap[e.anchor] = o),
    c = e.input.charCodeAt(e.position); c !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine,
    Rt(e, "tab characters must not be used in indentation")),
    !(c !== 45 || (a = e.input.charCodeAt(e.position + 1),
    !Vi(a)))); ) {
        if (s = !0,
        e.position++,
        Br(e, !0, -1) && e.lineIndent <= t) {
            o.push(null),
            c = e.input.charCodeAt(e.position);
            continue
        }
        if (n = e.line,
        Ku(e, t, hV, !1, !0),
        o.push(e.result),
        Br(e, !0, -1),
        c = e.input.charCodeAt(e.position),
        (e.line === n || e.lineIndent > t) && c !== 0)
            Rt(e, "bad indentation of a sequence entry");
        else if (e.lineIndent < t)
            break
    }
    return s ? (e.tag = r,
    e.anchor = i,
    e.kind = "sequence",
    e.result = o,
    !0) : !1
}
U(m_, "readBlockSequence");
function AV(e, t, n) {
    var r, i, o, a, s, c, u = e.tag, f = e.anchor, h = {}, m = Object.create(null), y = null, b = null, v = null, S = !1, C = !1, w;
    if (e.firstTabInLine !== -1)
        return !1;
    for (e.anchor !== null && (e.anchorMap[e.anchor] = h),
    w = e.input.charCodeAt(e.position); w !== 0; ) {
        if (!S && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine,
        Rt(e, "tab characters must not be used in indentation")),
        r = e.input.charCodeAt(e.position + 1),
        o = e.line,
        (w === 63 || w === 58) && Vi(r))
            w === 63 ? (S && (Eu(e, h, m, y, b, null, a, s, c),
            y = b = v = null),
            C = !0,
            S = !0,
            i = !0) : S ? (S = !1,
            i = !0) : Rt(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"),
            e.position += 1,
            w = r;
        else {
            if (a = e.line,
            s = e.lineStart,
            c = e.position,
            !Ku(e, n, fV, !1, !0))
                break;
            if (e.line === o) {
                for (w = e.input.charCodeAt(e.position); mc(w); )
                    w = e.input.charCodeAt(++e.position);
                if (w === 58)
                    w = e.input.charCodeAt(++e.position),
                    Vi(w) || Rt(e, "a whitespace character is expected after the key-value separator within a block mapping"),
                    S && (Eu(e, h, m, y, b, null, a, s, c),
                    y = b = v = null),
                    C = !0,
                    S = !1,
                    i = !1,
                    y = e.tag,
                    b = e.result;
                else if (C)
                    Rt(e, "can not read an implicit mapping pair; a colon is missed");
                else
                    return e.tag = u,
                    e.anchor = f,
                    !0
            } else if (C)
                Rt(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
            else
                return e.tag = u,
                e.anchor = f,
                !0
        }
        if ((e.line === o || e.lineIndent > t) && (S && (a = e.line,
        s = e.lineStart,
        c = e.position),
        Ku(e, t, iv, !0, i) && (S ? b = e.result : v = e.result),
        S || (Eu(e, h, m, y, b, v, a, s, c),
        y = b = v = null),
        Br(e, !0, -1),
        w = e.input.charCodeAt(e.position)),
        (e.line === o || e.lineIndent > t) && w !== 0)
            Rt(e, "bad indentation of a mapping entry");
        else if (e.lineIndent < t)
            break
    }
    return S && Eu(e, h, m, y, b, null, a, s, c),
    C && (e.tag = u,
    e.anchor = f,
    e.kind = "mapping",
    e.result = h),
    C
}
U(AV, "readBlockMapping");
function MV(e) {
    var t, n = !1, r = !1, i, o, a;
    if (a = e.input.charCodeAt(e.position),
    a !== 33)
        return !1;
    if (e.tag !== null && Rt(e, "duplication of a tag property"),
    a = e.input.charCodeAt(++e.position),
    a === 60 ? (n = !0,
    a = e.input.charCodeAt(++e.position)) : a === 33 ? (r = !0,
    i = "!!",
    a = e.input.charCodeAt(++e.position)) : i = "!",
    t = e.position,
    n) {
        do
            a = e.input.charCodeAt(++e.position);
        while (a !== 0 && a !== 62);
        e.position < e.length ? (o = e.input.slice(t, e.position),
        a = e.input.charCodeAt(++e.position)) : Rt(e, "unexpected end of the stream within a verbatim tag")
    } else {
        for (; a !== 0 && !Vi(a); )
            a === 33 && (r ? Rt(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1),
            pV.test(i) || Rt(e, "named tag handle cannot contain such characters"),
            r = !0,
            t = e.position + 1)),
            a = e.input.charCodeAt(++e.position);
        o = e.input.slice(t, e.position),
        ZMe.test(o) && Rt(e, "tag suffix cannot contain flow indicator characters")
    }
    o && !mV.test(o) && Rt(e, "tag name cannot contain such characters: " + o);
    try {
        o = decodeURIComponent(o)
    } catch {
        Rt(e, "tag name is malformed: " + o)
    }
    return n ? e.tag = o : kc.call(e.tagMap, i) ? e.tag = e.tagMap[i] + o : i === "!" ? e.tag = "!" + o : i === "!!" ? e.tag = "tag:yaml.org,2002:" + o : Rt(e, 'undeclared tag handle "' + i + '"'),
    !0
}
U(MV, "readTagProperty");
function PV(e) {
    var t, n;
    if (n = e.input.charCodeAt(e.position),
    n !== 38)
        return !1;
    for (e.anchor !== null && Rt(e, "duplication of an anchor property"),
    n = e.input.charCodeAt(++e.position),
    t = e.position; n !== 0 && !Vi(n) && !_u(n); )
        n = e.input.charCodeAt(++e.position);
    return e.position === t && Rt(e, "name of an anchor node must contain at least one character"),
    e.anchor = e.input.slice(t, e.position),
    !0
}
U(PV, "readAnchorProperty");
function RV(e) {
    var t, n, r;
    if (r = e.input.charCodeAt(e.position),
    r !== 42)
        return !1;
    for (r = e.input.charCodeAt(++e.position),
    t = e.position; r !== 0 && !Vi(r) && !_u(r); )
        r = e.input.charCodeAt(++e.position);
    return e.position === t && Rt(e, "name of an alias node must contain at least one character"),
    n = e.input.slice(t, e.position),
    kc.call(e.anchorMap, n) || Rt(e, 'unidentified alias "' + n + '"'),
    e.result = e.anchorMap[n],
    Br(e, !0, -1),
    !0
}
U(RV, "readAlias");
function Ku(e, t, n, r, i) {
    var o, a, s, c = 1, u = !1, f = !1, h, m, y, b, v, S;
    if (e.listener !== null && e.listener("open", e),
    e.tag = null,
    e.anchor = null,
    e.kind = null,
    e.result = null,
    o = a = s = iv === n || hV === n,
    r && Br(e, !0, -1) && (u = !0,
    e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)),
    c === 1)
        for (; MV(e) || PV(e); )
            Br(e, !0, -1) ? (u = !0,
            s = o,
            e.lineIndent > t ? c = 1 : e.lineIndent === t ? c = 0 : e.lineIndent < t && (c = -1)) : s = !1;
    if (s && (s = u || i),
    (c === 1 || iv === n) && (rv === n || fV === n ? v = t : v = t + 1,
    S = e.position - e.lineStart,
    c === 1 ? s && (m_(e, S) || AV(e, S, v)) || _V(e, v) ? f = !0 : (a && EV(e, v) || kV(e, v) || TV(e, v) ? f = !0 : RV(e) ? (f = !0,
    (e.tag !== null || e.anchor !== null) && Rt(e, "alias node should not have any properties")) : wV(e, v, rv === n) && (f = !0,
    e.tag === null && (e.tag = "?")),
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : c === 0 && (f = s && m_(e, S))),
    e.tag === null)
        e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
    else if (e.tag === "?") {
        for (e.result !== null && e.kind !== "scalar" && Rt(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'),
        h = 0,
        m = e.implicitTypes.length; h < m; h += 1)
            if (b = e.implicitTypes[h],
            b.resolve(e.result)) {
                e.result = b.construct(e.result),
                e.tag = b.tag,
                e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
                break
            }
    } else if (e.tag !== "!") {
        if (kc.call(e.typeMap[e.kind || "fallback"], e.tag))
            b = e.typeMap[e.kind || "fallback"][e.tag];
        else
            for (b = null,
            y = e.typeMap.multi[e.kind || "fallback"],
            h = 0,
            m = y.length; h < m; h += 1)
                if (e.tag.slice(0, y[h].tag.length) === y[h].tag) {
                    b = y[h];
                    break
                }
        b || Rt(e, "unknown tag !<" + e.tag + ">"),
        e.result !== null && b.kind !== e.kind && Rt(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + b.kind + '", not "' + e.kind + '"'),
        b.resolve(e.result, e.tag) ? (e.result = b.construct(e.result, e.tag),
        e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : Rt(e, "cannot resolve a node with !<" + e.tag + "> explicit tag")
    }
    return e.listener !== null && e.listener("close", e),
    e.tag !== null || e.anchor !== null || f
}
U(Ku, "composeNode");
function DV(e) {
    var t = e.position, n, r, i, o = !1, a;
    for (e.version = null,
    e.checkLineBreaks = e.legacy,
    e.tagMap = Object.create(null),
    e.anchorMap = Object.create(null); (a = e.input.charCodeAt(e.position)) !== 0 && (Br(e, !0, -1),
    a = e.input.charCodeAt(e.position),
    !(e.lineIndent > 0 || a !== 37)); ) {
        for (o = !0,
        a = e.input.charCodeAt(++e.position),
        n = e.position; a !== 0 && !Vi(a); )
            a = e.input.charCodeAt(++e.position);
        for (r = e.input.slice(n, e.position),
        i = [],
        r.length < 1 && Rt(e, "directive name must not be less than one character in length"); a !== 0; ) {
            for (; mc(a); )
                a = e.input.charCodeAt(++e.position);
            if (a === 35) {
                do
                    a = e.input.charCodeAt(++e.position);
                while (a !== 0 && !Ya(a));
                break
            }
            if (Ya(a))
                break;
            for (n = e.position; a !== 0 && !Vi(a); )
                a = e.input.charCodeAt(++e.position);
            i.push(e.input.slice(n, e.position))
        }
        a !== 0 && G1(e),
        kc.call(wz, r) ? wz[r](e, r, i) : cg(e, 'unknown document directive "' + r + '"')
    }
    if (Br(e, !0, -1),
    e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3,
    Br(e, !0, -1)) : o && Rt(e, "directives end mark is expected"),
    Ku(e, e.lineIndent - 1, iv, !1, !0),
    Br(e, !0, -1),
    e.checkLineBreaks && YMe.test(e.input.slice(t, e.position)) && cg(e, "non-ASCII line breaks are interpreted as content"),
    e.documents.push(e.result),
    e.position === e.lineStart && ay(e)) {
        e.input.charCodeAt(e.position) === 46 && (e.position += 3,
        Br(e, !0, -1));
        return
    }
    if (e.position < e.length - 1)
        Rt(e, "end of the stream or a document separator is expected");
    else
        return
}
U(DV, "readDocument");
function kM(e, t) {
    e = String(e),
    t = t || {},
    e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`),
    e.charCodeAt(0) === 65279 && (e = e.slice(1)));
    var n = new CV(e,t)
      , r = e.indexOf("\0");
    for (r !== -1 && (n.position = r,
    Rt(n, "null byte is not allowed in input")),
    n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
        n.lineIndent += 1,
        n.position += 1;
    for (; n.position < n.length - 1; )
        DV(n);
    return n.documents
}
U(kM, "loadDocuments");
function QMe(e, t, n) {
    t !== null && typeof t == "object" && typeof n > "u" && (n = t,
    t = null);
    var r = kM(e, n);
    if (typeof t != "function")
        return r;
    for (var i = 0, o = r.length; i < o; i += 1)
        t(r[i])
}
U(QMe, "loadAll$1");
function OV(e, t) {
    var n = kM(e, t);
    if (n.length !== 0) {
        if (n.length === 1)
            return n[0];
        throw new ho("expected a single document in the stream, but found more")
    }
}
U(OV, "load$1");
var KMe = OV
  , XMe = {
    load: KMe
}
  , IV = Object.prototype.toString
  , $V = Object.prototype.hasOwnProperty
  , TM = 65279
  , JMe = 9
  , ug = 10
  , ePe = 13
  , tPe = 32
  , nPe = 33
  , rPe = 34
  , g_ = 35
  , iPe = 37
  , oPe = 38
  , aPe = 39
  , sPe = 42
  , LV = 44
  , lPe = 45
  , ov = 58
  , cPe = 61
  , uPe = 62
  , dPe = 63
  , fPe = 64
  , jV = 91
  , BV = 93
  , hPe = 96
  , zV = 123
  , pPe = 124
  , FV = 125
  , Oi = {};
Oi[0] = "\\0";
Oi[7] = "\\a";
Oi[8] = "\\b";
Oi[9] = "\\t";
Oi[10] = "\\n";
Oi[11] = "\\v";
Oi[12] = "\\f";
Oi[13] = "\\r";
Oi[27] = "\\e";
Oi[34] = '\\"';
Oi[92] = "\\\\";
Oi[133] = "\\N";
Oi[160] = "\\_";
Oi[8232] = "\\L";
Oi[8233] = "\\P";
var mPe = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"]
  , gPe = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function NV(e, t) {
    var n, r, i, o, a, s, c;
    if (t === null)
        return {};
    for (n = {},
    r = Object.keys(t),
    i = 0,
    o = r.length; i < o; i += 1)
        a = r[i],
        s = String(t[a]),
        a.slice(0, 2) === "!!" && (a = "tag:yaml.org,2002:" + a.slice(2)),
        c = e.compiledTypeMap.fallback[a],
        c && $V.call(c.styleAliases, s) && (s = c.styleAliases[s]),
        n[a] = s;
    return n
}
U(NV, "compileStyleMap");
function UV(e) {
    var t, n, r;
    if (t = e.toString(16).toUpperCase(),
    e <= 255)
        n = "x",
        r = 2;
    else if (e <= 65535)
        n = "u",
        r = 4;
    else if (e <= 4294967295)
        n = "U",
        r = 8;
    else
        throw new ho("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + n + ii.repeat("0", r - t.length) + t
}
U(UV, "encodeHex");
var yPe = 1
  , dg = 2;
function VV(e) {
    this.schema = e.schema || dV,
    this.indent = Math.max(1, e.indent || 2),
    this.noArrayIndent = e.noArrayIndent || !1,
    this.skipInvalid = e.skipInvalid || !1,
    this.flowLevel = ii.isNothing(e.flowLevel) ? -1 : e.flowLevel,
    this.styleMap = NV(this.schema, e.styles || null),
    this.sortKeys = e.sortKeys || !1,
    this.lineWidth = e.lineWidth || 80,
    this.noRefs = e.noRefs || !1,
    this.noCompatMode = e.noCompatMode || !1,
    this.condenseFlow = e.condenseFlow || !1,
    this.quotingType = e.quotingType === '"' ? dg : yPe,
    this.forceQuotes = e.forceQuotes || !1,
    this.replacer = typeof e.replacer == "function" ? e.replacer : null,
    this.implicitTypes = this.schema.compiledImplicit,
    this.explicitTypes = this.schema.compiledExplicit,
    this.tag = null,
    this.result = "",
    this.duplicates = [],
    this.usedDuplicates = null
}
U(VV, "State");
function y_(e, t) {
    for (var n = ii.repeat(" ", t), r = 0, i = -1, o = "", a, s = e.length; r < s; )
        i = e.indexOf(`
`, r),
        i === -1 ? (a = e.slice(r),
        r = s) : (a = e.slice(r, i + 1),
        r = i + 1),
        a.length && a !== `
` && (o += n),
        o += a;
    return o
}
U(y_, "indentString");
function av(e, t) {
    return `
` + ii.repeat(" ", e.indent * t)
}
U(av, "generateNextLine");
function HV(e, t) {
    var n, r, i;
    for (n = 0,
    r = e.implicitTypes.length; n < r; n += 1)
        if (i = e.implicitTypes[n],
        i.resolve(t))
            return !0;
    return !1
}
U(HV, "testImplicitResolving");
function fg(e) {
    return e === tPe || e === JMe
}
U(fg, "isWhitespace");
function ih(e) {
    return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== TM || 65536 <= e && e <= 1114111
}
U(ih, "isPrintable");
function b_(e) {
    return ih(e) && e !== TM && e !== ePe && e !== ug
}
U(b_, "isNsCharOrWhitespace");
function x_(e, t, n) {
    var r = b_(e)
      , i = r && !fg(e);
    return (n ? r : r && e !== LV && e !== jV && e !== BV && e !== zV && e !== FV) && e !== g_ && !(t === ov && !i) || b_(t) && !fg(t) && e === g_ || t === ov && i
}
U(x_, "isPlainSafe");
function qV(e) {
    return ih(e) && e !== TM && !fg(e) && e !== lPe && e !== dPe && e !== ov && e !== LV && e !== jV && e !== BV && e !== zV && e !== FV && e !== g_ && e !== oPe && e !== sPe && e !== nPe && e !== pPe && e !== cPe && e !== uPe && e !== aPe && e !== rPe && e !== iPe && e !== fPe && e !== hPe
}
U(qV, "isPlainSafeFirst");
function WV(e) {
    return !fg(e) && e !== ov
}
U(WV, "isPlainSafeLast");
function mf(e, t) {
    var n = e.charCodeAt(t), r;
    return n >= 55296 && n <= 56319 && t + 1 < e.length && (r = e.charCodeAt(t + 1),
    r >= 56320 && r <= 57343) ? (n - 55296) * 1024 + r - 56320 + 65536 : n
}
U(mf, "codePointAt");
function _M(e) {
    var t = /^\n* /;
    return t.test(e)
}
U(_M, "needIndentIndicator");
var GV = 1
  , v_ = 2
  , YV = 3
  , ZV = 4
  , cf = 5;
function QV(e, t, n, r, i, o, a, s) {
    var c, u = 0, f = null, h = !1, m = !1, y = r !== -1, b = -1, v = qV(mf(e, 0)) && WV(mf(e, e.length - 1));
    if (t || a)
        for (c = 0; c < e.length; u >= 65536 ? c += 2 : c++) {
            if (u = mf(e, c),
            !ih(u))
                return cf;
            v = v && x_(u, f, s),
            f = u
        }
    else {
        for (c = 0; c < e.length; u >= 65536 ? c += 2 : c++) {
            if (u = mf(e, c),
            u === ug)
                h = !0,
                y && (m = m || c - b - 1 > r && e[b + 1] !== " ",
                b = c);
            else if (!ih(u))
                return cf;
            v = v && x_(u, f, s),
            f = u
        }
        m = m || y && c - b - 1 > r && e[b + 1] !== " "
    }
    return !h && !m ? v && !a && !i(e) ? GV : o === dg ? cf : v_ : n > 9 && _M(e) ? cf : a ? o === dg ? cf : v_ : m ? ZV : YV
}
U(QV, "chooseScalarStyle");
function KV(e, t, n, r, i) {
    e.dump = (function() {
        if (t.length === 0)
            return e.quotingType === dg ? '""' : "''";
        if (!e.noCompatMode && (mPe.indexOf(t) !== -1 || gPe.test(t)))
            return e.quotingType === dg ? '"' + t + '"' : "'" + t + "'";
        var o = e.indent * Math.max(1, n)
          , a = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - o)
          , s = r || e.flowLevel > -1 && n >= e.flowLevel;
        function c(u) {
            return HV(e, u)
        }
        switch (U(c, "testAmbiguity"),
        QV(t, s, e.indent, a, c, e.quotingType, e.forceQuotes && !r, i)) {
        case GV:
            return t;
        case v_:
            return "'" + t.replace(/'/g, "''") + "'";
        case YV:
            return "|" + S_(t, e.indent) + C_(y_(t, o));
        case ZV:
            return ">" + S_(t, e.indent) + C_(y_(XV(t, a), o));
        case cf:
            return '"' + JV(t) + '"';
        default:
            throw new ho("impossible error: invalid scalar style")
        }
    }
    )()
}
U(KV, "writeScalar");
function S_(e, t) {
    var n = _M(e) ? String(t) : ""
      , r = e[e.length - 1] === `
`
      , i = r && (e[e.length - 2] === `
` || e === `
`)
      , o = i ? "+" : r ? "" : "-";
    return n + o + `
`
}
U(S_, "blockHeader");
function C_(e) {
    return e[e.length - 1] === `
` ? e.slice(0, -1) : e
}
U(C_, "dropEndingNewline");
function XV(e, t) {
    for (var n = /(\n+)([^\n]*)/g, r = (function() {
        var u = e.indexOf(`
`);
        return u = u !== -1 ? u : e.length,
        n.lastIndex = u,
        w_(e.slice(0, u), t)
    }
    )(), i = e[0] === `
` || e[0] === " ", o, a; a = n.exec(e); ) {
        var s = a[1]
          , c = a[2];
        o = c[0] === " ",
        r += s + (!i && !o && c !== "" ? `
` : "") + w_(c, t),
        i = o
    }
    return r
}
U(XV, "foldString");
function w_(e, t) {
    if (e === "" || e[0] === " ")
        return e;
    for (var n = / [^ ]/g, r, i = 0, o, a = 0, s = 0, c = ""; r = n.exec(e); )
        s = r.index,
        s - i > t && (o = a > i ? a : s,
        c += `
` + e.slice(i, o),
        i = o + 1),
        a = s;
    return c += `
`,
    e.length - i > t && a > i ? c += e.slice(i, a) + `
` + e.slice(a + 1) : c += e.slice(i),
    c.slice(1)
}
U(w_, "foldLine");
function JV(e) {
    for (var t = "", n = 0, r, i = 0; i < e.length; n >= 65536 ? i += 2 : i++)
        n = mf(e, i),
        r = Oi[n],
        !r && ih(n) ? (t += e[i],
        n >= 65536 && (t += e[i + 1])) : t += r || UV(n);
    return t
}
U(JV, "escapeString");
function eH(e, t, n) {
    var r = "", i = e.tag, o, a, s;
    for (o = 0,
    a = n.length; o < a; o += 1)
        s = n[o],
        e.replacer && (s = e.replacer.call(n, String(o), s)),
        (Ms(e, t, s, !1, !1) || typeof s > "u" && Ms(e, t, null, !1, !1)) && (r !== "" && (r += "," + (e.condenseFlow ? "" : " ")),
        r += e.dump);
    e.tag = i,
    e.dump = "[" + r + "]"
}
U(eH, "writeFlowSequence");
function k_(e, t, n, r) {
    var i = "", o = e.tag, a, s, c;
    for (a = 0,
    s = n.length; a < s; a += 1)
        c = n[a],
        e.replacer && (c = e.replacer.call(n, String(a), c)),
        (Ms(e, t + 1, c, !0, !0, !1, !0) || typeof c > "u" && Ms(e, t + 1, null, !0, !0, !1, !0)) && ((!r || i !== "") && (i += av(e, t)),
        e.dump && ug === e.dump.charCodeAt(0) ? i += "-" : i += "- ",
        i += e.dump);
    e.tag = o,
    e.dump = i || "[]"
}
U(k_, "writeBlockSequence");
function tH(e, t, n) {
    var r = "", i = e.tag, o = Object.keys(n), a, s, c, u, f;
    for (a = 0,
    s = o.length; a < s; a += 1)
        f = "",
        r !== "" && (f += ", "),
        e.condenseFlow && (f += '"'),
        c = o[a],
        u = n[c],
        e.replacer && (u = e.replacer.call(n, c, u)),
        Ms(e, t, c, !1, !1) && (e.dump.length > 1024 && (f += "? "),
        f += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "),
        Ms(e, t, u, !1, !1) && (f += e.dump,
        r += f));
    e.tag = i,
    e.dump = "{" + r + "}"
}
U(tH, "writeFlowMapping");
function nH(e, t, n, r) {
    var i = "", o = e.tag, a = Object.keys(n), s, c, u, f, h, m;
    if (e.sortKeys === !0)
        a.sort();
    else if (typeof e.sortKeys == "function")
        a.sort(e.sortKeys);
    else if (e.sortKeys)
        throw new ho("sortKeys must be a boolean or a function");
    for (s = 0,
    c = a.length; s < c; s += 1)
        m = "",
        (!r || i !== "") && (m += av(e, t)),
        u = a[s],
        f = n[u],
        e.replacer && (f = e.replacer.call(n, u, f)),
        Ms(e, t + 1, u, !0, !0, !0) && (h = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024,
        h && (e.dump && ug === e.dump.charCodeAt(0) ? m += "?" : m += "? "),
        m += e.dump,
        h && (m += av(e, t)),
        Ms(e, t + 1, f, !0, h) && (e.dump && ug === e.dump.charCodeAt(0) ? m += ":" : m += ": ",
        m += e.dump,
        i += m));
    e.tag = o,
    e.dump = i || "{}"
}
U(nH, "writeBlockMapping");
function T_(e, t, n) {
    var r, i, o, a, s, c;
    for (i = n ? e.explicitTypes : e.implicitTypes,
    o = 0,
    a = i.length; o < a; o += 1)
        if (s = i[o],
        (s.instanceOf || s.predicate) && (!s.instanceOf || typeof t == "object" && t instanceof s.instanceOf) && (!s.predicate || s.predicate(t))) {
            if (n ? s.multi && s.representName ? e.tag = s.representName(t) : e.tag = s.tag : e.tag = "?",
            s.represent) {
                if (c = e.styleMap[s.tag] || s.defaultStyle,
                IV.call(s.represent) === "[object Function]")
                    r = s.represent(t, c);
                else if ($V.call(s.represent, c))
                    r = s.represent[c](t, c);
                else
                    throw new ho("!<" + s.tag + '> tag resolver accepts not "' + c + '" style');
                e.dump = r
            }
            return !0
        }
    return !1
}
U(T_, "detectType");
function Ms(e, t, n, r, i, o, a) {
    e.tag = null,
    e.dump = n,
    T_(e, n, !1) || T_(e, n, !0);
    var s = IV.call(e.dump), c = r, u;
    r && (r = e.flowLevel < 0 || e.flowLevel > t);
    var f = s === "[object Object]" || s === "[object Array]", h, m;
    if (f && (h = e.duplicates.indexOf(n),
    m = h !== -1),
    (e.tag !== null && e.tag !== "?" || m || e.indent !== 2 && t > 0) && (i = !1),
    m && e.usedDuplicates[h])
        e.dump = "*ref_" + h;
    else {
        if (f && m && !e.usedDuplicates[h] && (e.usedDuplicates[h] = !0),
        s === "[object Object]")
            r && Object.keys(e.dump).length !== 0 ? (nH(e, t, e.dump, i),
            m && (e.dump = "&ref_" + h + e.dump)) : (tH(e, t, e.dump),
            m && (e.dump = "&ref_" + h + " " + e.dump));
        else if (s === "[object Array]")
            r && e.dump.length !== 0 ? (e.noArrayIndent && !a && t > 0 ? k_(e, t - 1, e.dump, i) : k_(e, t, e.dump, i),
            m && (e.dump = "&ref_" + h + e.dump)) : (eH(e, t, e.dump),
            m && (e.dump = "&ref_" + h + " " + e.dump));
        else if (s === "[object String]")
            e.tag !== "?" && KV(e, e.dump, t, o, c);
        else {
            if (s === "[object Undefined]")
                return !1;
            if (e.skipInvalid)
                return !1;
            throw new ho("unacceptable kind of an object to dump " + s)
        }
        e.tag !== null && e.tag !== "?" && (u = encodeURI(e.tag[0] === "!" ? e.tag.slice(1) : e.tag).replace(/!/g, "%21"),
        e.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">",
        e.dump = u + " " + e.dump)
    }
    return !0
}
U(Ms, "writeNode");
function rH(e, t) {
    var n = [], r = [], i, o;
    for (sv(e, n, r),
    i = 0,
    o = r.length; i < o; i += 1)
        t.duplicates.push(n[r[i]]);
    t.usedDuplicates = new Array(o)
}
U(rH, "getDuplicateReferences");
function sv(e, t, n) {
    var r, i, o;
    if (e !== null && typeof e == "object")
        if (i = t.indexOf(e),
        i !== -1)
            n.indexOf(i) === -1 && n.push(i);
        else if (t.push(e),
        Array.isArray(e))
            for (i = 0,
            o = e.length; i < o; i += 1)
                sv(e[i], t, n);
        else
            for (r = Object.keys(e),
            i = 0,
            o = r.length; i < o; i += 1)
                sv(e[r[i]], t, n)
}
U(sv, "inspectNode");
function bPe(e, t) {
    t = t || {};
    var n = new VV(t);
    n.noRefs || rH(e, n);
    var r = e;
    return n.replacer && (r = n.replacer.call({
        "": r
    }, "", r)),
    Ms(n, 0, r, !0, !0) ? n.dump + `
` : ""
}
U(bPe, "dump$1");
function xPe(e, t) {
    return function() {
        throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.")
    }
}
U(xPe, "renamed");
var vPe = YU
  , SPe = XMe.load;
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
var _i = {
    aggregation: 17.25,
    extension: 17.25,
    composition: 17.25,
    dependency: 6,
    lollipop: 13.5,
    arrow_point: 4
}
  , kz = {
    arrow_point: 9,
    arrow_cross: 12.5,
    arrow_circle: 12.5
};
function om(e, t) {
    if (e === void 0 || t === void 0)
        return {
            angle: 0,
            deltaX: 0,
            deltaY: 0
        };
    e = br(e),
    t = br(t);
    const [n,r] = [e.x, e.y]
      , [i,o] = [t.x, t.y]
      , a = i - n
      , s = o - r;
    return {
        angle: Math.atan(s / a),
        deltaX: a,
        deltaY: s
    }
}
U(om, "calculateDeltaAndAngle");
var br = U(e => Array.isArray(e) ? {
    x: e[0],
    y: e[1]
} : e, "pointTransformer"), CPe = U(e => ({
    x: U(function(t, n, r) {
        let i = 0;
        const o = br(r[0]).x < br(r[r.length - 1]).x ? "left" : "right";
        if (n === 0 && Object.hasOwn(_i, e.arrowTypeStart)) {
            const {angle: y, deltaX: b} = om(r[0], r[1]);
            i = _i[e.arrowTypeStart] * Math.cos(y) * (b >= 0 ? 1 : -1)
        } else if (n === r.length - 1 && Object.hasOwn(_i, e.arrowTypeEnd)) {
            const {angle: y, deltaX: b} = om(r[r.length - 1], r[r.length - 2]);
            i = _i[e.arrowTypeEnd] * Math.cos(y) * (b >= 0 ? 1 : -1)
        }
        const a = Math.abs(br(t).x - br(r[r.length - 1]).x)
          , s = Math.abs(br(t).y - br(r[r.length - 1]).y)
          , c = Math.abs(br(t).x - br(r[0]).x)
          , u = Math.abs(br(t).y - br(r[0]).y)
          , f = _i[e.arrowTypeStart]
          , h = _i[e.arrowTypeEnd]
          , m = 1;
        if (a < h && a > 0 && s < h) {
            let y = h + m - a;
            y *= o === "right" ? -1 : 1,
            i -= y
        }
        if (c < f && c > 0 && u < f) {
            let y = f + m - c;
            y *= o === "right" ? -1 : 1,
            i += y
        }
        return br(t).x + i
    }, "x"),
    y: U(function(t, n, r) {
        let i = 0;
        const o = br(r[0]).y < br(r[r.length - 1]).y ? "down" : "up";
        if (n === 0 && Object.hasOwn(_i, e.arrowTypeStart)) {
            const {angle: y, deltaY: b} = om(r[0], r[1]);
            i = _i[e.arrowTypeStart] * Math.abs(Math.sin(y)) * (b >= 0 ? 1 : -1)
        } else if (n === r.length - 1 && Object.hasOwn(_i, e.arrowTypeEnd)) {
            const {angle: y, deltaY: b} = om(r[r.length - 1], r[r.length - 2]);
            i = _i[e.arrowTypeEnd] * Math.abs(Math.sin(y)) * (b >= 0 ? 1 : -1)
        }
        const a = Math.abs(br(t).y - br(r[r.length - 1]).y)
          , s = Math.abs(br(t).x - br(r[r.length - 1]).x)
          , c = Math.abs(br(t).y - br(r[0]).y)
          , u = Math.abs(br(t).x - br(r[0]).x)
          , f = _i[e.arrowTypeStart]
          , h = _i[e.arrowTypeEnd]
          , m = 1;
        if (a < h && a > 0 && s < h) {
            let y = h + m - a;
            y *= o === "up" ? -1 : 1,
            i -= y
        }
        if (c < f && c > 0 && u < f) {
            let y = f + m - c;
            y *= o === "up" ? -1 : 1,
            i += y
        }
        return br(t).y + i
    }, "y")
}), "getLineFunctionsWithOffset"), EM = U( ({flowchart: e}) => {
    const t = e?.subGraphTitleMargin?.top ?? 0
      , n = e?.subGraphTitleMargin?.bottom ?? 0
      , r = t + n;
    return {
        subGraphTitleTopMargin: t,
        subGraphTitleBottomMargin: n,
        subGraphTitleTotalMargin: r
    }
}
, "getSubGraphTitleMargins"), wPe = U(e => {
    const {handDrawnSeed: t} = Vn();
    return {
        fill: e,
        hachureAngle: 120,
        hachureGap: 4,
        fillWeight: 2,
        roughness: .7,
        stroke: e,
        seed: t
    }
}
, "solidStateFill"), Sh = U(e => {
    const t = kPe([...e.cssCompiledStyles || [], ...e.cssStyles || [], ...e.labelStyle || []]);
    return {
        stylesMap: t,
        stylesArray: [...t]
    }
}
, "compileStyles"), kPe = U(e => {
    const t = new Map;
    return e.forEach(n => {
        const [r,i] = n.split(":");
        t.set(r.trim(), i?.trim())
    }
    ),
    t
}
, "styles2Map"), iH = U(e => e === "color" || e === "font-size" || e === "font-family" || e === "font-weight" || e === "font-style" || e === "text-decoration" || e === "text-align" || e === "text-transform" || e === "line-height" || e === "letter-spacing" || e === "word-spacing" || e === "text-shadow" || e === "text-overflow" || e === "white-space" || e === "word-wrap" || e === "word-break" || e === "overflow-wrap" || e === "hyphens", "isLabelStyle"), kt = U(e => {
    const {stylesArray: t} = Sh(e)
      , n = []
      , r = []
      , i = []
      , o = [];
    return t.forEach(a => {
        const s = a[0];
        iH(s) ? n.push(a.join(":") + " !important") : (r.push(a.join(":") + " !important"),
        s.includes("stroke") && i.push(a.join(":") + " !important"),
        s === "fill" && o.push(a.join(":") + " !important"))
    }
    ),
    {
        labelStyles: n.join(";"),
        nodeStyles: r.join(";"),
        stylesArray: t,
        borderStyles: i,
        backgroundStyles: o
    }
}
, "styles2String"), wt = U( (e, t) => {
    const {themeVariables: n, handDrawnSeed: r} = Vn()
      , {nodeBorder: i, mainBkg: o} = n
      , {stylesMap: a} = Sh(e);
    return Object.assign({
        roughness: .7,
        fill: a.get("fill") || o,
        fillStyle: "hachure",
        fillWeight: 4,
        hachureGap: 5.2,
        stroke: a.get("stroke") || i,
        seed: r,
        strokeWidth: a.get("stroke-width")?.replace("px", "") || 1.3,
        fillLineDash: [0, 0],
        strokeLineDash: TPe(a.get("stroke-dasharray"))
    }, t)
}
, "userNodeOverrides"), TPe = U(e => {
    if (!e)
        return [0, 0];
    const t = e.trim().split(/\s+/).map(Number);
    if (t.length === 1) {
        const i = isNaN(t[0]) ? 0 : t[0];
        return [i, i]
    }
    const n = isNaN(t[0]) ? 0 : t[0]
      , r = isNaN(t[1]) ? 0 : t[1];
    return [n, r]
}
, "getStrokeDashArray"), zp = {}, ti = {}, Tz;
function _Pe() {
    return Tz || (Tz = 1,
    Object.defineProperty(ti, "__esModule", {
        value: !0
    }),
    ti.BLANK_URL = ti.relativeFirstCharacters = ti.whitespaceEscapeCharsRegex = ti.urlSchemeRegex = ti.ctrlCharactersRegex = ti.htmlCtrlEntityRegex = ti.htmlEntitiesRegex = ti.invalidProtocolRegex = void 0,
    ti.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im,
    ti.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g,
    ti.htmlCtrlEntityRegex = /&(newline|tab);/gi,
    ti.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim,
    ti.urlSchemeRegex = /^.+(:|&colon;)/gim,
    ti.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g,
    ti.relativeFirstCharacters = [".", "/"],
    ti.BLANK_URL = "about:blank"),
    ti
}
var _z;
function EPe() {
    if (_z)
        return zp;
    _z = 1,
    Object.defineProperty(zp, "__esModule", {
        value: !0
    }),
    zp.sanitizeUrl = void 0;
    var e = _Pe();
    function t(a) {
        return e.relativeFirstCharacters.indexOf(a[0]) > -1
    }
    function n(a) {
        var s = a.replace(e.ctrlCharactersRegex, "");
        return s.replace(e.htmlEntitiesRegex, function(c, u) {
            return String.fromCharCode(u)
        })
    }
    function r(a) {
        return URL.canParse(a)
    }
    function i(a) {
        try {
            return decodeURIComponent(a)
        } catch {
            return a
        }
    }
    function o(a) {
        if (!a)
            return e.BLANK_URL;
        var s, c = i(a.trim());
        do
            c = n(c).replace(e.htmlCtrlEntityRegex, "").replace(e.ctrlCharactersRegex, "").replace(e.whitespaceEscapeCharsRegex, "").trim(),
            c = i(c),
            s = c.match(e.ctrlCharactersRegex) || c.match(e.htmlEntitiesRegex) || c.match(e.htmlCtrlEntityRegex) || c.match(e.whitespaceEscapeCharsRegex);
        while (s && s.length > 0);
        var u = c;
        if (!u)
            return e.BLANK_URL;
        if (t(u))
            return u;
        var f = u.trimStart()
          , h = f.match(e.urlSchemeRegex);
        if (!h)
            return u;
        var m = h[0].toLowerCase().trim();
        if (e.invalidProtocolRegex.test(m))
            return e.BLANK_URL;
        var y = f.replace(/\\/g, "/");
        if (m === "mailto:" || m.includes("://"))
            return y;
        if (m === "http:" || m === "https:") {
            if (!r(y))
                return e.BLANK_URL;
            var b = new URL(y);
            return b.protocol = b.protocol.toLowerCase(),
            b.hostname = b.hostname.toLowerCase(),
            b.toString()
        }
        return y
    }
    return zp.sanitizeUrl = o,
    zp
}
var APe = EPe()
  , oH = typeof global == "object" && global && global.Object === Object && global
  , MPe = typeof self == "object" && self && self.Object === Object && self
  , js = oH || MPe || Function("return this")()
  , lv = js.Symbol
  , aH = Object.prototype
  , PPe = aH.hasOwnProperty
  , RPe = aH.toString
  , Fp = lv ? lv.toStringTag : void 0;
function DPe(e) {
    var t = PPe.call(e, Fp)
      , n = e[Fp];
    try {
        e[Fp] = void 0;
        var r = !0
    } catch {}
    var i = RPe.call(e);
    return r && (t ? e[Fp] = n : delete e[Fp]),
    i
}
var OPe = Object.prototype
  , IPe = OPe.toString;
function $Pe(e) {
    return IPe.call(e)
}
var LPe = "[object Null]"
  , jPe = "[object Undefined]"
  , Ez = lv ? lv.toStringTag : void 0;
function Ch(e) {
    return e == null ? e === void 0 ? jPe : LPe : Ez && Ez in Object(e) ? DPe(e) : $Pe(e)
}
function ad(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function")
}
var BPe = "[object AsyncFunction]"
  , zPe = "[object Function]"
  , FPe = "[object GeneratorFunction]"
  , NPe = "[object Proxy]";
function AM(e) {
    if (!ad(e))
        return !1;
    var t = Ch(e);
    return t == zPe || t == FPe || t == BPe || t == NPe
}
var n2 = js["__core-js_shared__"]
  , Az = (function() {
    var e = /[^.]+$/.exec(n2 && n2.keys && n2.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : ""
}
)();
function UPe(e) {
    return !!Az && Az in e
}
var VPe = Function.prototype
  , HPe = VPe.toString;
function sd(e) {
    if (e != null) {
        try {
            return HPe.call(e)
        } catch {}
        try {
            return e + ""
        } catch {}
    }
    return ""
}
var qPe = /[\\^$.*+?()[\]{}|]/g
  , WPe = /^\[object .+?Constructor\]$/
  , GPe = Function.prototype
  , YPe = Object.prototype
  , ZPe = GPe.toString
  , QPe = YPe.hasOwnProperty
  , KPe = RegExp("^" + ZPe.call(QPe).replace(qPe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function XPe(e) {
    if (!ad(e) || UPe(e))
        return !1;
    var t = AM(e) ? KPe : WPe;
    return t.test(sd(e))
}
function JPe(e, t) {
    return e?.[t]
}
function ld(e, t) {
    var n = JPe(e, t);
    return XPe(n) ? n : void 0
}
var hg = ld(Object, "create");
function eRe() {
    this.__data__ = hg ? hg(null) : {},
    this.size = 0
}
function tRe(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0,
    t
}
var nRe = "__lodash_hash_undefined__"
  , rRe = Object.prototype
  , iRe = rRe.hasOwnProperty;
function oRe(e) {
    var t = this.__data__;
    if (hg) {
        var n = t[e];
        return n === nRe ? void 0 : n
    }
    return iRe.call(t, e) ? t[e] : void 0
}
var aRe = Object.prototype
  , sRe = aRe.hasOwnProperty;
function lRe(e) {
    var t = this.__data__;
    return hg ? t[e] !== void 0 : sRe.call(t, e)
}
var cRe = "__lodash_hash_undefined__";
function uRe(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1,
    n[e] = hg && t === void 0 ? cRe : t,
    this
}
function Xu(e) {
    var t = -1
      , n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
Xu.prototype.clear = eRe;
Xu.prototype.delete = tRe;
Xu.prototype.get = oRe;
Xu.prototype.has = lRe;
Xu.prototype.set = uRe;
function dRe() {
    this.__data__ = [],
    this.size = 0
}
function Z1(e, t) {
    return e === t || e !== e && t !== t
}
function Q1(e, t) {
    for (var n = e.length; n--; )
        if (Z1(e[n][0], t))
            return n;
    return -1
}
var fRe = Array.prototype
  , hRe = fRe.splice;
function pRe(e) {
    var t = this.__data__
      , n = Q1(t, e);
    if (n < 0)
        return !1;
    var r = t.length - 1;
    return n == r ? t.pop() : hRe.call(t, n, 1),
    --this.size,
    !0
}
function mRe(e) {
    var t = this.__data__
      , n = Q1(t, e);
    return n < 0 ? void 0 : t[n][1]
}
function gRe(e) {
    return Q1(this.__data__, e) > -1
}
function yRe(e, t) {
    var n = this.__data__
      , r = Q1(n, e);
    return r < 0 ? (++this.size,
    n.push([e, t])) : n[r][1] = t,
    this
}
function Ml(e) {
    var t = -1
      , n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
Ml.prototype.clear = dRe;
Ml.prototype.delete = pRe;
Ml.prototype.get = mRe;
Ml.prototype.has = gRe;
Ml.prototype.set = yRe;
var pg = ld(js, "Map");
function bRe() {
    this.size = 0,
    this.__data__ = {
        hash: new Xu,
        map: new (pg || Ml),
        string: new Xu
    }
}
function xRe(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
}
function K1(e, t) {
    var n = e.__data__;
    return xRe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map
}
function vRe(e) {
    var t = K1(this, e).delete(e);
    return this.size -= t ? 1 : 0,
    t
}
function SRe(e) {
    return K1(this, e).get(e)
}
function CRe(e) {
    return K1(this, e).has(e)
}
function wRe(e, t) {
    var n = K1(this, e)
      , r = n.size;
    return n.set(e, t),
    this.size += n.size == r ? 0 : 1,
    this
}
function $c(e) {
    var t = -1
      , n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
$c.prototype.clear = bRe;
$c.prototype.delete = vRe;
$c.prototype.get = SRe;
$c.prototype.has = CRe;
$c.prototype.set = wRe;
var kRe = "Expected a function";
function sy(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
        throw new TypeError(kRe);
    var n = function() {
        var r = arguments
          , i = t ? t.apply(this, r) : r[0]
          , o = n.cache;
        if (o.has(i))
            return o.get(i);
        var a = e.apply(this, r);
        return n.cache = o.set(i, a) || o,
        a
    };
    return n.cache = new (sy.Cache || $c),
    n
}
sy.Cache = $c;
function TRe() {
    this.__data__ = new Ml,
    this.size = 0
}
function _Re(e) {
    var t = this.__data__
      , n = t.delete(e);
    return this.size = t.size,
    n
}
function ERe(e) {
    return this.__data__.get(e)
}
function ARe(e) {
    return this.__data__.has(e)
}
var MRe = 200;
function PRe(e, t) {
    var n = this.__data__;
    if (n instanceof Ml) {
        var r = n.__data__;
        if (!pg || r.length < MRe - 1)
            return r.push([e, t]),
            this.size = ++n.size,
            this;
        n = this.__data__ = new $c(r)
    }
    return n.set(e, t),
    this.size = n.size,
    this
}
function wh(e) {
    var t = this.__data__ = new Ml(e);
    this.size = t.size
}
wh.prototype.clear = TRe;
wh.prototype.delete = _Re;
wh.prototype.get = ERe;
wh.prototype.has = ARe;
wh.prototype.set = PRe;
var cv = (function() {
    try {
        var e = ld(Object, "defineProperty");
        return e({}, "", {}),
        e
    } catch {}
}
)();
function MM(e, t, n) {
    t == "__proto__" && cv ? cv(e, t, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
    }) : e[t] = n
}
function __(e, t, n) {
    (n !== void 0 && !Z1(e[t], n) || n === void 0 && !(t in e)) && MM(e, t, n)
}
function RRe(e) {
    return function(t, n, r) {
        for (var i = -1, o = Object(t), a = r(t), s = a.length; s--; ) {
            var c = a[++i];
            if (n(o[c], c, o) === !1)
                break
        }
        return t
    }
}
var DRe = RRe()
  , sH = typeof exports == "object" && exports && !exports.nodeType && exports
  , Mz = sH && typeof module == "object" && module && !module.nodeType && module
  , ORe = Mz && Mz.exports === sH
  , Pz = ORe ? js.Buffer : void 0
  , Rz = Pz ? Pz.allocUnsafe : void 0;
function IRe(e, t) {
    if (t)
        return e.slice();
    var n = e.length
      , r = Rz ? Rz(n) : new e.constructor(n);
    return e.copy(r),
    r
}
var Dz = js.Uint8Array;
function $Re(e) {
    var t = new e.constructor(e.byteLength);
    return new Dz(t).set(new Dz(e)),
    t
}
function LRe(e, t) {
    var n = t ? $Re(e.buffer) : e.buffer;
    return new e.constructor(n,e.byteOffset,e.length)
}
function jRe(e, t) {
    var n = -1
      , r = e.length;
    for (t || (t = Array(r)); ++n < r; )
        t[n] = e[n];
    return t
}
var Oz = Object.create
  , BRe = (function() {
    function e() {}
    return function(t) {
        if (!ad(t))
            return {};
        if (Oz)
            return Oz(t);
        e.prototype = t;
        var n = new e;
        return e.prototype = void 0,
        n
    }
}
)();
function lH(e, t) {
    return function(n) {
        return e(t(n))
    }
}
var cH = lH(Object.getPrototypeOf, Object)
  , zRe = Object.prototype;
function X1(e) {
    var t = e && e.constructor
      , n = typeof t == "function" && t.prototype || zRe;
    return e === n
}
function FRe(e) {
    return typeof e.constructor == "function" && !X1(e) ? BRe(cH(e)) : {}
}
function ly(e) {
    return e != null && typeof e == "object"
}
var NRe = "[object Arguments]";
function Iz(e) {
    return ly(e) && Ch(e) == NRe
}
var uH = Object.prototype
  , URe = uH.hasOwnProperty
  , VRe = uH.propertyIsEnumerable
  , uv = Iz((function() {
    return arguments
}
)()) ? Iz : function(e) {
    return ly(e) && URe.call(e, "callee") && !VRe.call(e, "callee")
}
  , dv = Array.isArray
  , HRe = 9007199254740991;
function dH(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= HRe
}
function J1(e) {
    return e != null && dH(e.length) && !AM(e)
}
function qRe(e) {
    return ly(e) && J1(e)
}
function WRe() {
    return !1
}
var fH = typeof exports == "object" && exports && !exports.nodeType && exports
  , $z = fH && typeof module == "object" && module && !module.nodeType && module
  , GRe = $z && $z.exports === fH
  , Lz = GRe ? js.Buffer : void 0
  , YRe = Lz ? Lz.isBuffer : void 0
  , PM = YRe || WRe
  , ZRe = "[object Object]"
  , QRe = Function.prototype
  , KRe = Object.prototype
  , hH = QRe.toString
  , XRe = KRe.hasOwnProperty
  , JRe = hH.call(Object);
function eDe(e) {
    if (!ly(e) || Ch(e) != ZRe)
        return !1;
    var t = cH(e);
    if (t === null)
        return !0;
    var n = XRe.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && hH.call(n) == JRe
}
var tDe = "[object Arguments]"
  , nDe = "[object Array]"
  , rDe = "[object Boolean]"
  , iDe = "[object Date]"
  , oDe = "[object Error]"
  , aDe = "[object Function]"
  , sDe = "[object Map]"
  , lDe = "[object Number]"
  , cDe = "[object Object]"
  , uDe = "[object RegExp]"
  , dDe = "[object Set]"
  , fDe = "[object String]"
  , hDe = "[object WeakMap]"
  , pDe = "[object ArrayBuffer]"
  , mDe = "[object DataView]"
  , gDe = "[object Float32Array]"
  , yDe = "[object Float64Array]"
  , bDe = "[object Int8Array]"
  , xDe = "[object Int16Array]"
  , vDe = "[object Int32Array]"
  , SDe = "[object Uint8Array]"
  , CDe = "[object Uint8ClampedArray]"
  , wDe = "[object Uint16Array]"
  , kDe = "[object Uint32Array]"
  , dr = {};
dr[gDe] = dr[yDe] = dr[bDe] = dr[xDe] = dr[vDe] = dr[SDe] = dr[CDe] = dr[wDe] = dr[kDe] = !0;
dr[tDe] = dr[nDe] = dr[pDe] = dr[rDe] = dr[mDe] = dr[iDe] = dr[oDe] = dr[aDe] = dr[sDe] = dr[lDe] = dr[cDe] = dr[uDe] = dr[dDe] = dr[fDe] = dr[hDe] = !1;
function TDe(e) {
    return ly(e) && dH(e.length) && !!dr[Ch(e)]
}
function _De(e) {
    return function(t) {
        return e(t)
    }
}
var pH = typeof exports == "object" && exports && !exports.nodeType && exports
  , Om = pH && typeof module == "object" && module && !module.nodeType && module
  , EDe = Om && Om.exports === pH
  , r2 = EDe && oH.process
  , jz = (function() {
    try {
        var e = Om && Om.require && Om.require("util").types;
        return e || r2 && r2.binding && r2.binding("util")
    } catch {}
}
)()
  , Bz = jz && jz.isTypedArray
  , RM = Bz ? _De(Bz) : TDe;
function E_(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
        return e[t]
}
var ADe = Object.prototype
  , MDe = ADe.hasOwnProperty;
function PDe(e, t, n) {
    var r = e[t];
    (!(MDe.call(e, t) && Z1(r, n)) || n === void 0 && !(t in e)) && MM(e, t, n)
}
function RDe(e, t, n, r) {
    var i = !n;
    n || (n = {});
    for (var o = -1, a = t.length; ++o < a; ) {
        var s = t[o]
          , c = void 0;
        c === void 0 && (c = e[s]),
        i ? MM(n, s, c) : PDe(n, s, c)
    }
    return n
}
function DDe(e, t) {
    for (var n = -1, r = Array(e); ++n < e; )
        r[n] = t(n);
    return r
}
var ODe = 9007199254740991
  , IDe = /^(?:0|[1-9]\d*)$/;
function mH(e, t) {
    var n = typeof e;
    return t = t ?? ODe,
    !!t && (n == "number" || n != "symbol" && IDe.test(e)) && e > -1 && e % 1 == 0 && e < t
}
var $De = Object.prototype
  , LDe = $De.hasOwnProperty;
function jDe(e, t) {
    var n = dv(e)
      , r = !n && uv(e)
      , i = !n && !r && PM(e)
      , o = !n && !r && !i && RM(e)
      , a = n || r || i || o
      , s = a ? DDe(e.length, String) : []
      , c = s.length;
    for (var u in e)
        (t || LDe.call(e, u)) && !(a && (u == "length" || i && (u == "offset" || u == "parent") || o && (u == "buffer" || u == "byteLength" || u == "byteOffset") || mH(u, c))) && s.push(u);
    return s
}
function BDe(e) {
    var t = [];
    if (e != null)
        for (var n in Object(e))
            t.push(n);
    return t
}
var zDe = Object.prototype
  , FDe = zDe.hasOwnProperty;
function NDe(e) {
    if (!ad(e))
        return BDe(e);
    var t = X1(e)
      , n = [];
    for (var r in e)
        r == "constructor" && (t || !FDe.call(e, r)) || n.push(r);
    return n
}
function gH(e) {
    return J1(e) ? jDe(e, !0) : NDe(e)
}
function UDe(e) {
    return RDe(e, gH(e))
}
function VDe(e, t, n, r, i, o, a) {
    var s = E_(e, n)
      , c = E_(t, n)
      , u = a.get(c);
    if (u) {
        __(e, n, u);
        return
    }
    var f = o ? o(s, c, n + "", e, t, a) : void 0
      , h = f === void 0;
    if (h) {
        var m = dv(c)
          , y = !m && PM(c)
          , b = !m && !y && RM(c);
        f = c,
        m || y || b ? dv(s) ? f = s : qRe(s) ? f = jRe(s) : y ? (h = !1,
        f = IRe(c, !0)) : b ? (h = !1,
        f = LRe(c, !0)) : f = [] : eDe(c) || uv(c) ? (f = s,
        uv(s) ? f = UDe(s) : (!ad(s) || AM(s)) && (f = FRe(c))) : h = !1
    }
    h && (a.set(c, f),
    i(f, c, r, o, a),
    a.delete(c)),
    __(e, n, f)
}
function yH(e, t, n, r, i) {
    e !== t && DRe(t, function(o, a) {
        if (i || (i = new wh),
        ad(o))
            VDe(e, t, a, n, yH, r, i);
        else {
            var s = r ? r(E_(e, a), o, a + "", e, t, i) : void 0;
            s === void 0 && (s = o),
            __(e, a, s)
        }
    }, gH)
}
function bH(e) {
    return e
}
function HDe(e, t, n) {
    switch (n.length) {
    case 0:
        return e.call(t);
    case 1:
        return e.call(t, n[0]);
    case 2:
        return e.call(t, n[0], n[1]);
    case 3:
        return e.call(t, n[0], n[1], n[2])
    }
    return e.apply(t, n)
}
var zz = Math.max;
function qDe(e, t, n) {
    return t = zz(t === void 0 ? e.length - 1 : t, 0),
    function() {
        for (var r = arguments, i = -1, o = zz(r.length - t, 0), a = Array(o); ++i < o; )
            a[i] = r[t + i];
        i = -1;
        for (var s = Array(t + 1); ++i < t; )
            s[i] = r[i];
        return s[t] = n(a),
        HDe(e, this, s)
    }
}
function WDe(e) {
    return function() {
        return e
    }
}
var GDe = cv ? function(e, t) {
    return cv(e, "toString", {
        configurable: !0,
        enumerable: !1,
        value: WDe(t),
        writable: !0
    })
}
: bH
  , YDe = 800
  , ZDe = 16
  , QDe = Date.now;
function KDe(e) {
    var t = 0
      , n = 0;
    return function() {
        var r = QDe()
          , i = ZDe - (r - n);
        if (n = r,
        i > 0) {
            if (++t >= YDe)
                return arguments[0]
        } else
            t = 0;
        return e.apply(void 0, arguments)
    }
}
var XDe = KDe(GDe);
function JDe(e, t) {
    return XDe(qDe(e, t, bH), e + "")
}
function eOe(e, t, n) {
    if (!ad(n))
        return !1;
    var r = typeof t;
    return (r == "number" ? J1(n) && mH(t, n.length) : r == "string" && t in n) ? Z1(n[t], e) : !1
}
function tOe(e) {
    return JDe(function(t, n) {
        var r = -1
          , i = n.length
          , o = i > 1 ? n[i - 1] : void 0
          , a = i > 2 ? n[2] : void 0;
        for (o = e.length > 3 && typeof o == "function" ? (i--,
        o) : void 0,
        a && eOe(n[0], n[1], a) && (o = i < 3 ? void 0 : o,
        i = 1),
        t = Object(t); ++r < i; ) {
            var s = n[r];
            s && e(t, s, r, o)
        }
        return t
    })
}
var nOe = tOe(function(e, t, n) {
    yH(e, t, n)
})
  , rOe = ""
  , iOe = {
    curveBasis: Wx,
    curveBasisClosed: aMe,
    curveBasisOpen: sMe,
    curveBumpX: rU,
    curveBumpY: iU,
    curveBundle: lMe,
    curveCardinalClosed: cMe,
    curveCardinalOpen: uMe,
    curveCardinal: lU,
    curveCatmullRomClosed: dMe,
    curveCatmullRomOpen: fMe,
    curveCatmullRom: uU,
    curveLinear: X0,
    curveLinearClosed: hMe,
    curveMonotoneX: gU,
    curveMonotoneY: yU,
    curveNatural: xU,
    curveStep: vU,
    curveStepAfter: CU,
    curveStepBefore: SU
}
  , oOe = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi
  , aOe = U(function(e, t) {
    const n = xH(e, /(?:init\b)|(?:initialize\b)/);
    let r = {};
    if (Array.isArray(n)) {
        const a = n.map(s => s.args);
        N0(a),
        r = ri(r, [...a])
    } else
        r = n.args;
    if (!r)
        return;
    let i = tM(e, t);
    const o = "config";
    return r[o] !== void 0 && (i === "flowchart-v2" && (i = "flowchart"),
    r[i] = r[o],
    delete r[o]),
    r
}, "detectInit")
  , xH = U(function(e, t=null) {
    try {
        const n = new RegExp(`[%]{2}(?![{]${oOe.source})(?=[}][%]{2}).*
`,"ig");
        e = e.trim().replace(n, "").replace(/'/gm, '"'),
        Qe.debug(`Detecting diagram directive${t !== null ? " type:" + t : ""} based on the text:${e}`);
        let r;
        const i = [];
        for (; (r = Rm.exec(e)) !== null; )
            if (r.index === Rm.lastIndex && Rm.lastIndex++,
            r && !t || t && r[1]?.match(t) || t && r[2]?.match(t)) {
                const o = r[1] ? r[1] : r[2]
                  , a = r[3] ? r[3].trim() : r[4] ? JSON.parse(r[4].trim()) : null;
                i.push({
                    type: o,
                    args: a
                })
            }
        return i.length === 0 ? {
            type: e,
            args: null
        } : i.length === 1 ? i[0] : i
    } catch (n) {
        return Qe.error(`ERROR: ${n.message} - Unable to parse directive type: '${t}' based on the text: '${e}'`),
        {
            type: void 0,
            args: null
        }
    }
}, "detectDirective")
  , sOe = U(function(e) {
    return e.replace(Rm, "")
}, "removeDirectives")
  , lOe = U(function(e, t) {
    for (const [n,r] of t.entries())
        if (r.match(e))
            return n;
    return -1
}, "isSubstringInArray");
function DM(e, t) {
    if (!e)
        return t;
    const n = `curve${e.charAt(0).toUpperCase() + e.slice(1)}`;
    return iOe[n] ?? t
}
U(DM, "interpolateToCurve");
function vH(e, t) {
    const n = e.trim();
    if (n)
        return t.securityLevel !== "loose" ? APe.sanitizeUrl(n) : n
}
U(vH, "formatUrl");
var cOe = U( (e, ...t) => {
    const n = e.split(".")
      , r = n.length - 1
      , i = n[r];
    let o = window;
    for (let a = 0; a < r; a++)
        if (o = o[n[a]],
        !o) {
            Qe.error(`Function name: ${e} not found in window`);
            return
        }
    o[i](...t)
}
, "runFunc");
function OM(e, t) {
    return !e || !t ? 0 : Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}
U(OM, "distance");
function SH(e) {
    let t, n = 0;
    e.forEach(i => {
        n += OM(i, t),
        t = i
    }
    );
    const r = n / 2;
    return IM(e, r)
}
U(SH, "traverseEdge");
function CH(e) {
    return e.length === 1 ? e[0] : SH(e)
}
U(CH, "calcLabelPosition");
var Fz = U( (e, t=2) => {
    const n = Math.pow(10, t);
    return Math.round(e * n) / n
}
, "roundNumber")
  , IM = U( (e, t) => {
    let n, r = t;
    for (const i of e) {
        if (n) {
            const o = OM(i, n);
            if (o === 0)
                return n;
            if (o < r)
                r -= o;
            else {
                const a = r / o;
                if (a <= 0)
                    return n;
                if (a >= 1)
                    return {
                        x: i.x,
                        y: i.y
                    };
                if (a > 0 && a < 1)
                    return {
                        x: Fz((1 - a) * n.x + a * i.x, 5),
                        y: Fz((1 - a) * n.y + a * i.y, 5)
                    }
            }
        }
        n = i
    }
    throw new Error("Could not find a suitable point for the given distance")
}
, "calculatePoint")
  , uOe = U( (e, t, n) => {
    Qe.info(`our points ${JSON.stringify(t)}`),
    t[0] !== n && (t = t.reverse());
    const i = IM(t, 25)
      , o = e ? 10 : 5
      , a = Math.atan2(t[0].y - i.y, t[0].x - i.x)
      , s = {
        x: 0,
        y: 0
    };
    return s.x = Math.sin(a) * o + (t[0].x + i.x) / 2,
    s.y = -Math.cos(a) * o + (t[0].y + i.y) / 2,
    s
}
, "calcCardinalityPosition");
function wH(e, t, n) {
    const r = structuredClone(n);
    Qe.info("our points", r),
    t !== "start_left" && t !== "start_right" && r.reverse();
    const i = 25 + e
      , o = IM(r, i)
      , a = 10 + e * .5
      , s = Math.atan2(r[0].y - o.y, r[0].x - o.x)
      , c = {
        x: 0,
        y: 0
    };
    return t === "start_left" ? (c.x = Math.sin(s + Math.PI) * a + (r[0].x + o.x) / 2,
    c.y = -Math.cos(s + Math.PI) * a + (r[0].y + o.y) / 2) : t === "end_right" ? (c.x = Math.sin(s - Math.PI) * a + (r[0].x + o.x) / 2 - 5,
    c.y = -Math.cos(s - Math.PI) * a + (r[0].y + o.y) / 2 - 5) : t === "end_left" ? (c.x = Math.sin(s) * a + (r[0].x + o.x) / 2 - 5,
    c.y = -Math.cos(s) * a + (r[0].y + o.y) / 2 - 5) : (c.x = Math.sin(s) * a + (r[0].x + o.x) / 2,
    c.y = -Math.cos(s) * a + (r[0].y + o.y) / 2),
    c
}
U(wH, "calcTerminalLabelPosition");
function kH(e) {
    let t = ""
      , n = "";
    for (const r of e)
        r !== void 0 && (r.startsWith("color:") || r.startsWith("text-align:") ? n = n + r + ";" : t = t + r + ";");
    return {
        style: t,
        labelStyle: n
    }
}
U(kH, "getStylesFromArray");
var Nz = 0
  , dOe = U( () => (Nz++,
"id-" + Math.random().toString(36).substr(2, 12) + "-" + Nz), "generateId");
function TH(e) {
    let t = "";
    const n = "0123456789abcdef"
      , r = n.length;
    for (let i = 0; i < e; i++)
        t += n.charAt(Math.floor(Math.random() * r));
    return t
}
U(TH, "makeRandomHex");
var fOe = U(e => TH(e.length), "random")
  , hOe = U(function() {
    return {
        x: 0,
        y: 0,
        fill: void 0,
        anchor: "start",
        style: "#666",
        width: 100,
        height: 100,
        textMargin: 0,
        rx: 0,
        ry: 0,
        valign: void 0,
        text: ""
    }
}, "getTextObj")
  , pOe = U(function(e, t) {
    const n = t.text.replace(vh.lineBreakRegex, " ")
      , [,r] = eS(t.fontSize)
      , i = e.append("text");
    i.attr("x", t.x),
    i.attr("y", t.y),
    i.style("text-anchor", t.anchor),
    i.style("font-family", t.fontFamily),
    i.style("font-size", r),
    i.style("font-weight", t.fontWeight),
    i.attr("fill", t.fill),
    t.class !== void 0 && i.attr("class", t.class);
    const o = i.append("tspan");
    return o.attr("x", t.x + t.textMargin * 2),
    o.attr("fill", t.fill),
    o.text(n),
    i
}, "drawSimpleText")
  , mOe = sy( (e, t, n) => {
    if (!e || (n = Object.assign({
        fontSize: 12,
        fontWeight: 400,
        fontFamily: "Arial",
        joinWith: "<br/>"
    }, n),
    vh.lineBreakRegex.test(e)))
        return e;
    const r = e.split(" ").filter(Boolean)
      , i = [];
    let o = "";
    return r.forEach( (a, s) => {
        const c = _l(`${a} `, n)
          , u = _l(o, n);
        if (c > t) {
            const {hyphenatedStrings: m, remainingWord: y} = gOe(a, t, "-", n);
            i.push(o, ...m),
            o = y
        } else
            u + c >= t ? (i.push(o),
            o = a) : o = [o, a].filter(Boolean).join(" ");
        s + 1 === r.length && i.push(o)
    }
    ),
    i.filter(a => a !== "").join(n.joinWith)
}
, (e, t, n) => `${e}${t}${n.fontSize}${n.fontWeight}${n.fontFamily}${n.joinWith}`)
  , gOe = sy( (e, t, n="-", r) => {
    r = Object.assign({
        fontSize: 12,
        fontWeight: 400,
        fontFamily: "Arial",
        margin: 0
    }, r);
    const i = [...e]
      , o = [];
    let a = "";
    return i.forEach( (s, c) => {
        const u = `${a}${s}`;
        if (_l(u, r) >= t) {
            const h = c + 1
              , m = i.length === h
              , y = `${u}${n}`;
            o.push(m ? u : y),
            a = ""
        } else
            a = u
    }
    ),
    {
        hyphenatedStrings: o,
        remainingWord: a
    }
}
, (e, t, n="-", r) => `${e}${t}${n}${r.fontSize}${r.fontWeight}${r.fontFamily}`);
function _H(e, t) {
    return $M(e, t).height
}
U(_H, "calculateTextHeight");
function _l(e, t) {
    return $M(e, t).width
}
U(_l, "calculateTextWidth");
var $M = sy( (e, t) => {
    const {fontSize: n=12, fontFamily: r="Arial", fontWeight: i=400} = t;
    if (!e)
        return {
            width: 0,
            height: 0
        };
    const [,o] = eS(n)
      , a = ["sans-serif", r]
      , s = e.split(vh.lineBreakRegex)
      , c = []
      , u = En("body");
    if (!u.remove)
        return {
            width: 0,
            height: 0,
            lineHeight: 0
        };
    const f = u.append("svg");
    for (const m of a) {
        let y = 0;
        const b = {
            width: 0,
            height: 0,
            lineHeight: 0
        };
        for (const v of s) {
            const S = hOe();
            S.text = v || rOe;
            const C = pOe(f, S).style("font-size", o).style("font-weight", i).style("font-family", m)
              , w = (C._groups || C)[0][0].getBBox();
            if (w.width === 0 && w.height === 0)
                throw new Error("svg element not in render tree");
            b.width = Math.round(Math.max(b.width, w.width)),
            y = Math.round(w.height),
            b.height += y,
            b.lineHeight = Math.round(Math.max(b.lineHeight, y))
        }
        c.push(b)
    }
    f.remove();
    const h = isNaN(c[1].height) || isNaN(c[1].width) || isNaN(c[1].lineHeight) || c[0].height > c[1].height && c[0].width > c[1].width && c[0].lineHeight > c[1].lineHeight ? 0 : 1;
    return c[h]
}
, (e, t) => `${e}${t.fontSize}${t.fontWeight}${t.fontFamily}`), zf, yOe = (zf = class {
    constructor(t=!1, n) {
        this.count = 0,
        this.count = n ? n.length : 0,
        this.next = t ? () => this.count++ : () => Date.now()
    }
}
,
U(zf, "InitIDGenerator"),
zf), cx, bOe = U(function(e) {
    return cx = cx || document.createElement("div"),
    e = escape(e).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"),
    cx.innerHTML = e,
    unescape(cx.textContent)
}, "entityDecode");
function LM(e) {
    return "str"in e
}
U(LM, "isDetailedError");
var xOe = U( (e, t, n, r) => {
    if (!r)
        return;
    const i = e.node()?.getBBox();
    i && e.append("text").text(r).attr("text-anchor", "middle").attr("x", i.x + i.width / 2).attr("y", -n).attr("class", t)
}
, "insertTitle")
  , eS = U(e => {
    if (typeof e == "number")
        return [e, e + "px"];
    const t = parseInt(e ?? "", 10);
    return Number.isNaN(t) ? [void 0, void 0] : e === String(t) ? [t, e + "px"] : [t, e]
}
, "parseFontSize");
function jM(e, t) {
    return nOe({}, e, t)
}
U(jM, "cleanAndMerge");
var Na = {
    assignWithDepth: ri,
    wrapLabel: mOe,
    calculateTextHeight: _H,
    calculateTextWidth: _l,
    calculateTextDimensions: $M,
    cleanAndMerge: jM,
    detectInit: aOe,
    detectDirective: xH,
    isSubstringInArray: lOe,
    interpolateToCurve: DM,
    calcLabelPosition: CH,
    calcCardinalityPosition: uOe,
    calcTerminalLabelPosition: wH,
    formatUrl: vH,
    getStylesFromArray: kH,
    generateId: dOe,
    random: fOe,
    runFunc: cOe,
    entityDecode: bOe,
    insertTitle: xOe,
    isLabelCoordinateInPath: EH,
    parseFontSize: eS,
    InitIDGenerator: yOe
}
  , vOe = U(function(e) {
    let t = e;
    return t = t.replace(/style.*:\S*#.*;/g, function(n) {
        return n.substring(0, n.length - 1)
    }),
    t = t.replace(/classDef.*:\S*#.*;/g, function(n) {
        return n.substring(0, n.length - 1)
    }),
    t = t.replace(/#\w+;/g, function(n) {
        const r = n.substring(1, n.length - 1);
        return /^\+?\d+$/.test(r) ? "" + r + "" : "" + r + ""
    }),
    t
}, "encodeEntities")
  , cd = U(function(e) {
    return e.replace(//g, "&#").replace(//g, "&").replace(//g, ";")
}, "decodeEntities")
  , iVe = U( (e, t, {counter: n=0, prefix: r, suffix: i}, o) => o || `${r ? `${r}_` : ""}${e}_ ${t}_ ${n}${i ? `_${i}` : ""}`, "getEdgeId");
function Ri(e) {
    return e ?? null
}
U(Ri, "handleUndefinedAttr");
function EH(e, t) {
    const n = Math.round(e.x)
      , r = Math.round(e.y)
      , i = t.replace(/(\d+\.\d+)/g, o => Math.round(parseFloat(o)).toString());
    return i.includes(n.toString()) || i.includes(r.toString())
}
U(EH, "isLabelCoordinateInPath");
const SOe = Object.freeze({
    left: 0,
    top: 0,
    width: 16,
    height: 16
})
  , fv = Object.freeze({
    rotate: 0,
    vFlip: !1,
    hFlip: !1
})
  , AH = Object.freeze({
    ...SOe,
    ...fv
})
  , COe = Object.freeze({
    ...AH,
    body: "",
    hidden: !1
})
  , wOe = Object.freeze({
    width: null,
    height: null
})
  , kOe = Object.freeze({
    ...wOe,
    ...fv
})
  , TOe = (e, t, n, r="") => {
    const i = e.split(":");
    if (e.slice(0, 1) === "@") {
        if (i.length < 2 || i.length > 3)
            return null;
        r = i.shift().slice(1)
    }
    if (i.length > 3 || !i.length)
        return null;
    if (i.length > 1) {
        const s = i.pop()
          , c = i.pop()
          , u = {
            provider: i.length > 0 ? i[0] : r,
            prefix: c,
            name: s
        };
        return i2(u) ? u : null
    }
    const o = i[0]
      , a = o.split("-");
    if (a.length > 1) {
        const s = {
            provider: r,
            prefix: a.shift(),
            name: a.join("-")
        };
        return i2(s) ? s : null
    }
    if (n && r === "") {
        const s = {
            provider: r,
            prefix: "",
            name: o
        };
        return i2(s, n) ? s : null
    }
    return null
}
  , i2 = (e, t) => e ? !!((t && e.prefix === "" || e.prefix) && e.name) : !1;
function _Oe(e, t) {
    const n = {};
    !e.hFlip != !t.hFlip && (n.hFlip = !0),
    !e.vFlip != !t.vFlip && (n.vFlip = !0);
    const r = ((e.rotate || 0) + (t.rotate || 0)) % 4;
    return r && (n.rotate = r),
    n
}
function Uz(e, t) {
    const n = _Oe(e, t);
    for (const r in COe)
        r in fv ? r in e && !(r in n) && (n[r] = fv[r]) : r in t ? n[r] = t[r] : r in e && (n[r] = e[r]);
    return n
}
function EOe(e, t) {
    const n = e.icons
      , r = e.aliases || Object.create(null)
      , i = Object.create(null);
    function o(a) {
        if (n[a])
            return i[a] = [];
        if (!(a in i)) {
            i[a] = null;
            const s = r[a] && r[a].parent
              , c = s && o(s);
            c && (i[a] = [s].concat(c))
        }
        return i[a]
    }
    return (t || Object.keys(n).concat(Object.keys(r))).forEach(o),
    i
}
function Vz(e, t, n) {
    const r = e.icons
      , i = e.aliases || Object.create(null);
    let o = {};
    function a(s) {
        o = Uz(r[s] || i[s], o)
    }
    return a(t),
    n.forEach(a),
    Uz(e, o)
}
function AOe(e, t) {
    if (e.icons[t])
        return Vz(e, t, []);
    const n = EOe(e, [t])[t];
    return n ? Vz(e, t, n) : null
}
const MOe = /(-?[0-9.]*[0-9]+[0-9.]*)/g
  , POe = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Hz(e, t, n) {
    if (t === 1)
        return e;
    if (n = n || 100,
    typeof e == "number")
        return Math.ceil(e * t * n) / n;
    if (typeof e != "string")
        return e;
    const r = e.split(MOe);
    if (r === null || !r.length)
        return e;
    const i = [];
    let o = r.shift()
      , a = POe.test(o);
    for (; ; ) {
        if (a) {
            const s = parseFloat(o);
            isNaN(s) ? i.push(o) : i.push(Math.ceil(s * t * n) / n)
        } else
            i.push(o);
        if (o = r.shift(),
        o === void 0)
            return i.join("");
        a = !a
    }
}
function ROe(e, t="defs") {
    let n = "";
    const r = e.indexOf("<" + t);
    for (; r >= 0; ) {
        const i = e.indexOf(">", r)
          , o = e.indexOf("</" + t);
        if (i === -1 || o === -1)
            break;
        const a = e.indexOf(">", o);
        if (a === -1)
            break;
        n += e.slice(i + 1, o).trim(),
        e = e.slice(0, r).trim() + e.slice(a + 1)
    }
    return {
        defs: n,
        content: e
    }
}
function DOe(e, t) {
    return e ? "<defs>" + e + "</defs>" + t : t
}
function OOe(e, t, n) {
    const r = ROe(e);
    return DOe(r.defs, t + r.content + n)
}
const IOe = e => e === "unset" || e === "undefined" || e === "none";
function $Oe(e, t) {
    const n = {
        ...AH,
        ...e
    }
      , r = {
        ...kOe,
        ...t
    }
      , i = {
        left: n.left,
        top: n.top,
        width: n.width,
        height: n.height
    };
    let o = n.body;
    [n, r].forEach(v => {
        const S = []
          , C = v.hFlip
          , w = v.vFlip;
        let k = v.rotate;
        C ? w ? k += 2 : (S.push("translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"),
        S.push("scale(-1 1)"),
        i.top = i.left = 0) : w && (S.push("translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"),
        S.push("scale(1 -1)"),
        i.top = i.left = 0);
        let T;
        switch (k < 0 && (k -= Math.floor(k / 4) * 4),
        k = k % 4,
        k) {
        case 1:
            T = i.height / 2 + i.top,
            S.unshift("rotate(90 " + T.toString() + " " + T.toString() + ")");
            break;
        case 2:
            S.unshift("rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")");
            break;
        case 3:
            T = i.width / 2 + i.left,
            S.unshift("rotate(-90 " + T.toString() + " " + T.toString() + ")");
            break
        }
        k % 2 === 1 && (i.left !== i.top && (T = i.left,
        i.left = i.top,
        i.top = T),
        i.width !== i.height && (T = i.width,
        i.width = i.height,
        i.height = T)),
        S.length && (o = OOe(o, '<g transform="' + S.join(" ") + '">', "</g>"))
    }
    );
    const a = r.width
      , s = r.height
      , c = i.width
      , u = i.height;
    let f, h;
    a === null ? (h = s === null ? "1em" : s === "auto" ? u : s,
    f = Hz(h, c / u)) : (f = a === "auto" ? c : a,
    h = s === null ? Hz(f, u / c) : s === "auto" ? u : s);
    const m = {}
      , y = (v, S) => {
        IOe(S) || (m[v] = S.toString())
    }
    ;
    y("width", f),
    y("height", h);
    const b = [i.left, i.top, c, u];
    return m.viewBox = b.join(" "),
    {
        attributes: m,
        viewBox: b,
        body: o
    }
}
const LOe = /\sid="(\S+)"/g
  , jOe = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let BOe = 0;
function zOe(e, t=jOe) {
    const n = [];
    let r;
    for (; r = LOe.exec(e); )
        n.push(r[1]);
    if (!n.length)
        return e;
    const i = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
    return n.forEach(o => {
        const a = typeof t == "function" ? t(o) : t + (BOe++).toString()
          , s = o.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        e = e.replace(new RegExp('([#;"])(' + s + ')([")]|\\.[a-z])',"g"), "$1" + a + i + "$3")
    }
    ),
    e = e.replace(new RegExp(i,"g"), ""),
    e
}
function FOe(e, t) {
    let n = e.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
    for (const r in t)
        n += " " + r + '="' + t[r] + '"';
    return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + e + "</svg>"
}
function BM() {
    return {
        async: !1,
        breaks: !1,
        extensions: null,
        gfm: !0,
        hooks: null,
        pedantic: !1,
        renderer: null,
        silent: !1,
        tokenizer: null,
        walkTokens: null
    }
}
var ud = BM();
function MH(e) {
    ud = e
}
var Im = {
    exec: () => null
};
function $n(e, t="") {
    let n = typeof e == "string" ? e : e.source
      , r = {
        replace: (i, o) => {
            let a = typeof o == "string" ? o : o.source;
            return a = a.replace(Hi.caret, "$1"),
            n = n.replace(i, a),
            r
        }
        ,
        getRegex: () => new RegExp(n,t)
    };
    return r
}
var Hi = {
    codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
    outputLinkReplace: /\\([\[\]])/g,
    indentCodeCompensation: /^(\s+)(?:```)/,
    beginningSpace: /^\s+/,
    endingHash: /#$/,
    startingSpaceChar: /^ /,
    endingSpaceChar: / $/,
    nonSpaceChar: /[^ ]/,
    newLineCharGlobal: /\n/g,
    tabCharGlobal: /\t/g,
    multipleSpaceGlobal: /\s+/g,
    blankLine: /^[ \t]*$/,
    doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
    blockquoteStart: /^ {0,3}>/,
    blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
    blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
    listReplaceTabs: /^\t+/,
    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
    listIsTask: /^\[[ xX]\] /,
    listReplaceTask: /^\[[ xX]\] +/,
    anyLine: /\n.*\n/,
    hrefBrackets: /^<(.*)>$/,
    tableDelimiter: /[:|]/,
    tableAlignChars: /^\||\| *$/g,
    tableRowBlankLine: /\n[ \t]*$/,
    tableAlignRight: /^ *-+: *$/,
    tableAlignCenter: /^ *:-+: *$/,
    tableAlignLeft: /^ *:-+ *$/,
    startATag: /^<a /i,
    endATag: /^<\/a>/i,
    startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
    endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
    startAngleBracket: /^</,
    endAngleBracket: />$/,
    pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
    unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
    escapeTest: /[&<>"']/,
    escapeReplace: /[&<>"']/g,
    escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
    escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
    unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
    caret: /(^|[^\[])\^/g,
    percentDecode: /%25/g,
    findPipe: /\|/g,
    splitPipe: / \|/,
    slashPipe: /\\\|/g,
    carriageReturn: /\r\n|\r/g,
    spaceLine: /^ +$/gm,
    notSpaceStart: /^\S*/,
    endingNewline: /\n$/,
    listItemRegex: e => new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`),
    nextBulletRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
    hrRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
    fencesBeginRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:\`\`\`|~~~)`),
    headingBeginRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}#`),
    htmlBeginRegex: e => new RegExp(`^ {0,${Math.min(3, e - 1)}}<(?:[a-z].*>|!--)`,"i")
}
  , NOe = /^(?:[ \t]*(?:\n|$))+/
  , UOe = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/
  , VOe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/
  , cy = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/
  , HOe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/
  , zM = /(?:[*+-]|\d{1,9}[.)])/
  , PH = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/
  , RH = $n(PH).replace(/bull/g, zM).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex()
  , qOe = $n(PH).replace(/bull/g, zM).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex()
  , FM = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/
  , WOe = /^[^\n]+/
  , NM = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/
  , GOe = $n(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", NM).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex()
  , YOe = $n(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, zM).getRegex()
  , tS = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul"
  , UM = /<!--(?:-?>|[\s\S]*?(?:-->|$))/
  , ZOe = $n("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", UM).replace("tag", tS).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex()
  , DH = $n(FM).replace("hr", cy).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", tS).getRegex()
  , QOe = $n(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", DH).getRegex()
  , VM = {
    blockquote: QOe,
    code: UOe,
    def: GOe,
    fences: VOe,
    heading: HOe,
    hr: cy,
    html: ZOe,
    lheading: RH,
    list: YOe,
    newline: NOe,
    paragraph: DH,
    table: Im,
    text: WOe
}
  , qz = $n("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", cy).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", tS).getRegex()
  , KOe = {
    ...VM,
    lheading: qOe,
    table: qz,
    paragraph: $n(FM).replace("hr", cy).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", qz).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", tS).getRegex()
}
  , XOe = {
    ...VM,
    html: $n(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", UM).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: Im,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: $n(FM).replace("hr", cy).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", RH).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}
  , JOe = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/
  , eIe = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/
  , OH = /^( {2,}|\\)\n(?!\s*$)/
  , tIe = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/
  , nS = /[\p{P}\p{S}]/u
  , HM = /[\s\p{P}\p{S}]/u
  , IH = /[^\s\p{P}\p{S}]/u
  , nIe = $n(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, HM).getRegex()
  , $H = /(?!~)[\p{P}\p{S}]/u
  , rIe = /(?!~)[\s\p{P}\p{S}]/u
  , iIe = /(?:[^\s\p{P}\p{S}]|~)/u
  , oIe = $n(/link|code|html/, "g").replace("link", new RegExp("\\[(?:[^\\[\\]`]|(?<!`)(?<a>`+)[^`]+\\k<a>(?!`))*?\\]\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)]|\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)])*\\))*\\)")).replace("code", new RegExp("(?<!`)(?<b>`+)[^`]+\\k<b>(?!`)")).replace("html", /<(?! )[^<>]*?>/).getRegex()
  , LH = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/
  , aIe = $n(LH, "u").replace(/punct/g, nS).getRegex()
  , sIe = $n(LH, "u").replace(/punct/g, $H).getRegex()
  , jH = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)"
  , lIe = $n(jH, "gu").replace(/notPunctSpace/g, IH).replace(/punctSpace/g, HM).replace(/punct/g, nS).getRegex()
  , cIe = $n(jH, "gu").replace(/notPunctSpace/g, iIe).replace(/punctSpace/g, rIe).replace(/punct/g, $H).getRegex()
  , uIe = $n("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, IH).replace(/punctSpace/g, HM).replace(/punct/g, nS).getRegex()
  , dIe = $n(/\\(punct)/, "gu").replace(/punct/g, nS).getRegex()
  , fIe = $n(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex()
  , hIe = $n(UM).replace("(?:-->|$)", "-->").getRegex()
  , pIe = $n("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", hIe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex()
  , hv = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/
  , mIe = $n(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", hv).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex()
  , BH = $n(/^!?\[(label)\]\[(ref)\]/).replace("label", hv).replace("ref", NM).getRegex()
  , zH = $n(/^!?\[(ref)\](?:\[\])?/).replace("ref", NM).getRegex()
  , gIe = $n("reflink|nolink(?!\\()", "g").replace("reflink", BH).replace("nolink", zH).getRegex()
  , Wz = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/
  , qM = {
    _backpedal: Im,
    anyPunctuation: dIe,
    autolink: fIe,
    blockSkip: oIe,
    br: OH,
    code: eIe,
    del: Im,
    emStrongLDelim: aIe,
    emStrongRDelimAst: lIe,
    emStrongRDelimUnd: uIe,
    escape: JOe,
    link: mIe,
    nolink: zH,
    punctuation: nIe,
    reflink: BH,
    reflinkSearch: gIe,
    tag: pIe,
    text: tIe,
    url: Im
}
  , yIe = {
    ...qM,
    link: $n(/^!?\[(label)\]\((.*?)\)/).replace("label", hv).getRegex(),
    reflink: $n(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", hv).getRegex()
}
  , A_ = {
    ...qM,
    emStrongRDelimAst: cIe,
    emStrongLDelim: sIe,
    url: $n(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", Wz).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,
    text: $n(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", Wz).getRegex()
}
  , bIe = {
    ...A_,
    br: $n(OH).replace("{2,}", "*").getRegex(),
    text: $n(A_.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}
  , ux = {
    normal: VM,
    gfm: KOe,
    pedantic: XOe
}
  , Np = {
    normal: qM,
    gfm: A_,
    breaks: bIe,
    pedantic: yIe
}
  , xIe = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
}
  , Gz = e => xIe[e];
function hs(e, t) {
    if (t) {
        if (Hi.escapeTest.test(e))
            return e.replace(Hi.escapeReplace, Gz)
    } else if (Hi.escapeTestNoEncode.test(e))
        return e.replace(Hi.escapeReplaceNoEncode, Gz);
    return e
}
function Yz(e) {
    try {
        e = encodeURI(e).replace(Hi.percentDecode, "%")
    } catch {
        return null
    }
    return e
}
function Zz(e, t) {
    let n = e.replace(Hi.findPipe, (o, a, s) => {
        let c = !1
          , u = a;
        for (; --u >= 0 && s[u] === "\\"; )
            c = !c;
        return c ? "|" : " |"
    }
    )
      , r = n.split(Hi.splitPipe)
      , i = 0;
    if (r[0].trim() || r.shift(),
    r.length > 0 && !r.at(-1)?.trim() && r.pop(),
    t)
        if (r.length > t)
            r.splice(t);
        else
            for (; r.length < t; )
                r.push("");
    for (; i < r.length; i++)
        r[i] = r[i].trim().replace(Hi.slashPipe, "|");
    return r
}
function Up(e, t, n) {
    let r = e.length;
    if (r === 0)
        return "";
    let i = 0;
    for (; i < r && e.charAt(r - i - 1) === t; )
        i++;
    return e.slice(0, r - i)
}
function vIe(e, t) {
    if (e.indexOf(t[1]) === -1)
        return -1;
    let n = 0;
    for (let r = 0; r < e.length; r++)
        if (e[r] === "\\")
            r++;
        else if (e[r] === t[0])
            n++;
        else if (e[r] === t[1] && (n--,
        n < 0))
            return r;
    return n > 0 ? -2 : -1
}
function Qz(e, t, n, r, i) {
    let o = t.href
      , a = t.title || null
      , s = e[1].replace(i.other.outputLinkReplace, "$1");
    r.state.inLink = !0;
    let c = {
        type: e[0].charAt(0) === "!" ? "image" : "link",
        raw: n,
        href: o,
        title: a,
        text: s,
        tokens: r.inlineTokens(s)
    };
    return r.state.inLink = !1,
    c
}
function SIe(e, t, n) {
    let r = e.match(n.other.indentCodeCompensation);
    if (r === null)
        return t;
    let i = r[1];
    return t.split(`
`).map(o => {
        let a = o.match(n.other.beginningSpace);
        if (a === null)
            return o;
        let[s] = a;
        return s.length >= i.length ? o.slice(i.length) : o
    }
    ).join(`
`)
}
var pv = class {
    options;
    rules;
    lexer;
    constructor(t) {
        this.options = t || ud
    }
    space(t) {
        let n = this.rules.block.newline.exec(t);
        if (n && n[0].length > 0)
            return {
                type: "space",
                raw: n[0]
            }
    }
    code(t) {
        let n = this.rules.block.code.exec(t);
        if (n) {
            let r = n[0].replace(this.rules.other.codeRemoveIndent, "");
            return {
                type: "code",
                raw: n[0],
                codeBlockStyle: "indented",
                text: this.options.pedantic ? r : Up(r, `
`)
            }
        }
    }
    fences(t) {
        let n = this.rules.block.fences.exec(t);
        if (n) {
            let r = n[0]
              , i = SIe(r, n[3] || "", this.rules);
            return {
                type: "code",
                raw: r,
                lang: n[2] ? n[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : n[2],
                text: i
            }
        }
    }
    heading(t) {
        let n = this.rules.block.heading.exec(t);
        if (n) {
            let r = n[2].trim();
            if (this.rules.other.endingHash.test(r)) {
                let i = Up(r, "#");
                (this.options.pedantic || !i || this.rules.other.endingSpaceChar.test(i)) && (r = i.trim())
            }
            return {
                type: "heading",
                raw: n[0],
                depth: n[1].length,
                text: r,
                tokens: this.lexer.inline(r)
            }
        }
    }
    hr(t) {
        let n = this.rules.block.hr.exec(t);
        if (n)
            return {
                type: "hr",
                raw: Up(n[0], `
`)
            }
    }
    blockquote(t) {
        let n = this.rules.block.blockquote.exec(t);
        if (n) {
            let r = Up(n[0], `
`).split(`
`)
              , i = ""
              , o = ""
              , a = [];
            for (; r.length > 0; ) {
                let s = !1, c = [], u;
                for (u = 0; u < r.length; u++)
                    if (this.rules.other.blockquoteStart.test(r[u]))
                        c.push(r[u]),
                        s = !0;
                    else if (!s)
                        c.push(r[u]);
                    else
                        break;
                r = r.slice(u);
                let f = c.join(`
`)
                  , h = f.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
                i = i ? `${i}
${f}` : f,
                o = o ? `${o}
${h}` : h;
                let m = this.lexer.state.top;
                if (this.lexer.state.top = !0,
                this.lexer.blockTokens(h, a, !0),
                this.lexer.state.top = m,
                r.length === 0)
                    break;
                let y = a.at(-1);
                if (y?.type === "code")
                    break;
                if (y?.type === "blockquote") {
                    let b = y
                      , v = b.raw + `
` + r.join(`
`)
                      , S = this.blockquote(v);
                    a[a.length - 1] = S,
                    i = i.substring(0, i.length - b.raw.length) + S.raw,
                    o = o.substring(0, o.length - b.text.length) + S.text;
                    break
                } else if (y?.type === "list") {
                    let b = y
                      , v = b.raw + `
` + r.join(`
`)
                      , S = this.list(v);
                    a[a.length - 1] = S,
                    i = i.substring(0, i.length - y.raw.length) + S.raw,
                    o = o.substring(0, o.length - b.raw.length) + S.raw,
                    r = v.substring(a.at(-1).raw.length).split(`
`);
                    continue
                }
            }
            return {
                type: "blockquote",
                raw: i,
                tokens: a,
                text: o
            }
        }
    }
    list(t) {
        let n = this.rules.block.list.exec(t);
        if (n) {
            let r = n[1].trim()
              , i = r.length > 1
              , o = {
                type: "list",
                raw: "",
                ordered: i,
                start: i ? +r.slice(0, -1) : "",
                loose: !1,
                items: []
            };
            r = i ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`,
            this.options.pedantic && (r = i ? r : "[*+-]");
            let a = this.rules.other.listItemRegex(r)
              , s = !1;
            for (; t; ) {
                let u = !1
                  , f = ""
                  , h = "";
                if (!(n = a.exec(t)) || this.rules.block.hr.test(t))
                    break;
                f = n[0],
                t = t.substring(f.length);
                let m = n[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, w => " ".repeat(3 * w.length))
                  , y = t.split(`
`, 1)[0]
                  , b = !m.trim()
                  , v = 0;
                if (this.options.pedantic ? (v = 2,
                h = m.trimStart()) : b ? v = n[1].length + 1 : (v = n[2].search(this.rules.other.nonSpaceChar),
                v = v > 4 ? 1 : v,
                h = m.slice(v),
                v += n[1].length),
                b && this.rules.other.blankLine.test(y) && (f += y + `
`,
                t = t.substring(y.length + 1),
                u = !0),
                !u) {
                    let w = this.rules.other.nextBulletRegex(v)
                      , k = this.rules.other.hrRegex(v)
                      , T = this.rules.other.fencesBeginRegex(v)
                      , E = this.rules.other.headingBeginRegex(v)
                      , P = this.rules.other.htmlBeginRegex(v);
                    for (; t; ) {
                        let D = t.split(`
`, 1)[0], $;
                        if (y = D,
                        this.options.pedantic ? (y = y.replace(this.rules.other.listReplaceNesting, "  "),
                        $ = y) : $ = y.replace(this.rules.other.tabCharGlobal, "    "),
                        T.test(y) || E.test(y) || P.test(y) || w.test(y) || k.test(y))
                            break;
                        if ($.search(this.rules.other.nonSpaceChar) >= v || !y.trim())
                            h += `
` + $.slice(v);
                        else {
                            if (b || m.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || T.test(m) || E.test(m) || k.test(m))
                                break;
                            h += `
` + y
                        }
                        !b && !y.trim() && (b = !0),
                        f += D + `
`,
                        t = t.substring(D.length + 1),
                        m = $.slice(v)
                    }
                }
                o.loose || (s ? o.loose = !0 : this.rules.other.doubleBlankLine.test(f) && (s = !0));
                let S = null, C;
                this.options.gfm && (S = this.rules.other.listIsTask.exec(h),
                S && (C = S[0] !== "[ ] ",
                h = h.replace(this.rules.other.listReplaceTask, ""))),
                o.items.push({
                    type: "list_item",
                    raw: f,
                    task: !!S,
                    checked: C,
                    loose: !1,
                    text: h,
                    tokens: []
                }),
                o.raw += f
            }
            let c = o.items.at(-1);
            if (c)
                c.raw = c.raw.trimEnd(),
                c.text = c.text.trimEnd();
            else
                return;
            o.raw = o.raw.trimEnd();
            for (let u = 0; u < o.items.length; u++)
                if (this.lexer.state.top = !1,
                o.items[u].tokens = this.lexer.blockTokens(o.items[u].text, []),
                !o.loose) {
                    let f = o.items[u].tokens.filter(m => m.type === "space")
                      , h = f.length > 0 && f.some(m => this.rules.other.anyLine.test(m.raw));
                    o.loose = h
                }
            if (o.loose)
                for (let u = 0; u < o.items.length; u++)
                    o.items[u].loose = !0;
            return o
        }
    }
    html(t) {
        let n = this.rules.block.html.exec(t);
        if (n)
            return {
                type: "html",
                block: !0,
                raw: n[0],
                pre: n[1] === "pre" || n[1] === "script" || n[1] === "style",
                text: n[0]
            }
    }
    def(t) {
        let n = this.rules.block.def.exec(t);
        if (n) {
            let r = n[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ")
              , i = n[2] ? n[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : ""
              , o = n[3] ? n[3].substring(1, n[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : n[3];
            return {
                type: "def",
                tag: r,
                raw: n[0],
                href: i,
                title: o
            }
        }
    }
    table(t) {
        let n = this.rules.block.table.exec(t);
        if (!n || !this.rules.other.tableDelimiter.test(n[2]))
            return;
        let r = Zz(n[1])
          , i = n[2].replace(this.rules.other.tableAlignChars, "").split("|")
          , o = n[3]?.trim() ? n[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : []
          , a = {
            type: "table",
            raw: n[0],
            header: [],
            align: [],
            rows: []
        };
        if (r.length === i.length) {
            for (let s of i)
                this.rules.other.tableAlignRight.test(s) ? a.align.push("right") : this.rules.other.tableAlignCenter.test(s) ? a.align.push("center") : this.rules.other.tableAlignLeft.test(s) ? a.align.push("left") : a.align.push(null);
            for (let s = 0; s < r.length; s++)
                a.header.push({
                    text: r[s],
                    tokens: this.lexer.inline(r[s]),
                    header: !0,
                    align: a.align[s]
                });
            for (let s of o)
                a.rows.push(Zz(s, a.header.length).map( (c, u) => ({
                    text: c,
                    tokens: this.lexer.inline(c),
                    header: !1,
                    align: a.align[u]
                })));
            return a
        }
    }
    lheading(t) {
        let n = this.rules.block.lheading.exec(t);
        if (n)
            return {
                type: "heading",
                raw: n[0],
                depth: n[2].charAt(0) === "=" ? 1 : 2,
                text: n[1],
                tokens: this.lexer.inline(n[1])
            }
    }
    paragraph(t) {
        let n = this.rules.block.paragraph.exec(t);
        if (n) {
            let r = n[1].charAt(n[1].length - 1) === `
` ? n[1].slice(0, -1) : n[1];
            return {
                type: "paragraph",
                raw: n[0],
                text: r,
                tokens: this.lexer.inline(r)
            }
        }
    }
    text(t) {
        let n = this.rules.block.text.exec(t);
        if (n)
            return {
                type: "text",
                raw: n[0],
                text: n[0],
                tokens: this.lexer.inline(n[0])
            }
    }
    escape(t) {
        let n = this.rules.inline.escape.exec(t);
        if (n)
            return {
                type: "escape",
                raw: n[0],
                text: n[1]
            }
    }
    tag(t) {
        let n = this.rules.inline.tag.exec(t);
        if (n)
            return !this.lexer.state.inLink && this.rules.other.startATag.test(n[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(n[0]) && (this.lexer.state.inLink = !1),
            !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(n[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(n[0]) && (this.lexer.state.inRawBlock = !1),
            {
                type: "html",
                raw: n[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: !1,
                text: n[0]
            }
    }
    link(t) {
        let n = this.rules.inline.link.exec(t);
        if (n) {
            let r = n[2].trim();
            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) {
                if (!this.rules.other.endAngleBracket.test(r))
                    return;
                let a = Up(r.slice(0, -1), "\\");
                if ((r.length - a.length) % 2 === 0)
                    return
            } else {
                let a = vIe(n[2], "()");
                if (a === -2)
                    return;
                if (a > -1) {
                    let s = (n[0].indexOf("!") === 0 ? 5 : 4) + n[1].length + a;
                    n[2] = n[2].substring(0, a),
                    n[0] = n[0].substring(0, s).trim(),
                    n[3] = ""
                }
            }
            let i = n[2]
              , o = "";
            if (this.options.pedantic) {
                let a = this.rules.other.pedanticHrefTitle.exec(i);
                a && (i = a[1],
                o = a[3])
            } else
                o = n[3] ? n[3].slice(1, -1) : "";
            return i = i.trim(),
            this.rules.other.startAngleBracket.test(i) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(r) ? i = i.slice(1) : i = i.slice(1, -1)),
            Qz(n, {
                href: i && i.replace(this.rules.inline.anyPunctuation, "$1"),
                title: o && o.replace(this.rules.inline.anyPunctuation, "$1")
            }, n[0], this.lexer, this.rules)
        }
    }
    reflink(t, n) {
        let r;
        if ((r = this.rules.inline.reflink.exec(t)) || (r = this.rules.inline.nolink.exec(t))) {
            let i = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " ")
              , o = n[i.toLowerCase()];
            if (!o) {
                let a = r[0].charAt(0);
                return {
                    type: "text",
                    raw: a,
                    text: a
                }
            }
            return Qz(r, o, r[0], this.lexer, this.rules)
        }
    }
    emStrong(t, n, r="") {
        let i = this.rules.inline.emStrongLDelim.exec(t);
        if (!(!i || i[3] && r.match(this.rules.other.unicodeAlphaNumeric)) && (!(i[1] || i[2]) || !r || this.rules.inline.punctuation.exec(r))) {
            let o = [...i[0]].length - 1, a, s, c = o, u = 0, f = i[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
            for (f.lastIndex = 0,
            n = n.slice(-1 * t.length + o); (i = f.exec(n)) != null; ) {
                if (a = i[1] || i[2] || i[3] || i[4] || i[5] || i[6],
                !a)
                    continue;
                if (s = [...a].length,
                i[3] || i[4]) {
                    c += s;
                    continue
                } else if ((i[5] || i[6]) && o % 3 && !((o + s) % 3)) {
                    u += s;
                    continue
                }
                if (c -= s,
                c > 0)
                    continue;
                s = Math.min(s, s + c + u);
                let h = [...i[0]][0].length
                  , m = t.slice(0, o + i.index + h + s);
                if (Math.min(o, s) % 2) {
                    let b = m.slice(1, -1);
                    return {
                        type: "em",
                        raw: m,
                        text: b,
                        tokens: this.lexer.inlineTokens(b)
                    }
                }
                let y = m.slice(2, -2);
                return {
                    type: "strong",
                    raw: m,
                    text: y,
                    tokens: this.lexer.inlineTokens(y)
                }
            }
        }
    }
    codespan(t) {
        let n = this.rules.inline.code.exec(t);
        if (n) {
            let r = n[2].replace(this.rules.other.newLineCharGlobal, " ")
              , i = this.rules.other.nonSpaceChar.test(r)
              , o = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r);
            return i && o && (r = r.substring(1, r.length - 1)),
            {
                type: "codespan",
                raw: n[0],
                text: r
            }
        }
    }
    br(t) {
        let n = this.rules.inline.br.exec(t);
        if (n)
            return {
                type: "br",
                raw: n[0]
            }
    }
    del(t) {
        let n = this.rules.inline.del.exec(t);
        if (n)
            return {
                type: "del",
                raw: n[0],
                text: n[2],
                tokens: this.lexer.inlineTokens(n[2])
            }
    }
    autolink(t) {
        let n = this.rules.inline.autolink.exec(t);
        if (n) {
            let r, i;
            return n[2] === "@" ? (r = n[1],
            i = "mailto:" + r) : (r = n[1],
            i = r),
            {
                type: "link",
                raw: n[0],
                text: r,
                href: i,
                tokens: [{
                    type: "text",
                    raw: r,
                    text: r
                }]
            }
        }
    }
    url(t) {
        let n;
        if (n = this.rules.inline.url.exec(t)) {
            let r, i;
            if (n[2] === "@")
                r = n[0],
                i = "mailto:" + r;
            else {
                let o;
                do
                    o = n[0],
                    n[0] = this.rules.inline._backpedal.exec(n[0])?.[0] ?? "";
                while (o !== n[0]);
                r = n[0],
                n[1] === "www." ? i = "http://" + n[0] : i = n[0]
            }
            return {
                type: "link",
                raw: n[0],
                text: r,
                href: i,
                tokens: [{
                    type: "text",
                    raw: r,
                    text: r
                }]
            }
        }
    }
    inlineText(t) {
        let n = this.rules.inline.text.exec(t);
        if (n) {
            let r = this.lexer.state.inRawBlock;
            return {
                type: "text",
                raw: n[0],
                text: n[0],
                escaped: r
            }
        }
    }
}
  , ja = class M_ {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(t) {
        this.tokens = [],
        this.tokens.links = Object.create(null),
        this.options = t || ud,
        this.options.tokenizer = this.options.tokenizer || new pv,
        this.tokenizer = this.options.tokenizer,
        this.tokenizer.options = this.options,
        this.tokenizer.lexer = this,
        this.inlineQueue = [],
        this.state = {
            inLink: !1,
            inRawBlock: !1,
            top: !0
        };
        let n = {
            other: Hi,
            block: ux.normal,
            inline: Np.normal
        };
        this.options.pedantic ? (n.block = ux.pedantic,
        n.inline = Np.pedantic) : this.options.gfm && (n.block = ux.gfm,
        this.options.breaks ? n.inline = Np.breaks : n.inline = Np.gfm),
        this.tokenizer.rules = n
    }
    static get rules() {
        return {
            block: ux,
            inline: Np
        }
    }
    static lex(t, n) {
        return new M_(n).lex(t)
    }
    static lexInline(t, n) {
        return new M_(n).inlineTokens(t)
    }
    lex(t) {
        t = t.replace(Hi.carriageReturn, `
`),
        this.blockTokens(t, this.tokens);
        for (let n = 0; n < this.inlineQueue.length; n++) {
            let r = this.inlineQueue[n];
            this.inlineTokens(r.src, r.tokens)
        }
        return this.inlineQueue = [],
        this.tokens
    }
    blockTokens(t, n=[], r=!1) {
        for (this.options.pedantic && (t = t.replace(Hi.tabCharGlobal, "    ").replace(Hi.spaceLine, "")); t; ) {
            let i;
            if (this.options.extensions?.block?.some(a => (i = a.call({
                lexer: this
            }, t, n)) ? (t = t.substring(i.raw.length),
            n.push(i),
            !0) : !1))
                continue;
            if (i = this.tokenizer.space(t)) {
                t = t.substring(i.raw.length);
                let a = n.at(-1);
                i.raw.length === 1 && a !== void 0 ? a.raw += `
` : n.push(i);
                continue
            }
            if (i = this.tokenizer.code(t)) {
                t = t.substring(i.raw.length);
                let a = n.at(-1);
                a?.type === "paragraph" || a?.type === "text" ? (a.raw += (a.raw.endsWith(`
`) ? "" : `
`) + i.raw,
                a.text += `
` + i.text,
                this.inlineQueue.at(-1).src = a.text) : n.push(i);
                continue
            }
            if (i = this.tokenizer.fences(t)) {
                t = t.substring(i.raw.length),
                n.push(i);
                continue
            }
            if (i = this.tokenizer.heading(t)) {
                t = t.substring(i.raw.length),
                n.push(i);
                continue
            }
            if (i = this.tokenizer.hr(t)) {
                t = t.substring(i.raw.length),
                n.push(i);
                continue
            }
            if (i = this.tokenizer.blockquote(t)) {
                t = t.substring(i.raw.length),
                n.push(i);
                continue
            }
            if (i = this.tokenizer.list(t)) {
                t = t.substring(i.raw.length),
                n.push(i);
                continue
            }
            if (i = this.tokenizer.html(t)) {
                t = t.substring(i.raw.length),
                n.push(i);
                continue
            }
            if (i = this.tokenizer.def(t)) {
                t = t.substring(i.raw.length);
                let a = n.at(-1);
                a?.type === "paragraph" || a?.type === "text" ? (a.raw += (a.raw.endsWith(`
`) ? "" : `
`) + i.raw,
                a.text += `
` + i.raw,
                this.inlineQueue.at(-1).src = a.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = {
                    href: i.href,
                    title: i.title
                },
                n.push(i));
                continue
            }
            if (i = this.tokenizer.table(t)) {
                t = t.substring(i.raw.length),
                n.push(i);
                continue
            }
            if (i = this.tokenizer.lheading(t)) {
                t = t.substring(i.raw.length),
                n.push(i);
                continue
            }
            let o = t;
            if (this.options.extensions?.startBlock) {
                let a = 1 / 0, s = t.slice(1), c;
                this.options.extensions.startBlock.forEach(u => {
                    c = u.call({
                        lexer: this
                    }, s),
                    typeof c == "number" && c >= 0 && (a = Math.min(a, c))
                }
                ),
                a < 1 / 0 && a >= 0 && (o = t.substring(0, a + 1))
            }
            if (this.state.top && (i = this.tokenizer.paragraph(o))) {
                let a = n.at(-1);
                r && a?.type === "paragraph" ? (a.raw += (a.raw.endsWith(`
`) ? "" : `
`) + i.raw,
                a.text += `
` + i.text,
                this.inlineQueue.pop(),
                this.inlineQueue.at(-1).src = a.text) : n.push(i),
                r = o.length !== t.length,
                t = t.substring(i.raw.length);
                continue
            }
            if (i = this.tokenizer.text(t)) {
                t = t.substring(i.raw.length);
                let a = n.at(-1);
                a?.type === "text" ? (a.raw += (a.raw.endsWith(`
`) ? "" : `
`) + i.raw,
                a.text += `
` + i.text,
                this.inlineQueue.pop(),
                this.inlineQueue.at(-1).src = a.text) : n.push(i);
                continue
            }
            if (t) {
                let a = "Infinite loop on byte: " + t.charCodeAt(0);
                if (this.options.silent) {
                    console.error(a);
                    break
                } else
                    throw new Error(a)
            }
        }
        return this.state.top = !0,
        n
    }
    inline(t, n=[]) {
        return this.inlineQueue.push({
            src: t,
            tokens: n
        }),
        n
    }
    inlineTokens(t, n=[]) {
        let r = t
          , i = null;
        if (this.tokens.links) {
            let s = Object.keys(this.tokens.links);
            if (s.length > 0)
                for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(r)) != null; )
                    s.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
        }
        for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(r)) != null; )
            r = r.slice(0, i.index) + "++" + r.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        for (; (i = this.tokenizer.rules.inline.blockSkip.exec(r)) != null; )
            r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        r = this.options.hooks?.emStrongMask?.call({
            lexer: this
        }, r) ?? r;
        let o = !1
          , a = "";
        for (; t; ) {
            o || (a = ""),
            o = !1;
            let s;
            if (this.options.extensions?.inline?.some(u => (s = u.call({
                lexer: this
            }, t, n)) ? (t = t.substring(s.raw.length),
            n.push(s),
            !0) : !1))
                continue;
            if (s = this.tokenizer.escape(t)) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            if (s = this.tokenizer.tag(t)) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            if (s = this.tokenizer.link(t)) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            if (s = this.tokenizer.reflink(t, this.tokens.links)) {
                t = t.substring(s.raw.length);
                let u = n.at(-1);
                s.type === "text" && u?.type === "text" ? (u.raw += s.raw,
                u.text += s.text) : n.push(s);
                continue
            }
            if (s = this.tokenizer.emStrong(t, r, a)) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            if (s = this.tokenizer.codespan(t)) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            if (s = this.tokenizer.br(t)) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            if (s = this.tokenizer.del(t)) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            if (s = this.tokenizer.autolink(t)) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            if (!this.state.inLink && (s = this.tokenizer.url(t))) {
                t = t.substring(s.raw.length),
                n.push(s);
                continue
            }
            let c = t;
            if (this.options.extensions?.startInline) {
                let u = 1 / 0, f = t.slice(1), h;
                this.options.extensions.startInline.forEach(m => {
                    h = m.call({
                        lexer: this
                    }, f),
                    typeof h == "number" && h >= 0 && (u = Math.min(u, h))
                }
                ),
                u < 1 / 0 && u >= 0 && (c = t.substring(0, u + 1))
            }
            if (s = this.tokenizer.inlineText(c)) {
                t = t.substring(s.raw.length),
                s.raw.slice(-1) !== "_" && (a = s.raw.slice(-1)),
                o = !0;
                let u = n.at(-1);
                u?.type === "text" ? (u.raw += s.raw,
                u.text += s.text) : n.push(s);
                continue
            }
            if (t) {
                let u = "Infinite loop on byte: " + t.charCodeAt(0);
                if (this.options.silent) {
                    console.error(u);
                    break
                } else
                    throw new Error(u)
            }
        }
        return n
    }
}
  , mv = class {
    options;
    parser;
    constructor(t) {
        this.options = t || ud
    }
    space(t) {
        return ""
    }
    code({text: t, lang: n, escaped: r}) {
        let i = (n || "").match(Hi.notSpaceStart)?.[0]
          , o = t.replace(Hi.endingNewline, "") + `
`;
        return i ? '<pre><code class="language-' + hs(i) + '">' + (r ? o : hs(o, !0)) + `</code></pre>
` : "<pre><code>" + (r ? o : hs(o, !0)) + `</code></pre>
`
    }
    blockquote({tokens: t}) {
        return `<blockquote>
${this.parser.parse(t)}</blockquote>
`
    }
    html({text: t}) {
        return t
    }
    def(t) {
        return ""
    }
    heading({tokens: t, depth: n}) {
        return `<h${n}>${this.parser.parseInline(t)}</h${n}>
`
    }
    hr(t) {
        return `<hr>
`
    }
    list(t) {
        let n = t.ordered
          , r = t.start
          , i = "";
        for (let s = 0; s < t.items.length; s++) {
            let c = t.items[s];
            i += this.listitem(c)
        }
        let o = n ? "ol" : "ul"
          , a = n && r !== 1 ? ' start="' + r + '"' : "";
        return "<" + o + a + `>
` + i + "</" + o + `>
`
    }
    listitem(t) {
        let n = "";
        if (t.task) {
            let r = this.checkbox({
                checked: !!t.checked
            });
            t.loose ? t.tokens[0]?.type === "paragraph" ? (t.tokens[0].text = r + " " + t.tokens[0].text,
            t.tokens[0].tokens && t.tokens[0].tokens.length > 0 && t.tokens[0].tokens[0].type === "text" && (t.tokens[0].tokens[0].text = r + " " + hs(t.tokens[0].tokens[0].text),
            t.tokens[0].tokens[0].escaped = !0)) : t.tokens.unshift({
                type: "text",
                raw: r + " ",
                text: r + " ",
                escaped: !0
            }) : n += r + " "
        }
        return n += this.parser.parse(t.tokens, !!t.loose),
        `<li>${n}</li>
`
    }
    checkbox({checked: t}) {
        return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox">'
    }
    paragraph({tokens: t}) {
        return `<p>${this.parser.parseInline(t)}</p>
`
    }
    table(t) {
        let n = ""
          , r = "";
        for (let o = 0; o < t.header.length; o++)
            r += this.tablecell(t.header[o]);
        n += this.tablerow({
            text: r
        });
        let i = "";
        for (let o = 0; o < t.rows.length; o++) {
            let a = t.rows[o];
            r = "";
            for (let s = 0; s < a.length; s++)
                r += this.tablecell(a[s]);
            i += this.tablerow({
                text: r
            })
        }
        return i && (i = `<tbody>${i}</tbody>`),
        `<table>
<thead>
` + n + `</thead>
` + i + `</table>
`
    }
    tablerow({text: t}) {
        return `<tr>
${t}</tr>
`
    }
    tablecell(t) {
        let n = this.parser.parseInline(t.tokens)
          , r = t.header ? "th" : "td";
        return (t.align ? `<${r} align="${t.align}">` : `<${r}>`) + n + `</${r}>
`
    }
    strong({tokens: t}) {
        return `<strong>${this.parser.parseInline(t)}</strong>`
    }
    em({tokens: t}) {
        return `<em>${this.parser.parseInline(t)}</em>`
    }
    codespan({text: t}) {
        return `<code>${hs(t, !0)}</code>`
    }
    br(t) {
        return "<br>"
    }
    del({tokens: t}) {
        return `<del>${this.parser.parseInline(t)}</del>`
    }
    link({href: t, title: n, tokens: r}) {
        let i = this.parser.parseInline(r)
          , o = Yz(t);
        if (o === null)
            return i;
        t = o;
        let a = '<a href="' + t + '"';
        return n && (a += ' title="' + hs(n) + '"'),
        a += ">" + i + "</a>",
        a
    }
    image({href: t, title: n, text: r, tokens: i}) {
        i && (r = this.parser.parseInline(i, this.parser.textRenderer));
        let o = Yz(t);
        if (o === null)
            return hs(r);
        t = o;
        let a = `<img src="${t}" alt="${r}"`;
        return n && (a += ` title="${hs(n)}"`),
        a += ">",
        a
    }
    text(t) {
        return "tokens"in t && t.tokens ? this.parser.parseInline(t.tokens) : "escaped"in t && t.escaped ? t.text : hs(t.text)
    }
}
  , WM = class {
    strong({text: t}) {
        return t
    }
    em({text: t}) {
        return t
    }
    codespan({text: t}) {
        return t
    }
    del({text: t}) {
        return t
    }
    html({text: t}) {
        return t
    }
    text({text: t}) {
        return t
    }
    link({text: t}) {
        return "" + t
    }
    image({text: t}) {
        return "" + t
    }
    br() {
        return ""
    }
}
  , Ba = class P_ {
    options;
    renderer;
    textRenderer;
    constructor(t) {
        this.options = t || ud,
        this.options.renderer = this.options.renderer || new mv,
        this.renderer = this.options.renderer,
        this.renderer.options = this.options,
        this.renderer.parser = this,
        this.textRenderer = new WM
    }
    static parse(t, n) {
        return new P_(n).parse(t)
    }
    static parseInline(t, n) {
        return new P_(n).parseInline(t)
    }
    parse(t, n=!0) {
        let r = "";
        for (let i = 0; i < t.length; i++) {
            let o = t[i];
            if (this.options.extensions?.renderers?.[o.type]) {
                let s = o
                  , c = this.options.extensions.renderers[s.type].call({
                    parser: this
                }, s);
                if (c !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(s.type)) {
                    r += c || "";
                    continue
                }
            }
            let a = o;
            switch (a.type) {
            case "space":
                {
                    r += this.renderer.space(a);
                    continue
                }
            case "hr":
                {
                    r += this.renderer.hr(a);
                    continue
                }
            case "heading":
                {
                    r += this.renderer.heading(a);
                    continue
                }
            case "code":
                {
                    r += this.renderer.code(a);
                    continue
                }
            case "table":
                {
                    r += this.renderer.table(a);
                    continue
                }
            case "blockquote":
                {
                    r += this.renderer.blockquote(a);
                    continue
                }
            case "list":
                {
                    r += this.renderer.list(a);
                    continue
                }
            case "html":
                {
                    r += this.renderer.html(a);
                    continue
                }
            case "def":
                {
                    r += this.renderer.def(a);
                    continue
                }
            case "paragraph":
                {
                    r += this.renderer.paragraph(a);
                    continue
                }
            case "text":
                {
                    let s = a
                      , c = this.renderer.text(s);
                    for (; i + 1 < t.length && t[i + 1].type === "text"; )
                        s = t[++i],
                        c += `
` + this.renderer.text(s);
                    n ? r += this.renderer.paragraph({
                        type: "paragraph",
                        raw: c,
                        text: c,
                        tokens: [{
                            type: "text",
                            raw: c,
                            text: c,
                            escaped: !0
                        }]
                    }) : r += c;
                    continue
                }
            default:
                {
                    let s = 'Token with "' + a.type + '" type was not found.';
                    if (this.options.silent)
                        return console.error(s),
                        "";
                    throw new Error(s)
                }
            }
        }
        return r
    }
    parseInline(t, n=this.renderer) {
        let r = "";
        for (let i = 0; i < t.length; i++) {
            let o = t[i];
            if (this.options.extensions?.renderers?.[o.type]) {
                let s = this.options.extensions.renderers[o.type].call({
                    parser: this
                }, o);
                if (s !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(o.type)) {
                    r += s || "";
                    continue
                }
            }
            let a = o;
            switch (a.type) {
            case "escape":
                {
                    r += n.text(a);
                    break
                }
            case "html":
                {
                    r += n.html(a);
                    break
                }
            case "link":
                {
                    r += n.link(a);
                    break
                }
            case "image":
                {
                    r += n.image(a);
                    break
                }
            case "strong":
                {
                    r += n.strong(a);
                    break
                }
            case "em":
                {
                    r += n.em(a);
                    break
                }
            case "codespan":
                {
                    r += n.codespan(a);
                    break
                }
            case "br":
                {
                    r += n.br(a);
                    break
                }
            case "del":
                {
                    r += n.del(a);
                    break
                }
            case "text":
                {
                    r += n.text(a);
                    break
                }
            default:
                {
                    let s = 'Token with "' + a.type + '" type was not found.';
                    if (this.options.silent)
                        return console.error(s),
                        "";
                    throw new Error(s)
                }
            }
        }
        return r
    }
}
  , am = class {
    options;
    block;
    constructor(t) {
        this.options = t || ud
    }
    static passThroughHooks = new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
    static passThroughHooksRespectAsync = new Set(["preprocess", "postprocess", "processAllTokens"]);
    preprocess(t) {
        return t
    }
    postprocess(t) {
        return t
    }
    processAllTokens(t) {
        return t
    }
    emStrongMask(t) {
        return t
    }
    provideLexer() {
        return this.block ? ja.lex : ja.lexInline
    }
    provideParser() {
        return this.block ? Ba.parse : Ba.parseInline
    }
}
  , CIe = class {
    defaults = BM();
    options = this.setOptions;
    parse = this.parseMarkdown(!0);
    parseInline = this.parseMarkdown(!1);
    Parser = Ba;
    Renderer = mv;
    TextRenderer = WM;
    Lexer = ja;
    Tokenizer = pv;
    Hooks = am;
    constructor(...t) {
        this.use(...t)
    }
    walkTokens(t, n) {
        let r = [];
        for (let i of t)
            switch (r = r.concat(n.call(this, i)),
            i.type) {
            case "table":
                {
                    let o = i;
                    for (let a of o.header)
                        r = r.concat(this.walkTokens(a.tokens, n));
                    for (let a of o.rows)
                        for (let s of a)
                            r = r.concat(this.walkTokens(s.tokens, n));
                    break
                }
            case "list":
                {
                    let o = i;
                    r = r.concat(this.walkTokens(o.items, n));
                    break
                }
            default:
                {
                    let o = i;
                    this.defaults.extensions?.childTokens?.[o.type] ? this.defaults.extensions.childTokens[o.type].forEach(a => {
                        let s = o[a].flat(1 / 0);
                        r = r.concat(this.walkTokens(s, n))
                    }
                    ) : o.tokens && (r = r.concat(this.walkTokens(o.tokens, n)))
                }
            }
        return r
    }
    use(...t) {
        let n = this.defaults.extensions || {
            renderers: {},
            childTokens: {}
        };
        return t.forEach(r => {
            let i = {
                ...r
            };
            if (i.async = this.defaults.async || i.async || !1,
            r.extensions && (r.extensions.forEach(o => {
                if (!o.name)
                    throw new Error("extension name required");
                if ("renderer"in o) {
                    let a = n.renderers[o.name];
                    a ? n.renderers[o.name] = function(...s) {
                        let c = o.renderer.apply(this, s);
                        return c === !1 && (c = a.apply(this, s)),
                        c
                    }
                    : n.renderers[o.name] = o.renderer
                }
                if ("tokenizer"in o) {
                    if (!o.level || o.level !== "block" && o.level !== "inline")
                        throw new Error("extension level must be 'block' or 'inline'");
                    let a = n[o.level];
                    a ? a.unshift(o.tokenizer) : n[o.level] = [o.tokenizer],
                    o.start && (o.level === "block" ? n.startBlock ? n.startBlock.push(o.start) : n.startBlock = [o.start] : o.level === "inline" && (n.startInline ? n.startInline.push(o.start) : n.startInline = [o.start]))
                }
                "childTokens"in o && o.childTokens && (n.childTokens[o.name] = o.childTokens)
            }
            ),
            i.extensions = n),
            r.renderer) {
                let o = this.defaults.renderer || new mv(this.defaults);
                for (let a in r.renderer) {
                    if (!(a in o))
                        throw new Error(`renderer '${a}' does not exist`);
                    if (["options", "parser"].includes(a))
                        continue;
                    let s = a
                      , c = r.renderer[s]
                      , u = o[s];
                    o[s] = (...f) => {
                        let h = c.apply(o, f);
                        return h === !1 && (h = u.apply(o, f)),
                        h || ""
                    }
                }
                i.renderer = o
            }
            if (r.tokenizer) {
                let o = this.defaults.tokenizer || new pv(this.defaults);
                for (let a in r.tokenizer) {
                    if (!(a in o))
                        throw new Error(`tokenizer '${a}' does not exist`);
                    if (["options", "rules", "lexer"].includes(a))
                        continue;
                    let s = a
                      , c = r.tokenizer[s]
                      , u = o[s];
                    o[s] = (...f) => {
                        let h = c.apply(o, f);
                        return h === !1 && (h = u.apply(o, f)),
                        h
                    }
                }
                i.tokenizer = o
            }
            if (r.hooks) {
                let o = this.defaults.hooks || new am;
                for (let a in r.hooks) {
                    if (!(a in o))
                        throw new Error(`hook '${a}' does not exist`);
                    if (["options", "block"].includes(a))
                        continue;
                    let s = a
                      , c = r.hooks[s]
                      , u = o[s];
                    am.passThroughHooks.has(a) ? o[s] = f => {
                        if (this.defaults.async && am.passThroughHooksRespectAsync.has(a))
                            return (async () => {
                                let m = await c.call(o, f);
                                return u.call(o, m)
                            }
                            )();
                        let h = c.call(o, f);
                        return u.call(o, h)
                    }
                    : o[s] = (...f) => {
                        if (this.defaults.async)
                            return (async () => {
                                let m = await c.apply(o, f);
                                return m === !1 && (m = await u.apply(o, f)),
                                m
                            }
                            )();
                        let h = c.apply(o, f);
                        return h === !1 && (h = u.apply(o, f)),
                        h
                    }
                }
                i.hooks = o
            }
            if (r.walkTokens) {
                let o = this.defaults.walkTokens
                  , a = r.walkTokens;
                i.walkTokens = function(s) {
                    let c = [];
                    return c.push(a.call(this, s)),
                    o && (c = c.concat(o.call(this, s))),
                    c
                }
            }
            this.defaults = {
                ...this.defaults,
                ...i
            }
        }
        ),
        this
    }
    setOptions(t) {
        return this.defaults = {
            ...this.defaults,
            ...t
        },
        this
    }
    lexer(t, n) {
        return ja.lex(t, n ?? this.defaults)
    }
    parser(t, n) {
        return Ba.parse(t, n ?? this.defaults)
    }
    parseMarkdown(t) {
        return (n, r) => {
            let i = {
                ...r
            }
              , o = {
                ...this.defaults,
                ...i
            }
              , a = this.onError(!!o.silent, !!o.async);
            if (this.defaults.async === !0 && i.async === !1)
                return a(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
            if (typeof n > "u" || n === null)
                return a(new Error("marked(): input parameter is undefined or null"));
            if (typeof n != "string")
                return a(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
            if (o.hooks && (o.hooks.options = o,
            o.hooks.block = t),
            o.async)
                return (async () => {
                    let s = o.hooks ? await o.hooks.preprocess(n) : n
                      , c = await (o.hooks ? await o.hooks.provideLexer() : t ? ja.lex : ja.lexInline)(s, o)
                      , u = o.hooks ? await o.hooks.processAllTokens(c) : c;
                    o.walkTokens && await Promise.all(this.walkTokens(u, o.walkTokens));
                    let f = await (o.hooks ? await o.hooks.provideParser() : t ? Ba.parse : Ba.parseInline)(u, o);
                    return o.hooks ? await o.hooks.postprocess(f) : f
                }
                )().catch(a);
            try {
                o.hooks && (n = o.hooks.preprocess(n));
                let s = (o.hooks ? o.hooks.provideLexer() : t ? ja.lex : ja.lexInline)(n, o);
                o.hooks && (s = o.hooks.processAllTokens(s)),
                o.walkTokens && this.walkTokens(s, o.walkTokens);
                let c = (o.hooks ? o.hooks.provideParser() : t ? Ba.parse : Ba.parseInline)(s, o);
                return o.hooks && (c = o.hooks.postprocess(c)),
                c
            } catch (s) {
                return a(s)
            }
        }
    }
    onError(t, n) {
        return r => {
            if (r.message += `
Please report this to https://github.com/markedjs/marked.`,
            t) {
                let i = "<p>An error occurred:</p><pre>" + hs(r.message + "", !0) + "</pre>";
                return n ? Promise.resolve(i) : i
            }
            if (n)
                return Promise.reject(r);
            throw r
        }
    }
}
  , Ju = new CIe;
function Hn(e, t) {
    return Ju.parse(e, t)
}
Hn.options = Hn.setOptions = function(e) {
    return Ju.setOptions(e),
    Hn.defaults = Ju.defaults,
    MH(Hn.defaults),
    Hn
}
;
Hn.getDefaults = BM;
Hn.defaults = ud;
Hn.use = function(...e) {
    return Ju.use(...e),
    Hn.defaults = Ju.defaults,
    MH(Hn.defaults),
    Hn
}
;
Hn.walkTokens = function(e, t) {
    return Ju.walkTokens(e, t)
}
;
Hn.parseInline = Ju.parseInline;
Hn.Parser = Ba;
Hn.parser = Ba.parse;
Hn.Renderer = mv;
Hn.TextRenderer = WM;
Hn.Lexer = ja;
Hn.lexer = ja.lex;
Hn.Tokenizer = pv;
Hn.Hooks = am;
Hn.parse = Hn;
Hn.options;
Hn.setOptions;
Hn.use;
Hn.walkTokens;
Hn.parseInline;
Ba.parse;
ja.lex;
function FH(e) {
    for (var t = [], n = 1; n < arguments.length; n++)
        t[n - 1] = arguments[n];
    var r = Array.from(typeof e == "string" ? [e] : e);
    r[r.length - 1] = r[r.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var i = r.reduce(function(s, c) {
        var u = c.match(/\n([\t ]+|(?!\s).)/g);
        return u ? s.concat(u.map(function(f) {
            var h, m;
            return (m = (h = f.match(/[\t ]/g)) === null || h === void 0 ? void 0 : h.length) !== null && m !== void 0 ? m : 0
        })) : s
    }, []);
    if (i.length) {
        var o = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}","g");
        r = r.map(function(s) {
            return s.replace(o, `
`)
        })
    }
    r[0] = r[0].replace(/^\r?\n/, "");
    var a = r[0];
    return t.forEach(function(s, c) {
        var u = a.match(/(?:^|\n)( *)$/)
          , f = u ? u[1] : ""
          , h = s;
        typeof s == "string" && s.includes(`
`) && (h = String(s).split(`
`).map(function(m, y) {
            return y === 0 ? m : "" + f + m
        }).join(`
`)),
        a += h + r[c + 1]
    }),
    a
}
var wIe = {
    body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
    height: 80,
    width: 80
}
  , R_ = new Map
  , NH = new Map
  , kIe = U(e => {
    for (const t of e) {
        if (!t.name)
            throw new Error('Invalid icon loader. Must have a "name" property with non-empty string value.');
        if (Qe.debug("Registering icon pack:", t.name),
        "loader"in t)
            NH.set(t.name, t.loader);
        else if ("icons"in t)
            R_.set(t.name, t.icons);
        else
            throw Qe.error("Invalid icon loader:", t),
            new Error('Invalid icon loader. Must have either "icons" or "loader" property.')
    }
}
, "registerIconPacks")
  , UH = U(async (e, t) => {
    const n = TOe(e, !0, t !== void 0);
    if (!n)
        throw new Error(`Invalid icon name: ${e}`);
    const r = n.prefix || t;
    if (!r)
        throw new Error(`Icon name must contain a prefix: ${e}`);
    let i = R_.get(r);
    if (!i) {
        const a = NH.get(r);
        if (!a)
            throw new Error(`Icon set not found: ${n.prefix}`);
        try {
            i = {
                ...await a(),
                prefix: r
            },
            R_.set(r, i)
        } catch (s) {
            throw Qe.error(s),
            new Error(`Failed to load icon set: ${n.prefix}`)
        }
    }
    const o = AOe(i, n.name);
    if (!o)
        throw new Error(`Icon not found: ${e}`);
    return o
}
, "getRegisteredIconData")
  , TIe = U(async e => {
    try {
        return await UH(e),
        !0
    } catch {
        return !1
    }
}
, "isIconAvailable")
  , uy = U(async (e, t, n) => {
    let r;
    try {
        r = await UH(e, t?.fallbackPrefix)
    } catch (a) {
        Qe.error(a),
        r = wIe
    }
    const i = $Oe(r, t)
      , o = FOe(zOe(i.body), {
        ...i.attributes,
        ...n
    });
    return ka(o, Mi())
}
, "getIconSVG");
function VH(e, {markdownAutoWrap: t}) {
    const r = e.replace(/<br\/>/g, `
`).replace(/\n{2,}/g, `
`)
      , i = FH(r);
    return t === !1 ? i.replace(/ /g, "&nbsp;") : i
}
U(VH, "preprocessMarkdown");
function HH(e, t={}) {
    const n = VH(e, t)
      , r = Hn.lexer(n)
      , i = [[]];
    let o = 0;
    function a(s, c="normal") {
        s.type === "text" ? s.text.split(`
`).forEach( (f, h) => {
            h !== 0 && (o++,
            i.push([])),
            f.split(" ").forEach(m => {
                m = m.replace(/&#39;/g, "'"),
                m && i[o].push({
                    content: m,
                    type: c
                })
            }
            )
        }
        ) : s.type === "strong" || s.type === "em" ? s.tokens.forEach(u => {
            a(u, s.type)
        }
        ) : s.type === "html" && i[o].push({
            content: s.text,
            type: "normal"
        })
    }
    return U(a, "processNode"),
    r.forEach(s => {
        s.type === "paragraph" ? s.tokens?.forEach(c => {
            a(c)
        }
        ) : s.type === "html" ? i[o].push({
            content: s.text,
            type: "normal"
        }) : i[o].push({
            content: s.raw,
            type: "normal"
        })
    }
    ),
    i
}
U(HH, "markdownToLines");
function qH(e, {markdownAutoWrap: t}={}) {
    const n = Hn.lexer(e);
    function r(i) {
        return i.type === "text" ? t === !1 ? i.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;") : i.text.replace(/\n */g, "<br/>") : i.type === "strong" ? `<strong>${i.tokens?.map(r).join("")}</strong>` : i.type === "em" ? `<em>${i.tokens?.map(r).join("")}</em>` : i.type === "paragraph" ? `<p>${i.tokens?.map(r).join("")}</p>` : i.type === "space" ? "" : i.type === "html" ? `${i.text}` : i.type === "escape" ? i.text : (Qe.warn(`Unsupported markdown: ${i.type}`),
        i.raw)
    }
    return U(r, "output"),
    n.map(r).join("")
}
U(qH, "markdownToHTML");
function WH(e) {
    return Intl.Segmenter ? [...new Intl.Segmenter().segment(e)].map(t => t.segment) : [...e]
}
U(WH, "splitTextToChars");
function GH(e, t) {
    const n = WH(t.content);
    return GM(e, [], n, t.type)
}
U(GH, "splitWordToFitWidth");
function GM(e, t, n, r) {
    if (n.length === 0)
        return [{
            content: t.join(""),
            type: r
        }, {
            content: "",
            type: r
        }];
    const [i,...o] = n
      , a = [...t, i];
    return e([{
        content: a.join(""),
        type: r
    }]) ? GM(e, a, o, r) : (t.length === 0 && i && (t.push(i),
    n.shift()),
    [{
        content: t.join(""),
        type: r
    }, {
        content: n.join(""),
        type: r
    }])
}
U(GM, "splitWordToFitWidthRecursion");
function YH(e, t) {
    if (e.some( ({content: n}) => n.includes(`
`)))
        throw new Error("splitLineToFitWidth does not support newlines in the line");
    return gv(e, t)
}
U(YH, "splitLineToFitWidth");
function gv(e, t, n=[], r=[]) {
    if (e.length === 0)
        return r.length > 0 && n.push(r),
        n.length > 0 ? n : [];
    let i = "";
    e[0].content === " " && (i = " ",
    e.shift());
    const o = e.shift() ?? {
        content: " ",
        type: "normal"
    }
      , a = [...r];
    if (i !== "" && a.push({
        content: i,
        type: "normal"
    }),
    a.push(o),
    t(a))
        return gv(e, t, n, a);
    if (r.length > 0)
        n.push(r),
        e.unshift(o);
    else if (o.content) {
        const [s,c] = GH(t, o);
        n.push([s]),
        c.content && e.unshift(c)
    }
    return gv(e, t, n)
}
U(gv, "splitLineToFitWidthRecursion");
function D_(e, t) {
    t && e.attr("style", t)
}
U(D_, "applyStyle");
async function ZH(e, t, n, r, i=!1, o=Mi()) {
    const a = e.append("foreignObject");
    a.attr("width", `${10 * n}px`),
    a.attr("height", `${10 * n}px`);
    const s = a.append("xhtml:div")
      , c = eh(t.label) ? await nM(t.label.replace(vh.lineBreakRegex, `
`), o) : ka(t.label, o)
      , u = t.isNode ? "nodeLabel" : "edgeLabel"
      , f = s.append("span");
    f.html(c),
    D_(f, t.labelStyle),
    f.attr("class", `${u} ${r}`),
    D_(s, t.labelStyle),
    s.style("display", "table-cell"),
    s.style("white-space", "nowrap"),
    s.style("line-height", "1.5"),
    s.style("max-width", n + "px"),
    s.style("text-align", "center"),
    s.attr("xmlns", "http://www.w3.org/1999/xhtml"),
    i && s.attr("class", "labelBkg");
    let h = s.node().getBoundingClientRect();
    return h.width === n && (s.style("display", "table"),
    s.style("white-space", "break-spaces"),
    s.style("width", n + "px"),
    h = s.node().getBoundingClientRect()),
    a.node()
}
U(ZH, "addHtmlSpan");
function rS(e, t, n) {
    return e.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", t * n - .1 + "em").attr("dy", n + "em")
}
U(rS, "createTspan");
function QH(e, t, n) {
    const r = e.append("text")
      , i = rS(r, 1, t);
    iS(i, n);
    const o = i.node().getComputedTextLength();
    return r.remove(),
    o
}
U(QH, "computeWidthOfText");
function _Ie(e, t, n) {
    const r = e.append("text")
      , i = rS(r, 1, t);
    iS(i, [{
        content: n,
        type: "normal"
    }]);
    const o = i.node()?.getBoundingClientRect();
    return o && r.remove(),
    o
}
U(_Ie, "computeDimensionOfText");
function KH(e, t, n, r=!1) {
    const o = t.append("g")
      , a = o.insert("rect").attr("class", "background").attr("style", "stroke: none")
      , s = o.append("text").attr("y", "-10.1");
    let c = 0;
    for (const u of n) {
        const f = U(m => QH(o, 1.1, m) <= e, "checkWidth")
          , h = f(u) ? [u] : YH(u, f);
        for (const m of h) {
            const y = rS(s, c, 1.1);
            iS(y, m),
            c++
        }
    }
    if (r) {
        const u = s.node().getBBox()
          , f = 2;
        return a.attr("x", u.x - f).attr("y", u.y - f).attr("width", u.width + 2 * f).attr("height", u.height + 2 * f),
        o.node()
    } else
        return s.node()
}
U(KH, "createFormattedText");
function iS(e, t) {
    e.text(""),
    t.forEach( (n, r) => {
        const i = e.append("tspan").attr("font-style", n.type === "em" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", n.type === "strong" ? "bold" : "normal");
        r === 0 ? i.text(n.content) : i.text(" " + n.content)
    }
    )
}
U(iS, "updateTextContentAndStyles");
async function XH(e, t={}) {
    const n = [];
    e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (i, o, a) => (n.push((async () => {
        const s = `${o}:${a}`;
        return await TIe(s) ? await uy(s, void 0, {
            class: "label-icon"
        }) : `<i class='${ka(i, t).replace(":", " ")}'></i>`
    }
    )()),
    i));
    const r = await Promise.all(n);
    return e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => r.shift() ?? "")
}
U(XH, "replaceIconSubstring");
var Lc = U(async (e, t="", {style: n="", isTitle: r=!1, classes: i="", useHtmlLabels: o=!0, isNode: a=!0, width: s=200, addSvgBackground: c=!1}={}, u) => {
    if (Qe.debug("XYZ createText", t, n, r, i, o, a, "addSvgBackground: ", c),
    o) {
        const f = qH(t, u)
          , h = await XH(cd(f), u)
          , m = t.replace(/\\\\/g, "\\")
          , y = {
            isNode: a,
            label: eh(t) ? m : h,
            labelStyle: n.replace("fill:", "color:")
        };
        return await ZH(e, y, s, i, c, u)
    } else {
        const f = t.replace(/<br\s*\/?>/g, "<br/>")
          , h = HH(f.replace("<br>", "<br/>"), u)
          , m = KH(s, e, h, t ? c : !1);
        if (a) {
            /stroke:/.exec(n) && (n = n.replace("stroke:", "lineColor:"));
            const y = n.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
            En(m).attr("style", y)
        } else {
            const y = n.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
            En(m).select("rect").attr("style", y.replace(/background:/g, "fill:"));
            const b = n.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
            En(m).select("text").attr("style", b)
        }
        return m
    }
}
, "createText");
function o2(e, t, n) {
    if (e && e.length) {
        const [r,i] = t
          , o = Math.PI / 180 * n
          , a = Math.cos(o)
          , s = Math.sin(o);
        for (const c of e) {
            const [u,f] = c;
            c[0] = (u - r) * a - (f - i) * s + r,
            c[1] = (u - r) * s + (f - i) * a + i
        }
    }
}
function EIe(e, t) {
    return e[0] === t[0] && e[1] === t[1]
}
function AIe(e, t, n, r=1) {
    const i = n
      , o = Math.max(t, .1)
      , a = e[0] && e[0][0] && typeof e[0][0] == "number" ? [e] : e
      , s = [0, 0];
    if (i)
        for (const u of a)
            o2(u, s, i);
    const c = (function(u, f, h) {
        const m = [];
        for (const w of u) {
            const k = [...w];
            EIe(k[0], k[k.length - 1]) || k.push([k[0][0], k[0][1]]),
            k.length > 2 && m.push(k)
        }
        const y = [];
        f = Math.max(f, .1);
        const b = [];
        for (const w of m)
            for (let k = 0; k < w.length - 1; k++) {
                const T = w[k]
                  , E = w[k + 1];
                if (T[1] !== E[1]) {
                    const P = Math.min(T[1], E[1]);
                    b.push({
                        ymin: P,
                        ymax: Math.max(T[1], E[1]),
                        x: P === T[1] ? T[0] : E[0],
                        islope: (E[0] - T[0]) / (E[1] - T[1])
                    })
                }
            }
        if (b.sort(( (w, k) => w.ymin < k.ymin ? -1 : w.ymin > k.ymin ? 1 : w.x < k.x ? -1 : w.x > k.x ? 1 : w.ymax === k.ymax ? 0 : (w.ymax - k.ymax) / Math.abs(w.ymax - k.ymax))),
        !b.length)
            return y;
        let v = []
          , S = b[0].ymin
          , C = 0;
        for (; v.length || b.length; ) {
            if (b.length) {
                let w = -1;
                for (let k = 0; k < b.length && !(b[k].ymin > S); k++)
                    w = k;
                b.splice(0, w + 1).forEach((k => {
                    v.push({
                        s: S,
                        edge: k
                    })
                }
                ))
            }
            if (v = v.filter((w => !(w.edge.ymax <= S))),
            v.sort(( (w, k) => w.edge.x === k.edge.x ? 0 : (w.edge.x - k.edge.x) / Math.abs(w.edge.x - k.edge.x))),
            (h !== 1 || C % f == 0) && v.length > 1)
                for (let w = 0; w < v.length; w += 2) {
                    const k = w + 1;
                    if (k >= v.length)
                        break;
                    const T = v[w].edge
                      , E = v[k].edge;
                    y.push([[Math.round(T.x), S], [Math.round(E.x), S]])
                }
            S += h,
            v.forEach((w => {
                w.edge.x = w.edge.x + h * w.edge.islope
            }
            )),
            C++
        }
        return y
    }
    )(a, o, r);
    if (i) {
        for (const u of a)
            o2(u, s, -i);
        (function(u, f, h) {
            const m = [];
            u.forEach((y => m.push(...y))),
            o2(m, f, h)
        }
        )(c, s, -i)
    }
    return c
}
function dy(e, t) {
    var n;
    const r = t.hachureAngle + 90;
    let i = t.hachureGap;
    i < 0 && (i = 4 * t.strokeWidth),
    i = Math.round(Math.max(i, .1));
    let o = 1;
    return t.roughness >= 1 && (((n = t.randomizer) === null || n === void 0 ? void 0 : n.next()) || Math.random()) > .7 && (o = i),
    AIe(e, i, r, o || 1)
}
class YM {
    constructor(t) {
        this.helper = t
    }
    fillPolygons(t, n) {
        return this._fillPolygons(t, n)
    }
    _fillPolygons(t, n) {
        const r = dy(t, n);
        return {
            type: "fillSketch",
            ops: this.renderLines(r, n)
        }
    }
    renderLines(t, n) {
        const r = [];
        for (const i of t)
            r.push(...this.helper.doubleLineOps(i[0][0], i[0][1], i[1][0], i[1][1], n));
        return r
    }
}
function oS(e) {
    const t = e[0]
      , n = e[1];
    return Math.sqrt(Math.pow(t[0] - n[0], 2) + Math.pow(t[1] - n[1], 2))
}
class MIe extends YM {
    fillPolygons(t, n) {
        let r = n.hachureGap;
        r < 0 && (r = 4 * n.strokeWidth),
        r = Math.max(r, .1);
        const i = dy(t, Object.assign({}, n, {
            hachureGap: r
        }))
          , o = Math.PI / 180 * n.hachureAngle
          , a = []
          , s = .5 * r * Math.cos(o)
          , c = .5 * r * Math.sin(o);
        for (const [u,f] of i)
            oS([u, f]) && a.push([[u[0] - s, u[1] + c], [...f]], [[u[0] + s, u[1] - c], [...f]]);
        return {
            type: "fillSketch",
            ops: this.renderLines(a, n)
        }
    }
}
class PIe extends YM {
    fillPolygons(t, n) {
        const r = this._fillPolygons(t, n)
          , i = Object.assign({}, n, {
            hachureAngle: n.hachureAngle + 90
        })
          , o = this._fillPolygons(t, i);
        return r.ops = r.ops.concat(o.ops),
        r
    }
}
class RIe {
    constructor(t) {
        this.helper = t
    }
    fillPolygons(t, n) {
        const r = dy(t, n = Object.assign({}, n, {
            hachureAngle: 0
        }));
        return this.dotsOnLines(r, n)
    }
    dotsOnLines(t, n) {
        const r = [];
        let i = n.hachureGap;
        i < 0 && (i = 4 * n.strokeWidth),
        i = Math.max(i, .1);
        let o = n.fillWeight;
        o < 0 && (o = n.strokeWidth / 2);
        const a = i / 4;
        for (const s of t) {
            const c = oS(s)
              , u = c / i
              , f = Math.ceil(u) - 1
              , h = c - f * i
              , m = (s[0][0] + s[1][0]) / 2 - i / 4
              , y = Math.min(s[0][1], s[1][1]);
            for (let b = 0; b < f; b++) {
                const v = y + h + b * i
                  , S = m - a + 2 * Math.random() * a
                  , C = v - a + 2 * Math.random() * a
                  , w = this.helper.ellipse(S, C, o, o, n);
                r.push(...w.ops)
            }
        }
        return {
            type: "fillSketch",
            ops: r
        }
    }
}
class DIe {
    constructor(t) {
        this.helper = t
    }
    fillPolygons(t, n) {
        const r = dy(t, n);
        return {
            type: "fillSketch",
            ops: this.dashedLine(r, n)
        }
    }
    dashedLine(t, n) {
        const r = n.dashOffset < 0 ? n.hachureGap < 0 ? 4 * n.strokeWidth : n.hachureGap : n.dashOffset
          , i = n.dashGap < 0 ? n.hachureGap < 0 ? 4 * n.strokeWidth : n.hachureGap : n.dashGap
          , o = [];
        return t.forEach((a => {
            const s = oS(a)
              , c = Math.floor(s / (r + i))
              , u = (s + i - c * (r + i)) / 2;
            let f = a[0]
              , h = a[1];
            f[0] > h[0] && (f = a[1],
            h = a[0]);
            const m = Math.atan((h[1] - f[1]) / (h[0] - f[0]));
            for (let y = 0; y < c; y++) {
                const b = y * (r + i)
                  , v = b + r
                  , S = [f[0] + b * Math.cos(m) + u * Math.cos(m), f[1] + b * Math.sin(m) + u * Math.sin(m)]
                  , C = [f[0] + v * Math.cos(m) + u * Math.cos(m), f[1] + v * Math.sin(m) + u * Math.sin(m)];
                o.push(...this.helper.doubleLineOps(S[0], S[1], C[0], C[1], n))
            }
        }
        )),
        o
    }
}
class OIe {
    constructor(t) {
        this.helper = t
    }
    fillPolygons(t, n) {
        const r = n.hachureGap < 0 ? 4 * n.strokeWidth : n.hachureGap
          , i = n.zigzagOffset < 0 ? r : n.zigzagOffset
          , o = dy(t, n = Object.assign({}, n, {
            hachureGap: r + i
        }));
        return {
            type: "fillSketch",
            ops: this.zigzagLines(o, i, n)
        }
    }
    zigzagLines(t, n, r) {
        const i = [];
        return t.forEach((o => {
            const a = oS(o)
              , s = Math.round(a / (2 * n));
            let c = o[0]
              , u = o[1];
            c[0] > u[0] && (c = o[1],
            u = o[0]);
            const f = Math.atan((u[1] - c[1]) / (u[0] - c[0]));
            for (let h = 0; h < s; h++) {
                const m = 2 * h * n
                  , y = 2 * (h + 1) * n
                  , b = Math.sqrt(2 * Math.pow(n, 2))
                  , v = [c[0] + m * Math.cos(f), c[1] + m * Math.sin(f)]
                  , S = [c[0] + y * Math.cos(f), c[1] + y * Math.sin(f)]
                  , C = [v[0] + b * Math.cos(f + Math.PI / 4), v[1] + b * Math.sin(f + Math.PI / 4)];
                i.push(...this.helper.doubleLineOps(v[0], v[1], C[0], C[1], r), ...this.helper.doubleLineOps(C[0], C[1], S[0], S[1], r))
            }
        }
        )),
        i
    }
}
const ao = {};
class IIe {
    constructor(t) {
        this.seed = t
    }
    next() {
        return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random()
    }
}
const $Ie = 0
  , a2 = 1
  , Kz = 2
  , dx = {
    A: 7,
    a: 7,
    C: 6,
    c: 6,
    H: 1,
    h: 1,
    L: 2,
    l: 2,
    M: 2,
    m: 2,
    Q: 4,
    q: 4,
    S: 4,
    s: 4,
    T: 2,
    t: 2,
    V: 1,
    v: 1,
    Z: 0,
    z: 0
};
function s2(e, t) {
    return e.type === t
}
function ZM(e) {
    const t = []
      , n = (function(a) {
        const s = new Array;
        for (; a !== ""; )
            if (a.match(/^([ \t\r\n,]+)/))
                a = a.substr(RegExp.$1.length);
            else if (a.match(/^([aAcChHlLmMqQsStTvVzZ])/))
                s[s.length] = {
                    type: $Ie,
                    text: RegExp.$1
                },
                a = a.substr(RegExp.$1.length);
            else {
                if (!a.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))
                    return [];
                s[s.length] = {
                    type: a2,
                    text: `${parseFloat(RegExp.$1)}`
                },
                a = a.substr(RegExp.$1.length)
            }
        return s[s.length] = {
            type: Kz,
            text: ""
        },
        s
    }
    )(e);
    let r = "BOD"
      , i = 0
      , o = n[i];
    for (; !s2(o, Kz); ) {
        let a = 0;
        const s = [];
        if (r === "BOD") {
            if (o.text !== "M" && o.text !== "m")
                return ZM("M0,0" + e);
            i++,
            a = dx[o.text],
            r = o.text
        } else
            s2(o, a2) ? a = dx[r] : (i++,
            a = dx[o.text],
            r = o.text);
        if (!(i + a < n.length))
            throw new Error("Path data ended short");
        for (let c = i; c < i + a; c++) {
            const u = n[c];
            if (!s2(u, a2))
                throw new Error("Param not a number: " + r + "," + u.text);
            s[s.length] = +u.text
        }
        if (typeof dx[r] != "number")
            throw new Error("Bad segment: " + r);
        {
            const c = {
                key: r,
                data: s
            };
            t.push(c),
            i += a,
            o = n[i],
            r === "M" && (r = "L"),
            r === "m" && (r = "l")
        }
    }
    return t
}
function JH(e) {
    let t = 0
      , n = 0
      , r = 0
      , i = 0;
    const o = [];
    for (const {key: a, data: s} of e)
        switch (a) {
        case "M":
            o.push({
                key: "M",
                data: [...s]
            }),
            [t,n] = s,
            [r,i] = s;
            break;
        case "m":
            t += s[0],
            n += s[1],
            o.push({
                key: "M",
                data: [t, n]
            }),
            r = t,
            i = n;
            break;
        case "L":
            o.push({
                key: "L",
                data: [...s]
            }),
            [t,n] = s;
            break;
        case "l":
            t += s[0],
            n += s[1],
            o.push({
                key: "L",
                data: [t, n]
            });
            break;
        case "C":
            o.push({
                key: "C",
                data: [...s]
            }),
            t = s[4],
            n = s[5];
            break;
        case "c":
            {
                const c = s.map(( (u, f) => f % 2 ? u + n : u + t));
                o.push({
                    key: "C",
                    data: c
                }),
                t = c[4],
                n = c[5];
                break
            }
        case "Q":
            o.push({
                key: "Q",
                data: [...s]
            }),
            t = s[2],
            n = s[3];
            break;
        case "q":
            {
                const c = s.map(( (u, f) => f % 2 ? u + n : u + t));
                o.push({
                    key: "Q",
                    data: c
                }),
                t = c[2],
                n = c[3];
                break
            }
        case "A":
            o.push({
                key: "A",
                data: [...s]
            }),
            t = s[5],
            n = s[6];
            break;
        case "a":
            t += s[5],
            n += s[6],
            o.push({
                key: "A",
                data: [s[0], s[1], s[2], s[3], s[4], t, n]
            });
            break;
        case "H":
            o.push({
                key: "H",
                data: [...s]
            }),
            t = s[0];
            break;
        case "h":
            t += s[0],
            o.push({
                key: "H",
                data: [t]
            });
            break;
        case "V":
            o.push({
                key: "V",
                data: [...s]
            }),
            n = s[0];
            break;
        case "v":
            n += s[0],
            o.push({
                key: "V",
                data: [n]
            });
            break;
        case "S":
            o.push({
                key: "S",
                data: [...s]
            }),
            t = s[2],
            n = s[3];
            break;
        case "s":
            {
                const c = s.map(( (u, f) => f % 2 ? u + n : u + t));
                o.push({
                    key: "S",
                    data: c
                }),
                t = c[2],
                n = c[3];
                break
            }
        case "T":
            o.push({
                key: "T",
                data: [...s]
            }),
            t = s[0],
            n = s[1];
            break;
        case "t":
            t += s[0],
            n += s[1],
            o.push({
                key: "T",
                data: [t, n]
            });
            break;
        case "Z":
        case "z":
            o.push({
                key: "Z",
                data: []
            }),
            t = r,
            n = i
        }
    return o
}
function eq(e) {
    const t = [];
    let n = ""
      , r = 0
      , i = 0
      , o = 0
      , a = 0
      , s = 0
      , c = 0;
    for (const {key: u, data: f} of e) {
        switch (u) {
        case "M":
            t.push({
                key: "M",
                data: [...f]
            }),
            [r,i] = f,
            [o,a] = f;
            break;
        case "C":
            t.push({
                key: "C",
                data: [...f]
            }),
            r = f[4],
            i = f[5],
            s = f[2],
            c = f[3];
            break;
        case "L":
            t.push({
                key: "L",
                data: [...f]
            }),
            [r,i] = f;
            break;
        case "H":
            r = f[0],
            t.push({
                key: "L",
                data: [r, i]
            });
            break;
        case "V":
            i = f[0],
            t.push({
                key: "L",
                data: [r, i]
            });
            break;
        case "S":
            {
                let h = 0
                  , m = 0;
                n === "C" || n === "S" ? (h = r + (r - s),
                m = i + (i - c)) : (h = r,
                m = i),
                t.push({
                    key: "C",
                    data: [h, m, ...f]
                }),
                s = f[0],
                c = f[1],
                r = f[2],
                i = f[3];
                break
            }
        case "T":
            {
                const [h,m] = f;
                let y = 0
                  , b = 0;
                n === "Q" || n === "T" ? (y = r + (r - s),
                b = i + (i - c)) : (y = r,
                b = i);
                const v = r + 2 * (y - r) / 3
                  , S = i + 2 * (b - i) / 3
                  , C = h + 2 * (y - h) / 3
                  , w = m + 2 * (b - m) / 3;
                t.push({
                    key: "C",
                    data: [v, S, C, w, h, m]
                }),
                s = y,
                c = b,
                r = h,
                i = m;
                break
            }
        case "Q":
            {
                const [h,m,y,b] = f
                  , v = r + 2 * (h - r) / 3
                  , S = i + 2 * (m - i) / 3
                  , C = y + 2 * (h - y) / 3
                  , w = b + 2 * (m - b) / 3;
                t.push({
                    key: "C",
                    data: [v, S, C, w, y, b]
                }),
                s = h,
                c = m,
                r = y,
                i = b;
                break
            }
        case "A":
            {
                const h = Math.abs(f[0])
                  , m = Math.abs(f[1])
                  , y = f[2]
                  , b = f[3]
                  , v = f[4]
                  , S = f[5]
                  , C = f[6];
                h === 0 || m === 0 ? (t.push({
                    key: "C",
                    data: [r, i, S, C, S, C]
                }),
                r = S,
                i = C) : (r !== S || i !== C) && (tq(r, i, S, C, h, m, y, b, v).forEach((function(w) {
                    t.push({
                        key: "C",
                        data: w
                    })
                }
                )),
                r = S,
                i = C);
                break
            }
        case "Z":
            t.push({
                key: "Z",
                data: []
            }),
            r = o,
            i = a
        }
        n = u
    }
    return t
}
function Vp(e, t, n) {
    return [e * Math.cos(n) - t * Math.sin(n), e * Math.sin(n) + t * Math.cos(n)]
}
function tq(e, t, n, r, i, o, a, s, c, u) {
    const f = (h = a,
    Math.PI * h / 180);
    var h;
    let m = []
      , y = 0
      , b = 0
      , v = 0
      , S = 0;
    if (u)
        [y,b,v,S] = u;
    else {
        [e,t] = Vp(e, t, -f),
        [n,r] = Vp(n, r, -f);
        const B = (e - n) / 2
          , L = (t - r) / 2;
        let F = B * B / (i * i) + L * L / (o * o);
        F > 1 && (F = Math.sqrt(F),
        i *= F,
        o *= F);
        const j = i * i
          , N = o * o
          , H = j * N - j * L * L - N * B * B
          , Z = j * L * L + N * B * B
          , q = (s === c ? -1 : 1) * Math.sqrt(Math.abs(H / Z));
        v = q * i * L / o + (e + n) / 2,
        S = q * -o * B / i + (t + r) / 2,
        y = Math.asin(parseFloat(((t - S) / o).toFixed(9))),
        b = Math.asin(parseFloat(((r - S) / o).toFixed(9))),
        e < v && (y = Math.PI - y),
        n < v && (b = Math.PI - b),
        y < 0 && (y = 2 * Math.PI + y),
        b < 0 && (b = 2 * Math.PI + b),
        c && y > b && (y -= 2 * Math.PI),
        !c && b > y && (b -= 2 * Math.PI)
    }
    let C = b - y;
    if (Math.abs(C) > 120 * Math.PI / 180) {
        const B = b
          , L = n
          , F = r;
        b = c && b > y ? y + 120 * Math.PI / 180 * 1 : y + 120 * Math.PI / 180 * -1,
        m = tq(n = v + i * Math.cos(b), r = S + o * Math.sin(b), L, F, i, o, a, 0, c, [b, B, v, S])
    }
    C = b - y;
    const w = Math.cos(y)
      , k = Math.sin(y)
      , T = Math.cos(b)
      , E = Math.sin(b)
      , P = Math.tan(C / 4)
      , D = 4 / 3 * i * P
      , $ = 4 / 3 * o * P
      , z = [e, t]
      , O = [e + D * k, t - $ * w]
      , I = [n + D * E, r - $ * T]
      , M = [n, r];
    if (O[0] = 2 * z[0] - O[0],
    O[1] = 2 * z[1] - O[1],
    u)
        return [O, I, M].concat(m);
    {
        m = [O, I, M].concat(m);
        const B = [];
        for (let L = 0; L < m.length; L += 3) {
            const F = Vp(m[L][0], m[L][1], f)
              , j = Vp(m[L + 1][0], m[L + 1][1], f)
              , N = Vp(m[L + 2][0], m[L + 2][1], f);
            B.push([F[0], F[1], j[0], j[1], N[0], N[1]])
        }
        return B
    }
}
const LIe = {
    randOffset: function(e, t) {
        return Gt(e, t)
    },
    randOffsetWithRange: function(e, t, n) {
        return yv(e, t, n)
    },
    ellipse: function(e, t, n, r, i) {
        const o = rq(n, r, i);
        return O_(e, t, i, o).opset
    },
    doubleLineOps: function(e, t, n, r, i) {
        return Tc(e, t, n, r, i, !0)
    }
};
function nq(e, t, n, r, i) {
    return {
        type: "path",
        ops: Tc(e, t, n, r, i)
    }
}
function Zx(e, t, n) {
    const r = (e || []).length;
    if (r > 2) {
        const i = [];
        for (let o = 0; o < r - 1; o++)
            i.push(...Tc(e[o][0], e[o][1], e[o + 1][0], e[o + 1][1], n));
        return t && i.push(...Tc(e[r - 1][0], e[r - 1][1], e[0][0], e[0][1], n)),
        {
            type: "path",
            ops: i
        }
    }
    return r === 2 ? nq(e[0][0], e[0][1], e[1][0], e[1][1], n) : {
        type: "path",
        ops: []
    }
}
function jIe(e, t, n, r, i) {
    return (function(o, a) {
        return Zx(o, !0, a)
    }
    )([[e, t], [e + n, t], [e + n, t + r], [e, t + r]], i)
}
function Xz(e, t) {
    if (e.length) {
        const n = typeof e[0][0] == "number" ? [e] : e
          , r = fx(n[0], 1 * (1 + .2 * t.roughness), t)
          , i = t.disableMultiStroke ? [] : fx(n[0], 1.5 * (1 + .22 * t.roughness), t5(t));
        for (let o = 1; o < n.length; o++) {
            const a = n[o];
            if (a.length) {
                const s = fx(a, 1 * (1 + .2 * t.roughness), t)
                  , c = t.disableMultiStroke ? [] : fx(a, 1.5 * (1 + .22 * t.roughness), t5(t));
                for (const u of s)
                    u.op !== "move" && r.push(u);
                for (const u of c)
                    u.op !== "move" && i.push(u)
            }
        }
        return {
            type: "path",
            ops: r.concat(i)
        }
    }
    return {
        type: "path",
        ops: []
    }
}
function rq(e, t, n) {
    const r = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(e / 2, 2) + Math.pow(t / 2, 2)) / 2))
      , i = Math.ceil(Math.max(n.curveStepCount, n.curveStepCount / Math.sqrt(200) * r))
      , o = 2 * Math.PI / i;
    let a = Math.abs(e / 2)
      , s = Math.abs(t / 2);
    const c = 1 - n.curveFitting;
    return a += Gt(a * c, n),
    s += Gt(s * c, n),
    {
        increment: o,
        rx: a,
        ry: s
    }
}
function O_(e, t, n, r) {
    const [i,o] = n5(r.increment, e, t, r.rx, r.ry, 1, r.increment * yv(.1, yv(.4, 1, n), n), n);
    let a = bv(i, null, n);
    if (!n.disableMultiStroke && n.roughness !== 0) {
        const [s] = n5(r.increment, e, t, r.rx, r.ry, 1.5, 0, n)
          , c = bv(s, null, n);
        a = a.concat(c)
    }
    return {
        estimatedPoints: o,
        opset: {
            type: "path",
            ops: a
        }
    }
}
function Jz(e, t, n, r, i, o, a, s, c) {
    const u = e
      , f = t;
    let h = Math.abs(n / 2)
      , m = Math.abs(r / 2);
    h += Gt(.01 * h, c),
    m += Gt(.01 * m, c);
    let y = i
      , b = o;
    for (; y < 0; )
        y += 2 * Math.PI,
        b += 2 * Math.PI;
    b - y > 2 * Math.PI && (y = 0,
    b = 2 * Math.PI);
    const v = 2 * Math.PI / c.curveStepCount
      , S = Math.min(v / 2, (b - y) / 2)
      , C = r5(S, u, f, h, m, y, b, 1, c);
    if (!c.disableMultiStroke) {
        const w = r5(S, u, f, h, m, y, b, 1.5, c);
        C.push(...w)
    }
    return a && (s ? C.push(...Tc(u, f, u + h * Math.cos(y), f + m * Math.sin(y), c), ...Tc(u, f, u + h * Math.cos(b), f + m * Math.sin(b), c)) : C.push({
        op: "lineTo",
        data: [u, f]
    }, {
        op: "lineTo",
        data: [u + h * Math.cos(y), f + m * Math.sin(y)]
    })),
    {
        type: "path",
        ops: C
    }
}
function e5(e, t) {
    const n = eq(JH(ZM(e)))
      , r = [];
    let i = [0, 0]
      , o = [0, 0];
    for (const {key: a, data: s} of n)
        switch (a) {
        case "M":
            o = [s[0], s[1]],
            i = [s[0], s[1]];
            break;
        case "L":
            r.push(...Tc(o[0], o[1], s[0], s[1], t)),
            o = [s[0], s[1]];
            break;
        case "C":
            {
                const [c,u,f,h,m,y] = s;
                r.push(...BIe(c, u, f, h, m, y, o, t)),
                o = [m, y];
                break
            }
        case "Z":
            r.push(...Tc(o[0], o[1], i[0], i[1], t)),
            o = [i[0], i[1]]
        }
    return {
        type: "path",
        ops: r
    }
}
function l2(e, t) {
    const n = [];
    for (const r of e)
        if (r.length) {
            const i = t.maxRandomnessOffset || 0
              , o = r.length;
            if (o > 2) {
                n.push({
                    op: "move",
                    data: [r[0][0] + Gt(i, t), r[0][1] + Gt(i, t)]
                });
                for (let a = 1; a < o; a++)
                    n.push({
                        op: "lineTo",
                        data: [r[a][0] + Gt(i, t), r[a][1] + Gt(i, t)]
                    })
            }
        }
    return {
        type: "fillPath",
        ops: n
    }
}
function tf(e, t) {
    return (function(n, r) {
        let i = n.fillStyle || "hachure";
        if (!ao[i])
            switch (i) {
            case "zigzag":
                ao[i] || (ao[i] = new MIe(r));
                break;
            case "cross-hatch":
                ao[i] || (ao[i] = new PIe(r));
                break;
            case "dots":
                ao[i] || (ao[i] = new RIe(r));
                break;
            case "dashed":
                ao[i] || (ao[i] = new DIe(r));
                break;
            case "zigzag-line":
                ao[i] || (ao[i] = new OIe(r));
                break;
            default:
                i = "hachure",
                ao[i] || (ao[i] = new YM(r))
            }
        return ao[i]
    }
    )(t, LIe).fillPolygons(e, t)
}
function t5(e) {
    const t = Object.assign({}, e);
    return t.randomizer = void 0,
    e.seed && (t.seed = e.seed + 1),
    t
}
function iq(e) {
    return e.randomizer || (e.randomizer = new IIe(e.seed || 0)),
    e.randomizer.next()
}
function yv(e, t, n, r=1) {
    return n.roughness * r * (iq(n) * (t - e) + e)
}
function Gt(e, t, n=1) {
    return yv(-e, e, t, n)
}
function Tc(e, t, n, r, i, o=!1) {
    const a = o ? i.disableMultiStrokeFill : i.disableMultiStroke
      , s = I_(e, t, n, r, i, !0, !1);
    if (a)
        return s;
    const c = I_(e, t, n, r, i, !0, !0);
    return s.concat(c)
}
function I_(e, t, n, r, i, o, a) {
    const s = Math.pow(e - n, 2) + Math.pow(t - r, 2)
      , c = Math.sqrt(s);
    let u = 1;
    u = c < 200 ? 1 : c > 500 ? .4 : -.0016668 * c + 1.233334;
    let f = i.maxRandomnessOffset || 0;
    f * f * 100 > s && (f = c / 10);
    const h = f / 2
      , m = .2 + .2 * iq(i);
    let y = i.bowing * i.maxRandomnessOffset * (r - t) / 200
      , b = i.bowing * i.maxRandomnessOffset * (e - n) / 200;
    y = Gt(y, i, u),
    b = Gt(b, i, u);
    const v = []
      , S = () => Gt(h, i, u)
      , C = () => Gt(f, i, u)
      , w = i.preserveVertices;
    return a ? v.push({
        op: "move",
        data: [e + (w ? 0 : S()), t + (w ? 0 : S())]
    }) : v.push({
        op: "move",
        data: [e + (w ? 0 : Gt(f, i, u)), t + (w ? 0 : Gt(f, i, u))]
    }),
    a ? v.push({
        op: "bcurveTo",
        data: [y + e + (n - e) * m + S(), b + t + (r - t) * m + S(), y + e + 2 * (n - e) * m + S(), b + t + 2 * (r - t) * m + S(), n + (w ? 0 : S()), r + (w ? 0 : S())]
    }) : v.push({
        op: "bcurveTo",
        data: [y + e + (n - e) * m + C(), b + t + (r - t) * m + C(), y + e + 2 * (n - e) * m + C(), b + t + 2 * (r - t) * m + C(), n + (w ? 0 : C()), r + (w ? 0 : C())]
    }),
    v
}
function fx(e, t, n) {
    if (!e.length)
        return [];
    const r = [];
    r.push([e[0][0] + Gt(t, n), e[0][1] + Gt(t, n)]),
    r.push([e[0][0] + Gt(t, n), e[0][1] + Gt(t, n)]);
    for (let i = 1; i < e.length; i++)
        r.push([e[i][0] + Gt(t, n), e[i][1] + Gt(t, n)]),
        i === e.length - 1 && r.push([e[i][0] + Gt(t, n), e[i][1] + Gt(t, n)]);
    return bv(r, null, n)
}
function bv(e, t, n) {
    const r = e.length
      , i = [];
    if (r > 3) {
        const o = []
          , a = 1 - n.curveTightness;
        i.push({
            op: "move",
            data: [e[1][0], e[1][1]]
        });
        for (let s = 1; s + 2 < r; s++) {
            const c = e[s];
            o[0] = [c[0], c[1]],
            o[1] = [c[0] + (a * e[s + 1][0] - a * e[s - 1][0]) / 6, c[1] + (a * e[s + 1][1] - a * e[s - 1][1]) / 6],
            o[2] = [e[s + 1][0] + (a * e[s][0] - a * e[s + 2][0]) / 6, e[s + 1][1] + (a * e[s][1] - a * e[s + 2][1]) / 6],
            o[3] = [e[s + 1][0], e[s + 1][1]],
            i.push({
                op: "bcurveTo",
                data: [o[1][0], o[1][1], o[2][0], o[2][1], o[3][0], o[3][1]]
            })
        }
    } else
        r === 3 ? (i.push({
            op: "move",
            data: [e[1][0], e[1][1]]
        }),
        i.push({
            op: "bcurveTo",
            data: [e[1][0], e[1][1], e[2][0], e[2][1], e[2][0], e[2][1]]
        })) : r === 2 && i.push(...I_(e[0][0], e[0][1], e[1][0], e[1][1], n, !0, !0));
    return i
}
function n5(e, t, n, r, i, o, a, s) {
    const c = []
      , u = [];
    if (s.roughness === 0) {
        e /= 4,
        u.push([t + r * Math.cos(-e), n + i * Math.sin(-e)]);
        for (let f = 0; f <= 2 * Math.PI; f += e) {
            const h = [t + r * Math.cos(f), n + i * Math.sin(f)];
            c.push(h),
            u.push(h)
        }
        u.push([t + r * Math.cos(0), n + i * Math.sin(0)]),
        u.push([t + r * Math.cos(e), n + i * Math.sin(e)])
    } else {
        const f = Gt(.5, s) - Math.PI / 2;
        u.push([Gt(o, s) + t + .9 * r * Math.cos(f - e), Gt(o, s) + n + .9 * i * Math.sin(f - e)]);
        const h = 2 * Math.PI + f - .01;
        for (let m = f; m < h; m += e) {
            const y = [Gt(o, s) + t + r * Math.cos(m), Gt(o, s) + n + i * Math.sin(m)];
            c.push(y),
            u.push(y)
        }
        u.push([Gt(o, s) + t + r * Math.cos(f + 2 * Math.PI + .5 * a), Gt(o, s) + n + i * Math.sin(f + 2 * Math.PI + .5 * a)]),
        u.push([Gt(o, s) + t + .98 * r * Math.cos(f + a), Gt(o, s) + n + .98 * i * Math.sin(f + a)]),
        u.push([Gt(o, s) + t + .9 * r * Math.cos(f + .5 * a), Gt(o, s) + n + .9 * i * Math.sin(f + .5 * a)])
    }
    return [u, c]
}
function r5(e, t, n, r, i, o, a, s, c) {
    const u = o + Gt(.1, c)
      , f = [];
    f.push([Gt(s, c) + t + .9 * r * Math.cos(u - e), Gt(s, c) + n + .9 * i * Math.sin(u - e)]);
    for (let h = u; h <= a; h += e)
        f.push([Gt(s, c) + t + r * Math.cos(h), Gt(s, c) + n + i * Math.sin(h)]);
    return f.push([t + r * Math.cos(a), n + i * Math.sin(a)]),
    f.push([t + r * Math.cos(a), n + i * Math.sin(a)]),
    bv(f, null, c)
}
function BIe(e, t, n, r, i, o, a, s) {
    const c = []
      , u = [s.maxRandomnessOffset || 1, (s.maxRandomnessOffset || 1) + .3];
    let f = [0, 0];
    const h = s.disableMultiStroke ? 1 : 2
      , m = s.preserveVertices;
    for (let y = 0; y < h; y++)
        y === 0 ? c.push({
            op: "move",
            data: [a[0], a[1]]
        }) : c.push({
            op: "move",
            data: [a[0] + (m ? 0 : Gt(u[0], s)), a[1] + (m ? 0 : Gt(u[0], s))]
        }),
        f = m ? [i, o] : [i + Gt(u[y], s), o + Gt(u[y], s)],
        c.push({
            op: "bcurveTo",
            data: [e + Gt(u[y], s), t + Gt(u[y], s), n + Gt(u[y], s), r + Gt(u[y], s), f[0], f[1]]
        });
    return c
}
function Hp(e) {
    return [...e]
}
function i5(e, t=0) {
    const n = e.length;
    if (n < 3)
        throw new Error("A curve must have at least three points.");
    const r = [];
    if (n === 3)
        r.push(Hp(e[0]), Hp(e[1]), Hp(e[2]), Hp(e[2]));
    else {
        const i = [];
        i.push(e[0], e[0]);
        for (let s = 1; s < e.length; s++)
            i.push(e[s]),
            s === e.length - 1 && i.push(e[s]);
        const o = []
          , a = 1 - t;
        r.push(Hp(i[0]));
        for (let s = 1; s + 2 < i.length; s++) {
            const c = i[s];
            o[0] = [c[0], c[1]],
            o[1] = [c[0] + (a * i[s + 1][0] - a * i[s - 1][0]) / 6, c[1] + (a * i[s + 1][1] - a * i[s - 1][1]) / 6],
            o[2] = [i[s + 1][0] + (a * i[s][0] - a * i[s + 2][0]) / 6, i[s + 1][1] + (a * i[s][1] - a * i[s + 2][1]) / 6],
            o[3] = [i[s + 1][0], i[s + 1][1]],
            r.push(o[1], o[2], o[3])
        }
    }
    return r
}
function Qx(e, t) {
    return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2)
}
function zIe(e, t, n) {
    const r = Qx(t, n);
    if (r === 0)
        return Qx(e, t);
    let i = ((e[0] - t[0]) * (n[0] - t[0]) + (e[1] - t[1]) * (n[1] - t[1])) / r;
    return i = Math.max(0, Math.min(1, i)),
    Qx(e, mu(t, n, i))
}
function mu(e, t, n) {
    return [e[0] + (t[0] - e[0]) * n, e[1] + (t[1] - e[1]) * n]
}
function $_(e, t, n, r) {
    const i = r || [];
    if ((function(s, c) {
        const u = s[c + 0]
          , f = s[c + 1]
          , h = s[c + 2]
          , m = s[c + 3];
        let y = 3 * f[0] - 2 * u[0] - m[0];
        y *= y;
        let b = 3 * f[1] - 2 * u[1] - m[1];
        b *= b;
        let v = 3 * h[0] - 2 * m[0] - u[0];
        v *= v;
        let S = 3 * h[1] - 2 * m[1] - u[1];
        return S *= S,
        y < v && (y = v),
        b < S && (b = S),
        y + b
    }
    )(e, t) < n) {
        const s = e[t + 0];
        i.length ? (o = i[i.length - 1],
        a = s,
        Math.sqrt(Qx(o, a)) > 1 && i.push(s)) : i.push(s),
        i.push(e[t + 3])
    } else {
        const c = e[t + 0]
          , u = e[t + 1]
          , f = e[t + 2]
          , h = e[t + 3]
          , m = mu(c, u, .5)
          , y = mu(u, f, .5)
          , b = mu(f, h, .5)
          , v = mu(m, y, .5)
          , S = mu(y, b, .5)
          , C = mu(v, S, .5);
        $_([c, m, v, C], 0, n, i),
        $_([C, S, b, h], 0, n, i)
    }
    var o, a;
    return i
}
function FIe(e, t) {
    return xv(e, 0, e.length, t)
}
function xv(e, t, n, r, i) {
    const o = i || []
      , a = e[t]
      , s = e[n - 1];
    let c = 0
      , u = 1;
    for (let f = t + 1; f < n - 1; ++f) {
        const h = zIe(e[f], a, s);
        h > c && (c = h,
        u = f)
    }
    return Math.sqrt(c) > r ? (xv(e, t, u + 1, r, o),
    xv(e, u, n, r, o)) : (o.length || o.push(a),
    o.push(s)),
    o
}
function c2(e, t=.15, n) {
    const r = []
      , i = (e.length - 1) / 3;
    for (let o = 0; o < i; o++)
        $_(e, 3 * o, t, r);
    return n && n > 0 ? xv(r, 0, r.length, n) : r
}
const jo = "none";
class vv {
    constructor(t) {
        this.defaultOptions = {
            maxRandomnessOffset: 2,
            roughness: 1,
            bowing: 1,
            stroke: "#000",
            strokeWidth: 1,
            curveTightness: 0,
            curveFitting: .95,
            curveStepCount: 9,
            fillStyle: "hachure",
            fillWeight: -1,
            hachureAngle: -41,
            hachureGap: -1,
            dashOffset: -1,
            dashGap: -1,
            zigzagOffset: -1,
            seed: 0,
            disableMultiStroke: !1,
            disableMultiStrokeFill: !1,
            preserveVertices: !1,
            fillShapeRoughnessGain: .8
        },
        this.config = t || {},
        this.config.options && (this.defaultOptions = this._o(this.config.options))
    }
    static newSeed() {
        return Math.floor(Math.random() * 2 ** 31)
    }
    _o(t) {
        return t ? Object.assign({}, this.defaultOptions, t) : this.defaultOptions
    }
    _d(t, n, r) {
        return {
            shape: t,
            sets: n || [],
            options: r || this.defaultOptions
        }
    }
    line(t, n, r, i, o) {
        const a = this._o(o);
        return this._d("line", [nq(t, n, r, i, a)], a)
    }
    rectangle(t, n, r, i, o) {
        const a = this._o(o)
          , s = []
          , c = jIe(t, n, r, i, a);
        if (a.fill) {
            const u = [[t, n], [t + r, n], [t + r, n + i], [t, n + i]];
            a.fillStyle === "solid" ? s.push(l2([u], a)) : s.push(tf([u], a))
        }
        return a.stroke !== jo && s.push(c),
        this._d("rectangle", s, a)
    }
    ellipse(t, n, r, i, o) {
        const a = this._o(o)
          , s = []
          , c = rq(r, i, a)
          , u = O_(t, n, a, c);
        if (a.fill)
            if (a.fillStyle === "solid") {
                const f = O_(t, n, a, c).opset;
                f.type = "fillPath",
                s.push(f)
            } else
                s.push(tf([u.estimatedPoints], a));
        return a.stroke !== jo && s.push(u.opset),
        this._d("ellipse", s, a)
    }
    circle(t, n, r, i) {
        const o = this.ellipse(t, n, r, r, i);
        return o.shape = "circle",
        o
    }
    linearPath(t, n) {
        const r = this._o(n);
        return this._d("linearPath", [Zx(t, !1, r)], r)
    }
    arc(t, n, r, i, o, a, s=!1, c) {
        const u = this._o(c)
          , f = []
          , h = Jz(t, n, r, i, o, a, s, !0, u);
        if (s && u.fill)
            if (u.fillStyle === "solid") {
                const m = Object.assign({}, u);
                m.disableMultiStroke = !0;
                const y = Jz(t, n, r, i, o, a, !0, !1, m);
                y.type = "fillPath",
                f.push(y)
            } else
                f.push((function(m, y, b, v, S, C, w) {
                    const k = m
                      , T = y;
                    let E = Math.abs(b / 2)
                      , P = Math.abs(v / 2);
                    E += Gt(.01 * E, w),
                    P += Gt(.01 * P, w);
                    let D = S
                      , $ = C;
                    for (; D < 0; )
                        D += 2 * Math.PI,
                        $ += 2 * Math.PI;
                    $ - D > 2 * Math.PI && (D = 0,
                    $ = 2 * Math.PI);
                    const z = ($ - D) / w.curveStepCount
                      , O = [];
                    for (let I = D; I <= $; I += z)
                        O.push([k + E * Math.cos(I), T + P * Math.sin(I)]);
                    return O.push([k + E * Math.cos($), T + P * Math.sin($)]),
                    O.push([k, T]),
                    tf([O], w)
                }
                )(t, n, r, i, o, a, u));
        return u.stroke !== jo && f.push(h),
        this._d("arc", f, u)
    }
    curve(t, n) {
        const r = this._o(n)
          , i = []
          , o = Xz(t, r);
        if (r.fill && r.fill !== jo)
            if (r.fillStyle === "solid") {
                const a = Xz(t, Object.assign(Object.assign({}, r), {
                    disableMultiStroke: !0,
                    roughness: r.roughness ? r.roughness + r.fillShapeRoughnessGain : 0
                }));
                i.push({
                    type: "fillPath",
                    ops: this._mergedShape(a.ops)
                })
            } else {
                const a = []
                  , s = t;
                if (s.length) {
                    const c = typeof s[0][0] == "number" ? [s] : s;
                    for (const u of c)
                        u.length < 3 ? a.push(...u) : u.length === 3 ? a.push(...c2(i5([u[0], u[0], u[1], u[2]]), 10, (1 + r.roughness) / 2)) : a.push(...c2(i5(u), 10, (1 + r.roughness) / 2))
                }
                a.length && i.push(tf([a], r))
            }
        return r.stroke !== jo && i.push(o),
        this._d("curve", i, r)
    }
    polygon(t, n) {
        const r = this._o(n)
          , i = []
          , o = Zx(t, !0, r);
        return r.fill && (r.fillStyle === "solid" ? i.push(l2([t], r)) : i.push(tf([t], r))),
        r.stroke !== jo && i.push(o),
        this._d("polygon", i, r)
    }
    path(t, n) {
        const r = this._o(n)
          , i = [];
        if (!t)
            return this._d("path", i, r);
        t = (t || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
        const o = r.fill && r.fill !== "transparent" && r.fill !== jo
          , a = r.stroke !== jo
          , s = !!(r.simplification && r.simplification < 1)
          , c = (function(f, h, m) {
            const y = eq(JH(ZM(f)))
              , b = [];
            let v = []
              , S = [0, 0]
              , C = [];
            const w = () => {
                C.length >= 4 && v.push(...c2(C, h)),
                C = []
            }
              , k = () => {
                w(),
                v.length && (b.push(v),
                v = [])
            }
            ;
            for (const {key: E, data: P} of y)
                switch (E) {
                case "M":
                    k(),
                    S = [P[0], P[1]],
                    v.push(S);
                    break;
                case "L":
                    w(),
                    v.push([P[0], P[1]]);
                    break;
                case "C":
                    if (!C.length) {
                        const D = v.length ? v[v.length - 1] : S;
                        C.push([D[0], D[1]])
                    }
                    C.push([P[0], P[1]]),
                    C.push([P[2], P[3]]),
                    C.push([P[4], P[5]]);
                    break;
                case "Z":
                    w(),
                    v.push([S[0], S[1]])
                }
            if (k(),
            !m)
                return b;
            const T = [];
            for (const E of b) {
                const P = FIe(E, m);
                P.length && T.push(P)
            }
            return T
        }
        )(t, 1, s ? 4 - 4 * (r.simplification || 1) : (1 + r.roughness) / 2)
          , u = e5(t, r);
        if (o)
            if (r.fillStyle === "solid")
                if (c.length === 1) {
                    const f = e5(t, Object.assign(Object.assign({}, r), {
                        disableMultiStroke: !0,
                        roughness: r.roughness ? r.roughness + r.fillShapeRoughnessGain : 0
                    }));
                    i.push({
                        type: "fillPath",
                        ops: this._mergedShape(f.ops)
                    })
                } else
                    i.push(l2(c, r));
            else
                i.push(tf(c, r));
        return a && (s ? c.forEach((f => {
            i.push(Zx(f, !1, r))
        }
        )) : i.push(u)),
        this._d("path", i, r)
    }
    opsToPath(t, n) {
        let r = "";
        for (const i of t.ops) {
            const o = typeof n == "number" && n >= 0 ? i.data.map((a => +a.toFixed(n))) : i.data;
            switch (i.op) {
            case "move":
                r += `M${o[0]} ${o[1]} `;
                break;
            case "bcurveTo":
                r += `C${o[0]} ${o[1]}, ${o[2]} ${o[3]}, ${o[4]} ${o[5]} `;
                break;
            case "lineTo":
                r += `L${o[0]} ${o[1]} `
            }
        }
        return r.trim()
    }
    toPaths(t) {
        const n = t.sets || []
          , r = t.options || this.defaultOptions
          , i = [];
        for (const o of n) {
            let a = null;
            switch (o.type) {
            case "path":
                a = {
                    d: this.opsToPath(o),
                    stroke: r.stroke,
                    strokeWidth: r.strokeWidth,
                    fill: jo
                };
                break;
            case "fillPath":
                a = {
                    d: this.opsToPath(o),
                    stroke: jo,
                    strokeWidth: 0,
                    fill: r.fill || jo
                };
                break;
            case "fillSketch":
                a = this.fillSketch(o, r)
            }
            a && i.push(a)
        }
        return i
    }
    fillSketch(t, n) {
        let r = n.fillWeight;
        return r < 0 && (r = n.strokeWidth / 2),
        {
            d: this.opsToPath(t),
            stroke: n.fill || jo,
            strokeWidth: r,
            fill: jo
        }
    }
    _mergedShape(t) {
        return t.filter(( (n, r) => r === 0 || n.op !== "move"))
    }
}
class NIe {
    constructor(t, n) {
        this.canvas = t,
        this.ctx = this.canvas.getContext("2d"),
        this.gen = new vv(n)
    }
    draw(t) {
        const n = t.sets || []
          , r = t.options || this.getDefaultOptions()
          , i = this.ctx
          , o = t.options.fixedDecimalPlaceDigits;
        for (const a of n)
            switch (a.type) {
            case "path":
                i.save(),
                i.strokeStyle = r.stroke === "none" ? "transparent" : r.stroke,
                i.lineWidth = r.strokeWidth,
                r.strokeLineDash && i.setLineDash(r.strokeLineDash),
                r.strokeLineDashOffset && (i.lineDashOffset = r.strokeLineDashOffset),
                this._drawToContext(i, a, o),
                i.restore();
                break;
            case "fillPath":
                {
                    i.save(),
                    i.fillStyle = r.fill || "";
                    const s = t.shape === "curve" || t.shape === "polygon" || t.shape === "path" ? "evenodd" : "nonzero";
                    this._drawToContext(i, a, o, s),
                    i.restore();
                    break
                }
            case "fillSketch":
                this.fillSketch(i, a, r)
            }
    }
    fillSketch(t, n, r) {
        let i = r.fillWeight;
        i < 0 && (i = r.strokeWidth / 2),
        t.save(),
        r.fillLineDash && t.setLineDash(r.fillLineDash),
        r.fillLineDashOffset && (t.lineDashOffset = r.fillLineDashOffset),
        t.strokeStyle = r.fill || "",
        t.lineWidth = i,
        this._drawToContext(t, n, r.fixedDecimalPlaceDigits),
        t.restore()
    }
    _drawToContext(t, n, r, i="nonzero") {
        t.beginPath();
        for (const o of n.ops) {
            const a = typeof r == "number" && r >= 0 ? o.data.map((s => +s.toFixed(r))) : o.data;
            switch (o.op) {
            case "move":
                t.moveTo(a[0], a[1]);
                break;
            case "bcurveTo":
                t.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
                break;
            case "lineTo":
                t.lineTo(a[0], a[1])
            }
        }
        n.type === "fillPath" ? t.fill(i) : t.stroke()
    }
    get generator() {
        return this.gen
    }
    getDefaultOptions() {
        return this.gen.defaultOptions
    }
    line(t, n, r, i, o) {
        const a = this.gen.line(t, n, r, i, o);
        return this.draw(a),
        a
    }
    rectangle(t, n, r, i, o) {
        const a = this.gen.rectangle(t, n, r, i, o);
        return this.draw(a),
        a
    }
    ellipse(t, n, r, i, o) {
        const a = this.gen.ellipse(t, n, r, i, o);
        return this.draw(a),
        a
    }
    circle(t, n, r, i) {
        const o = this.gen.circle(t, n, r, i);
        return this.draw(o),
        o
    }
    linearPath(t, n) {
        const r = this.gen.linearPath(t, n);
        return this.draw(r),
        r
    }
    polygon(t, n) {
        const r = this.gen.polygon(t, n);
        return this.draw(r),
        r
    }
    arc(t, n, r, i, o, a, s=!1, c) {
        const u = this.gen.arc(t, n, r, i, o, a, s, c);
        return this.draw(u),
        u
    }
    curve(t, n) {
        const r = this.gen.curve(t, n);
        return this.draw(r),
        r
    }
    path(t, n) {
        const r = this.gen.path(t, n);
        return this.draw(r),
        r
    }
}
const hx = "http://www.w3.org/2000/svg";
class UIe {
    constructor(t, n) {
        this.svg = t,
        this.gen = new vv(n)
    }
    draw(t) {
        const n = t.sets || []
          , r = t.options || this.getDefaultOptions()
          , i = this.svg.ownerDocument || window.document
          , o = i.createElementNS(hx, "g")
          , a = t.options.fixedDecimalPlaceDigits;
        for (const s of n) {
            let c = null;
            switch (s.type) {
            case "path":
                c = i.createElementNS(hx, "path"),
                c.setAttribute("d", this.opsToPath(s, a)),
                c.setAttribute("stroke", r.stroke),
                c.setAttribute("stroke-width", r.strokeWidth + ""),
                c.setAttribute("fill", "none"),
                r.strokeLineDash && c.setAttribute("stroke-dasharray", r.strokeLineDash.join(" ").trim()),
                r.strokeLineDashOffset && c.setAttribute("stroke-dashoffset", `${r.strokeLineDashOffset}`);
                break;
            case "fillPath":
                c = i.createElementNS(hx, "path"),
                c.setAttribute("d", this.opsToPath(s, a)),
                c.setAttribute("stroke", "none"),
                c.setAttribute("stroke-width", "0"),
                c.setAttribute("fill", r.fill || ""),
                t.shape !== "curve" && t.shape !== "polygon" || c.setAttribute("fill-rule", "evenodd");
                break;
            case "fillSketch":
                c = this.fillSketch(i, s, r)
            }
            c && o.appendChild(c)
        }
        return o
    }
    fillSketch(t, n, r) {
        let i = r.fillWeight;
        i < 0 && (i = r.strokeWidth / 2);
        const o = t.createElementNS(hx, "path");
        return o.setAttribute("d", this.opsToPath(n, r.fixedDecimalPlaceDigits)),
        o.setAttribute("stroke", r.fill || ""),
        o.setAttribute("stroke-width", i + ""),
        o.setAttribute("fill", "none"),
        r.fillLineDash && o.setAttribute("stroke-dasharray", r.fillLineDash.join(" ").trim()),
        r.fillLineDashOffset && o.setAttribute("stroke-dashoffset", `${r.fillLineDashOffset}`),
        o
    }
    get generator() {
        return this.gen
    }
    getDefaultOptions() {
        return this.gen.defaultOptions
    }
    opsToPath(t, n) {
        return this.gen.opsToPath(t, n)
    }
    line(t, n, r, i, o) {
        const a = this.gen.line(t, n, r, i, o);
        return this.draw(a)
    }
    rectangle(t, n, r, i, o) {
        const a = this.gen.rectangle(t, n, r, i, o);
        return this.draw(a)
    }
    ellipse(t, n, r, i, o) {
        const a = this.gen.ellipse(t, n, r, i, o);
        return this.draw(a)
    }
    circle(t, n, r, i) {
        const o = this.gen.circle(t, n, r, i);
        return this.draw(o)
    }
    linearPath(t, n) {
        const r = this.gen.linearPath(t, n);
        return this.draw(r)
    }
    polygon(t, n) {
        const r = this.gen.polygon(t, n);
        return this.draw(r)
    }
    arc(t, n, r, i, o, a, s=!1, c) {
        const u = this.gen.arc(t, n, r, i, o, a, s, c);
        return this.draw(u)
    }
    curve(t, n) {
        const r = this.gen.curve(t, n);
        return this.draw(r)
    }
    path(t, n) {
        const r = this.gen.path(t, n);
        return this.draw(r)
    }
}
var Ct = {
    canvas: (e, t) => new NIe(e,t),
    svg: (e, t) => new UIe(e,t),
    generator: e => new vv(e),
    newSeed: () => vv.newSeed()
}
  , Vt = U(async (e, t, n) => {
    let r;
    const i = t.useHtmlLabels || oi(Vn()?.htmlLabels);
    n ? r = n : r = "node default";
    const o = e.insert("g").attr("class", r).attr("id", t.domId || t.id)
      , a = o.insert("g").attr("class", "label").attr("style", Ri(t.labelStyle));
    let s;
    t.label === void 0 ? s = "" : s = typeof t.label == "string" ? t.label : t.label[0];
    const c = await Lc(a, ka(cd(s), Vn()), {
        useHtmlLabels: i,
        width: t.width || Vn().flowchart?.wrappingWidth,
        cssClasses: "markdown-node-label",
        style: t.labelStyle,
        addSvgBackground: !!t.icon || !!t.img
    });
    let u = c.getBBox();
    const f = (t?.padding ?? 0) / 2;
    if (i) {
        const h = c.children[0]
          , m = En(c)
          , y = h.getElementsByTagName("img");
        if (y) {
            const b = s.replace(/<img[^>]*>/g, "").trim() === "";
            await Promise.all([...y].map(v => new Promise(S => {
                function C() {
                    if (v.style.display = "flex",
                    v.style.flexDirection = "column",
                    b) {
                        const w = Vn().fontSize ? Vn().fontSize : window.getComputedStyle(document.body).fontSize
                          , k = 5
                          , [T=b8.fontSize] = eS(w)
                          , E = T * k + "px";
                        v.style.minWidth = E,
                        v.style.maxWidth = E
                    } else
                        v.style.width = "100%";
                    S(v)
                }
                U(C, "setupImage"),
                setTimeout( () => {
                    v.complete && C()
                }
                ),
                v.addEventListener("error", C),
                v.addEventListener("load", C)
            }
            )))
        }
        u = h.getBoundingClientRect(),
        m.attr("width", u.width),
        m.attr("height", u.height)
    }
    return i ? a.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")") : a.attr("transform", "translate(0, " + -u.height / 2 + ")"),
    t.centerLabel && a.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")"),
    a.insert("rect", ":first-child"),
    {
        shapeSvg: o,
        bbox: u,
        halfPadding: f,
        label: a
    }
}
, "labelHelper")
  , u2 = U(async (e, t, n) => {
    const r = n.useHtmlLabels || oi(Vn()?.flowchart?.htmlLabels)
      , i = e.insert("g").attr("class", "label").attr("style", n.labelStyle || "")
      , o = await Lc(i, ka(cd(t), Vn()), {
        useHtmlLabels: r,
        width: n.width || Vn()?.flowchart?.wrappingWidth,
        style: n.labelStyle,
        addSvgBackground: !!n.icon || !!n.img
    });
    let a = o.getBBox();
    const s = n.padding / 2;
    if (oi(Vn()?.flowchart?.htmlLabels)) {
        const c = o.children[0]
          , u = En(o);
        a = c.getBoundingClientRect(),
        u.attr("width", a.width),
        u.attr("height", a.height)
    }
    return r ? i.attr("transform", "translate(" + -a.width / 2 + ", " + -a.height / 2 + ")") : i.attr("transform", "translate(0, " + -a.height / 2 + ")"),
    n.centerLabel && i.attr("transform", "translate(" + -a.width / 2 + ", " + -a.height / 2 + ")"),
    i.insert("rect", ":first-child"),
    {
        shapeSvg: e,
        bbox: a,
        halfPadding: s,
        label: i
    }
}
, "insertLabel")
  , Tt = U( (e, t) => {
    const n = t.node().getBBox();
    e.width = n.width,
    e.height = n.height
}
, "updateNodeBounds")
  , jt = U( (e, t) => (e.look === "handDrawn" ? "rough-node" : "node") + " " + e.cssClasses + " " + (t || ""), "getNodeClasses");
function xn(e) {
    const t = e.map( (n, r) => `${r === 0 ? "M" : "L"}${n.x},${n.y}`);
    return t.push("Z"),
    t.join(" ")
}
U(xn, "createPathFromPoints");
function _c(e, t, n, r, i, o) {
    const a = []
      , c = n - e
      , u = r - t
      , f = c / o
      , h = 2 * Math.PI / f
      , m = t + u / 2;
    for (let y = 0; y <= 50; y++) {
        const b = y / 50
          , v = e + b * c
          , S = m + i * Math.sin(h * (v - e));
        a.push({
            x: v,
            y: S
        })
    }
    return a
}
U(_c, "generateFullSineWavePoints");
function mg(e, t, n, r, i, o) {
    const a = []
      , s = i * Math.PI / 180
      , f = (o * Math.PI / 180 - s) / (r - 1);
    for (let h = 0; h < r; h++) {
        const m = s + h * f
          , y = e + n * Math.cos(m)
          , b = t + n * Math.sin(m);
        a.push({
            x: -y,
            y: -b
        })
    }
    return a
}
U(mg, "generateCirclePoints");
var VIe = U( (e, t) => {
    var n = e.x, r = e.y, i = t.x - n, o = t.y - r, a = e.width / 2, s = e.height / 2, c, u;
    return Math.abs(o) * a > Math.abs(i) * s ? (o < 0 && (s = -s),
    c = o === 0 ? 0 : s * i / o,
    u = s) : (i < 0 && (a = -a),
    c = a,
    u = i === 0 ? 0 : a * o / i),
    {
        x: n + c,
        y: r + u
    }
}
, "intersectRect")
  , kh = VIe;
function oq(e, t) {
    t && e.attr("style", t)
}
U(oq, "applyStyle");
async function aq(e) {
    const t = En(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"))
      , n = t.append("xhtml:div")
      , r = Vn();
    let i = e.label;
    e.label && eh(e.label) && (i = await nM(e.label.replace(vh.lineBreakRegex, `
`), r));
    const a = '<span class="' + (e.isNode ? "nodeLabel" : "edgeLabel") + '" ' + (e.labelStyle ? 'style="' + e.labelStyle + '"' : "") + ">" + i + "</span>";
    return n.html(ka(a, r)),
    oq(n, e.labelStyle),
    n.style("display", "inline-block"),
    n.style("padding-right", "1px"),
    n.style("white-space", "nowrap"),
    n.attr("xmlns", "http://www.w3.org/1999/xhtml"),
    t.node()
}
U(aq, "addHtmlLabel");
var HIe = U(async (e, t, n, r) => {
    let i = e || "";
    if (typeof i == "object" && (i = i[0]),
    oi(Vn().flowchart.htmlLabels)) {
        i = i.replace(/\\n|\n/g, "<br />"),
        Qe.info("vertexText" + i);
        const o = {
            isNode: r,
            label: cd(i).replace(/fa[blrs]?:fa-[\w-]+/g, s => `<i class='${s.replace(":", " ")}'></i>`),
            labelStyle: t && t.replace("fill:", "color:")
        };
        return await aq(o)
    } else {
        const o = document.createElementNS("http://www.w3.org/2000/svg", "text");
        o.setAttribute("style", t.replace("color:", "fill:"));
        let a = [];
        typeof i == "string" ? a = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? a = i : a = [];
        for (const s of a) {
            const c = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
            c.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"),
            c.setAttribute("dy", "1em"),
            c.setAttribute("x", "0"),
            n ? c.setAttribute("class", "title-row") : c.setAttribute("class", "row"),
            c.textContent = s.trim(),
            o.appendChild(c)
        }
        return o
    }
}
, "createLabel")
  , Au = HIe
  , jc = U( (e, t, n, r, i) => ["M", e + i, t, "H", e + n - i, "A", i, i, 0, 0, 1, e + n, t + i, "V", t + r - i, "A", i, i, 0, 0, 1, e + n - i, t + r, "H", e + i, "A", i, i, 0, 0, 1, e, t + r - i, "V", t + i, "A", i, i, 0, 0, 1, e + i, t, "Z"].join(" "), "createRoundedRectPathD")
  , sq = U(async (e, t) => {
    Qe.info("Creating subgraph rect for ", t.id, t);
    const n = Vn()
      , {themeVariables: r, handDrawnSeed: i} = n
      , {clusterBkg: o, clusterBorder: a} = r
      , {labelStyles: s, nodeStyles: c, borderStyles: u, backgroundStyles: f} = kt(t)
      , h = e.insert("g").attr("class", "cluster " + t.cssClasses).attr("id", t.id).attr("data-look", t.look)
      , m = oi(n.flowchart.htmlLabels)
      , y = h.insert("g").attr("class", "cluster-label ")
      , b = await Lc(y, t.label, {
        style: t.labelStyle,
        useHtmlLabels: m,
        isNode: !0
    });
    let v = b.getBBox();
    if (oi(n.flowchart.htmlLabels)) {
        const D = b.children[0]
          , $ = En(b);
        v = D.getBoundingClientRect(),
        $.attr("width", v.width),
        $.attr("height", v.height)
    }
    const S = t.width <= v.width + t.padding ? v.width + t.padding : t.width;
    t.width <= v.width + t.padding ? t.diff = (S - t.width) / 2 - t.padding : t.diff = -t.padding;
    const C = t.height
      , w = t.x - S / 2
      , k = t.y - C / 2;
    Qe.trace("Data ", t, JSON.stringify(t));
    let T;
    if (t.look === "handDrawn") {
        const D = Ct.svg(h)
          , $ = wt(t, {
            roughness: .7,
            fill: o,
            stroke: a,
            fillWeight: 3,
            seed: i
        })
          , z = D.path(jc(w, k, S, C, 0), $);
        T = h.insert( () => (Qe.debug("Rough node insert CXC", z),
        z), ":first-child"),
        T.select("path:nth-child(2)").attr("style", u.join(";")),
        T.select("path").attr("style", f.join(";").replace("fill", "stroke"))
    } else
        T = h.insert("rect", ":first-child"),
        T.attr("style", c).attr("rx", t.rx).attr("ry", t.ry).attr("x", w).attr("y", k).attr("width", S).attr("height", C);
    const {subGraphTitleTopMargin: E} = EM(n);
    if (y.attr("transform", `translate(${t.x - v.width / 2}, ${t.y - t.height / 2 + E})`),
    s) {
        const D = y.select("span");
        D && D.attr("style", s)
    }
    const P = T.node().getBBox();
    return t.offsetX = 0,
    t.width = P.width,
    t.height = P.height,
    t.offsetY = v.height - t.padding / 2,
    t.intersect = function(D) {
        return kh(t, D)
    }
    ,
    {
        cluster: h,
        labelBBox: v
    }
}
, "rect")
  , qIe = U( (e, t) => {
    const n = e.insert("g").attr("class", "note-cluster").attr("id", t.id)
      , r = n.insert("rect", ":first-child")
      , i = 0 * t.padding
      , o = i / 2;
    r.attr("rx", t.rx).attr("ry", t.ry).attr("x", t.x - t.width / 2 - o).attr("y", t.y - t.height / 2 - o).attr("width", t.width + i).attr("height", t.height + i).attr("fill", "none");
    const a = r.node().getBBox();
    return t.width = a.width,
    t.height = a.height,
    t.intersect = function(s) {
        return kh(t, s)
    }
    ,
    {
        cluster: n,
        labelBBox: {
            width: 0,
            height: 0
        }
    }
}
, "noteGroup")
  , WIe = U(async (e, t) => {
    const n = Vn()
      , {themeVariables: r, handDrawnSeed: i} = n
      , {altBackground: o, compositeBackground: a, compositeTitleBackground: s, nodeBorder: c} = r
      , u = e.insert("g").attr("class", t.cssClasses).attr("id", t.id).attr("data-id", t.id).attr("data-look", t.look)
      , f = u.insert("g", ":first-child")
      , h = u.insert("g").attr("class", "cluster-label");
    let m = u.append("rect");
    const y = h.node().appendChild(await Au(t.label, t.labelStyle, void 0, !0));
    let b = y.getBBox();
    if (oi(n.flowchart.htmlLabels)) {
        const z = y.children[0]
          , O = En(y);
        b = z.getBoundingClientRect(),
        O.attr("width", b.width),
        O.attr("height", b.height)
    }
    const v = 0 * t.padding
      , S = v / 2
      , C = (t.width <= b.width + t.padding ? b.width + t.padding : t.width) + v;
    t.width <= b.width + t.padding ? t.diff = (C - t.width) / 2 - t.padding : t.diff = -t.padding;
    const w = t.height + v
      , k = t.height + v - b.height - 6
      , T = t.x - C / 2
      , E = t.y - w / 2;
    t.width = C;
    const P = t.y - t.height / 2 - S + b.height + 2;
    let D;
    if (t.look === "handDrawn") {
        const z = t.cssClasses.includes("statediagram-cluster-alt")
          , O = Ct.svg(u)
          , I = t.rx || t.ry ? O.path(jc(T, E, C, w, 10), {
            roughness: .7,
            fill: s,
            fillStyle: "solid",
            stroke: c,
            seed: i
        }) : O.rectangle(T, E, C, w, {
            seed: i
        });
        D = u.insert( () => I, ":first-child");
        const M = O.rectangle(T, P, C, k, {
            fill: z ? o : a,
            fillStyle: z ? "hachure" : "solid",
            stroke: c,
            seed: i
        });
        D = u.insert( () => I, ":first-child"),
        m = u.insert( () => M)
    } else
        D = f.insert("rect", ":first-child"),
        D.attr("class", "outer").attr("x", T).attr("y", E).attr("width", C).attr("height", w).attr("data-look", t.look),
        m.attr("class", "inner").attr("x", T).attr("y", P).attr("width", C).attr("height", k);
    h.attr("transform", `translate(${t.x - b.width / 2}, ${E + 1 - (oi(n.flowchart.htmlLabels) ? 0 : 3)})`);
    const $ = D.node().getBBox();
    return t.height = $.height,
    t.offsetX = 0,
    t.offsetY = b.height - t.padding / 2,
    t.labelBBox = b,
    t.intersect = function(z) {
        return kh(t, z)
    }
    ,
    {
        cluster: u,
        labelBBox: b
    }
}
, "roundedWithTitle")
  , GIe = U(async (e, t) => {
    Qe.info("Creating subgraph rect for ", t.id, t);
    const n = Vn()
      , {themeVariables: r, handDrawnSeed: i} = n
      , {clusterBkg: o, clusterBorder: a} = r
      , {labelStyles: s, nodeStyles: c, borderStyles: u, backgroundStyles: f} = kt(t)
      , h = e.insert("g").attr("class", "cluster " + t.cssClasses).attr("id", t.id).attr("data-look", t.look)
      , m = oi(n.flowchart.htmlLabels)
      , y = h.insert("g").attr("class", "cluster-label ")
      , b = await Lc(y, t.label, {
        style: t.labelStyle,
        useHtmlLabels: m,
        isNode: !0,
        width: t.width
    });
    let v = b.getBBox();
    if (oi(n.flowchart.htmlLabels)) {
        const D = b.children[0]
          , $ = En(b);
        v = D.getBoundingClientRect(),
        $.attr("width", v.width),
        $.attr("height", v.height)
    }
    const S = t.width <= v.width + t.padding ? v.width + t.padding : t.width;
    t.width <= v.width + t.padding ? t.diff = (S - t.width) / 2 - t.padding : t.diff = -t.padding;
    const C = t.height
      , w = t.x - S / 2
      , k = t.y - C / 2;
    Qe.trace("Data ", t, JSON.stringify(t));
    let T;
    if (t.look === "handDrawn") {
        const D = Ct.svg(h)
          , $ = wt(t, {
            roughness: .7,
            fill: o,
            stroke: a,
            fillWeight: 4,
            seed: i
        })
          , z = D.path(jc(w, k, S, C, t.rx), $);
        T = h.insert( () => (Qe.debug("Rough node insert CXC", z),
        z), ":first-child"),
        T.select("path:nth-child(2)").attr("style", u.join(";")),
        T.select("path").attr("style", f.join(";").replace("fill", "stroke"))
    } else
        T = h.insert("rect", ":first-child"),
        T.attr("style", c).attr("rx", t.rx).attr("ry", t.ry).attr("x", w).attr("y", k).attr("width", S).attr("height", C);
    const {subGraphTitleTopMargin: E} = EM(n);
    if (y.attr("transform", `translate(${t.x - v.width / 2}, ${t.y - t.height / 2 + E})`),
    s) {
        const D = y.select("span");
        D && D.attr("style", s)
    }
    const P = T.node().getBBox();
    return t.offsetX = 0,
    t.width = P.width,
    t.height = P.height,
    t.offsetY = v.height - t.padding / 2,
    t.intersect = function(D) {
        return kh(t, D)
    }
    ,
    {
        cluster: h,
        labelBBox: v
    }
}
, "kanbanSection")
  , YIe = U( (e, t) => {
    const n = Vn()
      , {themeVariables: r, handDrawnSeed: i} = n
      , {nodeBorder: o} = r
      , a = e.insert("g").attr("class", t.cssClasses).attr("id", t.id).attr("data-look", t.look)
      , s = a.insert("g", ":first-child")
      , c = 0 * t.padding
      , u = t.width + c;
    t.diff = -t.padding;
    const f = t.height + c
      , h = t.x - u / 2
      , m = t.y - f / 2;
    t.width = u;
    let y;
    if (t.look === "handDrawn") {
        const S = Ct.svg(a).rectangle(h, m, u, f, {
            fill: "lightgrey",
            roughness: .5,
            strokeLineDash: [5],
            stroke: o,
            seed: i
        });
        y = a.insert( () => S, ":first-child")
    } else
        y = s.insert("rect", ":first-child"),
        y.attr("class", "divider").attr("x", h).attr("y", m).attr("width", u).attr("height", f).attr("data-look", t.look);
    const b = y.node().getBBox();
    return t.height = b.height,
    t.offsetX = 0,
    t.offsetY = 0,
    t.intersect = function(v) {
        return kh(t, v)
    }
    ,
    {
        cluster: a,
        labelBBox: {}
    }
}
, "divider")
  , ZIe = sq
  , QIe = {
    rect: sq,
    squareRect: ZIe,
    roundedWithTitle: WIe,
    noteGroup: qIe,
    divider: YIe,
    kanbanSection: GIe
}
  , lq = new Map
  , KIe = U(async (e, t) => {
    const n = t.shape || "rect"
      , r = await QIe[n](e, t);
    return lq.set(t.id, r),
    r
}
, "insertCluster")
  , uVe = U( () => {
    lq = new Map
}
, "clear");
function cq(e, t) {
    return e.intersect(t)
}
U(cq, "intersectNode");
var XIe = cq;
function uq(e, t, n, r) {
    var i = e.x
      , o = e.y
      , a = i - r.x
      , s = o - r.y
      , c = Math.sqrt(t * t * s * s + n * n * a * a)
      , u = Math.abs(t * n * a / c);
    r.x < i && (u = -u);
    var f = Math.abs(t * n * s / c);
    return r.y < o && (f = -f),
    {
        x: i + u,
        y: o + f
    }
}
U(uq, "intersectEllipse");
var dq = uq;
function fq(e, t, n) {
    return dq(e, t, t, n)
}
U(fq, "intersectCircle");
var JIe = fq;
function hq(e, t, n, r) {
    {
        const i = t.y - e.y
          , o = e.x - t.x
          , a = t.x * e.y - e.x * t.y
          , s = i * n.x + o * n.y + a
          , c = i * r.x + o * r.y + a
          , u = 1e-6;
        if (s !== 0 && c !== 0 && L_(s, c))
            return;
        const f = r.y - n.y
          , h = n.x - r.x
          , m = r.x * n.y - n.x * r.y
          , y = f * e.x + h * e.y + m
          , b = f * t.x + h * t.y + m;
        if (Math.abs(y) < u && Math.abs(b) < u && L_(y, b))
            return;
        const v = i * h - f * o;
        if (v === 0)
            return;
        const S = Math.abs(v / 2);
        let C = o * m - h * a;
        const w = C < 0 ? (C - S) / v : (C + S) / v;
        C = f * a - i * m;
        const k = C < 0 ? (C - S) / v : (C + S) / v;
        return {
            x: w,
            y: k
        }
    }
}
U(hq, "intersectLine");
function L_(e, t) {
    return e * t > 0
}
U(L_, "sameSign");
var e$e = hq;
function pq(e, t, n) {
    let r = e.x
      , i = e.y
      , o = []
      , a = Number.POSITIVE_INFINITY
      , s = Number.POSITIVE_INFINITY;
    typeof t.forEach == "function" ? t.forEach(function(f) {
        a = Math.min(a, f.x),
        s = Math.min(s, f.y)
    }) : (a = Math.min(a, t.x),
    s = Math.min(s, t.y));
    let c = r - e.width / 2 - a
      , u = i - e.height / 2 - s;
    for (let f = 0; f < t.length; f++) {
        let h = t[f]
          , m = t[f < t.length - 1 ? f + 1 : 0]
          , y = e$e(e, n, {
            x: c + h.x,
            y: u + h.y
        }, {
            x: c + m.x,
            y: u + m.y
        });
        y && o.push(y)
    }
    return o.length ? (o.length > 1 && o.sort(function(f, h) {
        let m = f.x - n.x
          , y = f.y - n.y
          , b = Math.sqrt(m * m + y * y)
          , v = h.x - n.x
          , S = h.y - n.y
          , C = Math.sqrt(v * v + S * S);
        return b < C ? -1 : b === C ? 0 : 1
    }),
    o[0]) : e
}
U(pq, "intersectPolygon");
var t$e = pq
  , xt = {
    node: XIe,
    circle: JIe,
    ellipse: dq,
    polygon: t$e,
    rect: kh
};
function mq(e, t) {
    const {labelStyles: n} = kt(t);
    t.labelStyle = n;
    const r = jt(t);
    let i = r;
    r || (i = "anchor");
    const o = e.insert("g").attr("class", i).attr("id", t.domId || t.id)
      , a = 1
      , {cssStyles: s} = t
      , c = Ct.svg(o)
      , u = wt(t, {
        fill: "black",
        stroke: "none",
        fillStyle: "solid"
    });
    t.look !== "handDrawn" && (u.roughness = 0);
    const f = c.circle(0, 0, a * 2, u)
      , h = o.insert( () => f, ":first-child");
    return h.attr("class", "anchor").attr("style", Ri(s)),
    Tt(t, h),
    t.intersect = function(m) {
        return Qe.info("Circle intersect", t, a, m),
        xt.circle(t, a, m)
    }
    ,
    o
}
U(mq, "anchor");
function j_(e, t, n, r, i, o, a) {
    const c = (e + n) / 2
      , u = (t + r) / 2
      , f = Math.atan2(r - t, n - e)
      , h = (n - e) / 2
      , m = (r - t) / 2
      , y = h / i
      , b = m / o
      , v = Math.sqrt(y ** 2 + b ** 2);
    if (v > 1)
        throw new Error("The given radii are too small to create an arc between the points.");
    const S = Math.sqrt(1 - v ** 2)
      , C = c + S * o * Math.sin(f) * (a ? -1 : 1)
      , w = u - S * i * Math.cos(f) * (a ? -1 : 1)
      , k = Math.atan2((t - w) / o, (e - C) / i);
    let E = Math.atan2((r - w) / o, (n - C) / i) - k;
    a && E < 0 && (E += 2 * Math.PI),
    !a && E > 0 && (E -= 2 * Math.PI);
    const P = [];
    for (let D = 0; D < 20; D++) {
        const $ = D / 19
          , z = k + $ * E
          , O = C + i * Math.cos(z)
          , I = w + o * Math.sin(z);
        P.push({
            x: O,
            y: I
        })
    }
    return P
}
U(j_, "generateArcPoints");
async function gq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = o.width + t.padding + 20
      , s = o.height + t.padding
      , c = s / 2
      , u = c / (2.5 + s / 50)
      , {cssStyles: f} = t
      , h = [{
        x: a / 2,
        y: -s / 2
    }, {
        x: -a / 2,
        y: -s / 2
    }, ...j_(-a / 2, -s / 2, -a / 2, s / 2, u, c, !1), {
        x: a / 2,
        y: s / 2
    }, ...j_(a / 2, s / 2, a / 2, -s / 2, u, c, !0)]
      , m = Ct.svg(i)
      , y = wt(t, {});
    t.look !== "handDrawn" && (y.roughness = 0,
    y.fillStyle = "solid");
    const b = xn(h)
      , v = m.path(b, y)
      , S = i.insert( () => v, ":first-child");
    return S.attr("class", "basic label-container"),
    f && t.look !== "handDrawn" && S.selectAll("path").attr("style", f),
    r && t.look !== "handDrawn" && S.selectAll("path").attr("style", r),
    S.attr("transform", `translate(${u / 2}, 0)`),
    Tt(t, S),
    t.intersect = function(C) {
        return xt.polygon(t, h, C)
    }
    ,
    i
}
U(gq, "bowTieRect");
function Bc(e, t, n, r) {
    return e.insert("polygon", ":first-child").attr("points", r.map(function(i) {
        return i.x + "," + i.y
    }).join(" ")).attr("class", "label-container").attr("transform", "translate(" + -t / 2 + "," + n / 2 + ")")
}
U(Bc, "insertPolygonShape");
async function yq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = o.height + t.padding
      , s = 12
      , c = o.width + t.padding + s
      , u = 0
      , f = c
      , h = -a
      , m = 0
      , y = [{
        x: u + s,
        y: h
    }, {
        x: f,
        y: h
    }, {
        x: f,
        y: m
    }, {
        x: u,
        y: m
    }, {
        x: u,
        y: h + s
    }, {
        x: u + s,
        y: h
    }];
    let b;
    const {cssStyles: v} = t;
    if (t.look === "handDrawn") {
        const S = Ct.svg(i)
          , C = wt(t, {})
          , w = xn(y)
          , k = S.path(w, C);
        b = i.insert( () => k, ":first-child").attr("transform", `translate(${-c / 2}, ${a / 2})`),
        v && b.attr("style", v)
    } else
        b = Bc(i, c, a, y);
    return r && b.attr("style", r),
    Tt(t, b),
    t.intersect = function(S) {
        return xt.polygon(t, y, S)
    }
    ,
    i
}
U(yq, "card");
function bq(e, t) {
    const {nodeStyles: n} = kt(t);
    t.label = "";
    const r = e.insert("g").attr("class", jt(t)).attr("id", t.domId ?? t.id)
      , {cssStyles: i} = t
      , o = Math.max(28, t.width ?? 0)
      , a = [{
        x: 0,
        y: o / 2
    }, {
        x: o / 2,
        y: 0
    }, {
        x: 0,
        y: -o / 2
    }, {
        x: -o / 2,
        y: 0
    }]
      , s = Ct.svg(r)
      , c = wt(t, {});
    t.look !== "handDrawn" && (c.roughness = 0,
    c.fillStyle = "solid");
    const u = xn(a)
      , f = s.path(u, c)
      , h = r.insert( () => f, ":first-child");
    return i && t.look !== "handDrawn" && h.selectAll("path").attr("style", i),
    n && t.look !== "handDrawn" && h.selectAll("path").attr("style", n),
    t.width = 28,
    t.height = 28,
    t.intersect = function(m) {
        return xt.polygon(t, a, m)
    }
    ,
    r
}
U(bq, "choice");
async function QM(e, t, n) {
    const {labelStyles: r, nodeStyles: i} = kt(t);
    t.labelStyle = r;
    const {shapeSvg: o, bbox: a, halfPadding: s} = await Vt(e, t, jt(t))
      , c = n?.padding ?? s
      , u = a.width / 2 + c;
    let f;
    const {cssStyles: h} = t;
    if (t.look === "handDrawn") {
        const m = Ct.svg(o)
          , y = wt(t, {})
          , b = m.circle(0, 0, u * 2, y);
        f = o.insert( () => b, ":first-child"),
        f.attr("class", "basic label-container").attr("style", Ri(h))
    } else
        f = o.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", i).attr("r", u).attr("cx", 0).attr("cy", 0);
    return Tt(t, f),
    t.calcIntersect = function(m, y) {
        const b = m.width / 2;
        return xt.circle(m, b, y)
    }
    ,
    t.intersect = function(m) {
        return Qe.info("Circle intersect", t, u, m),
        xt.circle(t, u, m)
    }
    ,
    o
}
U(QM, "circle");
function xq(e) {
    const t = Math.cos(Math.PI / 4)
      , n = Math.sin(Math.PI / 4)
      , r = e * 2
      , i = {
        x: r / 2 * t,
        y: r / 2 * n
    }
      , o = {
        x: -(r / 2) * t,
        y: r / 2 * n
    }
      , a = {
        x: -(r / 2) * t,
        y: -(r / 2) * n
    }
      , s = {
        x: r / 2 * t,
        y: -(r / 2) * n
    };
    return `M ${o.x},${o.y} L ${s.x},${s.y}
                   M ${i.x},${i.y} L ${a.x},${a.y}`
}
U(xq, "createLine");
function vq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n,
    t.label = "";
    const i = e.insert("g").attr("class", jt(t)).attr("id", t.domId ?? t.id)
      , o = Math.max(30, t?.width ?? 0)
      , {cssStyles: a} = t
      , s = Ct.svg(i)
      , c = wt(t, {});
    t.look !== "handDrawn" && (c.roughness = 0,
    c.fillStyle = "solid");
    const u = s.circle(0, 0, o * 2, c)
      , f = xq(o)
      , h = s.path(f, c)
      , m = i.insert( () => u, ":first-child");
    return m.insert( () => h),
    a && t.look !== "handDrawn" && m.selectAll("path").attr("style", a),
    r && t.look !== "handDrawn" && m.selectAll("path").attr("style", r),
    Tt(t, m),
    t.intersect = function(y) {
        return Qe.info("crossedCircle intersect", t, {
            radius: o,
            point: y
        }),
        xt.circle(t, o, y)
    }
    ,
    i
}
U(vq, "crossedCircle");
function fl(e, t, n, r=100, i=0, o=180) {
    const a = []
      , s = i * Math.PI / 180
      , f = (o * Math.PI / 180 - s) / (r - 1);
    for (let h = 0; h < r; h++) {
        const m = s + h * f
          , y = e + n * Math.cos(m)
          , b = t + n * Math.sin(m);
        a.push({
            x: -y,
            y: -b
        })
    }
    return a
}
U(fl, "generateCirclePoints");
async function Sq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = o.width + (t.padding ?? 0)
      , c = o.height + (t.padding ?? 0)
      , u = Math.max(5, c * .1)
      , {cssStyles: f} = t
      , h = [...fl(s / 2, -c / 2, u, 30, -90, 0), {
        x: -s / 2 - u,
        y: u
    }, ...fl(s / 2 + u * 2, -u, u, 20, -180, -270), ...fl(s / 2 + u * 2, u, u, 20, -90, -180), {
        x: -s / 2 - u,
        y: -c / 2
    }, ...fl(s / 2, c / 2, u, 20, 0, 90)]
      , m = [{
        x: s / 2,
        y: -c / 2 - u
    }, {
        x: -s / 2,
        y: -c / 2 - u
    }, ...fl(s / 2, -c / 2, u, 20, -90, 0), {
        x: -s / 2 - u,
        y: -u
    }, ...fl(s / 2 + s * .1, -u, u, 20, -180, -270), ...fl(s / 2 + s * .1, u, u, 20, -90, -180), {
        x: -s / 2 - u,
        y: c / 2
    }, ...fl(s / 2, c / 2, u, 20, 0, 90), {
        x: -s / 2,
        y: c / 2 + u
    }, {
        x: s / 2,
        y: c / 2 + u
    }]
      , y = Ct.svg(i)
      , b = wt(t, {
        fill: "none"
    });
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const S = xn(h).replace("Z", "")
      , C = y.path(S, b)
      , w = xn(m)
      , k = y.path(w, {
        ...b
    })
      , T = i.insert("g", ":first-child");
    return T.insert( () => k, ":first-child").attr("stroke-opacity", 0),
    T.insert( () => C, ":first-child"),
    T.attr("class", "text"),
    f && t.look !== "handDrawn" && T.selectAll("path").attr("style", f),
    r && t.look !== "handDrawn" && T.selectAll("path").attr("style", r),
    T.attr("transform", `translate(${u}, 0)`),
    a.attr("transform", `translate(${-s / 2 + u - (o.x - (o.left ?? 0))},${-c / 2 + (t.padding ?? 0) / 2 - (o.y - (o.top ?? 0))})`),
    Tt(t, T),
    t.intersect = function(E) {
        return xt.polygon(t, m, E)
    }
    ,
    i
}
U(Sq, "curlyBraceLeft");
function hl(e, t, n, r=100, i=0, o=180) {
    const a = []
      , s = i * Math.PI / 180
      , f = (o * Math.PI / 180 - s) / (r - 1);
    for (let h = 0; h < r; h++) {
        const m = s + h * f
          , y = e + n * Math.cos(m)
          , b = t + n * Math.sin(m);
        a.push({
            x: y,
            y: b
        })
    }
    return a
}
U(hl, "generateCirclePoints");
async function Cq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = o.width + (t.padding ?? 0)
      , c = o.height + (t.padding ?? 0)
      , u = Math.max(5, c * .1)
      , {cssStyles: f} = t
      , h = [...hl(s / 2, -c / 2, u, 20, -90, 0), {
        x: s / 2 + u,
        y: -u
    }, ...hl(s / 2 + u * 2, -u, u, 20, -180, -270), ...hl(s / 2 + u * 2, u, u, 20, -90, -180), {
        x: s / 2 + u,
        y: c / 2
    }, ...hl(s / 2, c / 2, u, 20, 0, 90)]
      , m = [{
        x: -s / 2,
        y: -c / 2 - u
    }, {
        x: s / 2,
        y: -c / 2 - u
    }, ...hl(s / 2, -c / 2, u, 20, -90, 0), {
        x: s / 2 + u,
        y: -u
    }, ...hl(s / 2 + u * 2, -u, u, 20, -180, -270), ...hl(s / 2 + u * 2, u, u, 20, -90, -180), {
        x: s / 2 + u,
        y: c / 2
    }, ...hl(s / 2, c / 2, u, 20, 0, 90), {
        x: s / 2,
        y: c / 2 + u
    }, {
        x: -s / 2,
        y: c / 2 + u
    }]
      , y = Ct.svg(i)
      , b = wt(t, {
        fill: "none"
    });
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const S = xn(h).replace("Z", "")
      , C = y.path(S, b)
      , w = xn(m)
      , k = y.path(w, {
        ...b
    })
      , T = i.insert("g", ":first-child");
    return T.insert( () => k, ":first-child").attr("stroke-opacity", 0),
    T.insert( () => C, ":first-child"),
    T.attr("class", "text"),
    f && t.look !== "handDrawn" && T.selectAll("path").attr("style", f),
    r && t.look !== "handDrawn" && T.selectAll("path").attr("style", r),
    T.attr("transform", `translate(${-u}, 0)`),
    a.attr("transform", `translate(${-s / 2 + (t.padding ?? 0) / 2 - (o.x - (o.left ?? 0))},${-c / 2 + (t.padding ?? 0) / 2 - (o.y - (o.top ?? 0))})`),
    Tt(t, T),
    t.intersect = function(E) {
        return xt.polygon(t, m, E)
    }
    ,
    i
}
U(Cq, "curlyBraceRight");
function gi(e, t, n, r=100, i=0, o=180) {
    const a = []
      , s = i * Math.PI / 180
      , f = (o * Math.PI / 180 - s) / (r - 1);
    for (let h = 0; h < r; h++) {
        const m = s + h * f
          , y = e + n * Math.cos(m)
          , b = t + n * Math.sin(m);
        a.push({
            x: -y,
            y: -b
        })
    }
    return a
}
U(gi, "generateCirclePoints");
async function wq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = o.width + (t.padding ?? 0)
      , c = o.height + (t.padding ?? 0)
      , u = Math.max(5, c * .1)
      , {cssStyles: f} = t
      , h = [...gi(s / 2, -c / 2, u, 30, -90, 0), {
        x: -s / 2 - u,
        y: u
    }, ...gi(s / 2 + u * 2, -u, u, 20, -180, -270), ...gi(s / 2 + u * 2, u, u, 20, -90, -180), {
        x: -s / 2 - u,
        y: -c / 2
    }, ...gi(s / 2, c / 2, u, 20, 0, 90)]
      , m = [...gi(-s / 2 + u + u / 2, -c / 2, u, 20, -90, -180), {
        x: s / 2 - u / 2,
        y: u
    }, ...gi(-s / 2 - u / 2, -u, u, 20, 0, 90), ...gi(-s / 2 - u / 2, u, u, 20, -90, 0), {
        x: s / 2 - u / 2,
        y: -u
    }, ...gi(-s / 2 + u + u / 2, c / 2, u, 30, -180, -270)]
      , y = [{
        x: s / 2,
        y: -c / 2 - u
    }, {
        x: -s / 2,
        y: -c / 2 - u
    }, ...gi(s / 2, -c / 2, u, 20, -90, 0), {
        x: -s / 2 - u,
        y: -u
    }, ...gi(s / 2 + u * 2, -u, u, 20, -180, -270), ...gi(s / 2 + u * 2, u, u, 20, -90, -180), {
        x: -s / 2 - u,
        y: c / 2
    }, ...gi(s / 2, c / 2, u, 20, 0, 90), {
        x: -s / 2,
        y: c / 2 + u
    }, {
        x: s / 2 - u - u / 2,
        y: c / 2 + u
    }, ...gi(-s / 2 + u + u / 2, -c / 2, u, 20, -90, -180), {
        x: s / 2 - u / 2,
        y: u
    }, ...gi(-s / 2 - u / 2, -u, u, 20, 0, 90), ...gi(-s / 2 - u / 2, u, u, 20, -90, 0), {
        x: s / 2 - u / 2,
        y: -u
    }, ...gi(-s / 2 + u + u / 2, c / 2, u, 30, -180, -270)]
      , b = Ct.svg(i)
      , v = wt(t, {
        fill: "none"
    });
    t.look !== "handDrawn" && (v.roughness = 0,
    v.fillStyle = "solid");
    const C = xn(h).replace("Z", "")
      , w = b.path(C, v)
      , T = xn(m).replace("Z", "")
      , E = b.path(T, v)
      , P = xn(y)
      , D = b.path(P, {
        ...v
    })
      , $ = i.insert("g", ":first-child");
    return $.insert( () => D, ":first-child").attr("stroke-opacity", 0),
    $.insert( () => w, ":first-child"),
    $.insert( () => E, ":first-child"),
    $.attr("class", "text"),
    f && t.look !== "handDrawn" && $.selectAll("path").attr("style", f),
    r && t.look !== "handDrawn" && $.selectAll("path").attr("style", r),
    $.attr("transform", `translate(${u - u / 4}, 0)`),
    a.attr("transform", `translate(${-s / 2 + (t.padding ?? 0) / 2 - (o.x - (o.left ?? 0))},${-c / 2 + (t.padding ?? 0) / 2 - (o.y - (o.top ?? 0))})`),
    Tt(t, $),
    t.intersect = function(z) {
        return xt.polygon(t, y, z)
    }
    ,
    i
}
U(wq, "curlyBraces");
async function kq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = 80
      , s = 20
      , c = Math.max(a, (o.width + (t.padding ?? 0) * 2) * 1.25, t?.width ?? 0)
      , u = Math.max(s, o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , f = u / 2
      , {cssStyles: h} = t
      , m = Ct.svg(i)
      , y = wt(t, {});
    t.look !== "handDrawn" && (y.roughness = 0,
    y.fillStyle = "solid");
    const b = c
      , v = u
      , S = b - f
      , C = v / 4
      , w = [{
        x: S,
        y: 0
    }, {
        x: C,
        y: 0
    }, {
        x: 0,
        y: v / 2
    }, {
        x: C,
        y: v
    }, {
        x: S,
        y: v
    }, ...mg(-S, -v / 2, f, 50, 270, 90)]
      , k = xn(w)
      , T = m.path(k, y)
      , E = i.insert( () => T, ":first-child");
    return E.attr("class", "basic label-container"),
    h && t.look !== "handDrawn" && E.selectChildren("path").attr("style", h),
    r && t.look !== "handDrawn" && E.selectChildren("path").attr("style", r),
    E.attr("transform", `translate(${-c / 2}, ${-u / 2})`),
    Tt(t, E),
    t.intersect = function(P) {
        return xt.polygon(t, w, P)
    }
    ,
    i
}
U(kq, "curvedTrapezoid");
var n$e = U( (e, t, n, r, i, o) => [`M${e},${t + o}`, `a${i},${o} 0,0,0 ${n},0`, `a${i},${o} 0,0,0 ${-n},0`, `l0,${r}`, `a${i},${o} 0,0,0 ${n},0`, `l0,${-r}`].join(" "), "createCylinderPathD")
  , r$e = U( (e, t, n, r, i, o) => [`M${e},${t + o}`, `M${e + n},${t + o}`, `a${i},${o} 0,0,0 ${-n},0`, `l0,${r}`, `a${i},${o} 0,0,0 ${n},0`, `l0,${-r}`].join(" "), "createOuterCylinderPathD")
  , i$e = U( (e, t, n, r, i, o) => [`M${e - n / 2},${-r / 2}`, `a${i},${o} 0,0,0 ${n},0`].join(" "), "createInnerCylinderPathD");
async function Tq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + t.padding, t.width ?? 0)
      , c = s / 2
      , u = c / (2.5 + s / 50)
      , f = Math.max(o.height + u + t.padding, t.height ?? 0);
    let h;
    const {cssStyles: m} = t;
    if (t.look === "handDrawn") {
        const y = Ct.svg(i)
          , b = r$e(0, 0, s, f, c, u)
          , v = i$e(0, u, s, f, c, u)
          , S = y.path(b, wt(t, {}))
          , C = y.path(v, wt(t, {
            fill: "none"
        }));
        h = i.insert( () => C, ":first-child"),
        h = i.insert( () => S, ":first-child"),
        h.attr("class", "basic label-container"),
        m && h.attr("style", m)
    } else {
        const y = n$e(0, 0, s, f, c, u);
        h = i.insert("path", ":first-child").attr("d", y).attr("class", "basic label-container").attr("style", Ri(m)).attr("style", r)
    }
    return h.attr("label-offset-y", u),
    h.attr("transform", `translate(${-s / 2}, ${-(f / 2 + u)})`),
    Tt(t, h),
    a.attr("transform", `translate(${-(o.width / 2) - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + (t.padding ?? 0) / 1.5 - (o.y - (o.top ?? 0))})`),
    t.intersect = function(y) {
        const b = xt.rect(t, y)
          , v = b.x - (t.x ?? 0);
        if (c != 0 && (Math.abs(v) < (t.width ?? 0) / 2 || Math.abs(v) == (t.width ?? 0) / 2 && Math.abs(b.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - u)) {
            let S = u * u * (1 - v * v / (c * c));
            S > 0 && (S = Math.sqrt(S)),
            S = u - S,
            y.y - (t.y ?? 0) > 0 && (S = -S),
            b.y += S
        }
        return b
    }
    ,
    i
}
U(Tq, "cylinder");
async function _q(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = o.width + t.padding
      , c = o.height + t.padding
      , u = c * .2
      , f = -s / 2
      , h = -c / 2 - u / 2
      , {cssStyles: m} = t
      , y = Ct.svg(i)
      , b = wt(t, {});
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const v = [{
        x: f,
        y: h + u
    }, {
        x: -f,
        y: h + u
    }, {
        x: -f,
        y: -h
    }, {
        x: f,
        y: -h
    }, {
        x: f,
        y: h
    }, {
        x: -f,
        y: h
    }, {
        x: -f,
        y: h + u
    }]
      , S = y.polygon(v.map(w => [w.x, w.y]), b)
      , C = i.insert( () => S, ":first-child");
    return C.attr("class", "basic label-container"),
    m && t.look !== "handDrawn" && C.selectAll("path").attr("style", m),
    r && t.look !== "handDrawn" && C.selectAll("path").attr("style", r),
    a.attr("transform", `translate(${f + (t.padding ?? 0) / 2 - (o.x - (o.left ?? 0))}, ${h + u + (t.padding ?? 0) / 2 - (o.y - (o.top ?? 0))})`),
    Tt(t, C),
    t.intersect = function(w) {
        return xt.rect(t, w)
    }
    ,
    i
}
U(_q, "dividedRectangle");
async function Eq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, halfPadding: a} = await Vt(e, t, jt(t))
      , c = o.width / 2 + a + 5
      , u = o.width / 2 + a;
    let f;
    const {cssStyles: h} = t;
    if (t.look === "handDrawn") {
        const m = Ct.svg(i)
          , y = wt(t, {
            roughness: .2,
            strokeWidth: 2.5
        })
          , b = wt(t, {
            roughness: .2,
            strokeWidth: 1.5
        })
          , v = m.circle(0, 0, c * 2, y)
          , S = m.circle(0, 0, u * 2, b);
        f = i.insert("g", ":first-child"),
        f.attr("class", Ri(t.cssClasses)).attr("style", Ri(h)),
        f.node()?.appendChild(v),
        f.node()?.appendChild(S)
    } else {
        f = i.insert("g", ":first-child");
        const m = f.insert("circle", ":first-child")
          , y = f.insert("circle");
        f.attr("class", "basic label-container").attr("style", r),
        m.attr("class", "outer-circle").attr("style", r).attr("r", c).attr("cx", 0).attr("cy", 0),
        y.attr("class", "inner-circle").attr("style", r).attr("r", u).attr("cx", 0).attr("cy", 0)
    }
    return Tt(t, f),
    t.intersect = function(m) {
        return Qe.info("DoubleCircle intersect", t, c, m),
        xt.circle(t, c, m)
    }
    ,
    i
}
U(Eq, "doublecircle");
function Aq(e, t, {config: {themeVariables: n}}) {
    const {labelStyles: r, nodeStyles: i} = kt(t);
    t.label = "",
    t.labelStyle = r;
    const o = e.insert("g").attr("class", jt(t)).attr("id", t.domId ?? t.id)
      , a = 7
      , {cssStyles: s} = t
      , c = Ct.svg(o)
      , {nodeBorder: u} = n
      , f = wt(t, {
        fillStyle: "solid"
    });
    t.look !== "handDrawn" && (f.roughness = 0);
    const h = c.circle(0, 0, a * 2, f)
      , m = o.insert( () => h, ":first-child");
    return m.selectAll("path").attr("style", `fill: ${u} !important;`),
    s && s.length > 0 && t.look !== "handDrawn" && m.selectAll("path").attr("style", s),
    i && t.look !== "handDrawn" && m.selectAll("path").attr("style", i),
    Tt(t, m),
    t.intersect = function(y) {
        return Qe.info("filledCircle intersect", t, {
            radius: a,
            point: y
        }),
        xt.circle(t, a, y)
    }
    ,
    o
}
U(Aq, "filledCircle");
async function Mq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = o.width + (t.padding ?? 0)
      , c = s + o.height
      , u = s + o.height
      , f = [{
        x: 0,
        y: -c
    }, {
        x: u,
        y: -c
    }, {
        x: u / 2,
        y: 0
    }]
      , {cssStyles: h} = t
      , m = Ct.svg(i)
      , y = wt(t, {});
    t.look !== "handDrawn" && (y.roughness = 0,
    y.fillStyle = "solid");
    const b = xn(f)
      , v = m.path(b, y)
      , S = i.insert( () => v, ":first-child").attr("transform", `translate(${-c / 2}, ${c / 2})`);
    return h && t.look !== "handDrawn" && S.selectChildren("path").attr("style", h),
    r && t.look !== "handDrawn" && S.selectChildren("path").attr("style", r),
    t.width = s,
    t.height = c,
    Tt(t, S),
    a.attr("transform", `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${-c / 2 + (t.padding ?? 0) / 2 + (o.y - (o.top ?? 0))})`),
    t.intersect = function(C) {
        return Qe.info("Triangle intersect", t, f, C),
        xt.polygon(t, f, C)
    }
    ,
    i
}
U(Mq, "flippedTriangle");
function Pq(e, t, {dir: n, config: {state: r, themeVariables: i}}) {
    const {nodeStyles: o} = kt(t);
    t.label = "";
    const a = e.insert("g").attr("class", jt(t)).attr("id", t.domId ?? t.id)
      , {cssStyles: s} = t;
    let c = Math.max(70, t?.width ?? 0)
      , u = Math.max(10, t?.height ?? 0);
    n === "LR" && (c = Math.max(10, t?.width ?? 0),
    u = Math.max(70, t?.height ?? 0));
    const f = -1 * c / 2
      , h = -1 * u / 2
      , m = Ct.svg(a)
      , y = wt(t, {
        stroke: i.lineColor,
        fill: i.lineColor
    });
    t.look !== "handDrawn" && (y.roughness = 0,
    y.fillStyle = "solid");
    const b = m.rectangle(f, h, c, u, y)
      , v = a.insert( () => b, ":first-child");
    s && t.look !== "handDrawn" && v.selectAll("path").attr("style", s),
    o && t.look !== "handDrawn" && v.selectAll("path").attr("style", o),
    Tt(t, v);
    const S = r?.padding ?? 0;
    return t.width && t.height && (t.width += S / 2 || 0,
    t.height += S / 2 || 0),
    t.intersect = function(C) {
        return xt.rect(t, C)
    }
    ,
    a
}
U(Pq, "forkJoin");
async function Rq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const i = 80
      , o = 50
      , {shapeSvg: a, bbox: s} = await Vt(e, t, jt(t))
      , c = Math.max(i, s.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , u = Math.max(o, s.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , f = u / 2
      , {cssStyles: h} = t
      , m = Ct.svg(a)
      , y = wt(t, {});
    t.look !== "handDrawn" && (y.roughness = 0,
    y.fillStyle = "solid");
    const b = [{
        x: -c / 2,
        y: -u / 2
    }, {
        x: c / 2 - f,
        y: -u / 2
    }, ...mg(-c / 2 + f, 0, f, 50, 90, 270), {
        x: c / 2 - f,
        y: u / 2
    }, {
        x: -c / 2,
        y: u / 2
    }]
      , v = xn(b)
      , S = m.path(v, y)
      , C = a.insert( () => S, ":first-child");
    return C.attr("class", "basic label-container"),
    h && t.look !== "handDrawn" && C.selectChildren("path").attr("style", h),
    r && t.look !== "handDrawn" && C.selectChildren("path").attr("style", r),
    Tt(t, C),
    t.intersect = function(w) {
        return Qe.info("Pill intersect", t, {
            radius: f,
            point: w
        }),
        xt.polygon(t, b, w)
    }
    ,
    a
}
U(Rq, "halfRoundedRectangle");
async function Dq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = o.height + (t.padding ?? 0)
      , s = o.width + (t.padding ?? 0) * 2.5
      , {cssStyles: c} = t
      , u = Ct.svg(i)
      , f = wt(t, {});
    t.look !== "handDrawn" && (f.roughness = 0,
    f.fillStyle = "solid");
    let h = s / 2;
    const m = h / 6;
    h = h + m;
    const y = a / 2
      , b = y / 2
      , v = h - b
      , S = [{
        x: -v,
        y: -y
    }, {
        x: 0,
        y: -y
    }, {
        x: v,
        y: -y
    }, {
        x: h,
        y: 0
    }, {
        x: v,
        y
    }, {
        x: 0,
        y
    }, {
        x: -v,
        y
    }, {
        x: -h,
        y: 0
    }]
      , C = xn(S)
      , w = u.path(C, f)
      , k = i.insert( () => w, ":first-child");
    return k.attr("class", "basic label-container"),
    c && t.look !== "handDrawn" && k.selectChildren("path").attr("style", c),
    r && t.look !== "handDrawn" && k.selectChildren("path").attr("style", r),
    t.width = s,
    t.height = a,
    Tt(t, k),
    t.intersect = function(T) {
        return xt.polygon(t, S, T)
    }
    ,
    i
}
U(Dq, "hexagon");
async function Oq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.label = "",
    t.labelStyle = n;
    const {shapeSvg: i} = await Vt(e, t, jt(t))
      , o = Math.max(30, t?.width ?? 0)
      , a = Math.max(30, t?.height ?? 0)
      , {cssStyles: s} = t
      , c = Ct.svg(i)
      , u = wt(t, {});
    t.look !== "handDrawn" && (u.roughness = 0,
    u.fillStyle = "solid");
    const f = [{
        x: 0,
        y: 0
    }, {
        x: o,
        y: 0
    }, {
        x: 0,
        y: a
    }, {
        x: o,
        y: a
    }]
      , h = xn(f)
      , m = c.path(h, u)
      , y = i.insert( () => m, ":first-child");
    return y.attr("class", "basic label-container"),
    s && t.look !== "handDrawn" && y.selectChildren("path").attr("style", s),
    r && t.look !== "handDrawn" && y.selectChildren("path").attr("style", r),
    y.attr("transform", `translate(${-o / 2}, ${-a / 2})`),
    Tt(t, y),
    t.intersect = function(b) {
        return Qe.info("Pill intersect", t, {
            points: f
        }),
        xt.polygon(t, f, b)
    }
    ,
    i
}
U(Oq, "hourglass");
async function Iq(e, t, {config: {themeVariables: n, flowchart: r}}) {
    const {labelStyles: i} = kt(t);
    t.labelStyle = i;
    const o = t.assetHeight ?? 48
      , a = t.assetWidth ?? 48
      , s = Math.max(o, a)
      , c = r?.wrappingWidth;
    t.width = Math.max(s, c ?? 0);
    const {shapeSvg: u, bbox: f, label: h} = await Vt(e, t, "icon-shape default")
      , m = t.pos === "t"
      , y = s
      , b = s
      , {nodeBorder: v} = n
      , {stylesMap: S} = Sh(t)
      , C = -b / 2
      , w = -y / 2
      , k = t.label ? 8 : 0
      , T = Ct.svg(u)
      , E = wt(t, {
        stroke: "none",
        fill: "none"
    });
    t.look !== "handDrawn" && (E.roughness = 0,
    E.fillStyle = "solid");
    const P = T.rectangle(C, w, b, y, E)
      , D = Math.max(b, f.width)
      , $ = y + f.height + k
      , z = T.rectangle(-D / 2, -$ / 2, D, $, {
        ...E,
        fill: "transparent",
        stroke: "none"
    })
      , O = u.insert( () => P, ":first-child")
      , I = u.insert( () => z);
    if (t.icon) {
        const M = u.append("g");
        M.html(`<g>${await uy(t.icon, {
            height: s,
            width: s,
            fallbackPrefix: ""
        })}</g>`);
        const B = M.node().getBBox()
          , L = B.width
          , F = B.height
          , j = B.x
          , N = B.y;
        M.attr("transform", `translate(${-L / 2 - j},${m ? f.height / 2 + k / 2 - F / 2 - N : -f.height / 2 - k / 2 - F / 2 - N})`),
        M.attr("style", `color: ${S.get("stroke") ?? v};`)
    }
    return h.attr("transform", `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${m ? -$ / 2 : $ / 2 - f.height})`),
    O.attr("transform", `translate(0,${m ? f.height / 2 + k / 2 : -f.height / 2 - k / 2})`),
    Tt(t, I),
    t.intersect = function(M) {
        if (Qe.info("iconSquare intersect", t, M),
        !t.label)
            return xt.rect(t, M);
        const B = t.x ?? 0
          , L = t.y ?? 0
          , F = t.height ?? 0;
        let j = [];
        return m ? j = [{
            x: B - f.width / 2,
            y: L - F / 2
        }, {
            x: B + f.width / 2,
            y: L - F / 2
        }, {
            x: B + f.width / 2,
            y: L - F / 2 + f.height + k
        }, {
            x: B + b / 2,
            y: L - F / 2 + f.height + k
        }, {
            x: B + b / 2,
            y: L + F / 2
        }, {
            x: B - b / 2,
            y: L + F / 2
        }, {
            x: B - b / 2,
            y: L - F / 2 + f.height + k
        }, {
            x: B - f.width / 2,
            y: L - F / 2 + f.height + k
        }] : j = [{
            x: B - b / 2,
            y: L - F / 2
        }, {
            x: B + b / 2,
            y: L - F / 2
        }, {
            x: B + b / 2,
            y: L - F / 2 + y
        }, {
            x: B + f.width / 2,
            y: L - F / 2 + y
        }, {
            x: B + f.width / 2 / 2,
            y: L + F / 2
        }, {
            x: B - f.width / 2,
            y: L + F / 2
        }, {
            x: B - f.width / 2,
            y: L - F / 2 + y
        }, {
            x: B - b / 2,
            y: L - F / 2 + y
        }],
        xt.polygon(t, j, M)
    }
    ,
    u
}
U(Iq, "icon");
async function $q(e, t, {config: {themeVariables: n, flowchart: r}}) {
    const {labelStyles: i} = kt(t);
    t.labelStyle = i;
    const o = t.assetHeight ?? 48
      , a = t.assetWidth ?? 48
      , s = Math.max(o, a)
      , c = r?.wrappingWidth;
    t.width = Math.max(s, c ?? 0);
    const {shapeSvg: u, bbox: f, label: h} = await Vt(e, t, "icon-shape default")
      , m = 20
      , y = t.label ? 8 : 0
      , b = t.pos === "t"
      , {nodeBorder: v, mainBkg: S} = n
      , {stylesMap: C} = Sh(t)
      , w = Ct.svg(u)
      , k = wt(t, {});
    t.look !== "handDrawn" && (k.roughness = 0,
    k.fillStyle = "solid");
    const T = C.get("fill");
    k.stroke = T ?? S;
    const E = u.append("g");
    t.icon && E.html(`<g>${await uy(t.icon, {
        height: s,
        width: s,
        fallbackPrefix: ""
    })}</g>`);
    const P = E.node().getBBox()
      , D = P.width
      , $ = P.height
      , z = P.x
      , O = P.y
      , I = Math.max(D, $) * Math.SQRT2 + m * 2
      , M = w.circle(0, 0, I, k)
      , B = Math.max(I, f.width)
      , L = I + f.height + y
      , F = w.rectangle(-B / 2, -L / 2, B, L, {
        ...k,
        fill: "transparent",
        stroke: "none"
    })
      , j = u.insert( () => M, ":first-child")
      , N = u.insert( () => F);
    return E.attr("transform", `translate(${-D / 2 - z},${b ? f.height / 2 + y / 2 - $ / 2 - O : -f.height / 2 - y / 2 - $ / 2 - O})`),
    E.attr("style", `color: ${C.get("stroke") ?? v};`),
    h.attr("transform", `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${b ? -L / 2 : L / 2 - f.height})`),
    j.attr("transform", `translate(0,${b ? f.height / 2 + y / 2 : -f.height / 2 - y / 2})`),
    Tt(t, N),
    t.intersect = function(H) {
        return Qe.info("iconSquare intersect", t, H),
        xt.rect(t, H)
    }
    ,
    u
}
U($q, "iconCircle");
async function Lq(e, t, {config: {themeVariables: n, flowchart: r}}) {
    const {labelStyles: i} = kt(t);
    t.labelStyle = i;
    const o = t.assetHeight ?? 48
      , a = t.assetWidth ?? 48
      , s = Math.max(o, a)
      , c = r?.wrappingWidth;
    t.width = Math.max(s, c ?? 0);
    const {shapeSvg: u, bbox: f, halfPadding: h, label: m} = await Vt(e, t, "icon-shape default")
      , y = t.pos === "t"
      , b = s + h * 2
      , v = s + h * 2
      , {nodeBorder: S, mainBkg: C} = n
      , {stylesMap: w} = Sh(t)
      , k = -v / 2
      , T = -b / 2
      , E = t.label ? 8 : 0
      , P = Ct.svg(u)
      , D = wt(t, {});
    t.look !== "handDrawn" && (D.roughness = 0,
    D.fillStyle = "solid");
    const $ = w.get("fill");
    D.stroke = $ ?? C;
    const z = P.path(jc(k, T, v, b, 5), D)
      , O = Math.max(v, f.width)
      , I = b + f.height + E
      , M = P.rectangle(-O / 2, -I / 2, O, I, {
        ...D,
        fill: "transparent",
        stroke: "none"
    })
      , B = u.insert( () => z, ":first-child").attr("class", "icon-shape2")
      , L = u.insert( () => M);
    if (t.icon) {
        const F = u.append("g");
        F.html(`<g>${await uy(t.icon, {
            height: s,
            width: s,
            fallbackPrefix: ""
        })}</g>`);
        const j = F.node().getBBox()
          , N = j.width
          , H = j.height
          , Z = j.x
          , q = j.y;
        F.attr("transform", `translate(${-N / 2 - Z},${y ? f.height / 2 + E / 2 - H / 2 - q : -f.height / 2 - E / 2 - H / 2 - q})`),
        F.attr("style", `color: ${w.get("stroke") ?? S};`)
    }
    return m.attr("transform", `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${y ? -I / 2 : I / 2 - f.height})`),
    B.attr("transform", `translate(0,${y ? f.height / 2 + E / 2 : -f.height / 2 - E / 2})`),
    Tt(t, L),
    t.intersect = function(F) {
        if (Qe.info("iconSquare intersect", t, F),
        !t.label)
            return xt.rect(t, F);
        const j = t.x ?? 0
          , N = t.y ?? 0
          , H = t.height ?? 0;
        let Z = [];
        return y ? Z = [{
            x: j - f.width / 2,
            y: N - H / 2
        }, {
            x: j + f.width / 2,
            y: N - H / 2
        }, {
            x: j + f.width / 2,
            y: N - H / 2 + f.height + E
        }, {
            x: j + v / 2,
            y: N - H / 2 + f.height + E
        }, {
            x: j + v / 2,
            y: N + H / 2
        }, {
            x: j - v / 2,
            y: N + H / 2
        }, {
            x: j - v / 2,
            y: N - H / 2 + f.height + E
        }, {
            x: j - f.width / 2,
            y: N - H / 2 + f.height + E
        }] : Z = [{
            x: j - v / 2,
            y: N - H / 2
        }, {
            x: j + v / 2,
            y: N - H / 2
        }, {
            x: j + v / 2,
            y: N - H / 2 + b
        }, {
            x: j + f.width / 2,
            y: N - H / 2 + b
        }, {
            x: j + f.width / 2 / 2,
            y: N + H / 2
        }, {
            x: j - f.width / 2,
            y: N + H / 2
        }, {
            x: j - f.width / 2,
            y: N - H / 2 + b
        }, {
            x: j - v / 2,
            y: N - H / 2 + b
        }],
        xt.polygon(t, Z, F)
    }
    ,
    u
}
U(Lq, "iconRounded");
async function jq(e, t, {config: {themeVariables: n, flowchart: r}}) {
    const {labelStyles: i} = kt(t);
    t.labelStyle = i;
    const o = t.assetHeight ?? 48
      , a = t.assetWidth ?? 48
      , s = Math.max(o, a)
      , c = r?.wrappingWidth;
    t.width = Math.max(s, c ?? 0);
    const {shapeSvg: u, bbox: f, halfPadding: h, label: m} = await Vt(e, t, "icon-shape default")
      , y = t.pos === "t"
      , b = s + h * 2
      , v = s + h * 2
      , {nodeBorder: S, mainBkg: C} = n
      , {stylesMap: w} = Sh(t)
      , k = -v / 2
      , T = -b / 2
      , E = t.label ? 8 : 0
      , P = Ct.svg(u)
      , D = wt(t, {});
    t.look !== "handDrawn" && (D.roughness = 0,
    D.fillStyle = "solid");
    const $ = w.get("fill");
    D.stroke = $ ?? C;
    const z = P.path(jc(k, T, v, b, .1), D)
      , O = Math.max(v, f.width)
      , I = b + f.height + E
      , M = P.rectangle(-O / 2, -I / 2, O, I, {
        ...D,
        fill: "transparent",
        stroke: "none"
    })
      , B = u.insert( () => z, ":first-child")
      , L = u.insert( () => M);
    if (t.icon) {
        const F = u.append("g");
        F.html(`<g>${await uy(t.icon, {
            height: s,
            width: s,
            fallbackPrefix: ""
        })}</g>`);
        const j = F.node().getBBox()
          , N = j.width
          , H = j.height
          , Z = j.x
          , q = j.y;
        F.attr("transform", `translate(${-N / 2 - Z},${y ? f.height / 2 + E / 2 - H / 2 - q : -f.height / 2 - E / 2 - H / 2 - q})`),
        F.attr("style", `color: ${w.get("stroke") ?? S};`)
    }
    return m.attr("transform", `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${y ? -I / 2 : I / 2 - f.height})`),
    B.attr("transform", `translate(0,${y ? f.height / 2 + E / 2 : -f.height / 2 - E / 2})`),
    Tt(t, L),
    t.intersect = function(F) {
        if (Qe.info("iconSquare intersect", t, F),
        !t.label)
            return xt.rect(t, F);
        const j = t.x ?? 0
          , N = t.y ?? 0
          , H = t.height ?? 0;
        let Z = [];
        return y ? Z = [{
            x: j - f.width / 2,
            y: N - H / 2
        }, {
            x: j + f.width / 2,
            y: N - H / 2
        }, {
            x: j + f.width / 2,
            y: N - H / 2 + f.height + E
        }, {
            x: j + v / 2,
            y: N - H / 2 + f.height + E
        }, {
            x: j + v / 2,
            y: N + H / 2
        }, {
            x: j - v / 2,
            y: N + H / 2
        }, {
            x: j - v / 2,
            y: N - H / 2 + f.height + E
        }, {
            x: j - f.width / 2,
            y: N - H / 2 + f.height + E
        }] : Z = [{
            x: j - v / 2,
            y: N - H / 2
        }, {
            x: j + v / 2,
            y: N - H / 2
        }, {
            x: j + v / 2,
            y: N - H / 2 + b
        }, {
            x: j + f.width / 2,
            y: N - H / 2 + b
        }, {
            x: j + f.width / 2 / 2,
            y: N + H / 2
        }, {
            x: j - f.width / 2,
            y: N + H / 2
        }, {
            x: j - f.width / 2,
            y: N - H / 2 + b
        }, {
            x: j - v / 2,
            y: N - H / 2 + b
        }],
        xt.polygon(t, Z, F)
    }
    ,
    u
}
U(jq, "iconSquare");
async function Bq(e, t, {config: {flowchart: n}}) {
    const r = new Image;
    r.src = t?.img ?? "",
    await r.decode();
    const i = Number(r.naturalWidth.toString().replace("px", ""))
      , o = Number(r.naturalHeight.toString().replace("px", ""));
    t.imageAspectRatio = i / o;
    const {labelStyles: a} = kt(t);
    t.labelStyle = a;
    const s = n?.wrappingWidth;
    t.defaultWidth = n?.wrappingWidth;
    const c = Math.max(t.label ? s ?? 0 : 0, t?.assetWidth ?? i)
      , u = t.constraint === "on" && t?.assetHeight ? t.assetHeight * t.imageAspectRatio : c
      , f = t.constraint === "on" ? u / t.imageAspectRatio : t?.assetHeight ?? o;
    t.width = Math.max(u, s ?? 0);
    const {shapeSvg: h, bbox: m, label: y} = await Vt(e, t, "image-shape default")
      , b = t.pos === "t"
      , v = -u / 2
      , S = -f / 2
      , C = t.label ? 8 : 0
      , w = Ct.svg(h)
      , k = wt(t, {});
    t.look !== "handDrawn" && (k.roughness = 0,
    k.fillStyle = "solid");
    const T = w.rectangle(v, S, u, f, k)
      , E = Math.max(u, m.width)
      , P = f + m.height + C
      , D = w.rectangle(-E / 2, -P / 2, E, P, {
        ...k,
        fill: "none",
        stroke: "none"
    })
      , $ = h.insert( () => T, ":first-child")
      , z = h.insert( () => D);
    if (t.img) {
        const O = h.append("image");
        O.attr("href", t.img),
        O.attr("width", u),
        O.attr("height", f),
        O.attr("preserveAspectRatio", "none"),
        O.attr("transform", `translate(${-u / 2},${b ? P / 2 - f : -P / 2})`)
    }
    return y.attr("transform", `translate(${-m.width / 2 - (m.x - (m.left ?? 0))},${b ? -f / 2 - m.height / 2 - C / 2 : f / 2 - m.height / 2 + C / 2})`),
    $.attr("transform", `translate(0,${b ? m.height / 2 + C / 2 : -m.height / 2 - C / 2})`),
    Tt(t, z),
    t.intersect = function(O) {
        if (Qe.info("iconSquare intersect", t, O),
        !t.label)
            return xt.rect(t, O);
        const I = t.x ?? 0
          , M = t.y ?? 0
          , B = t.height ?? 0;
        let L = [];
        return b ? L = [{
            x: I - m.width / 2,
            y: M - B / 2
        }, {
            x: I + m.width / 2,
            y: M - B / 2
        }, {
            x: I + m.width / 2,
            y: M - B / 2 + m.height + C
        }, {
            x: I + u / 2,
            y: M - B / 2 + m.height + C
        }, {
            x: I + u / 2,
            y: M + B / 2
        }, {
            x: I - u / 2,
            y: M + B / 2
        }, {
            x: I - u / 2,
            y: M - B / 2 + m.height + C
        }, {
            x: I - m.width / 2,
            y: M - B / 2 + m.height + C
        }] : L = [{
            x: I - u / 2,
            y: M - B / 2
        }, {
            x: I + u / 2,
            y: M - B / 2
        }, {
            x: I + u / 2,
            y: M - B / 2 + f
        }, {
            x: I + m.width / 2,
            y: M - B / 2 + f
        }, {
            x: I + m.width / 2 / 2,
            y: M + B / 2
        }, {
            x: I - m.width / 2,
            y: M + B / 2
        }, {
            x: I - m.width / 2,
            y: M - B / 2 + f
        }, {
            x: I - u / 2,
            y: M - B / 2 + f
        }],
        xt.polygon(t, L, O)
    }
    ,
    h
}
U(Bq, "imageSquare");
async function zq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , s = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , c = [{
        x: 0,
        y: 0
    }, {
        x: a,
        y: 0
    }, {
        x: a + 3 * s / 6,
        y: -s
    }, {
        x: -3 * s / 6,
        y: -s
    }];
    let u;
    const {cssStyles: f} = t;
    if (t.look === "handDrawn") {
        const h = Ct.svg(i)
          , m = wt(t, {})
          , y = xn(c)
          , b = h.path(y, m);
        u = i.insert( () => b, ":first-child").attr("transform", `translate(${-a / 2}, ${s / 2})`),
        f && u.attr("style", f)
    } else
        u = Bc(i, a, s, c);
    return r && u.attr("style", r),
    t.width = a,
    t.height = s,
    Tt(t, u),
    t.intersect = function(h) {
        return xt.polygon(t, c, h)
    }
    ,
    i
}
U(zq, "inv_trapezoid");
async function aS(e, t, n) {
    const {labelStyles: r, nodeStyles: i} = kt(t);
    t.labelStyle = r;
    const {shapeSvg: o, bbox: a} = await Vt(e, t, jt(t))
      , s = Math.max(a.width + n.labelPaddingX * 2, t?.width || 0)
      , c = Math.max(a.height + n.labelPaddingY * 2, t?.height || 0)
      , u = -s / 2
      , f = -c / 2;
    let h, {rx: m, ry: y} = t;
    const {cssStyles: b} = t;
    if (n?.rx && n.ry && (m = n.rx,
    y = n.ry),
    t.look === "handDrawn") {
        const v = Ct.svg(o)
          , S = wt(t, {})
          , C = m || y ? v.path(jc(u, f, s, c, m || 0), S) : v.rectangle(u, f, s, c, S);
        h = o.insert( () => C, ":first-child"),
        h.attr("class", "basic label-container").attr("style", Ri(b))
    } else
        h = o.insert("rect", ":first-child"),
        h.attr("class", "basic label-container").attr("style", i).attr("rx", Ri(m)).attr("ry", Ri(y)).attr("x", u).attr("y", f).attr("width", s).attr("height", c);
    return Tt(t, h),
    t.calcIntersect = function(v, S) {
        return xt.rect(v, S)
    }
    ,
    t.intersect = function(v) {
        return xt.rect(t, v)
    }
    ,
    o
}
U(aS, "drawRect");
async function Fq(e, t) {
    const {shapeSvg: n, bbox: r, label: i} = await Vt(e, t, "label")
      , o = n.insert("rect", ":first-child");
    return o.attr("width", .1).attr("height", .1),
    n.attr("class", "label edgeLabel"),
    i.attr("transform", `translate(${-(r.width / 2) - (r.x - (r.left ?? 0))}, ${-(r.height / 2) - (r.y - (r.top ?? 0))})`),
    Tt(t, o),
    t.intersect = function(c) {
        return xt.rect(t, c)
    }
    ,
    n
}
U(Fq, "labelRect");
async function Nq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = Math.max(o.width + (t.padding ?? 0), t?.width ?? 0)
      , s = Math.max(o.height + (t.padding ?? 0), t?.height ?? 0)
      , c = [{
        x: 0,
        y: 0
    }, {
        x: a + 3 * s / 6,
        y: 0
    }, {
        x: a,
        y: -s
    }, {
        x: -(3 * s) / 6,
        y: -s
    }];
    let u;
    const {cssStyles: f} = t;
    if (t.look === "handDrawn") {
        const h = Ct.svg(i)
          , m = wt(t, {})
          , y = xn(c)
          , b = h.path(y, m);
        u = i.insert( () => b, ":first-child").attr("transform", `translate(${-a / 2}, ${s / 2})`),
        f && u.attr("style", f)
    } else
        u = Bc(i, a, s, c);
    return r && u.attr("style", r),
    t.width = a,
    t.height = s,
    Tt(t, u),
    t.intersect = function(h) {
        return xt.polygon(t, c, h)
    }
    ,
    i
}
U(Nq, "lean_left");
async function Uq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = Math.max(o.width + (t.padding ?? 0), t?.width ?? 0)
      , s = Math.max(o.height + (t.padding ?? 0), t?.height ?? 0)
      , c = [{
        x: -3 * s / 6,
        y: 0
    }, {
        x: a,
        y: 0
    }, {
        x: a + 3 * s / 6,
        y: -s
    }, {
        x: 0,
        y: -s
    }];
    let u;
    const {cssStyles: f} = t;
    if (t.look === "handDrawn") {
        const h = Ct.svg(i)
          , m = wt(t, {})
          , y = xn(c)
          , b = h.path(y, m);
        u = i.insert( () => b, ":first-child").attr("transform", `translate(${-a / 2}, ${s / 2})`),
        f && u.attr("style", f)
    } else
        u = Bc(i, a, s, c);
    return r && u.attr("style", r),
    t.width = a,
    t.height = s,
    Tt(t, u),
    t.intersect = function(h) {
        return xt.polygon(t, c, h)
    }
    ,
    i
}
U(Uq, "lean_right");
function Vq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.label = "",
    t.labelStyle = n;
    const i = e.insert("g").attr("class", jt(t)).attr("id", t.domId ?? t.id)
      , {cssStyles: o} = t
      , a = Math.max(35, t?.width ?? 0)
      , s = Math.max(35, t?.height ?? 0)
      , c = 7
      , u = [{
        x: a,
        y: 0
    }, {
        x: 0,
        y: s + c / 2
    }, {
        x: a - 2 * c,
        y: s + c / 2
    }, {
        x: 0,
        y: 2 * s
    }, {
        x: a,
        y: s - c / 2
    }, {
        x: 2 * c,
        y: s - c / 2
    }]
      , f = Ct.svg(i)
      , h = wt(t, {});
    t.look !== "handDrawn" && (h.roughness = 0,
    h.fillStyle = "solid");
    const m = xn(u)
      , y = f.path(m, h)
      , b = i.insert( () => y, ":first-child");
    return o && t.look !== "handDrawn" && b.selectAll("path").attr("style", o),
    r && t.look !== "handDrawn" && b.selectAll("path").attr("style", r),
    b.attr("transform", `translate(-${a / 2},${-s})`),
    Tt(t, b),
    t.intersect = function(v) {
        return Qe.info("lightningBolt intersect", t, v),
        xt.polygon(t, u, v)
    }
    ,
    i
}
U(Vq, "lightningBolt");
var o$e = U( (e, t, n, r, i, o, a) => [`M${e},${t + o}`, `a${i},${o} 0,0,0 ${n},0`, `a${i},${o} 0,0,0 ${-n},0`, `l0,${r}`, `a${i},${o} 0,0,0 ${n},0`, `l0,${-r}`, `M${e},${t + o + a}`, `a${i},${o} 0,0,0 ${n},0`].join(" "), "createCylinderPathD")
  , a$e = U( (e, t, n, r, i, o, a) => [`M${e},${t + o}`, `M${e + n},${t + o}`, `a${i},${o} 0,0,0 ${-n},0`, `l0,${r}`, `a${i},${o} 0,0,0 ${n},0`, `l0,${-r}`, `M${e},${t + o + a}`, `a${i},${o} 0,0,0 ${n},0`].join(" "), "createOuterCylinderPathD")
  , s$e = U( (e, t, n, r, i, o) => [`M${e - n / 2},${-r / 2}`, `a${i},${o} 0,0,0 ${n},0`].join(" "), "createInnerCylinderPathD");
async function Hq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0), t.width ?? 0)
      , c = s / 2
      , u = c / (2.5 + s / 50)
      , f = Math.max(o.height + u + (t.padding ?? 0), t.height ?? 0)
      , h = f * .1;
    let m;
    const {cssStyles: y} = t;
    if (t.look === "handDrawn") {
        const b = Ct.svg(i)
          , v = a$e(0, 0, s, f, c, u, h)
          , S = s$e(0, u, s, f, c, u)
          , C = wt(t, {})
          , w = b.path(v, C)
          , k = b.path(S, C);
        i.insert( () => k, ":first-child").attr("class", "line"),
        m = i.insert( () => w, ":first-child"),
        m.attr("class", "basic label-container"),
        y && m.attr("style", y)
    } else {
        const b = o$e(0, 0, s, f, c, u, h);
        m = i.insert("path", ":first-child").attr("d", b).attr("class", "basic label-container").attr("style", Ri(y)).attr("style", r)
    }
    return m.attr("label-offset-y", u),
    m.attr("transform", `translate(${-s / 2}, ${-(f / 2 + u)})`),
    Tt(t, m),
    a.attr("transform", `translate(${-(o.width / 2) - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + u - (o.y - (o.top ?? 0))})`),
    t.intersect = function(b) {
        const v = xt.rect(t, b)
          , S = v.x - (t.x ?? 0);
        if (c != 0 && (Math.abs(S) < (t.width ?? 0) / 2 || Math.abs(S) == (t.width ?? 0) / 2 && Math.abs(v.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - u)) {
            let C = u * u * (1 - S * S / (c * c));
            C > 0 && (C = Math.sqrt(C)),
            C = u - C,
            b.y - (t.y ?? 0) > 0 && (C = -C),
            v.y += C
        }
        return v
    }
    ,
    i
}
U(Hq, "linedCylinder");
async function qq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , c = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , u = c / 4
      , f = c + u
      , {cssStyles: h} = t
      , m = Ct.svg(i)
      , y = wt(t, {});
    t.look !== "handDrawn" && (y.roughness = 0,
    y.fillStyle = "solid");
    const b = [{
        x: -s / 2 - s / 2 * .1,
        y: -f / 2
    }, {
        x: -s / 2 - s / 2 * .1,
        y: f / 2
    }, ..._c(-s / 2 - s / 2 * .1, f / 2, s / 2 + s / 2 * .1, f / 2, u, .8), {
        x: s / 2 + s / 2 * .1,
        y: -f / 2
    }, {
        x: -s / 2 - s / 2 * .1,
        y: -f / 2
    }, {
        x: -s / 2,
        y: -f / 2
    }, {
        x: -s / 2,
        y: f / 2 * 1.1
    }, {
        x: -s / 2,
        y: -f / 2
    }]
      , v = m.polygon(b.map(C => [C.x, C.y]), y)
      , S = i.insert( () => v, ":first-child");
    return S.attr("class", "basic label-container"),
    h && t.look !== "handDrawn" && S.selectAll("path").attr("style", h),
    r && t.look !== "handDrawn" && S.selectAll("path").attr("style", r),
    S.attr("transform", `translate(0,${-u / 2})`),
    a.attr("transform", `translate(${-s / 2 + (t.padding ?? 0) + s / 2 * .1 / 2 - (o.x - (o.left ?? 0))},${-c / 2 + (t.padding ?? 0) - u / 2 - (o.y - (o.top ?? 0))})`),
    Tt(t, S),
    t.intersect = function(C) {
        return xt.polygon(t, b, C)
    }
    ,
    i
}
U(qq, "linedWaveEdgedRect");
async function Wq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , c = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , u = 5
      , f = -s / 2
      , h = -c / 2
      , {cssStyles: m} = t
      , y = Ct.svg(i)
      , b = wt(t, {})
      , v = [{
        x: f - u,
        y: h + u
    }, {
        x: f - u,
        y: h + c + u
    }, {
        x: f + s - u,
        y: h + c + u
    }, {
        x: f + s - u,
        y: h + c
    }, {
        x: f + s,
        y: h + c
    }, {
        x: f + s,
        y: h + c - u
    }, {
        x: f + s + u,
        y: h + c - u
    }, {
        x: f + s + u,
        y: h - u
    }, {
        x: f + u,
        y: h - u
    }, {
        x: f + u,
        y: h
    }, {
        x: f,
        y: h
    }, {
        x: f,
        y: h + u
    }]
      , S = [{
        x: f,
        y: h + u
    }, {
        x: f + s - u,
        y: h + u
    }, {
        x: f + s - u,
        y: h + c
    }, {
        x: f + s,
        y: h + c
    }, {
        x: f + s,
        y: h
    }, {
        x: f,
        y: h
    }];
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const C = xn(v)
      , w = y.path(C, b)
      , k = xn(S)
      , T = y.path(k, {
        ...b,
        fill: "none"
    })
      , E = i.insert( () => T, ":first-child");
    return E.insert( () => w, ":first-child"),
    E.attr("class", "basic label-container"),
    m && t.look !== "handDrawn" && E.selectAll("path").attr("style", m),
    r && t.look !== "handDrawn" && E.selectAll("path").attr("style", r),
    a.attr("transform", `translate(${-(o.width / 2) - u - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + u - (o.y - (o.top ?? 0))})`),
    Tt(t, E),
    t.intersect = function(P) {
        return xt.polygon(t, v, P)
    }
    ,
    i
}
U(Wq, "multiRect");
async function Gq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , c = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , u = c / 4
      , f = c + u
      , h = -s / 2
      , m = -f / 2
      , y = 5
      , {cssStyles: b} = t
      , v = _c(h - y, m + f + y, h + s - y, m + f + y, u, .8)
      , S = v?.[v.length - 1]
      , C = [{
        x: h - y,
        y: m + y
    }, {
        x: h - y,
        y: m + f + y
    }, ...v, {
        x: h + s - y,
        y: S.y - y
    }, {
        x: h + s,
        y: S.y - y
    }, {
        x: h + s,
        y: S.y - 2 * y
    }, {
        x: h + s + y,
        y: S.y - 2 * y
    }, {
        x: h + s + y,
        y: m - y
    }, {
        x: h + y,
        y: m - y
    }, {
        x: h + y,
        y: m
    }, {
        x: h,
        y: m
    }, {
        x: h,
        y: m + y
    }]
      , w = [{
        x: h,
        y: m + y
    }, {
        x: h + s - y,
        y: m + y
    }, {
        x: h + s - y,
        y: S.y - y
    }, {
        x: h + s,
        y: S.y - y
    }, {
        x: h + s,
        y: m
    }, {
        x: h,
        y: m
    }]
      , k = Ct.svg(i)
      , T = wt(t, {});
    t.look !== "handDrawn" && (T.roughness = 0,
    T.fillStyle = "solid");
    const E = xn(C)
      , P = k.path(E, T)
      , D = xn(w)
      , $ = k.path(D, T)
      , z = i.insert( () => P, ":first-child");
    return z.insert( () => $),
    z.attr("class", "basic label-container"),
    b && t.look !== "handDrawn" && z.selectAll("path").attr("style", b),
    r && t.look !== "handDrawn" && z.selectAll("path").attr("style", r),
    z.attr("transform", `translate(0,${-u / 2})`),
    a.attr("transform", `translate(${-(o.width / 2) - y - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + y - u / 2 - (o.y - (o.top ?? 0))})`),
    Tt(t, z),
    t.intersect = function(O) {
        return xt.polygon(t, C, O)
    }
    ,
    i
}
U(Gq, "multiWaveEdgedRectangle");
async function Yq(e, t, {config: {themeVariables: n}}) {
    const {labelStyles: r, nodeStyles: i} = kt(t);
    t.labelStyle = r,
    t.useHtmlLabels || Mi().flowchart?.htmlLabels !== !1 || (t.centerLabel = !0);
    const {shapeSvg: a, bbox: s, label: c} = await Vt(e, t, jt(t))
      , u = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , f = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , h = -u / 2
      , m = -f / 2
      , {cssStyles: y} = t
      , b = Ct.svg(a)
      , v = wt(t, {
        fill: n.noteBkgColor,
        stroke: n.noteBorderColor
    });
    t.look !== "handDrawn" && (v.roughness = 0,
    v.fillStyle = "solid");
    const S = b.rectangle(h, m, u, f, v)
      , C = a.insert( () => S, ":first-child");
    return C.attr("class", "basic label-container"),
    y && t.look !== "handDrawn" && C.selectAll("path").attr("style", y),
    i && t.look !== "handDrawn" && C.selectAll("path").attr("style", i),
    c.attr("transform", `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`),
    Tt(t, C),
    t.intersect = function(w) {
        return xt.rect(t, w)
    }
    ,
    a
}
U(Yq, "note");
var l$e = U( (e, t, n) => [`M${e + n / 2},${t}`, `L${e + n},${t - n / 2}`, `L${e + n / 2},${t - n}`, `L${e},${t - n / 2}`, "Z"].join(" "), "createDecisionBoxPathD");
async function Zq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = o.width + t.padding
      , s = o.height + t.padding
      , c = a + s
      , u = .5
      , f = [{
        x: c / 2,
        y: 0
    }, {
        x: c,
        y: -c / 2
    }, {
        x: c / 2,
        y: -c
    }, {
        x: 0,
        y: -c / 2
    }];
    let h;
    const {cssStyles: m} = t;
    if (t.look === "handDrawn") {
        const y = Ct.svg(i)
          , b = wt(t, {})
          , v = l$e(0, 0, c)
          , S = y.path(v, b);
        h = i.insert( () => S, ":first-child").attr("transform", `translate(${-c / 2 + u}, ${c / 2})`),
        m && h.attr("style", m)
    } else
        h = Bc(i, c, c, f),
        h.attr("transform", `translate(${-c / 2 + u}, ${c / 2})`);
    return r && h.attr("style", r),
    Tt(t, h),
    t.calcIntersect = function(y, b) {
        const v = y.width
          , S = [{
            x: v / 2,
            y: 0
        }, {
            x: v,
            y: -v / 2
        }, {
            x: v / 2,
            y: -v
        }, {
            x: 0,
            y: -v / 2
        }]
          , C = xt.polygon(y, S, b);
        return {
            x: C.x - .5,
            y: C.y - .5
        }
    }
    ,
    t.intersect = function(y) {
        return this.calcIntersect(t, y)
    }
    ,
    i
}
U(Zq, "question");
async function Qq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0), t?.width ?? 0)
      , c = Math.max(o.height + (t.padding ?? 0), t?.height ?? 0)
      , u = -s / 2
      , f = -c / 2
      , h = f / 2
      , m = [{
        x: u + h,
        y: f
    }, {
        x: u,
        y: 0
    }, {
        x: u + h,
        y: -f
    }, {
        x: -u,
        y: -f
    }, {
        x: -u,
        y: f
    }]
      , {cssStyles: y} = t
      , b = Ct.svg(i)
      , v = wt(t, {});
    t.look !== "handDrawn" && (v.roughness = 0,
    v.fillStyle = "solid");
    const S = xn(m)
      , C = b.path(S, v)
      , w = i.insert( () => C, ":first-child");
    return w.attr("class", "basic label-container"),
    y && t.look !== "handDrawn" && w.selectAll("path").attr("style", y),
    r && t.look !== "handDrawn" && w.selectAll("path").attr("style", r),
    w.attr("transform", `translate(${-h / 2},0)`),
    a.attr("transform", `translate(${-h / 2 - o.width / 2 - (o.x - (o.left ?? 0))}, ${-(o.height / 2) - (o.y - (o.top ?? 0))})`),
    Tt(t, w),
    t.intersect = function(k) {
        return xt.polygon(t, m, k)
    }
    ,
    i
}
U(Qq, "rect_left_inv_arrow");
async function Kq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    let i;
    t.cssClasses ? i = "node " + t.cssClasses : i = "node default";
    const o = e.insert("g").attr("class", i).attr("id", t.domId || t.id)
      , a = o.insert("g")
      , s = o.insert("g").attr("class", "label").attr("style", r)
      , c = t.description
      , u = t.label
      , f = s.node().appendChild(await Au(u, t.labelStyle, !0, !0));
    let h = {
        width: 0,
        height: 0
    };
    if (oi(Vn()?.flowchart?.htmlLabels)) {
        const $ = f.children[0]
          , z = En(f);
        h = $.getBoundingClientRect(),
        z.attr("width", h.width),
        z.attr("height", h.height)
    }
    Qe.info("Text 2", c);
    const m = c || []
      , y = f.getBBox()
      , b = s.node().appendChild(await Au(m.join ? m.join("<br/>") : m, t.labelStyle, !0, !0))
      , v = b.children[0]
      , S = En(b);
    h = v.getBoundingClientRect(),
    S.attr("width", h.width),
    S.attr("height", h.height);
    const C = (t.padding || 0) / 2;
    En(b).attr("transform", "translate( " + (h.width > y.width ? 0 : (y.width - h.width) / 2) + ", " + (y.height + C + 5) + ")"),
    En(f).attr("transform", "translate( " + (h.width < y.width ? 0 : -(y.width - h.width) / 2) + ", 0)"),
    h = s.node().getBBox(),
    s.attr("transform", "translate(" + -h.width / 2 + ", " + (-h.height / 2 - C + 3) + ")");
    const w = h.width + (t.padding || 0)
      , k = h.height + (t.padding || 0)
      , T = -h.width / 2 - C
      , E = -h.height / 2 - C;
    let P, D;
    if (t.look === "handDrawn") {
        const $ = Ct.svg(o)
          , z = wt(t, {})
          , O = $.path(jc(T, E, w, k, t.rx || 0), z)
          , I = $.line(-h.width / 2 - C, -h.height / 2 - C + y.height + C, h.width / 2 + C, -h.height / 2 - C + y.height + C, z);
        D = o.insert( () => (Qe.debug("Rough node insert CXC", O),
        I), ":first-child"),
        P = o.insert( () => (Qe.debug("Rough node insert CXC", O),
        O), ":first-child")
    } else
        P = a.insert("rect", ":first-child"),
        D = a.insert("line"),
        P.attr("class", "outer title-state").attr("style", r).attr("x", -h.width / 2 - C).attr("y", -h.height / 2 - C).attr("width", h.width + (t.padding || 0)).attr("height", h.height + (t.padding || 0)),
        D.attr("class", "divider").attr("x1", -h.width / 2 - C).attr("x2", h.width / 2 + C).attr("y1", -h.height / 2 - C + y.height + C).attr("y2", -h.height / 2 - C + y.height + C);
    return Tt(t, P),
    t.intersect = function($) {
        return xt.rect(t, $)
    }
    ,
    o
}
U(Kq, "rectWithTitle");
function sm(e, t, n, r, i, o, a) {
    const c = (e + n) / 2
      , u = (t + r) / 2
      , f = Math.atan2(r - t, n - e)
      , h = (n - e) / 2
      , m = (r - t) / 2
      , y = h / i
      , b = m / o
      , v = Math.sqrt(y ** 2 + b ** 2);
    if (v > 1)
        throw new Error("The given radii are too small to create an arc between the points.");
    const S = Math.sqrt(1 - v ** 2)
      , C = c + S * o * Math.sin(f) * (a ? -1 : 1)
      , w = u - S * i * Math.cos(f) * (a ? -1 : 1)
      , k = Math.atan2((t - w) / o, (e - C) / i);
    let E = Math.atan2((r - w) / o, (n - C) / i) - k;
    a && E < 0 && (E += 2 * Math.PI),
    !a && E > 0 && (E -= 2 * Math.PI);
    const P = [];
    for (let D = 0; D < 20; D++) {
        const $ = D / 19
          , z = k + $ * E
          , O = C + i * Math.cos(z)
          , I = w + o * Math.sin(z);
        P.push({
            x: O,
            y: I
        })
    }
    return P
}
U(sm, "generateArcPoints");
async function Xq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = t?.padding ?? 0
      , s = t?.padding ?? 0
      , c = (t?.width ? t?.width : o.width) + a * 2
      , u = (t?.height ? t?.height : o.height) + s * 2
      , f = t.radius || 5
      , h = t.taper || 5
      , {cssStyles: m} = t
      , y = Ct.svg(i)
      , b = wt(t, {});
    t.stroke && (b.stroke = t.stroke),
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const v = [{
        x: -c / 2 + h,
        y: -u / 2
    }, {
        x: c / 2 - h,
        y: -u / 2
    }, ...sm(c / 2 - h, -u / 2, c / 2, -u / 2 + h, f, f, !0), {
        x: c / 2,
        y: -u / 2 + h
    }, {
        x: c / 2,
        y: u / 2 - h
    }, ...sm(c / 2, u / 2 - h, c / 2 - h, u / 2, f, f, !0), {
        x: c / 2 - h,
        y: u / 2
    }, {
        x: -c / 2 + h,
        y: u / 2
    }, ...sm(-c / 2 + h, u / 2, -c / 2, u / 2 - h, f, f, !0), {
        x: -c / 2,
        y: u / 2 - h
    }, {
        x: -c / 2,
        y: -u / 2 + h
    }, ...sm(-c / 2, -u / 2 + h, -c / 2 + h, -u / 2, f, f, !0)]
      , S = xn(v)
      , C = y.path(S, b)
      , w = i.insert( () => C, ":first-child");
    return w.attr("class", "basic label-container outer-path"),
    m && t.look !== "handDrawn" && w.selectChildren("path").attr("style", m),
    r && t.look !== "handDrawn" && w.selectChildren("path").attr("style", r),
    Tt(t, w),
    t.intersect = function(k) {
        return xt.polygon(t, v, k)
    }
    ,
    i
}
U(Xq, "roundedRect");
async function Jq(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = t?.padding ?? 0
      , c = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , u = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , f = -o.width / 2 - s
      , h = -o.height / 2 - s
      , {cssStyles: m} = t
      , y = Ct.svg(i)
      , b = wt(t, {});
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const v = [{
        x: f,
        y: h
    }, {
        x: f + c + 8,
        y: h
    }, {
        x: f + c + 8,
        y: h + u
    }, {
        x: f - 8,
        y: h + u
    }, {
        x: f - 8,
        y: h
    }, {
        x: f,
        y: h
    }, {
        x: f,
        y: h + u
    }]
      , S = y.polygon(v.map(w => [w.x, w.y]), b)
      , C = i.insert( () => S, ":first-child");
    return C.attr("class", "basic label-container").attr("style", Ri(m)),
    r && t.look !== "handDrawn" && C.selectAll("path").attr("style", r),
    m && t.look !== "handDrawn" && C.selectAll("path").attr("style", r),
    a.attr("transform", `translate(${-c / 2 + 4 + (t.padding ?? 0) - (o.x - (o.left ?? 0))},${-u / 2 + (t.padding ?? 0) - (o.y - (o.top ?? 0))})`),
    Tt(t, C),
    t.intersect = function(w) {
        return xt.rect(t, w)
    }
    ,
    i
}
U(Jq, "shadedProcess");
async function eW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , c = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , u = -s / 2
      , f = -c / 2
      , {cssStyles: h} = t
      , m = Ct.svg(i)
      , y = wt(t, {});
    t.look !== "handDrawn" && (y.roughness = 0,
    y.fillStyle = "solid");
    const b = [{
        x: u,
        y: f
    }, {
        x: u,
        y: f + c
    }, {
        x: u + s,
        y: f + c
    }, {
        x: u + s,
        y: f - c / 2
    }]
      , v = xn(b)
      , S = m.path(v, y)
      , C = i.insert( () => S, ":first-child");
    return C.attr("class", "basic label-container"),
    h && t.look !== "handDrawn" && C.selectChildren("path").attr("style", h),
    r && t.look !== "handDrawn" && C.selectChildren("path").attr("style", r),
    C.attr("transform", `translate(0, ${c / 4})`),
    a.attr("transform", `translate(${-s / 2 + (t.padding ?? 0) - (o.x - (o.left ?? 0))}, ${-c / 4 + (t.padding ?? 0) - (o.y - (o.top ?? 0))})`),
    Tt(t, C),
    t.intersect = function(w) {
        return xt.polygon(t, b, w)
    }
    ,
    i
}
U(eW, "slopedRect");
async function tW(e, t) {
    const n = {
        rx: 0,
        ry: 0,
        labelPaddingX: t.labelPaddingX ?? (t?.padding || 0) * 2,
        labelPaddingY: (t?.padding || 0) * 1
    };
    return aS(e, t, n)
}
U(tW, "squareRect");
async function nW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = o.height + t.padding
      , s = o.width + a / 4 + t.padding
      , c = a / 2
      , {cssStyles: u} = t
      , f = Ct.svg(i)
      , h = wt(t, {});
    t.look !== "handDrawn" && (h.roughness = 0,
    h.fillStyle = "solid");
    const m = [{
        x: -s / 2 + c,
        y: -a / 2
    }, {
        x: s / 2 - c,
        y: -a / 2
    }, ...mg(-s / 2 + c, 0, c, 50, 90, 270), {
        x: s / 2 - c,
        y: a / 2
    }, ...mg(s / 2 - c, 0, c, 50, 270, 450)]
      , y = xn(m)
      , b = f.path(y, h)
      , v = i.insert( () => b, ":first-child");
    return v.attr("class", "basic label-container outer-path"),
    u && t.look !== "handDrawn" && v.selectChildren("path").attr("style", u),
    r && t.look !== "handDrawn" && v.selectChildren("path").attr("style", r),
    Tt(t, v),
    t.intersect = function(S) {
        return xt.polygon(t, m, S)
    }
    ,
    i
}
U(nW, "stadium");
async function rW(e, t) {
    return aS(e, t, {
        rx: 5,
        ry: 5
    })
}
U(rW, "state");
function iW(e, t, {config: {themeVariables: n}}) {
    const {labelStyles: r, nodeStyles: i} = kt(t);
    t.labelStyle = r;
    const {cssStyles: o} = t
      , {lineColor: a, stateBorder: s, nodeBorder: c} = n
      , u = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id)
      , f = Ct.svg(u)
      , h = wt(t, {});
    t.look !== "handDrawn" && (h.roughness = 0,
    h.fillStyle = "solid");
    const m = f.circle(0, 0, 14, {
        ...h,
        stroke: a,
        strokeWidth: 2
    })
      , y = s ?? c
      , b = f.circle(0, 0, 5, {
        ...h,
        fill: y,
        stroke: y,
        strokeWidth: 2,
        fillStyle: "solid"
    })
      , v = u.insert( () => m, ":first-child");
    return v.insert( () => b),
    o && v.selectAll("path").attr("style", o),
    i && v.selectAll("path").attr("style", i),
    Tt(t, v),
    t.intersect = function(S) {
        return xt.circle(t, 7, S)
    }
    ,
    u
}
U(iW, "stateEnd");
function oW(e, t, {config: {themeVariables: n}}) {
    const {lineColor: r} = n
      , i = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id);
    let o;
    if (t.look === "handDrawn") {
        const s = Ct.svg(i).circle(0, 0, 14, wPe(r));
        o = i.insert( () => s),
        o.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14)
    } else
        o = i.insert("circle", ":first-child"),
        o.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
    return Tt(t, o),
    t.intersect = function(a) {
        return xt.circle(t, 7, a)
    }
    ,
    i
}
U(oW, "stateStart");
async function aW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = (t?.padding || 0) / 2
      , s = o.width + t.padding
      , c = o.height + t.padding
      , u = -o.width / 2 - a
      , f = -o.height / 2 - a
      , h = [{
        x: 0,
        y: 0
    }, {
        x: s,
        y: 0
    }, {
        x: s,
        y: -c
    }, {
        x: 0,
        y: -c
    }, {
        x: 0,
        y: 0
    }, {
        x: -8,
        y: 0
    }, {
        x: s + 8,
        y: 0
    }, {
        x: s + 8,
        y: -c
    }, {
        x: -8,
        y: -c
    }, {
        x: -8,
        y: 0
    }];
    if (t.look === "handDrawn") {
        const m = Ct.svg(i)
          , y = wt(t, {})
          , b = m.rectangle(u - 8, f, s + 16, c, y)
          , v = m.line(u, f, u, f + c, y)
          , S = m.line(u + s, f, u + s, f + c, y);
        i.insert( () => v, ":first-child"),
        i.insert( () => S, ":first-child");
        const C = i.insert( () => b, ":first-child")
          , {cssStyles: w} = t;
        C.attr("class", "basic label-container").attr("style", Ri(w)),
        Tt(t, C)
    } else {
        const m = Bc(i, s, c, h);
        r && m.attr("style", r),
        Tt(t, m)
    }
    return t.intersect = function(m) {
        return xt.polygon(t, h, m)
    }
    ,
    i
}
U(aW, "subroutine");
async function sW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , s = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , c = -a / 2
      , u = -s / 2
      , f = .2 * s
      , h = .2 * s
      , {cssStyles: m} = t
      , y = Ct.svg(i)
      , b = wt(t, {})
      , v = [{
        x: c - f / 2,
        y: u
    }, {
        x: c + a + f / 2,
        y: u
    }, {
        x: c + a + f / 2,
        y: u + s
    }, {
        x: c - f / 2,
        y: u + s
    }]
      , S = [{
        x: c + a - f / 2,
        y: u + s
    }, {
        x: c + a + f / 2,
        y: u + s
    }, {
        x: c + a + f / 2,
        y: u + s - h
    }];
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const C = xn(v)
      , w = y.path(C, b)
      , k = xn(S)
      , T = y.path(k, {
        ...b,
        fillStyle: "solid"
    })
      , E = i.insert( () => T, ":first-child");
    return E.insert( () => w, ":first-child"),
    E.attr("class", "basic label-container"),
    m && t.look !== "handDrawn" && E.selectAll("path").attr("style", m),
    r && t.look !== "handDrawn" && E.selectAll("path").attr("style", r),
    Tt(t, E),
    t.intersect = function(P) {
        return xt.polygon(t, v, P)
    }
    ,
    i
}
U(sW, "taggedRect");
async function lW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , c = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , u = c / 4
      , f = .2 * s
      , h = .2 * c
      , m = c + u
      , {cssStyles: y} = t
      , b = Ct.svg(i)
      , v = wt(t, {});
    t.look !== "handDrawn" && (v.roughness = 0,
    v.fillStyle = "solid");
    const S = [{
        x: -s / 2 - s / 2 * .1,
        y: m / 2
    }, ..._c(-s / 2 - s / 2 * .1, m / 2, s / 2 + s / 2 * .1, m / 2, u, .8), {
        x: s / 2 + s / 2 * .1,
        y: -m / 2
    }, {
        x: -s / 2 - s / 2 * .1,
        y: -m / 2
    }]
      , C = -s / 2 + s / 2 * .1
      , w = -m / 2 - h * .4
      , k = [{
        x: C + s - f,
        y: (w + c) * 1.4
    }, {
        x: C + s,
        y: w + c - h
    }, {
        x: C + s,
        y: (w + c) * .9
    }, ..._c(C + s, (w + c) * 1.3, C + s - f, (w + c) * 1.5, -c * .03, .5)]
      , T = xn(S)
      , E = b.path(T, v)
      , P = xn(k)
      , D = b.path(P, {
        ...v,
        fillStyle: "solid"
    })
      , $ = i.insert( () => D, ":first-child");
    return $.insert( () => E, ":first-child"),
    $.attr("class", "basic label-container"),
    y && t.look !== "handDrawn" && $.selectAll("path").attr("style", y),
    r && t.look !== "handDrawn" && $.selectAll("path").attr("style", r),
    $.attr("transform", `translate(0,${-u / 2})`),
    a.attr("transform", `translate(${-s / 2 + (t.padding ?? 0) - (o.x - (o.left ?? 0))},${-c / 2 + (t.padding ?? 0) - u / 2 - (o.y - (o.top ?? 0))})`),
    Tt(t, $),
    t.intersect = function(z) {
        return xt.polygon(t, S, z)
    }
    ,
    i
}
U(lW, "taggedWaveEdgedRectangle");
async function cW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = Math.max(o.width + t.padding, t?.width || 0)
      , s = Math.max(o.height + t.padding, t?.height || 0)
      , c = -a / 2
      , u = -s / 2
      , f = i.insert("rect", ":first-child");
    return f.attr("class", "text").attr("style", r).attr("rx", 0).attr("ry", 0).attr("x", c).attr("y", u).attr("width", a).attr("height", s),
    Tt(t, f),
    t.intersect = function(h) {
        return xt.rect(t, h)
    }
    ,
    i
}
U(cW, "text");
var c$e = U( (e, t, n, r, i, o) => `M${e},${t}
    a${i},${o} 0,0,1 0,${-r}
    l${n},0
    a${i},${o} 0,0,1 0,${r}
    M${n},${-r}
    a${i},${o} 0,0,0 0,${r}
    l${-n},0`, "createCylinderPathD")
  , u$e = U( (e, t, n, r, i, o) => [`M${e},${t}`, `M${e + n},${t}`, `a${i},${o} 0,0,0 0,${-r}`, `l${-n},0`, `a${i},${o} 0,0,0 0,${r}`, `l${n},0`].join(" "), "createOuterCylinderPathD")
  , d$e = U( (e, t, n, r, i, o) => [`M${e + n / 2},${-r / 2}`, `a${i},${o} 0,0,0 0,${r}`].join(" "), "createInnerCylinderPathD");
async function uW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a, halfPadding: s} = await Vt(e, t, jt(t))
      , c = t.look === "neo" ? s * 2 : s
      , u = o.height + c
      , f = u / 2
      , h = f / (2.5 + u / 50)
      , m = o.width + h + c
      , {cssStyles: y} = t;
    let b;
    if (t.look === "handDrawn") {
        const v = Ct.svg(i)
          , S = u$e(0, 0, m, u, h, f)
          , C = d$e(0, 0, m, u, h, f)
          , w = v.path(S, wt(t, {}))
          , k = v.path(C, wt(t, {
            fill: "none"
        }));
        b = i.insert( () => k, ":first-child"),
        b = i.insert( () => w, ":first-child"),
        b.attr("class", "basic label-container"),
        y && b.attr("style", y)
    } else {
        const v = c$e(0, 0, m, u, h, f);
        b = i.insert("path", ":first-child").attr("d", v).attr("class", "basic label-container").attr("style", Ri(y)).attr("style", r),
        b.attr("class", "basic label-container"),
        y && b.selectAll("path").attr("style", y),
        r && b.selectAll("path").attr("style", r)
    }
    return b.attr("label-offset-x", h),
    b.attr("transform", `translate(${-m / 2}, ${u / 2} )`),
    a.attr("transform", `translate(${-(o.width / 2) - h - (o.x - (o.left ?? 0))}, ${-(o.height / 2) - (o.y - (o.top ?? 0))})`),
    Tt(t, b),
    t.intersect = function(v) {
        const S = xt.rect(t, v)
          , C = S.y - (t.y ?? 0);
        if (f != 0 && (Math.abs(C) < (t.height ?? 0) / 2 || Math.abs(C) == (t.height ?? 0) / 2 && Math.abs(S.x - (t.x ?? 0)) > (t.width ?? 0) / 2 - h)) {
            let w = h * h * (1 - C * C / (f * f));
            w != 0 && (w = Math.sqrt(Math.abs(w))),
            w = h - w,
            v.x - (t.x ?? 0) > 0 && (w = -w),
            S.x += w
        }
        return S
    }
    ,
    i
}
U(uW, "tiltedCylinder");
async function dW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = o.width + t.padding
      , s = o.height + t.padding
      , c = [{
        x: -3 * s / 6,
        y: 0
    }, {
        x: a + 3 * s / 6,
        y: 0
    }, {
        x: a,
        y: -s
    }, {
        x: 0,
        y: -s
    }];
    let u;
    const {cssStyles: f} = t;
    if (t.look === "handDrawn") {
        const h = Ct.svg(i)
          , m = wt(t, {})
          , y = xn(c)
          , b = h.path(y, m);
        u = i.insert( () => b, ":first-child").attr("transform", `translate(${-a / 2}, ${s / 2})`),
        f && u.attr("style", f)
    } else
        u = Bc(i, a, s, c);
    return r && u.attr("style", r),
    t.width = a,
    t.height = s,
    Tt(t, u),
    t.intersect = function(h) {
        return xt.polygon(t, c, h)
    }
    ,
    i
}
U(dW, "trapezoid");
async function fW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = 60
      , s = 20
      , c = Math.max(a, o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , u = Math.max(s, o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , {cssStyles: f} = t
      , h = Ct.svg(i)
      , m = wt(t, {});
    t.look !== "handDrawn" && (m.roughness = 0,
    m.fillStyle = "solid");
    const y = [{
        x: -c / 2 * .8,
        y: -u / 2
    }, {
        x: c / 2 * .8,
        y: -u / 2
    }, {
        x: c / 2,
        y: -u / 2 * .6
    }, {
        x: c / 2,
        y: u / 2
    }, {
        x: -c / 2,
        y: u / 2
    }, {
        x: -c / 2,
        y: -u / 2 * .6
    }]
      , b = xn(y)
      , v = h.path(b, m)
      , S = i.insert( () => v, ":first-child");
    return S.attr("class", "basic label-container"),
    f && t.look !== "handDrawn" && S.selectChildren("path").attr("style", f),
    r && t.look !== "handDrawn" && S.selectChildren("path").attr("style", r),
    Tt(t, S),
    t.intersect = function(C) {
        return xt.polygon(t, y, C)
    }
    ,
    i
}
U(fW, "trapezoidalPentagon");
async function hW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = oi(Vn().flowchart?.htmlLabels)
      , c = o.width + (t.padding ?? 0)
      , u = c + o.height
      , f = c + o.height
      , h = [{
        x: 0,
        y: 0
    }, {
        x: f,
        y: 0
    }, {
        x: f / 2,
        y: -u
    }]
      , {cssStyles: m} = t
      , y = Ct.svg(i)
      , b = wt(t, {});
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const v = xn(h)
      , S = y.path(v, b)
      , C = i.insert( () => S, ":first-child").attr("transform", `translate(${-u / 2}, ${u / 2})`);
    return m && t.look !== "handDrawn" && C.selectChildren("path").attr("style", m),
    r && t.look !== "handDrawn" && C.selectChildren("path").attr("style", r),
    t.width = c,
    t.height = u,
    Tt(t, C),
    a.attr("transform", `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${u / 2 - (o.height + (t.padding ?? 0) / (s ? 2 : 1) - (o.y - (o.top ?? 0)))})`),
    t.intersect = function(w) {
        return Qe.info("Triangle intersect", t, h, w),
        xt.polygon(t, h, w)
    }
    ,
    i
}
U(hW, "triangle");
async function pW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , c = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , u = c / 8
      , f = c + u
      , {cssStyles: h} = t
      , y = 70 - s
      , b = y > 0 ? y / 2 : 0
      , v = Ct.svg(i)
      , S = wt(t, {});
    t.look !== "handDrawn" && (S.roughness = 0,
    S.fillStyle = "solid");
    const C = [{
        x: -s / 2 - b,
        y: f / 2
    }, ..._c(-s / 2 - b, f / 2, s / 2 + b, f / 2, u, .8), {
        x: s / 2 + b,
        y: -f / 2
    }, {
        x: -s / 2 - b,
        y: -f / 2
    }]
      , w = xn(C)
      , k = v.path(w, S)
      , T = i.insert( () => k, ":first-child");
    return T.attr("class", "basic label-container"),
    h && t.look !== "handDrawn" && T.selectAll("path").attr("style", h),
    r && t.look !== "handDrawn" && T.selectAll("path").attr("style", r),
    T.attr("transform", `translate(0,${-u / 2})`),
    a.attr("transform", `translate(${-s / 2 + (t.padding ?? 0) - (o.x - (o.left ?? 0))},${-c / 2 + (t.padding ?? 0) - u - (o.y - (o.top ?? 0))})`),
    Tt(t, T),
    t.intersect = function(E) {
        return xt.polygon(t, C, E)
    }
    ,
    i
}
U(pW, "waveEdgedRectangle");
async function mW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o} = await Vt(e, t, jt(t))
      , a = 100
      , s = 50
      , c = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , u = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , f = c / u;
    let h = c
      , m = u;
    h > m * f ? m = h / f : h = m * f,
    h = Math.max(h, a),
    m = Math.max(m, s);
    const y = Math.min(m * .2, m / 4)
      , b = m + y * 2
      , {cssStyles: v} = t
      , S = Ct.svg(i)
      , C = wt(t, {});
    t.look !== "handDrawn" && (C.roughness = 0,
    C.fillStyle = "solid");
    const w = [{
        x: -h / 2,
        y: b / 2
    }, ..._c(-h / 2, b / 2, h / 2, b / 2, y, 1), {
        x: h / 2,
        y: -b / 2
    }, ..._c(h / 2, -b / 2, -h / 2, -b / 2, y, -1)]
      , k = xn(w)
      , T = S.path(k, C)
      , E = i.insert( () => T, ":first-child");
    return E.attr("class", "basic label-container"),
    v && t.look !== "handDrawn" && E.selectAll("path").attr("style", v),
    r && t.look !== "handDrawn" && E.selectAll("path").attr("style", r),
    Tt(t, E),
    t.intersect = function(P) {
        return xt.polygon(t, w, P)
    }
    ,
    i
}
U(mW, "waveRectangle");
async function gW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, label: a} = await Vt(e, t, jt(t))
      , s = Math.max(o.width + (t.padding ?? 0) * 2, t?.width ?? 0)
      , c = Math.max(o.height + (t.padding ?? 0) * 2, t?.height ?? 0)
      , u = 5
      , f = -s / 2
      , h = -c / 2
      , {cssStyles: m} = t
      , y = Ct.svg(i)
      , b = wt(t, {})
      , v = [{
        x: f - u,
        y: h - u
    }, {
        x: f - u,
        y: h + c
    }, {
        x: f + s,
        y: h + c
    }, {
        x: f + s,
        y: h - u
    }]
      , S = `M${f - u},${h - u} L${f + s},${h - u} L${f + s},${h + c} L${f - u},${h + c} L${f - u},${h - u}
                M${f - u},${h} L${f + s},${h}
                M${f},${h - u} L${f},${h + c}`;
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const C = y.path(S, b)
      , w = i.insert( () => C, ":first-child");
    return w.attr("transform", `translate(${u / 2}, ${u / 2})`),
    w.attr("class", "basic label-container"),
    m && t.look !== "handDrawn" && w.selectAll("path").attr("style", m),
    r && t.look !== "handDrawn" && w.selectAll("path").attr("style", r),
    a.attr("transform", `translate(${-(o.width / 2) + u / 2 - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + u / 2 - (o.y - (o.top ?? 0))})`),
    Tt(t, w),
    t.intersect = function(k) {
        return xt.polygon(t, v, k)
    }
    ,
    i
}
U(gW, "windowPane");
async function KM(e, t) {
    const n = t;
    if (n.alias && (t.label = n.alias),
    t.look === "handDrawn") {
        const {themeVariables: Y} = Mi()
          , {background: W} = Y
          , te = {
            ...t,
            id: t.id + "-background",
            look: "default",
            cssStyles: ["stroke: none", `fill: ${W}`]
        };
        await KM(e, te)
    }
    const r = Mi();
    t.useHtmlLabels = r.htmlLabels;
    let i = r.er?.diagramPadding ?? 10
      , o = r.er?.entityPadding ?? 6;
    const {cssStyles: a} = t
      , {labelStyles: s, nodeStyles: c} = kt(t);
    if (n.attributes.length === 0 && t.label) {
        const Y = {
            rx: 0,
            ry: 0,
            labelPaddingX: i,
            labelPaddingY: i * 1.5
        };
        _l(t.label, r) + Y.labelPaddingX * 2 < r.er.minEntityWidth && (t.width = r.er.minEntityWidth);
        const W = await aS(e, t, Y);
        if (!oi(r.htmlLabels)) {
            const te = W.select("text")
              , K = te.node()?.getBBox();
            te.attr("transform", `translate(${-K.width / 2}, 0)`)
        }
        return W
    }
    r.htmlLabels || (i *= 1.25,
    o *= 1.25);
    let u = jt(t);
    u || (u = "node default");
    const f = e.insert("g").attr("class", u).attr("id", t.domId || t.id)
      , h = await uf(f, t.label ?? "", r, 0, 0, ["name"], s);
    h.height += o;
    let m = 0;
    const y = []
      , b = [];
    let v = 0
      , S = 0
      , C = 0
      , w = 0
      , k = !0
      , T = !0;
    for (const Y of n.attributes) {
        const W = await uf(f, Y.type, r, 0, m, ["attribute-type"], s);
        v = Math.max(v, W.width + i);
        const te = await uf(f, Y.name, r, 0, m, ["attribute-name"], s);
        S = Math.max(S, te.width + i);
        const K = await uf(f, Y.keys.join(), r, 0, m, ["attribute-keys"], s);
        C = Math.max(C, K.width + i);
        const ee = await uf(f, Y.comment, r, 0, m, ["attribute-comment"], s);
        w = Math.max(w, ee.width + i);
        const re = Math.max(W.height, te.height, K.height, ee.height) + o;
        b.push({
            yOffset: m,
            rowHeight: re
        }),
        m += re
    }
    let E = 4;
    C <= i && (k = !1,
    C = 0,
    E--),
    w <= i && (T = !1,
    w = 0,
    E--);
    const P = f.node().getBBox();
    if (h.width + i * 2 - (v + S + C + w) > 0) {
        const Y = h.width + i * 2 - (v + S + C + w);
        v += Y / E,
        S += Y / E,
        C > 0 && (C += Y / E),
        w > 0 && (w += Y / E)
    }
    const D = v + S + C + w
      , $ = Ct.svg(f)
      , z = wt(t, {});
    t.look !== "handDrawn" && (z.roughness = 0,
    z.fillStyle = "solid");
    let O = 0;
    b.length > 0 && (O = b.reduce( (Y, W) => Y + (W?.rowHeight ?? 0), 0));
    const I = Math.max(P.width + i * 2, t?.width || 0, D)
      , M = Math.max((O ?? 0) + h.height, t?.height || 0)
      , B = -I / 2
      , L = -M / 2;
    f.selectAll("g:not(:first-child)").each( (Y, W, te) => {
        const K = En(te[W])
          , ee = K.attr("transform");
        let re = 0
          , ie = 0;
        if (ee) {
            const oe = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(ee);
            oe && (re = parseFloat(oe[1]),
            ie = parseFloat(oe[2]),
            K.attr("class").includes("attribute-name") ? re += v : K.attr("class").includes("attribute-keys") ? re += v + S : K.attr("class").includes("attribute-comment") && (re += v + S + C))
        }
        K.attr("transform", `translate(${B + i / 2 + re}, ${ie + L + h.height + o / 2})`)
    }
    ),
    f.select(".name").attr("transform", "translate(" + -h.width / 2 + ", " + (L + o / 2) + ")");
    const F = $.rectangle(B, L, I, M, z)
      , j = f.insert( () => F, ":first-child").attr("style", a.join(""))
      , {themeVariables: N} = Mi()
      , {rowEven: H, rowOdd: Z, nodeBorder: q} = N;
    y.push(0);
    for (const [Y,W] of b.entries()) {
        const K = (Y + 1) % 2 === 0 && W.yOffset !== 0
          , ee = $.rectangle(B, h.height + L + W?.yOffset, I, W?.rowHeight, {
            ...z,
            fill: K ? H : Z,
            stroke: q
        });
        f.insert( () => ee, "g.label").attr("style", a.join("")).attr("class", `row-rect-${K ? "even" : "odd"}`)
    }
    let V = $.line(B, h.height + L, I + B, h.height + L, z);
    f.insert( () => V).attr("class", "divider"),
    V = $.line(v + B, h.height + L, v + B, M + L, z),
    f.insert( () => V).attr("class", "divider"),
    k && (V = $.line(v + S + B, h.height + L, v + S + B, M + L, z),
    f.insert( () => V).attr("class", "divider")),
    T && (V = $.line(v + S + C + B, h.height + L, v + S + C + B, M + L, z),
    f.insert( () => V).attr("class", "divider"));
    for (const Y of y)
        V = $.line(B, h.height + L + Y, I + B, h.height + L + Y, z),
        f.insert( () => V).attr("class", "divider");
    if (Tt(t, j),
    c && t.look !== "handDrawn") {
        const W = c.split(";")?.filter(te => te.includes("stroke"))?.map(te => `${te}`).join("; ");
        f.selectAll("path").attr("style", W ?? ""),
        f.selectAll(".row-rect-even path").attr("style", c)
    }
    return t.intersect = function(Y) {
        return xt.rect(t, Y)
    }
    ,
    f
}
U(KM, "erBox");
async function uf(e, t, n, r=0, i=0, o=[], a="") {
    const s = e.insert("g").attr("class", `label ${o.join(" ")}`).attr("transform", `translate(${r}, ${i})`).attr("style", a);
    t !== KB(t) && (t = KB(t),
    t = t.replaceAll("<", "&lt;").replaceAll(">", "&gt;"));
    const c = s.node().appendChild(await Lc(s, t, {
        width: _l(t, n) + 100,
        style: a,
        useHtmlLabels: n.htmlLabels
    }, n));
    if (t.includes("&lt;") || t.includes("&gt;")) {
        let f = c.children[0];
        for (f.textContent = f.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">"); f.childNodes[0]; )
            f = f.childNodes[0],
            f.textContent = f.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">")
    }
    let u = c.getBBox();
    if (oi(n.htmlLabels)) {
        const f = c.children[0];
        f.style.textAlign = "start";
        const h = En(c);
        u = f.getBoundingClientRect(),
        h.attr("width", u.width),
        h.attr("height", u.height)
    }
    return u
}
U(uf, "addText");
async function yW(e, t, n, r, i=n.class.padding ?? 12) {
    const o = r ? 0 : 3
      , a = e.insert("g").attr("class", jt(t)).attr("id", t.domId || t.id);
    let s = null
      , c = null
      , u = null
      , f = null
      , h = 0
      , m = 0
      , y = 0;
    if (s = a.insert("g").attr("class", "annotation-group text"),
    t.annotations.length > 0) {
        const w = t.annotations[0];
        await lm(s, {
            text: `${w}`
        }, 0),
        h = s.node().getBBox().height
    }
    c = a.insert("g").attr("class", "label-group text"),
    await lm(c, t, 0, ["font-weight: bolder"]);
    const b = c.node().getBBox();
    m = b.height,
    u = a.insert("g").attr("class", "members-group text");
    let v = 0;
    for (const w of t.members) {
        const k = await lm(u, w, v, [w.parseClassifier()]);
        v += k + o
    }
    y = u.node().getBBox().height,
    y <= 0 && (y = i / 2),
    f = a.insert("g").attr("class", "methods-group text");
    let S = 0;
    for (const w of t.methods) {
        const k = await lm(f, w, S, [w.parseClassifier()]);
        S += k + o
    }
    let C = a.node().getBBox();
    if (s !== null) {
        const w = s.node().getBBox();
        s.attr("transform", `translate(${-w.width / 2})`)
    }
    return c.attr("transform", `translate(${-b.width / 2}, ${h})`),
    C = a.node().getBBox(),
    u.attr("transform", `translate(0, ${h + m + i * 2})`),
    C = a.node().getBBox(),
    f.attr("transform", `translate(0, ${h + m + (y ? y + i * 4 : i * 2)})`),
    C = a.node().getBBox(),
    {
        shapeSvg: a,
        bbox: C
    }
}
U(yW, "textHelper");
async function lm(e, t, n, r=[]) {
    const i = e.insert("g").attr("class", "label").attr("style", r.join("; "))
      , o = Mi();
    let a = "useHtmlLabels"in t ? t.useHtmlLabels : oi(o.htmlLabels) ?? !0
      , s = "";
    "text"in t ? s = t.text : s = t.label,
    !a && s.startsWith("\\") && (s = s.substring(1)),
    eh(s) && (a = !0);
    const c = await Lc(i, sM(cd(s)), {
        width: _l(s, o) + 50,
        classes: "markdown-node-label",
        useHtmlLabels: a
    }, o);
    let u, f = 1;
    if (a) {
        const h = c.children[0]
          , m = En(c);
        f = h.innerHTML.split("<br>").length,
        h.innerHTML.includes("</math>") && (f += h.innerHTML.split("<mrow>").length - 1);
        const y = h.getElementsByTagName("img");
        if (y) {
            const b = s.replace(/<img[^>]*>/g, "").trim() === "";
            await Promise.all([...y].map(v => new Promise(S => {
                function C() {
                    if (v.style.display = "flex",
                    v.style.flexDirection = "column",
                    b) {
                        const w = o.fontSize?.toString() ?? window.getComputedStyle(document.body).fontSize
                          , T = parseInt(w, 10) * 5 + "px";
                        v.style.minWidth = T,
                        v.style.maxWidth = T
                    } else
                        v.style.width = "100%";
                    S(v)
                }
                U(C, "setupImage"),
                setTimeout( () => {
                    v.complete && C()
                }
                ),
                v.addEventListener("error", C),
                v.addEventListener("load", C)
            }
            )))
        }
        u = h.getBoundingClientRect(),
        m.attr("width", u.width),
        m.attr("height", u.height)
    } else {
        r.includes("font-weight: bolder") && En(c).selectAll("tspan").attr("font-weight", ""),
        f = c.children.length;
        const h = c.children[0];
        (c.textContent === "" || c.textContent.includes("&gt")) && (h.textContent = s[0] + s.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim(),
        s[1] === " " && (h.textContent = h.textContent[0] + " " + h.textContent.substring(1))),
        h.textContent === "undefined" && (h.textContent = ""),
        u = c.getBBox()
    }
    return i.attr("transform", "translate(0," + (-u.height / (2 * f) + n) + ")"),
    u.height
}
U(lm, "addText");
async function bW(e, t) {
    const n = Vn()
      , r = n.class.padding ?? 12
      , i = r
      , o = t.useHtmlLabels ?? oi(n.htmlLabels) ?? !0
      , a = t;
    a.annotations = a.annotations ?? [],
    a.members = a.members ?? [],
    a.methods = a.methods ?? [];
    const {shapeSvg: s, bbox: c} = await yW(e, t, n, o, i)
      , {labelStyles: u, nodeStyles: f} = kt(t);
    t.labelStyle = u,
    t.cssStyles = a.styles || "";
    const h = a.styles?.join(";") || f || "";
    t.cssStyles || (t.cssStyles = h.replaceAll("!important", "").split(";"));
    const m = a.members.length === 0 && a.methods.length === 0 && !n.class?.hideEmptyMembersBox
      , y = Ct.svg(s)
      , b = wt(t, {});
    t.look !== "handDrawn" && (b.roughness = 0,
    b.fillStyle = "solid");
    const v = c.width;
    let S = c.height;
    a.members.length === 0 && a.methods.length === 0 ? S += i : a.members.length > 0 && a.methods.length === 0 && (S += i * 2);
    const C = -v / 2
      , w = -S / 2
      , k = y.rectangle(C - r, w - r - (m ? r : a.members.length === 0 && a.methods.length === 0 ? -r / 2 : 0), v + 2 * r, S + 2 * r + (m ? r * 2 : a.members.length === 0 && a.methods.length === 0 ? -r : 0), b)
      , T = s.insert( () => k, ":first-child");
    T.attr("class", "basic label-container");
    const E = T.node().getBBox();
    s.selectAll(".text").each( (z, O, I) => {
        const M = En(I[O])
          , B = M.attr("transform");
        let L = 0;
        if (B) {
            const H = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(B);
            H && (L = parseFloat(H[2]))
        }
        let F = L + w + r - (m ? r : a.members.length === 0 && a.methods.length === 0 ? -r / 2 : 0);
        o || (F -= 4);
        let j = C;
        (M.attr("class").includes("label-group") || M.attr("class").includes("annotation-group")) && (j = -M.node()?.getBBox().width / 2 || 0,
        s.selectAll("text").each(function(N, H, Z) {
            window.getComputedStyle(Z[H]).textAnchor === "middle" && (j = 0)
        })),
        M.attr("transform", `translate(${j}, ${F})`)
    }
    );
    const P = s.select(".annotation-group").node().getBBox().height - (m ? r / 2 : 0) || 0
      , D = s.select(".label-group").node().getBBox().height - (m ? r / 2 : 0) || 0
      , $ = s.select(".members-group").node().getBBox().height - (m ? r / 2 : 0) || 0;
    if (a.members.length > 0 || a.methods.length > 0 || m) {
        const z = y.line(E.x, P + D + w + r, E.x + E.width, P + D + w + r, b);
        s.insert( () => z).attr("class", "divider").attr("style", h)
    }
    if (m || a.members.length > 0 || a.methods.length > 0) {
        const z = y.line(E.x, P + D + $ + w + i * 2 + r, E.x + E.width, P + D + $ + w + r + i * 2, b);
        s.insert( () => z).attr("class", "divider").attr("style", h)
    }
    if (a.look !== "handDrawn" && s.selectAll("path").attr("style", h),
    T.select(":nth-child(2)").attr("style", h),
    s.selectAll(".divider").select("path").attr("style", h),
    t.labelStyle ? s.selectAll("span").attr("style", t.labelStyle) : s.selectAll("span").attr("style", h),
    !o) {
        const z = RegExp(/color\s*:\s*([^;]*)/)
          , O = z.exec(h);
        if (O) {
            const I = O[0].replace("color", "fill");
            s.selectAll("tspan").attr("style", I)
        } else if (u) {
            const I = z.exec(u);
            if (I) {
                const M = I[0].replace("color", "fill");
                s.selectAll("tspan").attr("style", M)
            }
        }
    }
    return Tt(t, T),
    t.intersect = function(z) {
        return xt.rect(t, z)
    }
    ,
    s
}
U(bW, "classBox");
async function xW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const i = t
      , o = t
      , a = 20
      , s = 20
      , c = "verifyMethod"in t
      , u = jt(t)
      , f = e.insert("g").attr("class", u).attr("id", t.domId ?? t.id);
    let h;
    c ? h = await ps(f, `&lt;&lt;${i.type}&gt;&gt;`, 0, t.labelStyle) : h = await ps(f, "&lt;&lt;Element&gt;&gt;", 0, t.labelStyle);
    let m = h;
    const y = await ps(f, i.name, m, t.labelStyle + "; font-weight: bold;");
    if (m += y + s,
    c) {
        const P = await ps(f, `${i.requirementId ? `ID: ${i.requirementId}` : ""}`, m, t.labelStyle);
        m += P;
        const D = await ps(f, `${i.text ? `Text: ${i.text}` : ""}`, m, t.labelStyle);
        m += D;
        const $ = await ps(f, `${i.risk ? `Risk: ${i.risk}` : ""}`, m, t.labelStyle);
        m += $,
        await ps(f, `${i.verifyMethod ? `Verification: ${i.verifyMethod}` : ""}`, m, t.labelStyle)
    } else {
        const P = await ps(f, `${o.type ? `Type: ${o.type}` : ""}`, m, t.labelStyle);
        m += P,
        await ps(f, `${o.docRef ? `Doc Ref: ${o.docRef}` : ""}`, m, t.labelStyle)
    }
    const b = (f.node()?.getBBox().width ?? 200) + a
      , v = (f.node()?.getBBox().height ?? 200) + a
      , S = -b / 2
      , C = -v / 2
      , w = Ct.svg(f)
      , k = wt(t, {});
    t.look !== "handDrawn" && (k.roughness = 0,
    k.fillStyle = "solid");
    const T = w.rectangle(S, C, b, v, k)
      , E = f.insert( () => T, ":first-child");
    if (E.attr("class", "basic label-container").attr("style", r),
    f.selectAll(".label").each( (P, D, $) => {
        const z = En($[D])
          , O = z.attr("transform");
        let I = 0
          , M = 0;
        if (O) {
            const j = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(O);
            j && (I = parseFloat(j[1]),
            M = parseFloat(j[2]))
        }
        const B = M - v / 2;
        let L = S + a / 2;
        (D === 0 || D === 1) && (L = I),
        z.attr("transform", `translate(${L}, ${B + a})`)
    }
    ),
    m > h + y + s) {
        const P = w.line(S, C + h + y + s, S + b, C + h + y + s, k);
        f.insert( () => P).attr("style", r)
    }
    return Tt(t, E),
    t.intersect = function(P) {
        return xt.rect(t, P)
    }
    ,
    f
}
U(xW, "requirementBox");
async function ps(e, t, n, r="") {
    if (t === "")
        return 0;
    const i = e.insert("g").attr("class", "label").attr("style", r)
      , o = Vn()
      , a = o.htmlLabels ?? !0
      , s = await Lc(i, sM(cd(t)), {
        width: _l(t, o) + 50,
        classes: "markdown-node-label",
        useHtmlLabels: a,
        style: r
    }, o);
    let c;
    if (a) {
        const u = s.children[0]
          , f = En(s);
        c = u.getBoundingClientRect(),
        f.attr("width", c.width),
        f.attr("height", c.height)
    } else {
        const u = s.children[0];
        for (const f of u.children)
            f.textContent = f.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<"),
            r && f.setAttribute("style", r);
        c = s.getBBox(),
        c.height += 6
    }
    return i.attr("transform", `translate(${-c.width / 2},${-c.height / 2 + n})`),
    c.height
}
U(ps, "addText");
var f$e = U(e => {
    switch (e) {
    case "Very High":
        return "red";
    case "High":
        return "orange";
    case "Medium":
        return null;
    case "Low":
        return "blue";
    case "Very Low":
        return "lightblue"
    }
}
, "colorFromPriority");
async function vW(e, t, {config: n}) {
    const {labelStyles: r, nodeStyles: i} = kt(t);
    t.labelStyle = r || "";
    const o = 10
      , a = t.width;
    t.width = (t.width ?? 200) - 10;
    const {shapeSvg: s, bbox: c, label: u} = await Vt(e, t, jt(t))
      , f = t.padding || 10;
    let h = "", m;
    "ticket"in t && t.ticket && n?.kanban?.ticketBaseUrl && (h = n?.kanban?.ticketBaseUrl.replace("#TICKET#", t.ticket),
    m = s.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", h).attr("target", "_blank"));
    const y = {
        useHtmlLabels: t.useHtmlLabels,
        labelStyle: t.labelStyle || "",
        width: t.width,
        img: t.img,
        padding: t.padding || 8,
        centerLabel: !1
    };
    let b, v;
    m ? {label: b, bbox: v} = await u2(m, "ticket"in t && t.ticket || "", y) : {label: b, bbox: v} = await u2(s, "ticket"in t && t.ticket || "", y);
    const {label: S, bbox: C} = await u2(s, "assigned"in t && t.assigned || "", y);
    t.width = a;
    const w = 10
      , k = t?.width || 0
      , T = Math.max(v.height, C.height) / 2
      , E = Math.max(c.height + w * 2, t?.height || 0) + T
      , P = -k / 2
      , D = -E / 2;
    u.attr("transform", "translate(" + (f - k / 2) + ", " + (-T - c.height / 2) + ")"),
    b.attr("transform", "translate(" + (f - k / 2) + ", " + (-T + c.height / 2) + ")"),
    S.attr("transform", "translate(" + (f + k / 2 - C.width - 2 * o) + ", " + (-T + c.height / 2) + ")");
    let $;
    const {rx: z, ry: O} = t
      , {cssStyles: I} = t;
    if (t.look === "handDrawn") {
        const M = Ct.svg(s)
          , B = wt(t, {})
          , L = z || O ? M.path(jc(P, D, k, E, z || 0), B) : M.rectangle(P, D, k, E, B);
        $ = s.insert( () => L, ":first-child"),
        $.attr("class", "basic label-container").attr("style", I || null)
    } else {
        $ = s.insert("rect", ":first-child"),
        $.attr("class", "basic label-container __APA__").attr("style", i).attr("rx", z ?? 5).attr("ry", O ?? 5).attr("x", P).attr("y", D).attr("width", k).attr("height", E);
        const M = "priority"in t && t.priority;
        if (M) {
            const B = s.append("line")
              , L = P + 2
              , F = D + Math.floor((z ?? 0) / 2)
              , j = D + E - Math.floor((z ?? 0) / 2);
            B.attr("x1", L).attr("y1", F).attr("x2", L).attr("y2", j).attr("stroke-width", "4").attr("stroke", f$e(M))
        }
    }
    return Tt(t, $),
    t.height = E,
    t.intersect = function(M) {
        return xt.rect(t, M)
    }
    ,
    s
}
U(vW, "kanbanItem");
async function SW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, halfPadding: a, label: s} = await Vt(e, t, jt(t))
      , c = o.width + 10 * a
      , u = o.height + 8 * a
      , f = .15 * c
      , {cssStyles: h} = t
      , m = o.width + 20
      , y = o.height + 20
      , b = Math.max(c, m)
      , v = Math.max(u, y);
    s.attr("transform", `translate(${-o.width / 2}, ${-o.height / 2})`);
    let S;
    const C = `M0 0 
    a${f},${f} 1 0,0 ${b * .25},${-1 * v * .1}
    a${f},${f} 1 0,0 ${b * .25},0
    a${f},${f} 1 0,0 ${b * .25},0
    a${f},${f} 1 0,0 ${b * .25},${v * .1}

    a${f},${f} 1 0,0 ${b * .15},${v * .33}
    a${f * .8},${f * .8} 1 0,0 0,${v * .34}
    a${f},${f} 1 0,0 ${-1 * b * .15},${v * .33}

    a${f},${f} 1 0,0 ${-1 * b * .25},${v * .15}
    a${f},${f} 1 0,0 ${-1 * b * .25},0
    a${f},${f} 1 0,0 ${-1 * b * .25},0
    a${f},${f} 1 0,0 ${-1 * b * .25},${-1 * v * .15}

    a${f},${f} 1 0,0 ${-1 * b * .1},${-1 * v * .33}
    a${f * .8},${f * .8} 1 0,0 0,${-1 * v * .34}
    a${f},${f} 1 0,0 ${b * .1},${-1 * v * .33}
  H0 V0 Z`;
    if (t.look === "handDrawn") {
        const w = Ct.svg(i)
          , k = wt(t, {})
          , T = w.path(C, k);
        S = i.insert( () => T, ":first-child"),
        S.attr("class", "basic label-container").attr("style", Ri(h))
    } else
        S = i.insert("path", ":first-child").attr("class", "basic label-container").attr("style", r).attr("d", C);
    return S.attr("transform", `translate(${-b / 2}, ${-v / 2})`),
    Tt(t, S),
    t.calcIntersect = function(w, k) {
        return xt.rect(w, k)
    }
    ,
    t.intersect = function(w) {
        return Qe.info("Bang intersect", t, w),
        xt.rect(t, w)
    }
    ,
    i
}
U(SW, "bang");
async function CW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, halfPadding: a, label: s} = await Vt(e, t, jt(t))
      , c = o.width + 2 * a
      , u = o.height + 2 * a
      , f = .15 * c
      , h = .25 * c
      , m = .35 * c
      , y = .2 * c
      , {cssStyles: b} = t;
    let v;
    const S = `M0 0 
    a${f},${f} 0 0,1 ${c * .25},${-1 * c * .1}
    a${m},${m} 1 0,1 ${c * .4},${-1 * c * .1}
    a${h},${h} 1 0,1 ${c * .35},${c * .2}

    a${f},${f} 1 0,1 ${c * .15},${u * .35}
    a${y},${y} 1 0,1 ${-1 * c * .15},${u * .65}

    a${h},${f} 1 0,1 ${-1 * c * .25},${c * .15}
    a${m},${m} 1 0,1 ${-1 * c * .5},0
    a${f},${f} 1 0,1 ${-1 * c * .25},${-1 * c * .15}

    a${f},${f} 1 0,1 ${-1 * c * .1},${-1 * u * .35}
    a${y},${y} 1 0,1 ${c * .1},${-1 * u * .65}
  H0 V0 Z`;
    if (t.look === "handDrawn") {
        const C = Ct.svg(i)
          , w = wt(t, {})
          , k = C.path(S, w);
        v = i.insert( () => k, ":first-child"),
        v.attr("class", "basic label-container").attr("style", Ri(b))
    } else
        v = i.insert("path", ":first-child").attr("class", "basic label-container").attr("style", r).attr("d", S);
    return s.attr("transform", `translate(${-o.width / 2}, ${-o.height / 2})`),
    v.attr("transform", `translate(${-c / 2}, ${-u / 2})`),
    Tt(t, v),
    t.calcIntersect = function(C, w) {
        return xt.rect(C, w)
    }
    ,
    t.intersect = function(C) {
        return Qe.info("Cloud intersect", t, C),
        xt.rect(t, C)
    }
    ,
    i
}
U(CW, "cloud");
async function wW(e, t) {
    const {labelStyles: n, nodeStyles: r} = kt(t);
    t.labelStyle = n;
    const {shapeSvg: i, bbox: o, halfPadding: a, label: s} = await Vt(e, t, jt(t))
      , c = o.width + 8 * a
      , u = o.height + 2 * a
      , f = 5
      , h = `
    M${-c / 2} ${u / 2 - f}
    v${-u + 2 * f}
    q0,-${f} ${f},-${f}
    h${c - 2 * f}
    q${f},0 ${f},${f}
    v${u - 2 * f}
    q0,${f} -${f},${f}
    h${-c + 2 * f}
    q-${f},0 -${f},-${f}
    Z
  `
      , m = i.append("path").attr("id", "node-" + t.id).attr("class", "node-bkg node-" + t.type).attr("style", r).attr("d", h);
    return i.append("line").attr("class", "node-line-").attr("x1", -c / 2).attr("y1", u / 2).attr("x2", c / 2).attr("y2", u / 2),
    s.attr("transform", `translate(${-o.width / 2}, ${-o.height / 2})`),
    i.append( () => s.node()),
    Tt(t, m),
    t.calcIntersect = function(y, b) {
        return xt.rect(y, b)
    }
    ,
    t.intersect = function(y) {
        return xt.rect(t, y)
    }
    ,
    i
}
U(wW, "defaultMindmapNode");
async function kW(e, t) {
    const n = {
        padding: t.padding ?? 0
    };
    return QM(e, t, n)
}
U(kW, "mindmapCircle");
var h$e = [{
    semanticName: "Process",
    name: "Rectangle",
    shortName: "rect",
    description: "Standard process shape",
    aliases: ["proc", "process", "rectangle"],
    internalAliases: ["squareRect"],
    handler: tW
}, {
    semanticName: "Event",
    name: "Rounded Rectangle",
    shortName: "rounded",
    description: "Represents an event",
    aliases: ["event"],
    internalAliases: ["roundedRect"],
    handler: Xq
}, {
    semanticName: "Terminal Point",
    name: "Stadium",
    shortName: "stadium",
    description: "Terminal point",
    aliases: ["terminal", "pill"],
    handler: nW
}, {
    semanticName: "Subprocess",
    name: "Framed Rectangle",
    shortName: "fr-rect",
    description: "Subprocess",
    aliases: ["subprocess", "subproc", "framed-rectangle", "subroutine"],
    handler: aW
}, {
    semanticName: "Database",
    name: "Cylinder",
    shortName: "cyl",
    description: "Database storage",
    aliases: ["db", "database", "cylinder"],
    handler: Tq
}, {
    semanticName: "Start",
    name: "Circle",
    shortName: "circle",
    description: "Starting point",
    aliases: ["circ"],
    handler: QM
}, {
    semanticName: "Bang",
    name: "Bang",
    shortName: "bang",
    description: "Bang",
    aliases: ["bang"],
    handler: SW
}, {
    semanticName: "Cloud",
    name: "Cloud",
    shortName: "cloud",
    description: "cloud",
    aliases: ["cloud"],
    handler: CW
}, {
    semanticName: "Decision",
    name: "Diamond",
    shortName: "diam",
    description: "Decision-making step",
    aliases: ["decision", "diamond", "question"],
    handler: Zq
}, {
    semanticName: "Prepare Conditional",
    name: "Hexagon",
    shortName: "hex",
    description: "Preparation or condition step",
    aliases: ["hexagon", "prepare"],
    handler: Dq
}, {
    semanticName: "Data Input/Output",
    name: "Lean Right",
    shortName: "lean-r",
    description: "Represents input or output",
    aliases: ["lean-right", "in-out"],
    internalAliases: ["lean_right"],
    handler: Uq
}, {
    semanticName: "Data Input/Output",
    name: "Lean Left",
    shortName: "lean-l",
    description: "Represents output or input",
    aliases: ["lean-left", "out-in"],
    internalAliases: ["lean_left"],
    handler: Nq
}, {
    semanticName: "Priority Action",
    name: "Trapezoid Base Bottom",
    shortName: "trap-b",
    description: "Priority action",
    aliases: ["priority", "trapezoid-bottom", "trapezoid"],
    handler: dW
}, {
    semanticName: "Manual Operation",
    name: "Trapezoid Base Top",
    shortName: "trap-t",
    description: "Represents a manual task",
    aliases: ["manual", "trapezoid-top", "inv-trapezoid"],
    internalAliases: ["inv_trapezoid"],
    handler: zq
}, {
    semanticName: "Stop",
    name: "Double Circle",
    shortName: "dbl-circ",
    description: "Represents a stop point",
    aliases: ["double-circle"],
    internalAliases: ["doublecircle"],
    handler: Eq
}, {
    semanticName: "Text Block",
    name: "Text Block",
    shortName: "text",
    description: "Text block",
    handler: cW
}, {
    semanticName: "Card",
    name: "Notched Rectangle",
    shortName: "notch-rect",
    description: "Represents a card",
    aliases: ["card", "notched-rectangle"],
    handler: yq
}, {
    semanticName: "Lined/Shaded Process",
    name: "Lined Rectangle",
    shortName: "lin-rect",
    description: "Lined process shape",
    aliases: ["lined-rectangle", "lined-process", "lin-proc", "shaded-process"],
    handler: Jq
}, {
    semanticName: "Start",
    name: "Small Circle",
    shortName: "sm-circ",
    description: "Small starting point",
    aliases: ["start", "small-circle"],
    internalAliases: ["stateStart"],
    handler: oW
}, {
    semanticName: "Stop",
    name: "Framed Circle",
    shortName: "fr-circ",
    description: "Stop point",
    aliases: ["stop", "framed-circle"],
    internalAliases: ["stateEnd"],
    handler: iW
}, {
    semanticName: "Fork/Join",
    name: "Filled Rectangle",
    shortName: "fork",
    description: "Fork or join in process flow",
    aliases: ["join"],
    internalAliases: ["forkJoin"],
    handler: Pq
}, {
    semanticName: "Collate",
    name: "Hourglass",
    shortName: "hourglass",
    description: "Represents a collate operation",
    aliases: ["hourglass", "collate"],
    handler: Oq
}, {
    semanticName: "Comment",
    name: "Curly Brace",
    shortName: "brace",
    description: "Adds a comment",
    aliases: ["comment", "brace-l"],
    handler: Sq
}, {
    semanticName: "Comment Right",
    name: "Curly Brace",
    shortName: "brace-r",
    description: "Adds a comment",
    handler: Cq
}, {
    semanticName: "Comment with braces on both sides",
    name: "Curly Braces",
    shortName: "braces",
    description: "Adds a comment",
    handler: wq
}, {
    semanticName: "Com Link",
    name: "Lightning Bolt",
    shortName: "bolt",
    description: "Communication link",
    aliases: ["com-link", "lightning-bolt"],
    handler: Vq
}, {
    semanticName: "Document",
    name: "Document",
    shortName: "doc",
    description: "Represents a document",
    aliases: ["doc", "document"],
    handler: pW
}, {
    semanticName: "Delay",
    name: "Half-Rounded Rectangle",
    shortName: "delay",
    description: "Represents a delay",
    aliases: ["half-rounded-rectangle"],
    handler: Rq
}, {
    semanticName: "Direct Access Storage",
    name: "Horizontal Cylinder",
    shortName: "h-cyl",
    description: "Direct access storage",
    aliases: ["das", "horizontal-cylinder"],
    handler: uW
}, {
    semanticName: "Disk Storage",
    name: "Lined Cylinder",
    shortName: "lin-cyl",
    description: "Disk storage",
    aliases: ["disk", "lined-cylinder"],
    handler: Hq
}, {
    semanticName: "Display",
    name: "Curved Trapezoid",
    shortName: "curv-trap",
    description: "Represents a display",
    aliases: ["curved-trapezoid", "display"],
    handler: kq
}, {
    semanticName: "Divided Process",
    name: "Divided Rectangle",
    shortName: "div-rect",
    description: "Divided process shape",
    aliases: ["div-proc", "divided-rectangle", "divided-process"],
    handler: _q
}, {
    semanticName: "Extract",
    name: "Triangle",
    shortName: "tri",
    description: "Extraction process",
    aliases: ["extract", "triangle"],
    handler: hW
}, {
    semanticName: "Internal Storage",
    name: "Window Pane",
    shortName: "win-pane",
    description: "Internal storage",
    aliases: ["internal-storage", "window-pane"],
    handler: gW
}, {
    semanticName: "Junction",
    name: "Filled Circle",
    shortName: "f-circ",
    description: "Junction point",
    aliases: ["junction", "filled-circle"],
    handler: Aq
}, {
    semanticName: "Loop Limit",
    name: "Trapezoidal Pentagon",
    shortName: "notch-pent",
    description: "Loop limit step",
    aliases: ["loop-limit", "notched-pentagon"],
    handler: fW
}, {
    semanticName: "Manual File",
    name: "Flipped Triangle",
    shortName: "flip-tri",
    description: "Manual file operation",
    aliases: ["manual-file", "flipped-triangle"],
    handler: Mq
}, {
    semanticName: "Manual Input",
    name: "Sloped Rectangle",
    shortName: "sl-rect",
    description: "Manual input step",
    aliases: ["manual-input", "sloped-rectangle"],
    handler: eW
}, {
    semanticName: "Multi-Document",
    name: "Stacked Document",
    shortName: "docs",
    description: "Multiple documents",
    aliases: ["documents", "st-doc", "stacked-document"],
    handler: Gq
}, {
    semanticName: "Multi-Process",
    name: "Stacked Rectangle",
    shortName: "st-rect",
    description: "Multiple processes",
    aliases: ["procs", "processes", "stacked-rectangle"],
    handler: Wq
}, {
    semanticName: "Stored Data",
    name: "Bow Tie Rectangle",
    shortName: "bow-rect",
    description: "Stored data",
    aliases: ["stored-data", "bow-tie-rectangle"],
    handler: gq
}, {
    semanticName: "Summary",
    name: "Crossed Circle",
    shortName: "cross-circ",
    description: "Summary",
    aliases: ["summary", "crossed-circle"],
    handler: vq
}, {
    semanticName: "Tagged Document",
    name: "Tagged Document",
    shortName: "tag-doc",
    description: "Tagged document",
    aliases: ["tag-doc", "tagged-document"],
    handler: lW
}, {
    semanticName: "Tagged Process",
    name: "Tagged Rectangle",
    shortName: "tag-rect",
    description: "Tagged process",
    aliases: ["tagged-rectangle", "tag-proc", "tagged-process"],
    handler: sW
}, {
    semanticName: "Paper Tape",
    name: "Flag",
    shortName: "flag",
    description: "Paper tape",
    aliases: ["paper-tape"],
    handler: mW
}, {
    semanticName: "Odd",
    name: "Odd",
    shortName: "odd",
    description: "Odd shape",
    internalAliases: ["rect_left_inv_arrow"],
    handler: Qq
}, {
    semanticName: "Lined Document",
    name: "Lined Document",
    shortName: "lin-doc",
    description: "Lined document",
    aliases: ["lined-document"],
    handler: qq
}]
  , p$e = U( () => {
    const t = [...Object.entries({
        state: rW,
        choice: bq,
        note: Yq,
        rectWithTitle: Kq,
        labelRect: Fq,
        iconSquare: jq,
        iconCircle: $q,
        icon: Iq,
        iconRounded: Lq,
        imageSquare: Bq,
        anchor: mq,
        kanbanItem: vW,
        mindmapCircle: kW,
        defaultMindmapNode: wW,
        classBox: bW,
        erBox: KM,
        requirementBox: xW
    }), ...h$e.flatMap(n => [n.shortName, ..."aliases"in n ? n.aliases : [], ..."internalAliases"in n ? n.internalAliases : []].map(i => [i, n.handler]))];
    return Object.fromEntries(t)
}
, "generateShapeMap")
  , TW = p$e();
function m$e(e) {
    return e in TW
}
U(m$e, "isValidShape");
var sS = new Map;
async function _W(e, t, n) {
    let r, i;
    t.shape === "rect" && (t.rx && t.ry ? t.shape = "roundedRect" : t.shape = "squareRect");
    const o = t.shape ? TW[t.shape] : void 0;
    if (!o)
        throw new Error(`No such shape: ${t.shape}. Please check your syntax.`);
    if (t.link) {
        let a;
        n.config.securityLevel === "sandbox" ? a = "_top" : t.linkTarget && (a = t.linkTarget || "_blank"),
        r = e.insert("svg:a").attr("xlink:href", t.link).attr("target", a ?? null),
        i = await o(r, t, n)
    } else
        i = await o(e, t, n),
        r = i;
    return t.tooltip && i.attr("title", t.tooltip),
    sS.set(t.id, r),
    t.haveCallback && r.attr("class", r.attr("class") + " clickable"),
    r
}
U(_W, "insertNode");
var dVe = U( (e, t) => {
    sS.set(t.id, e)
}
, "setNodeElem")
  , fVe = U( () => {
    sS.clear()
}
, "clear")
  , hVe = U(e => {
    const t = sS.get(e.id);
    Qe.trace("Transforming node", e.diff, e, "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")");
    const n = 8
      , r = e.diff || 0;
    return e.clusterNode ? t.attr("transform", "translate(" + (e.x + r - e.width / 2) + ", " + (e.y - e.height / 2 - n) + ")") : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"),
    r
}
, "positionNode")
  , g$e = U( (e, t, n, r, i, o) => {
    t.arrowTypeStart && o5(e, "start", t.arrowTypeStart, n, r, i, o),
    t.arrowTypeEnd && o5(e, "end", t.arrowTypeEnd, n, r, i, o)
}
, "addEdgeMarkers")
  , y$e = {
    arrow_cross: {
        type: "cross",
        fill: !1
    },
    arrow_point: {
        type: "point",
        fill: !0
    },
    arrow_barb: {
        type: "barb",
        fill: !0
    },
    arrow_circle: {
        type: "circle",
        fill: !1
    },
    aggregation: {
        type: "aggregation",
        fill: !1
    },
    extension: {
        type: "extension",
        fill: !1
    },
    composition: {
        type: "composition",
        fill: !0
    },
    dependency: {
        type: "dependency",
        fill: !0
    },
    lollipop: {
        type: "lollipop",
        fill: !1
    },
    only_one: {
        type: "onlyOne",
        fill: !1
    },
    zero_or_one: {
        type: "zeroOrOne",
        fill: !1
    },
    one_or_more: {
        type: "oneOrMore",
        fill: !1
    },
    zero_or_more: {
        type: "zeroOrMore",
        fill: !1
    },
    requirement_arrow: {
        type: "requirement_arrow",
        fill: !1
    },
    requirement_contains: {
        type: "requirement_contains",
        fill: !1
    }
}
  , o5 = U( (e, t, n, r, i, o, a) => {
    const s = y$e[n];
    if (!s) {
        Qe.warn(`Unknown arrow type: ${n}`);
        return
    }
    const c = s.type
      , f = `${i}_${o}-${c}${t === "start" ? "Start" : "End"}`;
    if (a && a.trim() !== "") {
        const h = a.replace(/[^\dA-Za-z]/g, "_")
          , m = `${f}_${h}`;
        if (!document.getElementById(m)) {
            const y = document.getElementById(f);
            if (y) {
                const b = y.cloneNode(!0);
                b.id = m,
                b.querySelectorAll("path, circle, line").forEach(S => {
                    S.setAttribute("stroke", a),
                    s.fill && S.setAttribute("fill", a)
                }
                ),
                y.parentNode?.appendChild(b)
            }
        }
        e.attr(`marker-${t}`, `url(${r}#${m})`)
    } else
        e.attr(`marker-${t}`, `url(${r}#${f})`)
}
, "addEdgeMarker")
  , Sv = new Map
  , bi = new Map
  , pVe = U( () => {
    Sv.clear(),
    bi.clear()
}
, "clear")
  , px = U(e => e ? e.reduce( (n, r) => n + ";" + r, "") : "", "getLabelStyles")
  , b$e = U(async (e, t) => {
    let n = oi(Vn().flowchart.htmlLabels);
    const {labelStyles: r} = kt(t);
    t.labelStyle = r;
    const i = await Lc(e, t.label, {
        style: t.labelStyle,
        useHtmlLabels: n,
        addSvgBackground: !0,
        isNode: !1
    });
    Qe.info("abc82", t, t.labelType);
    const o = e.insert("g").attr("class", "edgeLabel")
      , a = o.insert("g").attr("class", "label").attr("data-id", t.id);
    a.node().appendChild(i);
    let s = i.getBBox();
    if (n) {
        const u = i.children[0]
          , f = En(i);
        s = u.getBoundingClientRect(),
        f.attr("width", s.width),
        f.attr("height", s.height)
    }
    a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"),
    Sv.set(t.id, o),
    t.width = s.width,
    t.height = s.height;
    let c;
    if (t.startLabelLeft) {
        const u = await Au(t.startLabelLeft, px(t.labelStyle))
          , f = e.insert("g").attr("class", "edgeTerminals")
          , h = f.insert("g").attr("class", "inner");
        c = h.node().appendChild(u);
        const m = u.getBBox();
        h.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"),
        bi.get(t.id) || bi.set(t.id, {}),
        bi.get(t.id).startLeft = f,
        cm(c, t.startLabelLeft)
    }
    if (t.startLabelRight) {
        const u = await Au(t.startLabelRight, px(t.labelStyle))
          , f = e.insert("g").attr("class", "edgeTerminals")
          , h = f.insert("g").attr("class", "inner");
        c = f.node().appendChild(u),
        h.node().appendChild(u);
        const m = u.getBBox();
        h.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"),
        bi.get(t.id) || bi.set(t.id, {}),
        bi.get(t.id).startRight = f,
        cm(c, t.startLabelRight)
    }
    if (t.endLabelLeft) {
        const u = await Au(t.endLabelLeft, px(t.labelStyle))
          , f = e.insert("g").attr("class", "edgeTerminals")
          , h = f.insert("g").attr("class", "inner");
        c = h.node().appendChild(u);
        const m = u.getBBox();
        h.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"),
        f.node().appendChild(u),
        bi.get(t.id) || bi.set(t.id, {}),
        bi.get(t.id).endLeft = f,
        cm(c, t.endLabelLeft)
    }
    if (t.endLabelRight) {
        const u = await Au(t.endLabelRight, px(t.labelStyle))
          , f = e.insert("g").attr("class", "edgeTerminals")
          , h = f.insert("g").attr("class", "inner");
        c = h.node().appendChild(u);
        const m = u.getBBox();
        h.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"),
        f.node().appendChild(u),
        bi.get(t.id) || bi.set(t.id, {}),
        bi.get(t.id).endRight = f,
        cm(c, t.endLabelRight)
    }
    return i
}
, "insertEdgeLabel");
function cm(e, t) {
    Vn().flowchart.htmlLabels && e && (e.style.width = t.length * 9 + "px",
    e.style.height = "12px")
}
U(cm, "setTerminalWidth");
var x$e = U( (e, t) => {
    Qe.debug("Moving label abc88 ", e.id, e.label, Sv.get(e.id), t);
    let n = t.updatedPath ? t.updatedPath : t.originalPath;
    const r = Vn()
      , {subGraphTitleTotalMargin: i} = EM(r);
    if (e.label) {
        const o = Sv.get(e.id);
        let a = e.x
          , s = e.y;
        if (n) {
            const c = Na.calcLabelPosition(n);
            Qe.debug("Moving label " + e.label + " from (", a, ",", s, ") to (", c.x, ",", c.y, ") abc88"),
            t.updatedPath && (a = c.x,
            s = c.y)
        }
        o.attr("transform", `translate(${a}, ${s + i / 2})`)
    }
    if (e.startLabelLeft) {
        const o = bi.get(e.id).startLeft;
        let a = e.x
          , s = e.y;
        if (n) {
            const c = Na.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_left", n);
            a = c.x,
            s = c.y
        }
        o.attr("transform", `translate(${a}, ${s})`)
    }
    if (e.startLabelRight) {
        const o = bi.get(e.id).startRight;
        let a = e.x
          , s = e.y;
        if (n) {
            const c = Na.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_right", n);
            a = c.x,
            s = c.y
        }
        o.attr("transform", `translate(${a}, ${s})`)
    }
    if (e.endLabelLeft) {
        const o = bi.get(e.id).endLeft;
        let a = e.x
          , s = e.y;
        if (n) {
            const c = Na.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_left", n);
            a = c.x,
            s = c.y
        }
        o.attr("transform", `translate(${a}, ${s})`)
    }
    if (e.endLabelRight) {
        const o = bi.get(e.id).endRight;
        let a = e.x
          , s = e.y;
        if (n) {
            const c = Na.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_right", n);
            a = c.x,
            s = c.y
        }
        o.attr("transform", `translate(${a}, ${s})`)
    }
}
, "positionEdgeLabel")
  , v$e = U( (e, t) => {
    const n = e.x
      , r = e.y
      , i = Math.abs(t.x - n)
      , o = Math.abs(t.y - r)
      , a = e.width / 2
      , s = e.height / 2;
    return i >= a || o >= s
}
, "outsideNode")
  , S$e = U( (e, t, n) => {
    Qe.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(n)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
    const r = e.x
      , i = e.y
      , o = Math.abs(r - n.x)
      , a = e.width / 2;
    let s = n.x < t.x ? a - o : a + o;
    const c = e.height / 2
      , u = Math.abs(t.y - n.y)
      , f = Math.abs(t.x - n.x);
    if (Math.abs(i - t.y) * a > Math.abs(r - t.x) * c) {
        let h = n.y < t.y ? t.y - c - i : i - c - t.y;
        s = f * h / u;
        const m = {
            x: n.x < t.x ? n.x + s : n.x - f + s,
            y: n.y < t.y ? n.y + u - h : n.y - u + h
        };
        return s === 0 && (m.x = t.x,
        m.y = t.y),
        f === 0 && (m.x = t.x),
        u === 0 && (m.y = t.y),
        Qe.debug(`abc89 top/bottom calc, Q ${u}, q ${h}, R ${f}, r ${s}`, m),
        m
    } else {
        n.x < t.x ? s = t.x - a - r : s = r - a - t.x;
        let h = u * s / f
          , m = n.x < t.x ? n.x + f - s : n.x - f + s
          , y = n.y < t.y ? n.y + h : n.y - h;
        return Qe.debug(`sides calc abc89, Q ${u}, q ${h}, R ${f}, r ${s}`, {
            _x: m,
            _y: y
        }),
        s === 0 && (m = t.x,
        y = t.y),
        f === 0 && (m = t.x),
        u === 0 && (y = t.y),
        {
            x: m,
            y
        }
    }
}
, "intersection")
  , a5 = U( (e, t) => {
    Qe.warn("abc88 cutPathAtIntersect", e, t);
    let n = []
      , r = e[0]
      , i = !1;
    return e.forEach(o => {
        if (Qe.info("abc88 checking point", o, t),
        !v$e(t, o) && !i) {
            const a = S$e(t, r, o);
            Qe.debug("abc88 inside", o, r, a),
            Qe.debug("abc88 intersection", a, t);
            let s = !1;
            n.forEach(c => {
                s = s || c.x === a.x && c.y === a.y
            }
            ),
            n.some(c => c.x === a.x && c.y === a.y) ? Qe.warn("abc88 no intersect", a, n) : n.push(a),
            i = !0
        } else
            Qe.warn("abc88 outside", o, r),
            r = o,
            i || n.push(o)
    }
    ),
    Qe.debug("returning points", n),
    n
}
, "cutPathAtIntersect");
function EW(e) {
    const t = []
      , n = [];
    for (let r = 1; r < e.length - 1; r++) {
        const i = e[r - 1]
          , o = e[r]
          , a = e[r + 1];
        (i.x === o.x && o.y === a.y && Math.abs(o.x - a.x) > 5 && Math.abs(o.y - i.y) > 5 || i.y === o.y && o.x === a.x && Math.abs(o.x - i.x) > 5 && Math.abs(o.y - a.y) > 5) && (t.push(o),
        n.push(r))
    }
    return {
        cornerPoints: t,
        cornerPointPositions: n
    }
}
U(EW, "extractCornerPoints");
var s5 = U(function(e, t, n) {
    const r = t.x - e.x
      , i = t.y - e.y
      , o = Math.sqrt(r * r + i * i)
      , a = n / o;
    return {
        x: t.x - a * r,
        y: t.y - a * i
    }
}, "findAdjacentPoint")
  , C$e = U(function(e) {
    const {cornerPointPositions: t} = EW(e)
      , n = [];
    for (let r = 0; r < e.length; r++)
        if (t.includes(r)) {
            const i = e[r - 1]
              , o = e[r + 1]
              , a = e[r]
              , s = s5(i, a, 5)
              , c = s5(o, a, 5)
              , u = c.x - s.x
              , f = c.y - s.y;
            n.push(s);
            const h = Math.sqrt(2) * 2;
            let m = {
                x: a.x,
                y: a.y
            };
            if (Math.abs(o.x - i.x) > 10 && Math.abs(o.y - i.y) >= 10) {
                Qe.debug("Corner point fixing", Math.abs(o.x - i.x), Math.abs(o.y - i.y));
                const y = 5;
                a.x === s.x ? m = {
                    x: u < 0 ? s.x - y + h : s.x + y - h,
                    y: f < 0 ? s.y - h : s.y + h
                } : m = {
                    x: u < 0 ? s.x - h : s.x + h,
                    y: f < 0 ? s.y - y + h : s.y + y - h
                }
            } else
                Qe.debug("Corner point skipping fixing", Math.abs(o.x - i.x), Math.abs(o.y - i.y));
            n.push(m, c)
        } else
            n.push(e[r]);
    return n
}, "fixCorners")
  , w$e = U( (e, t, n) => {
    const r = e - t - n
      , i = 2
      , o = 2
      , a = i + o
      , s = Math.floor(r / a)
      , c = Array(s).fill(`${i} ${o}`).join(" ");
    return `0 ${t} ${c} ${n}`
}
, "generateDashArray")
  , k$e = U(function(e, t, n, r, i, o, a, s=!1) {
    const {handDrawnSeed: c} = Vn();
    let u = t.points
      , f = !1;
    const h = i;
    var m = o;
    const y = [];
    for (const L in t.cssCompiledStyles)
        iH(L) || y.push(t.cssCompiledStyles[L]);
    Qe.debug("UIO intersect check", t.points, m.x, h.x),
    m.intersect && h.intersect && !s && (u = u.slice(1, t.points.length - 1),
    u.unshift(h.intersect(u[0])),
    Qe.debug("Last point UIO", t.start, "-->", t.end, u[u.length - 1], m, m.intersect(u[u.length - 1])),
    u.push(m.intersect(u[u.length - 1])));
    const b = btoa(JSON.stringify(u));
    t.toCluster && (Qe.info("to cluster abc88", n.get(t.toCluster)),
    u = a5(t.points, n.get(t.toCluster).node),
    f = !0),
    t.fromCluster && (Qe.debug("from cluster abc88", n.get(t.fromCluster), JSON.stringify(u, null, 2)),
    u = a5(u.reverse(), n.get(t.fromCluster).node).reverse(),
    f = !0);
    let v = u.filter(L => !Number.isNaN(L.y));
    v = C$e(v);
    let S = Wx;
    switch (S = X0,
    t.curve) {
    case "linear":
        S = X0;
        break;
    case "basis":
        S = Wx;
        break;
    case "cardinal":
        S = lU;
        break;
    case "bumpX":
        S = rU;
        break;
    case "bumpY":
        S = iU;
        break;
    case "catmullRom":
        S = uU;
        break;
    case "monotoneX":
        S = gU;
        break;
    case "monotoneY":
        S = yU;
        break;
    case "natural":
        S = xU;
        break;
    case "step":
        S = vU;
        break;
    case "stepAfter":
        S = CU;
        break;
    case "stepBefore":
        S = SU;
        break;
    default:
        S = Wx
    }
    const {x: C, y: w} = CPe(t)
      , k = oMe().x(C).y(w).curve(S);
    let T;
    switch (t.thickness) {
    case "normal":
        T = "edge-thickness-normal";
        break;
    case "thick":
        T = "edge-thickness-thick";
        break;
    case "invisible":
        T = "edge-thickness-invisible";
        break;
    default:
        T = "edge-thickness-normal"
    }
    switch (t.pattern) {
    case "solid":
        T += " edge-pattern-solid";
        break;
    case "dotted":
        T += " edge-pattern-dotted";
        break;
    case "dashed":
        T += " edge-pattern-dashed";
        break;
    default:
        T += " edge-pattern-solid"
    }
    let E, P = t.curve === "rounded" ? AW(MW(v, t), 5) : k(v);
    const D = Array.isArray(t.style) ? t.style : [t.style];
    let $ = D.find(L => L?.startsWith("stroke:"))
      , z = !1;
    if (t.look === "handDrawn") {
        const L = Ct.svg(e);
        Object.assign([], v);
        const F = L.path(P, {
            roughness: .3,
            seed: c
        });
        T += " transition",
        E = En(F).select("path").attr("id", t.id).attr("class", " " + T + (t.classes ? " " + t.classes : "")).attr("style", D ? D.reduce( (N, H) => N + ";" + H, "") : "");
        let j = E.attr("d");
        E.attr("d", j),
        e.node().appendChild(E.node())
    } else {
        const L = y.join(";")
          , F = D ? D.reduce( (Y, W) => Y + W + ";", "") : "";
        let j = "";
        t.animate && (j = " edge-animation-fast"),
        t.animation && (j = " edge-animation-" + t.animation);
        const N = (L ? L + ";" + F + ";" : F) + ";" + (D ? D.reduce( (Y, W) => Y + ";" + W, "") : "");
        E = e.append("path").attr("d", P).attr("id", t.id).attr("class", " " + T + (t.classes ? " " + t.classes : "") + (j ?? "")).attr("style", N),
        $ = N.match(/stroke:([^;]+)/)?.[1],
        z = t.animate === !0 || !!t.animation || L.includes("animation");
        const H = E.node()
          , Z = typeof H.getTotalLength == "function" ? H.getTotalLength() : 0
          , q = kz[t.arrowTypeStart] || 0
          , V = kz[t.arrowTypeEnd] || 0;
        if (t.look === "neo" && !z) {
            const W = `stroke-dasharray: ${t.pattern === "dotted" || t.pattern === "dashed" ? w$e(Z, q, V) : `0 ${q} ${Z - q - V} ${V}`}; stroke-dashoffset: 0;`;
            E.attr("style", W + E.attr("style"))
        }
    }
    E.attr("data-edge", !0),
    E.attr("data-et", "edge"),
    E.attr("data-id", t.id),
    E.attr("data-points", b),
    t.showPoints && v.forEach(L => {
        e.append("circle").style("stroke", "red").style("fill", "red").attr("r", 1).attr("cx", L.x).attr("cy", L.y)
    }
    );
    let O = "";
    (Vn().flowchart.arrowMarkerAbsolute || Vn().state.arrowMarkerAbsolute) && (O = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search,
    O = O.replace(/\(/g, "\\(").replace(/\)/g, "\\)")),
    Qe.info("arrowTypeStart", t.arrowTypeStart),
    Qe.info("arrowTypeEnd", t.arrowTypeEnd),
    g$e(E, t, O, a, r, $);
    const I = Math.floor(u.length / 2)
      , M = u[I];
    Na.isLabelCoordinateInPath(M, E.attr("d")) || (f = !0);
    let B = {};
    return f && (B.updatedPath = u),
    B.originalPath = t.points,
    B
}, "insertEdge");
function AW(e, t) {
    if (e.length < 2)
        return "";
    let n = "";
    const r = e.length
      , i = 1e-5;
    for (let o = 0; o < r; o++) {
        const a = e[o]
          , s = e[o - 1]
          , c = e[o + 1];
        if (o === 0)
            n += `M${a.x},${a.y}`;
        else if (o === r - 1)
            n += `L${a.x},${a.y}`;
        else {
            const u = a.x - s.x
              , f = a.y - s.y
              , h = c.x - a.x
              , m = c.y - a.y
              , y = Math.hypot(u, f)
              , b = Math.hypot(h, m);
            if (y < i || b < i) {
                n += `L${a.x},${a.y}`;
                continue
            }
            const v = u / y
              , S = f / y
              , C = h / b
              , w = m / b
              , k = v * C + S * w
              , T = Math.max(-1, Math.min(1, k))
              , E = Math.acos(T);
            if (E < i || Math.abs(Math.PI - E) < i) {
                n += `L${a.x},${a.y}`;
                continue
            }
            const P = Math.min(t / Math.sin(E / 2), y / 2, b / 2)
              , D = a.x - v * P
              , $ = a.y - S * P
              , z = a.x + C * P
              , O = a.y + w * P;
            n += `L${D},${$}`,
            n += `Q${a.x},${a.y} ${z},${O}`
        }
    }
    return n
}
U(AW, "generateRoundedPath");
function B_(e, t) {
    if (!e || !t)
        return {
            angle: 0,
            deltaX: 0,
            deltaY: 0
        };
    const n = t.x - e.x
      , r = t.y - e.y;
    return {
        angle: Math.atan2(r, n),
        deltaX: n,
        deltaY: r
    }
}
U(B_, "calculateDeltaAndAngle");
function MW(e, t) {
    const n = e.map(i => ({
        ...i
    }));
    if (e.length >= 2 && _i[t.arrowTypeStart]) {
        const i = _i[t.arrowTypeStart]
          , o = e[0]
          , a = e[1]
          , {angle: s} = B_(o, a)
          , c = i * Math.cos(s)
          , u = i * Math.sin(s);
        n[0].x = o.x + c,
        n[0].y = o.y + u
    }
    const r = e.length;
    if (r >= 2 && _i[t.arrowTypeEnd]) {
        const i = _i[t.arrowTypeEnd]
          , o = e[r - 1]
          , a = e[r - 2]
          , {angle: s} = B_(a, o)
          , c = i * Math.cos(s)
          , u = i * Math.sin(s);
        n[r - 1].x = o.x - c,
        n[r - 1].y = o.y - u
    }
    return n
}
U(MW, "applyMarkerOffsetsToPoints");
var T$e = U( (e, t, n, r) => {
    t.forEach(i => {
        N$e[i](e, n, r)
    }
    )
}
, "insertMarkers")
  , _$e = U( (e, t, n) => {
    Qe.trace("Making markers for ", n),
    e.append("defs").append("marker").attr("id", n + "_" + t + "-extensionStart").attr("class", "marker extension " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"),
    e.append("defs").append("marker").attr("id", n + "_" + t + "-extensionEnd").attr("class", "marker extension " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z")
}
, "extension")
  , E$e = U( (e, t, n) => {
    e.append("defs").append("marker").attr("id", n + "_" + t + "-compositionStart").attr("class", "marker composition " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"),
    e.append("defs").append("marker").attr("id", n + "_" + t + "-compositionEnd").attr("class", "marker composition " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z")
}
, "composition")
  , A$e = U( (e, t, n) => {
    e.append("defs").append("marker").attr("id", n + "_" + t + "-aggregationStart").attr("class", "marker aggregation " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"),
    e.append("defs").append("marker").attr("id", n + "_" + t + "-aggregationEnd").attr("class", "marker aggregation " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z")
}
, "aggregation")
  , M$e = U( (e, t, n) => {
    e.append("defs").append("marker").attr("id", n + "_" + t + "-dependencyStart").attr("class", "marker dependency " + t).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"),
    e.append("defs").append("marker").attr("id", n + "_" + t + "-dependencyEnd").attr("class", "marker dependency " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z")
}
, "dependency")
  , P$e = U( (e, t, n) => {
    e.append("defs").append("marker").attr("id", n + "_" + t + "-lollipopStart").attr("class", "marker lollipop " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6),
    e.append("defs").append("marker").attr("id", n + "_" + t + "-lollipopEnd").attr("class", "marker lollipop " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6)
}
, "lollipop")
  , R$e = U( (e, t, n) => {
    e.append("marker").attr("id", n + "_" + t + "-pointEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"),
    e.append("marker").attr("id", n + "_" + t + "-pointStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0")
}
, "point")
  , D$e = U( (e, t, n) => {
    e.append("marker").attr("id", n + "_" + t + "-circleEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"),
    e.append("marker").attr("id", n + "_" + t + "-circleStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0")
}
, "circle")
  , O$e = U( (e, t, n) => {
    e.append("marker").attr("id", n + "_" + t + "-crossEnd").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"),
    e.append("marker").attr("id", n + "_" + t + "-crossStart").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0")
}
, "cross")
  , I$e = U( (e, t, n) => {
    e.append("defs").append("marker").attr("id", n + "_" + t + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z")
}
, "barb")
  , $$e = U( (e, t, n) => {
    e.append("defs").append("marker").attr("id", n + "_" + t + "-onlyOneStart").attr("class", "marker onlyOne " + t).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18"),
    e.append("defs").append("marker").attr("id", n + "_" + t + "-onlyOneEnd").attr("class", "marker onlyOne " + t).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18")
}
, "only_one")
  , L$e = U( (e, t, n) => {
    const r = e.append("defs").append("marker").attr("id", n + "_" + t + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + t).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
    r.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6),
    r.append("path").attr("d", "M9,0 L9,18");
    const i = e.append("defs").append("marker").attr("id", n + "_" + t + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + t).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
    i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6),
    i.append("path").attr("d", "M21,0 L21,18")
}
, "zero_or_one")
  , j$e = U( (e, t, n) => {
    e.append("defs").append("marker").attr("id", n + "_" + t + "-oneOrMoreStart").attr("class", "marker oneOrMore " + t).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"),
    e.append("defs").append("marker").attr("id", n + "_" + t + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + t).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18")
}
, "one_or_more")
  , B$e = U( (e, t, n) => {
    const r = e.append("defs").append("marker").attr("id", n + "_" + t + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + t).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
    r.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6),
    r.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
    const i = e.append("defs").append("marker").attr("id", n + "_" + t + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + t).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
    i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6),
    i.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18")
}
, "zero_or_more")
  , z$e = U( (e, t, n) => {
    e.append("defs").append("marker").attr("id", n + "_" + t + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr("d", `M0,0
      L20,10
      M20,10
      L0,20`)
}
, "requirement_arrow")
  , F$e = U( (e, t, n) => {
    const r = e.append("defs").append("marker").attr("id", n + "_" + t + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
    r.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none"),
    r.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10),
    r.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10)
}
, "requirement_contains")
  , N$e = {
    extension: _$e,
    composition: E$e,
    aggregation: A$e,
    dependency: M$e,
    lollipop: P$e,
    point: R$e,
    circle: D$e,
    cross: O$e,
    barb: I$e,
    only_one: $$e,
    zero_or_one: L$e,
    one_or_more: j$e,
    zero_or_more: B$e,
    requirement_arrow: z$e,
    requirement_contains: F$e
}
  , U$e = T$e
  , V$e = {
    common: vh,
    getConfig: Mi,
    insertCluster: KIe,
    insertEdge: k$e,
    insertEdgeLabel: b$e,
    insertMarkers: U$e,
    insertNode: _W,
    interpolateToCurve: DM,
    labelHelper: Vt,
    log: Qe,
    positionEdgeLabel: x$e
}
  , gg = {}
  , PW = U(e => {
    for (const t of e)
        gg[t.name] = t
}
, "registerLayoutLoaders")
  , H$e = U( () => {
    PW([{
        name: "dagre",
        loader: U(async () => await qn( () => import("./dagre-6UL2VRFP-BVRzo63V.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5])), "loader")
    }, {
        name: "cose-bilkent",
        loader: U(async () => await qn( () => import("./cose-bilkent-S5V4N54A-DxaxPR1Z.js"), __vite__mapDeps([6, 7])), "loader")
    }])
}
, "registerDefaultLayoutLoaders");
H$e();
var mVe = U(async (e, t) => {
    if (!(e.layoutAlgorithm in gg))
        throw new Error(`Unknown layout algorithm: ${e.layoutAlgorithm}`);
    const n = gg[e.layoutAlgorithm];
    return (await n.loader()).render(e, t, V$e, {
        algorithm: n.algorithm
    })
}
, "render")
  , gVe = U( (e="", {fallback: t="dagre"}={}) => {
    if (e in gg)
        return e;
    if (t in gg)
        return Qe.warn(`Layout algorithm ${e} is not registered. Using ${t} as fallback.`),
        t;
    throw new Error(`Both layout algorithms ${e} and ${t} are not registered.`)
}
, "getRegisteredLayoutAlgorithm")
  , RW = "comm"
  , DW = "rule"
  , OW = "decl"
  , q$e = "@import"
  , W$e = "@namespace"
  , G$e = "@keyframes"
  , Y$e = "@layer"
  , IW = Math.abs
  , XM = String.fromCharCode;
function $W(e) {
    return e.trim()
}
function Kx(e, t, n) {
    return e.replace(t, n)
}
function Z$e(e, t, n) {
    return e.indexOf(t, n)
}
function Af(e, t) {
    return e.charCodeAt(t) | 0
}
function oh(e, t, n) {
    return e.slice(t, n)
}
function gs(e) {
    return e.length
}
function Q$e(e) {
    return e.length
}
function mx(e, t) {
    return t.push(e),
    e
}
var lS = 1
  , ah = 1
  , LW = 0
  , Ta = 0
  , Qr = 0
  , Th = "";
function JM(e, t, n, r, i, o, a, s) {
    return {
        value: e,
        root: t,
        parent: n,
        type: r,
        props: i,
        children: o,
        line: lS,
        column: ah,
        length: a,
        return: "",
        siblings: s
    }
}
function K$e() {
    return Qr
}
function X$e() {
    return Qr = Ta > 0 ? Af(Th, --Ta) : 0,
    ah--,
    Qr === 10 && (ah = 1,
    lS--),
    Qr
}
function Za() {
    return Qr = Ta < LW ? Af(Th, Ta++) : 0,
    ah++,
    Qr === 10 && (ah = 1,
    lS++),
    Qr
}
function dc() {
    return Af(Th, Ta)
}
function Xx() {
    return Ta
}
function cS(e, t) {
    return oh(Th, e, t)
}
function yg(e) {
    switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function J$e(e) {
    return lS = ah = 1,
    LW = gs(Th = e),
    Ta = 0,
    []
}
function eLe(e) {
    return Th = "",
    e
}
function d2(e) {
    return $W(cS(Ta - 1, z_(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}
function tLe(e) {
    for (; (Qr = dc()) && Qr < 33; )
        Za();
    return yg(e) > 2 || yg(Qr) > 3 ? "" : " "
}
function nLe(e, t) {
    for (; --t && Za() && !(Qr < 48 || Qr > 102 || Qr > 57 && Qr < 65 || Qr > 70 && Qr < 97); )
        ;
    return cS(e, Xx() + (t < 6 && dc() == 32 && Za() == 32))
}
function z_(e) {
    for (; Za(); )
        switch (Qr) {
        case e:
            return Ta;
        case 34:
        case 39:
            e !== 34 && e !== 39 && z_(Qr);
            break;
        case 40:
            e === 41 && z_(e);
            break;
        case 92:
            Za();
            break
        }
    return Ta
}
function rLe(e, t) {
    for (; Za() && e + Qr !== 57; )
        if (e + Qr === 84 && dc() === 47)
            break;
    return "/*" + cS(t, Ta - 1) + "*" + XM(e === 47 ? e : Za())
}
function iLe(e) {
    for (; !yg(dc()); )
        Za();
    return cS(e, Ta)
}
function oLe(e) {
    return eLe(Jx("", null, null, null, [""], e = J$e(e), 0, [0], e))
}
function Jx(e, t, n, r, i, o, a, s, c) {
    for (var u = 0, f = 0, h = a, m = 0, y = 0, b = 0, v = 1, S = 1, C = 1, w = 0, k = "", T = i, E = o, P = r, D = k; S; )
        switch (b = w,
        w = Za()) {
        case 40:
            if (b != 108 && Af(D, h - 1) == 58) {
                Z$e(D += Kx(d2(w), "&", "&\f"), "&\f", IW(u ? s[u - 1] : 0)) != -1 && (C = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            D += d2(w);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            D += tLe(b);
            break;
        case 92:
            D += nLe(Xx() - 1, 7);
            continue;
        case 47:
            switch (dc()) {
            case 42:
            case 47:
                mx(aLe(rLe(Za(), Xx()), t, n, c), c),
                (yg(b || 1) == 5 || yg(dc() || 1) == 5) && gs(D) && oh(D, -1, void 0) !== " " && (D += " ");
                break;
            default:
                D += "/"
            }
            break;
        case 123 * v:
            s[u++] = gs(D) * C;
        case 125 * v:
        case 59:
        case 0:
            switch (w) {
            case 0:
            case 125:
                S = 0;
            case 59 + f:
                C == -1 && (D = Kx(D, /\f/g, "")),
                y > 0 && (gs(D) - h || v === 0 && b === 47) && mx(y > 32 ? c5(D + ";", r, n, h - 1, c) : c5(Kx(D, " ", "") + ";", r, n, h - 2, c), c);
                break;
            case 59:
                D += ";";
            default:
                if (mx(P = l5(D, t, n, u, f, i, s, k, T = [], E = [], h, o), o),
                w === 123)
                    if (f === 0)
                        Jx(D, t, P, P, T, o, h, s, E);
                    else {
                        switch (m) {
                        case 99:
                            if (Af(D, 3) === 110)
                                break;
                        case 108:
                            if (Af(D, 2) === 97)
                                break;
                        default:
                            f = 0;
                        case 100:
                        case 109:
                        case 115:
                        }
                        f ? Jx(e, P, P, r && mx(l5(e, P, P, 0, 0, i, s, k, i, T = [], h, E), E), i, E, h, s, r ? T : E) : Jx(D, P, P, P, [""], E, 0, s, E)
                    }
            }
            u = f = y = 0,
            v = C = 1,
            k = D = "",
            h = a;
            break;
        case 58:
            h = 1 + gs(D),
            y = b;
        default:
            if (v < 1) {
                if (w == 123)
                    --v;
                else if (w == 125 && v++ == 0 && X$e() == 125)
                    continue
            }
            switch (D += XM(w),
            w * v) {
            case 38:
                C = f > 0 ? 1 : (D += "\f",
                -1);
                break;
            case 44:
                s[u++] = (gs(D) - 1) * C,
                C = 1;
                break;
            case 64:
                dc() === 45 && (D += d2(Za())),
                m = dc(),
                f = h = gs(k = D += iLe(Xx())),
                w++;
                break;
            case 45:
                b === 45 && gs(D) == 2 && (v = 0)
            }
        }
    return o
}
function l5(e, t, n, r, i, o, a, s, c, u, f, h) {
    for (var m = i - 1, y = i === 0 ? o : [""], b = Q$e(y), v = 0, S = 0, C = 0; v < r; ++v)
        for (var w = 0, k = oh(e, m + 1, m = IW(S = a[v])), T = e; w < b; ++w)
            (T = $W(S > 0 ? y[w] + " " + k : Kx(k, /&\f/g, y[w]))) && (c[C++] = T);
    return JM(e, t, n, i === 0 ? DW : s, c, u, f, h)
}
function aLe(e, t, n, r) {
    return JM(e, t, n, RW, XM(K$e()), oh(e, 2, -2), 0, r)
}
function c5(e, t, n, r, i) {
    return JM(e, t, n, OW, oh(e, 0, r), oh(e, r + 1, -1), r, i)
}
function F_(e, t) {
    for (var n = "", r = 0; r < e.length; r++)
        n += t(e[r], r, e, t) || "";
    return n
}
function sLe(e, t, n, r) {
    switch (e.type) {
    case Y$e:
        if (e.children.length)
            break;
    case q$e:
    case W$e:
    case OW:
        return e.return = e.return || e.value;
    case RW:
        return "";
    case G$e:
        return e.return = e.value + "{" + F_(e.children, r) + "}";
    case DW:
        if (!gs(e.value = e.props.join(",")))
            return ""
    }
    return gs(n = F_(e.children, r)) ? e.return = e.value + "{" + n + "}" : ""
}
var lLe = lH(Object.keys, Object)
  , cLe = Object.prototype
  , uLe = cLe.hasOwnProperty;
function dLe(e) {
    if (!X1(e))
        return lLe(e);
    var t = [];
    for (var n in Object(e))
        uLe.call(e, n) && n != "constructor" && t.push(n);
    return t
}
var N_ = ld(js, "DataView")
  , U_ = ld(js, "Promise")
  , V_ = ld(js, "Set")
  , H_ = ld(js, "WeakMap")
  , u5 = "[object Map]"
  , fLe = "[object Object]"
  , d5 = "[object Promise]"
  , f5 = "[object Set]"
  , h5 = "[object WeakMap]"
  , p5 = "[object DataView]"
  , hLe = sd(N_)
  , pLe = sd(pg)
  , mLe = sd(U_)
  , gLe = sd(V_)
  , yLe = sd(H_)
  , gu = Ch;
(N_ && gu(new N_(new ArrayBuffer(1))) != p5 || pg && gu(new pg) != u5 || U_ && gu(U_.resolve()) != d5 || V_ && gu(new V_) != f5 || H_ && gu(new H_) != h5) && (gu = function(e) {
    var t = Ch(e)
      , n = t == fLe ? e.constructor : void 0
      , r = n ? sd(n) : "";
    if (r)
        switch (r) {
        case hLe:
            return p5;
        case pLe:
            return u5;
        case mLe:
            return d5;
        case gLe:
            return f5;
        case yLe:
            return h5
        }
    return t
}
);
var bLe = "[object Map]"
  , xLe = "[object Set]"
  , vLe = Object.prototype
  , SLe = vLe.hasOwnProperty;
function m5(e) {
    if (e == null)
        return !0;
    if (J1(e) && (dv(e) || typeof e == "string" || typeof e.splice == "function" || PM(e) || RM(e) || uv(e)))
        return !e.length;
    var t = gu(e);
    if (t == bLe || t == xLe)
        return !e.size;
    if (X1(e))
        return !dLe(e).length;
    for (var n in e)
        if (SLe.call(e, n))
            return !1;
    return !0
}
var jW = "c4"
  , CLe = U(e => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(e), "detector")
  , wLe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./c4Diagram-YG6GDRKO-CWLcVrDv.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([8, 9]));
    return {
        id: jW,
        diagram: e
    }
}
, "loader")
  , kLe = {
    id: jW,
    detector: CLe,
    loader: wLe
}
  , TLe = kLe
  , BW = "flowchart"
  , _Le = U( (e, t) => t?.flowchart?.defaultRenderer === "dagre-wrapper" || t?.flowchart?.defaultRenderer === "elk" ? !1 : /^\s*graph/.test(e), "detector")
  , ELe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./flowDiagram-NV44I4VS-BnAOTmyK.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([10, 11, 12, 13, 14]));
    return {
        id: BW,
        diagram: e
    }
}
, "loader")
  , ALe = {
    id: BW,
    detector: _Le,
    loader: ELe
}
  , MLe = ALe
  , zW = "flowchart-v2"
  , PLe = U( (e, t) => t?.flowchart?.defaultRenderer === "dagre-d3" ? !1 : (t?.flowchart?.defaultRenderer === "elk" && (t.layout = "elk"),
/^\s*graph/.test(e) && t?.flowchart?.defaultRenderer === "dagre-wrapper" ? !0 : /^\s*flowchart/.test(e)), "detector")
  , RLe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./flowDiagram-NV44I4VS-BnAOTmyK.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([10, 11, 12, 13, 14]));
    return {
        id: zW,
        diagram: e
    }
}
, "loader")
  , DLe = {
    id: zW,
    detector: PLe,
    loader: RLe
}
  , OLe = DLe
  , FW = "er"
  , ILe = U(e => /^\s*erDiagram/.test(e), "detector")
  , $Le = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./erDiagram-Q2GNP2WA-Cr3vVunF.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([15, 12, 13, 14]));
    return {
        id: FW,
        diagram: e
    }
}
, "loader")
  , LLe = {
    id: FW,
    detector: ILe,
    loader: $Le
}
  , jLe = LLe
  , NW = "gitGraph"
  , BLe = U(e => /^\s*gitGraph/.test(e), "detector")
  , zLe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./gitGraphDiagram-NY62KEGX-CC2lGZLA.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([16, 17, 18, 19, 2, 4, 5]));
    return {
        id: NW,
        diagram: e
    }
}
, "loader")
  , FLe = {
    id: NW,
    detector: BLe,
    loader: zLe
}
  , NLe = FLe
  , UW = "gantt"
  , ULe = U(e => /^\s*gantt/.test(e), "detector")
  , VLe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./ganttDiagram-LVOFAZNH-B08ysZ5a.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([20, 21, 22, 23]));
    return {
        id: UW,
        diagram: e
    }
}
, "loader")
  , HLe = {
    id: UW,
    detector: ULe,
    loader: VLe
}
  , qLe = HLe
  , VW = "info"
  , WLe = U(e => /^\s*info/.test(e), "detector")
  , GLe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./infoDiagram-F6ZHWCRC-DYFv4gnV.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([24, 19, 2, 4, 5]));
    return {
        id: VW,
        diagram: e
    }
}
, "loader")
  , YLe = {
    id: VW,
    detector: WLe,
    loader: GLe
}
  , HW = "pie"
  , ZLe = U(e => /^\s*pie/.test(e), "detector")
  , QLe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./pieDiagram-ADFJNKIX-Cpt-Y17L.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([25, 17, 19, 2, 4, 5, 26, 27, 22]));
    return {
        id: HW,
        diagram: e
    }
}
, "loader")
  , KLe = {
    id: HW,
    detector: ZLe,
    loader: QLe
}
  , qW = "quadrantChart"
  , XLe = U(e => /^\s*quadrantChart/.test(e), "detector")
  , JLe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./quadrantDiagram-AYHSOK5B-CpEeCLo5.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([28, 21, 22, 23]));
    return {
        id: qW,
        diagram: e
    }
}
, "loader")
  , eje = {
    id: qW,
    detector: XLe,
    loader: JLe
}
  , tje = eje
  , WW = "xychart"
  , nje = U(e => /^\s*xychart(-beta)?/.test(e), "detector")
  , rje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./xychartDiagram-PRI3JC2R-Du79RmHN.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([29, 22, 27, 21, 23]));
    return {
        id: WW,
        diagram: e
    }
}
, "loader")
  , ije = {
    id: WW,
    detector: nje,
    loader: rje
}
  , oje = ije
  , GW = "requirement"
  , aje = U(e => /^\s*requirement(Diagram)?/.test(e), "detector")
  , sje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./requirementDiagram-UZGBJVZJ-Bj1N6rPu.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([30, 12, 13]));
    return {
        id: GW,
        diagram: e
    }
}
, "loader")
  , lje = {
    id: GW,
    detector: aje,
    loader: sje
}
  , cje = lje
  , YW = "sequence"
  , uje = U(e => /^\s*sequenceDiagram/.test(e), "detector")
  , dje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./sequenceDiagram-WL72ISMW-DuPk3aIv.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([31, 9, 18]));
    return {
        id: YW,
        diagram: e
    }
}
, "loader")
  , fje = {
    id: YW,
    detector: uje,
    loader: dje
}
  , hje = fje
  , ZW = "class"
  , pje = U( (e, t) => t?.class?.defaultRenderer === "dagre-wrapper" ? !1 : /^\s*classDiagram/.test(e), "detector")
  , mje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./classDiagram-2ON5EDUG-B4UOuWem.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([32, 33, 11, 12, 13]));
    return {
        id: ZW,
        diagram: e
    }
}
, "loader")
  , gje = {
    id: ZW,
    detector: pje,
    loader: mje
}
  , yje = gje
  , QW = "classDiagram"
  , bje = U( (e, t) => /^\s*classDiagram/.test(e) && t?.class?.defaultRenderer === "dagre-wrapper" ? !0 : /^\s*classDiagram-v2/.test(e), "detector")
  , xje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./classDiagram-v2-WZHVMYZB-B4UOuWem.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([34, 33, 11, 12, 13]));
    return {
        id: QW,
        diagram: e
    }
}
, "loader")
  , vje = {
    id: QW,
    detector: bje,
    loader: xje
}
  , Sje = vje
  , KW = "state"
  , Cje = U( (e, t) => t?.state?.defaultRenderer === "dagre-wrapper" ? !1 : /^\s*stateDiagram/.test(e), "detector")
  , wje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./stateDiagram-FKZM4ZOC-Y3dVFcIw.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([35, 36, 12, 13, 1, 2, 3, 4]));
    return {
        id: KW,
        diagram: e
    }
}
, "loader")
  , kje = {
    id: KW,
    detector: Cje,
    loader: wje
}
  , Tje = kje
  , XW = "stateDiagram"
  , _je = U( (e, t) => !!(/^\s*stateDiagram-v2/.test(e) || /^\s*stateDiagram/.test(e) && t?.state?.defaultRenderer === "dagre-wrapper"), "detector")
  , Eje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./stateDiagram-v2-4FDKWEC3-DQugY_wq.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([37, 36, 12, 13]));
    return {
        id: XW,
        diagram: e
    }
}
, "loader")
  , Aje = {
    id: XW,
    detector: _je,
    loader: Eje
}
  , Mje = Aje
  , JW = "journey"
  , Pje = U(e => /^\s*journey/.test(e), "detector")
  , Rje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./journeyDiagram-XKPGCS4Q-7IJs1njS.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([38, 9, 11, 26]));
    return {
        id: JW,
        diagram: e
    }
}
, "loader")
  , Dje = {
    id: JW,
    detector: Pje,
    loader: Rje
}
  , Oje = Dje
  , Ije = U( (e, t, n) => {
    Qe.debug(`rendering svg for syntax error
`);
    const r = pMe(t)
      , i = r.append("g");
    r.attr("viewBox", "0 0 2412 512"),
    _8(r, 100, 512, !0),
    i.append("path").attr("class", "error-icon").attr("d", "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"),
    i.append("path").attr("class", "error-icon").attr("d", "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"),
    i.append("path").attr("class", "error-icon").attr("d", "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"),
    i.append("path").attr("class", "error-icon").attr("d", "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"),
    i.append("path").attr("class", "error-icon").attr("d", "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"),
    i.append("path").attr("class", "error-icon").attr("d", "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"),
    i.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text"),
    i.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${n}`)
}
, "draw")
  , e7 = {
    draw: Ije
}
  , $je = e7
  , Lje = {
    db: {},
    renderer: e7,
    parser: {
        parse: U( () => {}
        , "parse")
    }
}
  , jje = Lje
  , t7 = "flowchart-elk"
  , Bje = U( (e, t={}) => /^\s*flowchart-elk/.test(e) || /^\s*(flowchart|graph)/.test(e) && t?.flowchart?.defaultRenderer === "elk" ? (t.layout = "elk",
!0) : !1, "detector")
  , zje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./flowDiagram-NV44I4VS-BnAOTmyK.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([10, 11, 12, 13, 14]));
    return {
        id: t7,
        diagram: e
    }
}
, "loader")
  , Fje = {
    id: t7,
    detector: Bje,
    loader: zje
}
  , Nje = Fje
  , n7 = "timeline"
  , Uje = U(e => /^\s*timeline/.test(e), "detector")
  , Vje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./timeline-definition-IT6M3QCI-DnIJgjNQ.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([39, 26]));
    return {
        id: n7,
        diagram: e
    }
}
, "loader")
  , Hje = {
    id: n7,
    detector: Uje,
    loader: Vje
}
  , qje = Hje
  , r7 = "mindmap"
  , Wje = U(e => /^\s*mindmap/.test(e), "detector")
  , Gje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./mindmap-definition-VGOIOE7T-u8frsvOj.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([40, 12, 13]));
    return {
        id: r7,
        diagram: e
    }
}
, "loader")
  , Yje = {
    id: r7,
    detector: Wje,
    loader: Gje
}
  , Zje = Yje
  , i7 = "kanban"
  , Qje = U(e => /^\s*kanban/.test(e), "detector")
  , Kje = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./kanban-definition-3W4ZIXB7-BQGRiOmD.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([41, 11]));
    return {
        id: i7,
        diagram: e
    }
}
, "loader")
  , Xje = {
    id: i7,
    detector: Qje,
    loader: Kje
}
  , Jje = Xje
  , o7 = "sankey"
  , eBe = U(e => /^\s*sankey(-beta)?/.test(e), "detector")
  , tBe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./sankeyDiagram-TZEHDZUN-D3KcfQuK.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([42, 27, 22]));
    return {
        id: o7,
        diagram: e
    }
}
, "loader")
  , nBe = {
    id: o7,
    detector: eBe,
    loader: tBe
}
  , rBe = nBe
  , a7 = "packet"
  , iBe = U(e => /^\s*packet(-beta)?/.test(e), "detector")
  , oBe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./diagram-S2PKOQOG-By75yC75.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([43, 17, 19, 2, 4, 5]));
    return {
        id: a7,
        diagram: e
    }
}
, "loader")
  , aBe = {
    id: a7,
    detector: iBe,
    loader: oBe
}
  , s7 = "radar"
  , sBe = U(e => /^\s*radar-beta/.test(e), "detector")
  , lBe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./diagram-QEK2KX5R-Q7ov5C6P.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([44, 17, 19, 2, 4, 5]));
    return {
        id: s7,
        diagram: e
    }
}
, "loader")
  , cBe = {
    id: s7,
    detector: sBe,
    loader: lBe
}
  , l7 = "block"
  , uBe = U(e => /^\s*block(-beta)?/.test(e), "detector")
  , dBe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./blockDiagram-VD42YOAC-7GPNweqI.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([45, 11, 5, 2, 1, 14]));
    return {
        id: l7,
        diagram: e
    }
}
, "loader")
  , fBe = {
    id: l7,
    detector: uBe,
    loader: dBe
}
  , hBe = fBe
  , c7 = "architecture"
  , pBe = U(e => /^\s*architecture/.test(e), "detector")
  , mBe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./architectureDiagram-VXUJARFQ-VtqpxFd5.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([46, 17, 19, 2, 4, 5, 7]));
    return {
        id: c7,
        diagram: e
    }
}
, "loader")
  , gBe = {
    id: c7,
    detector: pBe,
    loader: mBe
}
  , yBe = gBe
  , u7 = "treemap"
  , bBe = U(e => /^\s*treemap/.test(e), "detector")
  , xBe = U(async () => {
    const {diagram: e} = await qn(async () => {
        const {diagram: t} = await import("./diagram-PSM6KHXK-m8j4PP9B.js");
        return {
            diagram: t
        }
    }
    , __vite__mapDeps([47, 13, 17, 19, 2, 4, 5, 23, 27, 22]));
    return {
        id: u7,
        diagram: e
    }
}
, "loader")
  , vBe = {
    id: u7,
    detector: bBe,
    loader: xBe
}
  , g5 = !1
  , uS = U( () => {
    g5 || (g5 = !0,
    q0("error", jje, e => e.toLowerCase().trim() === "error"),
    q0("---", {
        db: {
            clear: U( () => {}
            , "clear")
        },
        styles: {},
        renderer: {
            draw: U( () => {}
            , "draw")
        },
        parser: {
            parse: U( () => {
                throw new Error("Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks")
            }
            , "parse")
        },
        init: U( () => null, "init")
    }, e => e.toLowerCase().trimStart().startsWith("---")),
    KT(Nje, Zje, yBe),
    KT(TLe, Jje, Sje, yje, jLe, qLe, YLe, KLe, cje, hje, OLe, MLe, qje, NLe, Mje, Tje, Oje, tje, rBe, aBe, oje, hBe, cBe, vBe))
}
, "addDiagrams")
  , SBe = U(async () => {
    Qe.debug("Loading registered diagrams");
    const t = (await Promise.allSettled(Object.entries(Yu).map(async ([n,{detector: r, loader: i}]) => {
        if (i)
            try {
                t_(n)
            } catch {
                try {
                    const {diagram: o, id: a} = await i();
                    q0(a, o, r)
                } catch (o) {
                    throw Qe.error(`Failed to load external diagram with key ${n}. Removing from detectors.`),
                    delete Yu[n],
                    o
                }
            }
    }
    ))).filter(n => n.status === "rejected");
    if (t.length > 0) {
        Qe.error(`Failed to load ${t.length} external diagrams`);
        for (const n of t)
            Qe.error(n);
        throw new Error(`Failed to load ${t.length} external diagrams`)
    }
}
, "loadRegisteredDiagrams")
  , CBe = "graphics-document document";
function d7(e, t) {
    e.attr("role", CBe),
    t !== "" && e.attr("aria-roledescription", t)
}
U(d7, "setA11yDiagramInfo");
function f7(e, t, n, r) {
    if (e.insert !== void 0) {
        if (n) {
            const i = `chart-desc-${r}`;
            e.attr("aria-describedby", i),
            e.insert("desc", ":first-child").attr("id", i).text(n)
        }
        if (t) {
            const i = `chart-title-${r}`;
            e.attr("aria-labelledby", i),
            e.insert("title", ":first-child").attr("id", i).text(t)
        }
    }
}
U(f7, "addSVGa11yTitleDescription");
var Iu, q_ = (Iu = class {
    constructor(t, n, r, i, o) {
        this.type = t,
        this.text = n,
        this.db = r,
        this.parser = i,
        this.renderer = o
    }
    static async fromText(t, n={}) {
        const r = Mi()
          , i = tM(t, r);
        t = vOe(t) + `
`;
        try {
            t_(i)
        } catch {
            const u = H2e(i);
            if (!u)
                throw new p8(`Diagram ${i} not found.`);
            const {id: f, diagram: h} = await u();
            q0(f, h)
        }
        const {db: o, parser: a, renderer: s, init: c} = t_(i);
        return a.parser && (a.parser.yy = o),
        o.clear?.(),
        c?.(r),
        n.title && o.setDiagramTitle?.(n.title),
        await a.parse(t),
        new Iu(i,t,o,a,s)
    }
    async render(t, n) {
        await this.renderer.draw(this.text, t, n, this)
    }
    getParser() {
        return this.parser
    }
    getType() {
        return this.type
    }
}
,
U(Iu, "Diagram"),
Iu), y5 = [], wBe = U( () => {
    y5.forEach(e => {
        e()
    }
    ),
    y5 = []
}
, "attachFunctions"), kBe = U(e => e.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(), "cleanupComments");
function h7(e) {
    const t = e.match(h8);
    if (!t)
        return {
            text: e,
            metadata: {}
        };
    let n = SPe(t[1], {
        schema: vPe
    }) ?? {};
    n = typeof n == "object" && !Array.isArray(n) ? n : {};
    const r = {};
    return n.displayMode && (r.displayMode = n.displayMode.toString()),
    n.title && (r.title = n.title.toString()),
    n.config && (r.config = n.config),
    {
        text: e.slice(t[0].length),
        metadata: r
    }
}
U(h7, "extractFrontMatter");
var TBe = U(e => e.replace(/\r\n?/g, `
`).replace(/<(\w+)([^>]*)>/g, (t, n, r) => "<" + n + r.replace(/="([^"]*)"/g, "='$1'") + ">"), "cleanupText")
  , _Be = U(e => {
    const {text: t, metadata: n} = h7(e)
      , {displayMode: r, title: i, config: o={}} = n;
    return r && (o.gantt || (o.gantt = {}),
    o.gantt.displayMode = r),
    {
        title: i,
        config: o,
        text: t
    }
}
, "processFrontmatter")
  , EBe = U(e => {
    const t = Na.detectInit(e) ?? {}
      , n = Na.detectDirective(e, "wrap");
    return Array.isArray(n) ? t.wrap = n.some( ({type: r}) => r === "wrap") : n?.type === "wrap" && (t.wrap = !0),
    {
        text: sOe(e),
        directive: t
    }
}
, "processDirectives");
function eP(e) {
    const t = TBe(e)
      , n = _Be(t)
      , r = EBe(n.text)
      , i = jM(n.config, r.directive);
    return e = kBe(r.text),
    {
        code: e,
        title: n.title,
        config: i
    }
}
U(eP, "preprocessDiagram");
function p7(e) {
    const t = new TextEncoder().encode(e)
      , n = Array.from(t, r => String.fromCodePoint(r)).join("");
    return btoa(n)
}
U(p7, "toBase64");
var ABe = 5e4
  , MBe = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa"
  , PBe = "sandbox"
  , RBe = "loose"
  , DBe = "http://www.w3.org/2000/svg"
  , OBe = "http://www.w3.org/1999/xlink"
  , IBe = "http://www.w3.org/1999/xhtml"
  , $Be = "100%"
  , LBe = "100%"
  , jBe = "border:0;margin:0;"
  , BBe = "margin:0"
  , zBe = "allow-top-navigation-by-user-activation allow-popups"
  , FBe = 'The "iframe" tag is not supported by your browser.'
  , NBe = ["foreignobject"]
  , UBe = ["dominant-baseline"];
function tP(e) {
    const t = eP(e);
    return V0(),
    aTe(t.config ?? {}),
    t
}
U(tP, "processAndSetConfigs");
async function m7(e, t) {
    uS();
    try {
        const {code: n, config: r} = tP(e);
        return {
            diagramType: (await y7(n)).type,
            config: r
        }
    } catch (n) {
        if (t?.suppressErrors)
            return !1;
        throw n
    }
}
U(m7, "parse");
var b5 = U( (e, t, n=[]) => `
.${e} ${t} { ${n.join(" !important; ")} !important; }`, "cssImportantStyles")
  , VBe = U( (e, t=new Map) => {
    let n = "";
    if (e.themeCSS !== void 0 && (n += `
${e.themeCSS}`),
    e.fontFamily !== void 0 && (n += `
:root { --mermaid-font-family: ${e.fontFamily}}`),
    e.altFontFamily !== void 0 && (n += `
:root { --mermaid-alt-font-family: ${e.altFontFamily}}`),
    t instanceof Map) {
        const a = e.htmlLabels ?? e.flowchart?.htmlLabels ? ["> *", "span"] : ["rect", "polygon", "ellipse", "circle", "path"];
        t.forEach(s => {
            m5(s.styles) || a.forEach(c => {
                n += b5(s.id, c, s.styles)
            }
            ),
            m5(s.textStyles) || (n += b5(s.id, "tspan", (s?.textStyles || []).map(c => c.replace("color", "fill"))))
        }
        )
    }
    return n
}
, "createCssStyles")
  , HBe = U( (e, t, n, r) => {
    const i = VBe(e, n)
      , o = _Te(t, i, e.themeVariables);
    return F_(oLe(`${r}{${o}}`), sLe)
}
, "createUserStyles")
  , qBe = U( (e="", t, n) => {
    let r = e;
    return !n && !t && (r = r.replace(/marker-end="url\([\d+./:=?A-Za-z-]*?#/g, 'marker-end="url(#')),
    r = cd(r),
    r = r.replace(/<br>/g, "<br/>"),
    r
}
, "cleanUpSvgCode")
  , WBe = U( (e="", t) => {
    const n = t?.viewBox?.baseVal?.height ? t.viewBox.baseVal.height + "px" : LBe
      , r = p7(`<body style="${BBe}">${e}</body>`);
    return `<iframe style="width:${$Be};height:${n};${jBe}" src="data:text/html;charset=UTF-8;base64,${r}" sandbox="${zBe}">
  ${FBe}
</iframe>`
}
, "putIntoIFrame")
  , x5 = U( (e, t, n, r, i) => {
    const o = e.append("div");
    o.attr("id", n),
    r && o.attr("style", r);
    const a = o.append("svg").attr("id", t).attr("width", "100%").attr("xmlns", DBe);
    return i && a.attr("xmlns:xlink", i),
    a.append("g"),
    e
}
, "appendDivSvgG");
function W_(e, t) {
    return e.append("iframe").attr("id", t).attr("style", "width: 100%; height: 100%;").attr("sandbox", "")
}
U(W_, "sandboxedIframe");
var GBe = U( (e, t, n, r) => {
    e.getElementById(t)?.remove(),
    e.getElementById(n)?.remove(),
    e.getElementById(r)?.remove()
}
, "removeExistingElements")
  , YBe = U(async function(e, t, n) {
    uS();
    const r = tP(t);
    t = r.code;
    const i = Mi();
    Qe.debug(i),
    t.length > (i?.maxTextSize ?? ABe) && (t = MBe);
    const o = "#" + e
      , a = "i" + e
      , s = "#" + a
      , c = "d" + e
      , u = "#" + c
      , f = U( () => {
        const B = En(m ? s : u).node();
        B && "remove"in B && B.remove()
    }
    , "removeTempElements");
    let h = En("body");
    const m = i.securityLevel === PBe
      , y = i.securityLevel === RBe
      , b = i.fontFamily;
    if (n !== void 0) {
        if (n && (n.innerHTML = ""),
        m) {
            const M = W_(En(n), a);
            h = En(M.nodes()[0].contentDocument.body),
            h.node().style.margin = 0
        } else
            h = En(n);
        x5(h, e, c, `font-family: ${b}`, OBe)
    } else {
        if (GBe(document, e, c, a),
        m) {
            const M = W_(En("body"), a);
            h = En(M.nodes()[0].contentDocument.body),
            h.node().style.margin = 0
        } else
            h = En("body");
        x5(h, e, c)
    }
    let v, S;
    try {
        v = await q_.fromText(t, {
            title: r.title
        })
    } catch (M) {
        if (i.suppressErrorRendering)
            throw f(),
            M;
        v = await q_.fromText("error"),
        S = M
    }
    const C = h.select(u).node()
      , w = v.type
      , k = C.firstChild
      , T = k.firstChild
      , E = v.renderer.getClasses?.(t, v)
      , P = HBe(i, w, E, o)
      , D = document.createElement("style");
    D.innerHTML = P,
    k.insertBefore(D, T);
    try {
        await v.renderer.draw(t, e, zB.version, v)
    } catch (M) {
        throw i.suppressErrorRendering ? f() : $je.draw(t, e, zB.version),
        M
    }
    const $ = h.select(`${u} svg`)
      , z = v.db.getAccTitle?.()
      , O = v.db.getAccDescription?.();
    b7(w, $, z, O),
    h.select(`[id="${e}"]`).selectAll("foreignobject > *").attr("xmlns", IBe);
    let I = h.select(u).node().innerHTML;
    if (Qe.debug("config.arrowMarkerAbsolute", i.arrowMarkerAbsolute),
    I = qBe(I, m, oi(i.arrowMarkerAbsolute)),
    m) {
        const M = h.select(u + " svg").node();
        I = WBe(I, M)
    } else
        y || (I = Xf.sanitize(I, {
            ADD_TAGS: NBe,
            ADD_ATTR: UBe,
            HTML_INTEGRATION_POINTS: {
                foreignobject: !0
            }
        }));
    if (wBe(),
    S)
        throw S;
    return f(),
    {
        diagramType: w,
        svg: I,
        bindFunctions: v.db.bindFunctions
    }
}, "render");
function g7(e={}) {
    const t = ri({}, e);
    t?.fontFamily && !t.themeVariables?.fontFamily && (t.themeVariables || (t.themeVariables = {}),
    t.themeVariables.fontFamily = t.fontFamily),
    iTe(t),
    t?.theme && t.theme in xl ? t.themeVariables = xl[t.theme].getThemeVariables(t.themeVariables) : t && (t.themeVariables = xl.default.getThemeVariables(t.themeVariables));
    const n = typeof t == "object" ? rTe(t) : x8();
    eM(n.logLevel),
    uS()
}
U(g7, "initialize");
var y7 = U( (e, t={}) => {
    const {code: n} = eP(e);
    return q_.fromText(n, t)
}
, "getDiagramFromText");
function b7(e, t, n, r) {
    d7(t, e),
    f7(t, n, r, t.attr("id"))
}
U(b7, "addA11yInfo");
var ed = Object.freeze({
    render: YBe,
    parse: m7,
    getDiagramFromText: y7,
    initialize: g7,
    getConfig: Mi,
    setConfig: v8,
    getSiteConfig: x8,
    updateSiteConfig: oTe,
    reset: U( () => {
        V0()
    }
    , "reset"),
    globalReset: U( () => {
        V0(Jf)
    }
    , "globalReset"),
    defaultConfig: Jf
});
eM(Mi().logLevel);
V0(Mi());
var ZBe = U( (e, t, n) => {
    Qe.warn(e),
    LM(e) ? (n && n(e.str, e.hash),
    t.push({
        ...e,
        message: e.str,
        error: e
    })) : (n && n(e),
    e instanceof Error && t.push({
        str: e.message,
        message: e.message,
        hash: e.name,
        error: e
    }))
}
, "handleError")
  , x7 = U(async function(e={
    querySelector: ".mermaid"
}) {
    try {
        await QBe(e)
    } catch (t) {
        if (LM(t) && Qe.error(t.str),
        El.parseError && El.parseError(t),
        !e.suppressErrors)
            throw Qe.error("Use the suppressErrors option to suppress these errors"),
            t
    }
}, "run")
  , QBe = U(async function({postRenderCallback: e, querySelector: t, nodes: n}={
    querySelector: ".mermaid"
}) {
    const r = ed.getConfig();
    Qe.debug(`${e ? "" : "No "}Callback function found`);
    let i;
    if (n)
        i = n;
    else if (t)
        i = document.querySelectorAll(t);
    else
        throw new Error("Nodes and querySelector are both undefined");
    Qe.debug(`Found ${i.length} diagrams`),
    r?.startOnLoad !== void 0 && (Qe.debug("Start On Load: " + r?.startOnLoad),
    ed.updateSiteConfig({
        startOnLoad: r?.startOnLoad
    }));
    const o = new Na.InitIDGenerator(r.deterministicIds,r.deterministicIDSeed);
    let a;
    const s = [];
    for (const c of Array.from(i)) {
        if (Qe.info("Rendering diagram: " + c.id),
        c.getAttribute("data-processed"))
            continue;
        c.setAttribute("data-processed", "true");
        const u = `mermaid-${o.next()}`;
        a = c.innerHTML,
        a = FH(Na.entityDecode(a)).trim().replace(/<br\s*\/?>/gi, "<br/>");
        const f = Na.detectInit(a);
        f && Qe.debug("Detected early reinit: ", f);
        try {
            const {svg: h, bindFunctions: m} = await w7(u, a, c);
            c.innerHTML = h,
            e && await e(u),
            m && m(c)
        } catch (h) {
            ZBe(h, s, El.parseError)
        }
    }
    if (s.length > 0)
        throw s[0]
}, "runThrowsErrors")
  , v7 = U(function(e) {
    ed.initialize(e)
}, "initialize")
  , KBe = U(async function(e, t, n) {
    Qe.warn("mermaid.init is deprecated. Please use run instead."),
    e && v7(e);
    const r = {
        postRenderCallback: n,
        querySelector: ".mermaid"
    };
    typeof t == "string" ? r.querySelector = t : t && (t instanceof HTMLElement ? r.nodes = [t] : r.nodes = t),
    await x7(r)
}, "init")
  , XBe = U(async (e, {lazyLoad: t=!0}={}) => {
    uS(),
    KT(...e),
    t === !1 && await SBe()
}
, "registerExternalDiagrams")
  , S7 = U(function() {
    if (El.startOnLoad) {
        const {startOnLoad: e} = ed.getConfig();
        e && El.run().catch(t => Qe.error("Mermaid failed to initialize", t))
    }
}, "contentLoaded");
typeof document < "u" && window.addEventListener("load", S7, !1);
var JBe = U(function(e) {
    El.parseError = e
}, "setParseErrorHandler")
  , Cv = []
  , f2 = !1
  , C7 = U(async () => {
    if (!f2) {
        for (f2 = !0; Cv.length > 0; ) {
            const e = Cv.shift();
            if (e)
                try {
                    await e()
                } catch (t) {
                    Qe.error("Error executing queue", t)
                }
        }
        f2 = !1
    }
}
, "executeQueue")
  , eze = U(async (e, t) => new Promise( (n, r) => {
    const i = U( () => new Promise( (o, a) => {
        ed.parse(e, t).then(s => {
            o(s),
            n(s)
        }
        , s => {
            Qe.error("Error parsing", s),
            El.parseError?.(s),
            a(s),
            r(s)
        }
        )
    }
    ), "performCall");
    Cv.push(i),
    C7().catch(r)
}
), "parse")
  , w7 = U( (e, t, n) => new Promise( (r, i) => {
    const o = U( () => new Promise( (a, s) => {
        ed.render(e, t, n).then(c => {
            a(c),
            r(c)
        }
        , c => {
            Qe.error("Error parsing", c),
            El.parseError?.(c),
            s(c),
            i(c)
        }
        )
    }
    ), "performCall");
    Cv.push(o),
    C7().catch(i)
}
), "render")
  , tze = U( () => Object.keys(Yu).map(e => ({
    id: e
})), "getRegisteredDiagramsMetadata")
  , El = {
    startOnLoad: !0,
    mermaidAPI: ed,
    parse: eze,
    render: w7,
    init: KBe,
    run: x7,
    registerExternalDiagrams: XBe,
    registerLayoutLoaders: PW,
    initialize: v7,
    parseError: void 0,
    contentLoaded: S7,
    setParseErrorHandler: JBe,
    detectType: tM,
    registerIconPacks: kIe,
    getRegisteredDiagramsMetadata: tze
}
  , h2 = El;
/*! Check if previously processed */
/*!
 * Wait for document loaded before starting the execution
 */
let v5 = !1;
const k7 = ({chart: e, config: t, className: n, style: r}) => {
    const i = A.useId().replace(/:/g, "")
      , o = A.useRef(null);
    return A.useEffect( () => {
        const a = {
            startOnLoad: !1,
            securityLevel: "loose",
            theme: "default",
            themeVariables: {
                fontSize: "12px",
                lineColor: "#333",
                axisTextColor: "#333",
                axisTextSize: "10px",
                xAxisLabelAngle: 45
            }
        };
        v5 ? t && h2.initialize({
            ...a,
            ...t || {}
        }) : (h2.initialize({
            ...a,
            ...t || {}
        }),
        v5 = !0);
        let s = !1;
        return (async () => {
            if (o.current) {
                o.current.innerHTML = "";
                try {
                    const {svg: u} = await h2.render(`mmd-${i}`, e);
                    !s && o.current && (o.current.innerHTML = u)
                } catch (u) {
                    o.current && (o.current.innerHTML = `<pre style="color:#d32f2f">${String(u)}</pre>`)
                }
            }
        }
        )(),
        () => {
            s = !0
        }
    }
    , [e, t, i]),
    g.jsx("div", {
        ref: o,
        className: n,
        style: {
            overflowX: "auto",
            maxWidth: "100%",
            ...r
        }
    })
}
;
function nze({children: e, mermaidConfig: t}) {
    return g.jsx(Be, {
        sx: {
            width: "100%"
        },
        children: g.jsx(o8, {
            components: {
                code({inline: n, className: r, children: i, ...o}) {
                    const a = String(i).trim()
                      , s = (r || "").replace("language-", "");
                    return !n && (s === "mermaid" || a.startsWith("%%{")) ? g.jsx(Be, {
                        sx: {
                            my: 2
                        },
                        children: g.jsx(k7, {
                            chart: a,
                            config: {
                                startOnLoad: !0,
                                ...t || {}
                            }
                        })
                    }) : g.jsx(Be, {
                        component: "code",
                        sx: {
                            bgcolor: "action.hover",
                            px: .75,
                            py: .25,
                            borderRadius: 1,
                            fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
                            fontSize: "0.85rem"
                        },
                        ...o,
                        children: i
                    })
                },
                p: ({node: n, ...r}) => g.jsx(Ae, {
                    variant: "body2",
                    sx: {
                        mb: 1
                    },
                    ...r
                }),
                ul: ({node: n, ...r}) => g.jsx(Be, {
                    component: "ul",
                    sx: {
                        pl: 3,
                        mb: 1
                    },
                    ...r
                }),
                ol: ({node: n, ...r}) => g.jsx(Be, {
                    component: "ol",
                    sx: {
                        pl: 3,
                        mb: 1
                    },
                    ...r
                }),
                li: ({node: n, ...r}) => g.jsx(Ae, {
                    component: "li",
                    variant: "body2",
                    sx: {
                        mb: .5
                    },
                    ...r
                })
            },
            children: e
        })
    })
}
const rze = `
\`\`\`mermaid
%%{init: {'theme': 'forest', 'themeVariables': { 'fontSize': '14px'}}}%%
xychart-beta
    title "Monthly Sales Trend"
    x-axis [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]
    y-axis "Sales ($ millions)" 0 --> 5
    line "Product A" [2.1, 2.3, 2.8, 2.6, 3.1, 3.4, 3.7, 3.9, 4.0, 4.2, 4.4, 4.5]
    line "Product B" [1.8, 2.0, 2.3, 2.4, 2.7, 3.0, 3.2, 3.3, 3.4, 3.6, 3.8, 4.0]
`;
function ize() {
    return g.jsx(nze, {
        children: rze
    })
}
function oze() {
    const {notifications: e, clearNotifications: t} = bA();
    return g.jsxs("div", {
        className: "p-4",
        children: [g.jsx(Ae, {
            variant: "h5",
            children: "Notification History"
        }), g.jsx(Fu, {
            children: e.map(n => g.jsxs("div", {
                children: [g.jsx(HE, {
                    children: g.jsxs(Ae, {
                        variant: "body2",
                        children: ["[", n.timestamp.toLocaleTimeString(), "] ", n.message]
                    })
                }), g.jsx(Wm, {})]
            }, n.id))
        }), g.jsx(Mt, {
            onClick: t,
            variant: "contained",
            color: "secondary",
            children: "Clear All"
        })]
    })
}
const ul = {
    avatarUrl: "/static/images/avatar/1.jpg",
    name: "Sanjana Adepu",
    email: "sanjana@example.com",
    dob: "2002-06-15",
    phone: "+91-9876543210",
    address: "IIT Hyderabad, Kandi, Telangana",
    occupation: "UI/UX Designer",
    gender: "Female"
};
function aze() {
    const e = Os();
    return g.jsxs(je, {
        container: !0,
        spacing: 4,
        children: [g.jsxs(je, {
            size: {
                xs: 12,
                md: 4
            },
            sx: {
                textAlign: "center"
            },
            children: [g.jsx(zu, {
                alt: ul.name,
                src: ul.avatarUrl,
                sx: {
                    width: "20vw",
                    height: "20vw",
                    mx: "auto"
                }
            }), g.jsx(Ae, {
                variant: "h6",
                mt: 2,
                children: ul.name
            })]
        }), g.jsx(je, {
            size: {
                xs: 12,
                md: 8
            },
            children: g.jsxs(Be, {
                children: [g.jsx(nf, {
                    label: "Email",
                    value: ul.email
                }), g.jsx(nf, {
                    label: "Date of Birth",
                    value: ul.dob
                }), g.jsx(nf, {
                    label: "Phone",
                    value: ul.phone
                }), g.jsx(nf, {
                    label: "Address",
                    value: ul.address
                }), g.jsx(nf, {
                    label: "Occupation",
                    value: ul.occupation
                }), g.jsx(nf, {
                    label: "Gender",
                    value: ul.gender
                }), g.jsx(Mt, {
                    variant: "contained",
                    color: "primary",
                    sx: {
                        mt: 2
                    },
                    startIcon: g.jsx(rg, {}),
                    onClick: () => e("/profile/update"),
                    children: "Edit"
                })]
            })
        })]
    })
}
function nf({label: e, value: t}) {
    return t ? g.jsxs(Be, {
        mb: 2,
        children: [g.jsx(Ae, {
            variant: "subtitle2",
            color: "text.secondary",
            children: e
        }), g.jsx(Ae, {
            variant: "body1",
            children: t
        }), g.jsx(Wm, {
            sx: {
                mt: 1
            }
        })]
    }) : null
}
const sze = {
    avatarUrl: "/static/images/avatar/1.jpg",
    name: "Sanjana Adepu",
    email: "sanjana@example.com",
    dob: "2002-06-15",
    phone: "+91-9876543210",
    address: "IIT Hyderabad, Kandi, Telangana",
    occupation: "UI/UX Designer",
    gender: "Female"
};
function lze() {
    const [e,t] = A.useState(sze)
      , {addNotification: n} = bA()
      , r = Os()
      , i = a => {
        const s = a.target.files?.[0];
        if (s) {
            const c = new FileReader;
            c.onload = () => {
                t(u => ({
                    ...u,
                    avatarUrl: c.result
                }))
            }
            ,
            c.readAsDataURL(s)
        }
    }
      , o = a => {
        t({
            ...e,
            [a.target.name]: a.target.value
        })
    }
    ;
    return g.jsxs(je, {
        container: !0,
        spacing: 4,
        children: [g.jsxs(je, {
            size: {
                xs: 12,
                md: 4
            },
            sx: {
                textAlign: "center"
            },
            children: [g.jsx(zu, {
                alt: e.name,
                src: e.avatarUrl,
                sx: {
                    width: "20vw",
                    height: "20vw",
                    mx: "auto"
                }
            }), g.jsxs(Mt, {
                variant: "outlined",
                component: "label",
                sx: {
                    mt: 2
                },
                children: ["Change Picture", g.jsx("input", {
                    type: "file",
                    accept: "image/*",
                    hidden: !0,
                    onChange: i
                })]
            })]
        }), g.jsxs(je, {
            size: {
                xs: 12,
                md: 8
            },
            children: [g.jsx(ct, {
                label: "Name",
                name: "name",
                value: e.name,
                onChange: o,
                fullWidth: !0,
                margin: "normal"
            }), g.jsx(ct, {
                label: "Email",
                name: "email",
                value: e.email,
                onChange: o,
                fullWidth: !0,
                margin: "normal"
            }), g.jsx(ct, {
                fullWidth: !0,
                label: "Date of Birth",
                name: "dob",
                type: "date",
                margin: "normal",
                slotProps: {
                    inputLabel: {
                        shrink: !0
                    }
                },
                value: e.dob,
                onChange: o
            }), g.jsx(ct, {
                fullWidth: !0,
                label: "Mobile Number",
                name: "phone",
                type: "tel",
                margin: "normal",
                slotProps: {
                    inputLabel: {
                        shrink: !0
                    },
                    input: {
                        inputProps: {
                            maxLength: 10,
                            inputMode: "numeric",
                            pattern: "[0-9]*"
                        }
                    }
                },
                value: e.phone,
                onChange: o
            }), g.jsx(ct, {
                label: "Address",
                name: "address",
                value: e.address,
                onChange: o,
                fullWidth: !0,
                margin: "normal"
            }), g.jsx(ct, {
                label: "Occupation",
                name: "occupation",
                value: e.occupation,
                onChange: o,
                fullWidth: !0,
                margin: "normal"
            }), g.jsx(ct, {
                label: "Gender",
                name: "gender",
                value: e.gender,
                onChange: o,
                fullWidth: !0,
                margin: "normal"
            })]
        }), g.jsx(je, {
            size: 12,
            sx: {
                textAlign: "center",
                mt: 2
            },
            children: g.jsx(Mt, {
                type: "submit",
                variant: "contained",
                color: "primary",
                onClick: () => {
                    r("/profile"),
                    n("Profile updated successfully!", "success")
                }
                ,
                children: "Update"
            })
        })]
    })
}
const cze = Xg({
    productName: On().min(1, "Product Name is required").max(100, "Product Name cannot exceed 100 characters"),
    productDescription: On().min(1, "Product Description is required").max(500, "Product Description cannot exceed 500 characters"),
    productCategory: On().optional().nullable().transform(e => e === "" ? null : e),
    productGroup: On().optional().nullable().transform(e => e === "" ? null : e),
    price: gl().min(0, "Price cannot be negative").optional().nullable().or(On().regex(/^\d+(\.\d{1,2})?$/, "Invalid price format").transform(e => e ? parseFloat(e) : null))
})
  , uze = (e, t, n) => {
    const r = e.target.value;
    r && !/^\d+(\.\d{0,2})?$/.test(r) && n(t, {
        type: "manual",
        message: "Please enter a valid number with up to 2 decimal places"
    })
}
  , dze = {
    productName: "",
    productDescription: "",
    productCategory: "",
    productGroup: "",
    price: null
}
  , fze = ({onCancel: e, onSubmit: t, initialData: n=dze, isSubmitting: r=!1}) => {
    const i = MA({
        resolver: LA(cze),
        defaultValues: n,
        mode: "onTouched"
    })
      , {control: o, handleSubmit: a, reset: s, formState: c, setError: u} = i
      , {errors: f} = c
      , h = [{
        value: "electronics",
        label: "Electronics"
    }, {
        value: "clothing",
        label: "Clothing"
    }, {
        value: "furniture",
        label: "Furniture"
    }, {
        value: "groceries",
        label: "Groceries"
    }]
      , m = [{
        value: "consumer",
        label: "Consumer Products"
    }, {
        value: "industrial",
        label: "Industrial Products"
    }, {
        value: "premium",
        label: "Premium Products"
    }, {
        value: "budget",
        label: "Budget Products"
    }];
    return g.jsxs(yn, {
        sx: {
            p: 3
        },
        children: [g.jsxs(Be, {
            mb: 3,
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            children: [g.jsx(Ae, {
                variant: "h5",
                children: "Add New Product"
            }), g.jsx(Mt, {
                variant: "outlined",
                onClick: e,
                size: "small",
                sx: {
                    borderRadius: "8px",
                    minWidth: "100px"
                },
                children: "Back"
            })]
        }), g.jsx(TA, {
            ...i,
            children: g.jsx("form", {
                onSubmit: a(t),
                children: g.jsxs(je, {
                    container: !0,
                    spacing: 2,
                    children: [g.jsx(je, {
                        size: {
                            xs: 12
                        },
                        children: g.jsx(Ae, {
                            variant: "body1",
                            gutterBottom: !0,
                            children: "Product Details"
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6
                        },
                        children: g.jsx(un, {
                            name: "productName",
                            control: o,
                            render: ({field: y}) => g.jsx(ct, {
                                ...y,
                                label: "Product Name *",
                                fullWidth: !0,
                                size: "small",
                                error: !!f.productName,
                                helperText: f.productName?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6
                        },
                        children: g.jsx(un, {
                            name: "productCategory",
                            control: o,
                            render: ({field: y}) => g.jsxs(x0, {
                                fullWidth: !0,
                                size: "small",
                                children: [g.jsx(S0, {
                                    id: "product-category-label",
                                    children: "Product Category"
                                }), g.jsxs(Gm, {
                                    ...y,
                                    labelId: "product-category-label",
                                    label: "Product Category",
                                    value: y.value || "",
                                    error: !!f.productCategory,
                                    children: [g.jsx(Yr, {
                                        value: "",
                                        children: g.jsx("em", {
                                            children: "None"
                                        })
                                    }), h.map(b => g.jsx(Yr, {
                                        value: b.value,
                                        children: b.label
                                    }, b.value))]
                                })]
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6
                        },
                        children: g.jsx(un, {
                            name: "productGroup",
                            control: o,
                            render: ({field: y}) => g.jsxs(x0, {
                                fullWidth: !0,
                                size: "small",
                                children: [g.jsx(S0, {
                                    id: "product-group-label",
                                    children: "Product Group"
                                }), g.jsxs(Gm, {
                                    ...y,
                                    labelId: "product-group-label",
                                    label: "Product Group",
                                    value: y.value || "",
                                    error: !!f.productGroup,
                                    children: [g.jsx(Yr, {
                                        value: "",
                                        children: g.jsx("em", {
                                            children: "None"
                                        })
                                    }), m.map(b => g.jsx(Yr, {
                                        value: b.value,
                                        children: b.label
                                    }, b.value))]
                                })]
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6
                        },
                        children: g.jsx(un, {
                            name: "price",
                            control: o,
                            render: ({field: y}) => g.jsx(ct, {
                                ...y,
                                label: "Price",
                                fullWidth: !0,
                                size: "small",
                                type: "text",
                                value: y.value === null ? "" : y.value,
                                error: !!f.price,
                                helperText: f.price?.message,
                                inputProps: {
                                    step: "0.01",
                                    pattern: "^\\d+(\\.\\d{1,2})?$",
                                    title: "Enter a valid price with up to 2 decimal places"
                                },
                                onChange: b => {
                                    y.onChange(b),
                                    uze(b, "price", u)
                                }
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12
                        },
                        children: g.jsx(un, {
                            name: "productDescription",
                            control: o,
                            render: ({field: y}) => g.jsx(ct, {
                                ...y,
                                label: "Product Description *",
                                fullWidth: !0,
                                size: "small",
                                multiline: !0,
                                rows: 3,
                                error: !!f.productDescription,
                                helperText: f.productDescription?.message
                            })
                        })
                    }), g.jsxs(je, {
                        size: {
                            xs: 12
                        },
                        sx: {
                            mt: 2
                        },
                        children: [g.jsx(Mt, {
                            variant: "contained",
                            type: "submit",
                            disabled: r,
                            size: "small",
                            sx: {
                                borderRadius: "8px",
                                minWidth: "100px"
                            },
                            children: r ? g.jsx(Jr, {
                                size: 20,
                                color: "inherit"
                            }) : "Submit"
                        }), g.jsx(Mt, {
                            variant: "outlined",
                            onClick: () => s(n),
                            disabled: r,
                            size: "small",
                            sx: {
                                ml: 2,
                                borderRadius: "8px",
                                minWidth: "100px"
                            },
                            children: "Reset"
                        })]
                    })]
                })
            })
        })]
    })
}
  , hze = [{
    id: 1,
    name: "Laptop",
    description: "High-performance laptop",
    category: "electronics",
    group: "premium",
    price: 1200
}, {
    id: 2,
    name: "T-Shirt",
    description: "Cotton t-shirt",
    category: "clothing",
    group: "budget",
    price: 25
}, {
    id: 3,
    name: "Coffee Table",
    description: "Wooden coffee table",
    category: "furniture",
    group: "consumer",
    price: 150
}];
function pze() {
    const [e,t] = A.useState([])
      , [n,r] = A.useState(!1)
      , [i,o] = A.useState(!1)
      , [a,s] = A.useState(!0)
      , [c,u] = A.useState("asc")
      , [f,h] = A.useState("name")
      , [m,y] = A.useState(0)
      , [b,v] = A.useState(5)
      , [S,C] = A.useState("")
      , [w,k] = A.useState(!1)
      , [T,E] = A.useState("")
      , [P,D] = A.useState("success");
    bt.useEffect( () => {
        (async () => {
            s(!0);
            try {
                await new Promise(H => setTimeout(H, 1500)),
                t(hze)
            } catch (H) {
                console.error("Error fetching products:", H),
                E("Failed to load products"),
                D("error"),
                k(!0)
            } finally {
                s(!1)
            }
        }
        )()
    }
    , []);
    const $ = N => {
        o(!0),
        setTimeout( () => {
            try {
                const H = {
                    id: e.length > 0 ? Math.max(...e.map(Z => Z.id)) + 1 : 1,
                    name: N.productName,
                    description: N.productDescription,
                    category: N.productCategory || void 0,
                    group: N.productGroup || void 0,
                    price: N.price || void 0
                };
                t([...e, H]),
                E("Product added successfully!"),
                D("success"),
                k(!0),
                r(!1)
            } catch {
                E("Failed to add product."),
                D("error"),
                k(!0)
            } finally {
                o(!1)
            }
        }
        , 1e3)
    }
      , z = N => {
        u(f === N && c === "asc" ? "desc" : "asc"),
        h(N)
    }
    ;
    function O(N, H) {
        return N === "desc" ? (Z, q) => I(Z, q, H) : (Z, q) => -I(Z, q, H)
    }
    function I(N, H, Z) {
        const q = N[Z]
          , V = H[Z];
        return V < q ? -1 : V > q ? 1 : 0
    }
    const M = e.filter(N => N.name.toLowerCase().includes(S.toLowerCase()) || N.description.toLowerCase().includes(S.toLowerCase()) || N.category && N.category.toLowerCase().includes(S.toLowerCase()) || N.group && N.group.toLowerCase().includes(S.toLowerCase())).sort(O(c, f))
      , B = (N, H) => {
        y(H)
    }
      , L = N => {
        v(parseInt(N.target.value, 10)),
        y(0)
    }
      , F = M.slice(m * b, m * b + b)
      , j = () => Array(b).fill(0).map( (N, H) => g.jsxs(gn, {
        children: [g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "70%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "90%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "50%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "40%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "30%",
                height: 24,
                animation: "wave"
            })
        })]
    }, `skeleton-${H}`));
    return g.jsxs(Be, {
        children: [g.jsx(hh, {
            open: w,
            autoHideDuration: 4e3,
            onClose: () => k(!1),
            anchorOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            children: g.jsx(Mc, {
                onClose: () => k(!1),
                severity: P,
                sx: {
                    width: "100%"
                },
                children: T
            })
        }), n ? g.jsx(Be, {
            p: 2,
            children: g.jsx(fze, {
                onCancel: () => r(!1),
                onSubmit: $,
                isSubmitting: i
            })
        }) : g.jsx(Be, {
            children: g.jsxs(Be, {
                p: 2,
                children: [g.jsx(Ae, {
                    variant: "h5",
                    gutterBottom: !0,
                    children: "Products"
                }), g.jsxs(Be, {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    mb: 2,
                    children: [g.jsx(ct, {
                        label: "Search",
                        variant: "outlined",
                        size: "small",
                        value: S,
                        onChange: N => {
                            C(N.target.value),
                            y(0)
                        }
                        ,
                        sx: {
                            width: 250
                        },
                        disabled: a,
                        InputProps: {
                            endAdornment: a && g.jsx(Jr, {
                                color: "inherit",
                                size: 20
                            })
                        }
                    }), g.jsx(Mt, {
                        variant: "contained",
                        startIcon: a ? g.jsx(Jr, {
                            size: 20,
                            color: "inherit"
                        }) : g.jsx(Go, {}),
                        size: "small",
                        sx: {
                            borderRadius: "8px",
                            minWidth: "100px"
                        },
                        onClick: () => r(!0),
                        disabled: a,
                        children: "Add New"
                    })]
                }), g.jsxs(Ha, {
                    component: yn,
                    children: [g.jsxs(Ua, {
                        size: "small",
                        children: [g.jsx(qa, {
                            children: g.jsxs(gn, {
                                children: [g.jsx(Me, {
                                    sx: {
                                        py: 1.5,
                                        fontWeight: 600
                                    },
                                    children: a ? g.jsx(Fn, {
                                        variant: "text",
                                        width: "70%",
                                        height: 24,
                                        animation: "wave"
                                    }) : g.jsx(Fi, {
                                        active: f === "name",
                                        direction: f === "name" ? c : "asc",
                                        onClick: () => z("name"),
                                        disabled: a,
                                        children: "Name"
                                    })
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1.5,
                                        fontWeight: 600
                                    },
                                    children: a ? g.jsx(Fn, {
                                        variant: "text",
                                        width: "70%",
                                        height: 24,
                                        animation: "wave"
                                    }) : g.jsx(Fi, {
                                        active: f === "description",
                                        direction: f === "description" ? c : "asc",
                                        onClick: () => z("description"),
                                        disabled: a,
                                        children: "Description"
                                    })
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1.5,
                                        fontWeight: 600
                                    },
                                    children: a ? g.jsx(Fn, {
                                        variant: "text",
                                        width: "70%",
                                        height: 24,
                                        animation: "wave"
                                    }) : g.jsx(Fi, {
                                        active: f === "category",
                                        direction: f === "category" ? c : "asc",
                                        onClick: () => z("category"),
                                        disabled: a,
                                        children: "Category"
                                    })
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1.5,
                                        fontWeight: 600
                                    },
                                    children: a ? g.jsx(Fn, {
                                        variant: "text",
                                        width: "70%",
                                        height: 24,
                                        animation: "wave"
                                    }) : g.jsx(Fi, {
                                        active: f === "group",
                                        direction: f === "group" ? c : "asc",
                                        onClick: () => z("group"),
                                        disabled: a,
                                        children: "Group"
                                    })
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1.5,
                                        fontWeight: 600
                                    },
                                    children: a ? g.jsx(Fn, {
                                        variant: "text",
                                        width: "70%",
                                        height: 24,
                                        animation: "wave"
                                    }) : g.jsx(Fi, {
                                        active: f === "price",
                                        direction: f === "price" ? c : "asc",
                                        onClick: () => z("price"),
                                        disabled: a,
                                        children: "Price"
                                    })
                                })]
                            })
                        }), g.jsxs(Va, {
                            children: [a ? j() : F.map(N => g.jsxs(gn, {
                                sx: {
                                    "&:hover": {
                                        backgroundColor: "#f1f1fa",
                                        cursor: "pointer"
                                    }
                                },
                                children: [g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.name
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.description
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.category || "-"
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.group || "-"
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.price ? `$${N.price.toFixed(2)}` : "-"
                                })]
                            }, N.id)), !a && F.length === 0 && g.jsx(gn, {
                                children: g.jsx(Me, {
                                    colSpan: 5,
                                    align: "center",
                                    sx: {
                                        py: 2
                                    },
                                    children: "No products found."
                                })
                            })]
                        })]
                    }), g.jsx(Bg, {
                        component: "div",
                        count: a ? 0 : M.length,
                        page: m,
                        onPageChange: B,
                        rowsPerPage: b,
                        onRowsPerPageChange: L,
                        rowsPerPageOptions: [5, 10, 25],
                        disabled: a
                    })]
                })]
            })
        })]
    })
}
const p2 = [{
    id: "RN001",
    date: "8/5/2025",
    object: "Material",
    group: "Finished Goods",
    project: "Deduplication",
    owner: "Satya C",
    due: "8/8/2025",
    status: "In-Progress"
}, {
    id: "RN002",
    date: "8/5/2025",
    object: "Material",
    group: "Raw Materials",
    project: "Deduplication",
    owner: "Satya C",
    due: "8/8/2025",
    status: "In-Progress"
}, {
    id: "RN003",
    date: "8/5/2025",
    object: "Material",
    group: "Service Materials",
    project: "Deduplication",
    owner: "Satya C",
    due: "8/8/2025",
    status: "In-Progress"
}, {
    id: "RN004",
    date: "8/5/2025",
    object: "Material",
    group: "Semi-Finished Materials",
    project: "Deduplication",
    owner: "Satya C",
    due: "8/8/2025",
    status: "In-Progress"
}, {
    id: "RN005",
    date: "8/6/2025",
    object: "Vendor",
    group: "North America",
    project: "Deduplication",
    owner: "Hemanth S",
    due: "8/9/2025",
    status: "Closed"
}, {
    id: "RN006",
    date: "8/6/2025",
    object: "Vendor",
    group: "Asia",
    project: "Deduplication",
    owner: "Hemanth S",
    due: "8/9/2025",
    status: "Closed"
}, {
    id: "RN007",
    date: "8/6/2025",
    object: "Vendor",
    group: "South America",
    project: "Deduplication",
    owner: "Hemanth S",
    due: "8/9/2025",
    status: "In-Progress"
}, {
    id: "RN008",
    date: "8/6/2025",
    object: "Vendor",
    group: "EMEA 1",
    project: "Deduplication",
    owner: "Hemanth S",
    due: "8/9/2025",
    status: "In-Progress"
}, {
    id: "RN009",
    date: "8/6/2025",
    object: "Vendor",
    group: "EMEA 2",
    project: "Deduplication",
    owner: "Hemanth S",
    due: "8/9/2025",
    status: "In-Progress"
}]
  , mze = () => {
    const e = Os()
      , t = (n, r, i, o) => {
        e("/workflow", {
            state: {
                workflowId: n,
                date: r,
                description: i + " " + o
            }
        })
    }
    ;
    return g.jsxs(Be, {
        sx: {
            p: {
                xs: 2,
                md: 4
            }
        },
        children: [g.jsx(Ae, {
            variant: "h4",
            fontWeight: "bold",
            mb: 2,
            children: "Welcome to Inventory Application"
        }), g.jsxs(je, {
            container: !0,
            spacing: 3,
            children: [g.jsx(je, {
                size: {
                    xs: 12,
                    md: 4
                },
                children: g.jsx(X2, {
                    sx: {
                        bgcolor: "#1B3F6F",
                        color: "white",
                        borderRadius: 3,
                        boxShadow: 3,
                        height: "90%",
                        display: "flex",
                        flexDirection: "column",
                        justifyContent: "center",
                        alignItems: "center"
                    },
                    children: g.jsxs(J2, {
                        sx: {
                            textAlign: "center",
                            py: 3
                        },
                        children: [g.jsx(Be, {
                            sx: {
                                mb: 2
                            },
                            children: g.jsx(L1e, {
                                sx: {
                                    fontSize: 48,
                                    color: "white"
                                }
                            })
                        }), g.jsx(Ae, {
                            variant: "h6",
                            fontWeight: "bold",
                            gutterBottom: !0,
                            children: "Monitor & Optimize Data"
                        }), g.jsx(Ae, {
                            variant: "body2",
                            sx: {
                                fontSize: "0.95rem",
                                opacity: .9,
                                mb: 2
                            },
                            children: "Real-time insights, AI recommendations, and seamless automation all in one place."
                        }), g.jsx(Mt, {
                            variant: "outlined",
                            size: "small",
                            sx: {
                                color: "white",
                                borderColor: "white",
                                "&:hover": {
                                    borderColor: "white",
                                    bgcolor: "rgba(255,255,255,0.1)"
                                }
                            },
                            children: "Learn More"
                        })]
                    })
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    md: 4
                },
                children: g.jsx(X2, {
                    sx: {
                        bgcolor: "#00AFC0",
                        color: "white",
                        borderRadius: 3,
                        boxShadow: 3,
                        height: "90%",
                        display: "flex",
                        flexDirection: "column",
                        justifyContent: "center",
                        alignItems: "center"
                    },
                    children: g.jsxs(J2, {
                        sx: {
                            textAlign: "center",
                            py: 3
                        },
                        children: [g.jsx(Be, {
                            sx: {
                                mb: 2
                            },
                            children: g.jsx(j1e, {
                                sx: {
                                    fontSize: 48,
                                    color: "white"
                                }
                            })
                        }), g.jsx(Ae, {
                            variant: "h6",
                            fontWeight: "bold",
                            gutterBottom: !0,
                            children: "Workflow Transformation"
                        }), g.jsx(Ae, {
                            variant: "body2",
                            sx: {
                                fontSize: "0.95rem",
                                opacity: .9,
                                mb: 2
                            },
                            children: "Streamline your business processes with AI-powered workflows that drive measurable results."
                        }), g.jsx(Mt, {
                            variant: "outlined",
                            size: "small",
                            sx: {
                                color: "white",
                                borderColor: "white",
                                "&:hover": {
                                    borderColor: "white",
                                    bgcolor: "rgba(255,255,255,0.1)"
                                }
                            },
                            children: "Start Workflow"
                        })]
                    })
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    md: 4
                },
                children: g.jsx(Be, {
                    component: "img",
                    src: "/chat_dash.png",
                    alt: "chat with your database",
                    sx: {
                        width: "100%",
                        height: "90%",
                        objectFit: "cover",
                        borderRadius: "10px",
                        cursor: "pointer",
                        boxShadow: 2
                    },
                    onClick: () => e("/chat")
                })
            })]
        }), g.jsxs(Be, {
            sx: {
                mt: 6
            },
            children: [g.jsx(Be, {
                sx: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    mb: 2
                },
                children: g.jsx(Ae, {
                    variant: "h6",
                    fontWeight: "bold",
                    children: "Active Workflows"
                })
            }), g.jsx(Ha, {
                component: yn,
                sx: {
                    borderRadius: 3,
                    boxShadow: "0 4px 20px rgba(0,0,0,0.08)",
                    overflow: "hidden",
                    transition: "all 0.3s ease"
                },
                children: g.jsxs(Ua, {
                    children: [g.jsx(qa, {
                        sx: {
                            bgcolor: "#f8fafc"
                        },
                        children: g.jsxs(gn, {
                            children: [g.jsx(Me, {
                                sx: {
                                    fontWeight: "bold",
                                    color: "#475569"
                                },
                                children: "RUN ID"
                            }), g.jsx(Me, {
                                sx: {
                                    fontWeight: "bold",
                                    color: "#475569"
                                },
                                children: "Date and Time"
                            }), g.jsx(Me, {
                                sx: {
                                    fontWeight: "bold",
                                    color: "#475569"
                                },
                                children: "Object"
                            }), g.jsx(Me, {
                                sx: {
                                    fontWeight: "bold",
                                    color: "#475569"
                                },
                                children: "Group"
                            }), g.jsx(Me, {
                                sx: {
                                    fontWeight: "bold",
                                    color: "#475569"
                                },
                                children: "Project / Process"
                            }), g.jsx(Me, {
                                sx: {
                                    fontWeight: "bold",
                                    color: "#475569"
                                },
                                children: "Data Owner"
                            }), g.jsx(Me, {
                                sx: {
                                    fontWeight: "bold",
                                    color: "#475569"
                                },
                                children: "Due"
                            }), g.jsx(Me, {
                                sx: {
                                    fontWeight: "bold",
                                    color: "#475569"
                                },
                                children: "Status"
                            })]
                        })
                    }), g.jsx(Va, {
                        children: p2.map(n => g.jsxs(gn, {
                            sx: {
                                transition: "all 0.2s",
                                cursor: "pointer",
                                "&:hover": {
                                    bgcolor: "#f1f8fd",
                                    transform: "translateY(-2px)",
                                    boxShadow: "0 4px 12px rgba(0,0,0,0.05)"
                                }
                            },
                            onClick: () => t(n.id, n.date, n.object, n.group),
                            children: [g.jsx(Me, {
                                sx: {
                                    fontWeight: 500
                                },
                                children: n.id
                            }), g.jsx(Me, {
                                children: n.date
                            }), g.jsx(Me, {
                                children: g.jsxs(Be, {
                                    sx: {
                                        display: "flex",
                                        alignItems: "center",
                                        gap: 1
                                    },
                                    children: [g.jsx(Be, {
                                        sx: {
                                            width: 8,
                                            height: 8,
                                            bgcolor: n.object === "Material" ? "#1976d2" : "#ff9800",
                                            borderRadius: "50%"
                                        }
                                    }), n.object]
                                })
                            }), g.jsx(Me, {
                                children: n.group
                            }), g.jsx(Me, {
                                children: n.project
                            }), g.jsx(Me, {
                                children: n.owner
                            }), g.jsx(Me, {
                                children: g.jsx(Be, {
                                    sx: {
                                        color: new Date(n.due) < new Date ? "#d32f2f" : "inherit",
                                        fontWeight: new Date(n.due) < new Date ? 500 : 400
                                    },
                                    children: n.due
                                })
                            }), g.jsx(Me, {
                                children: g.jsx(Be, {
                                    sx: {
                                        display: "inline-block",
                                        px: 1.5,
                                        py: .5,
                                        borderRadius: 6,
                                        fontSize: "0.75rem",
                                        fontWeight: 600,
                                        textTransform: "uppercase",
                                        backgroundColor: n.status === "Closed" ? "#e5f6ed" : "#e3f2fd",
                                        color: n.status === "Closed" ? "#16a34a" : "#0277bd",
                                        border: 1,
                                        borderColor: n.status === "Closed" ? "#86efac" : "#90caf9",
                                        letterSpacing: "0.5px"
                                    },
                                    children: n.status
                                })
                            })]
                        }, n.id))
                    })]
                })
            }), g.jsxs(Be, {
                sx: {
                    display: "flex",
                    justifyContent: "space-between",
                    mt: 2,
                    alignItems: "center"
                },
                children: [g.jsxs(Ae, {
                    variant: "body2",
                    color: "text.secondary",
                    children: ["Showing ", p2.length, " of ", p2.length, " workflows"]
                }), g.jsxs(Be, {
                    sx: {
                        display: "flex",
                        gap: 1
                    },
                    children: [g.jsx(Mt, {
                        variant: "outlined",
                        size: "small",
                        disabled: !0,
                        sx: {
                            minWidth: "unset",
                            p: "4px 8px"
                        },
                        children: "Previous"
                    }), g.jsx(Mt, {
                        variant: "contained",
                        size: "small",
                        sx: {
                            minWidth: "unset",
                            p: "4px 10px",
                            bgcolor: "#f5f5f5",
                            color: "#000",
                            boxShadow: "none"
                        },
                        children: "1"
                    }), g.jsx(Mt, {
                        variant: "outlined",
                        size: "small",
                        disabled: !0,
                        sx: {
                            minWidth: "unset",
                            p: "4px 8px"
                        },
                        children: "Next"
                    })]
                })]
            })]
        })]
    })
}
  , T7 = () => g.jsx("p", {
    children: "View page"
})
  , $m = [{
    id: 1,
    name: "United States"
}, {
    id: 2,
    name: "Canada"
}, {
    id: 3,
    name: "India"
}]
  , G_ = [{
    id: 1,
    countryId: 1,
    name: "California"
}, {
    id: 2,
    countryId: 1,
    name: "Texas"
}, {
    id: 3,
    countryId: 2,
    name: "Ontario"
}, {
    id: 4,
    countryId: 3,
    name: "Maharashtra"
}]
  , gze = Xg({
    id: gl(),
    countryId: gl().optional().nullable(),
    category: On().optional().nullable(),
    name: On().min(1, "Name is required"),
    taxNumber: On().optional().nullable()
})
  , yze = Xg({
    id: gl(),
    bankName: On().min(1, "Bank Name is required"),
    accountNumber: On().min(1, "Account Number is required").regex(/^[0-9]+$/, "Account Number must contain only digits"),
    routingNumber: On().regex(/^[0-9]*$/, "Routing Number must contain only digits").optional().nullable(),
    accountName: On().optional().nullable(),
    phoneNumber: On().optional().nullable(),
    primary: Zve()
})
  , bze = Xg({
    vendorId: gl().default(0),
    companyName1: On().min(1, "Company Name 1 is required"),
    companyName2: On().min(1, "Company Name 2 is required"),
    dba: On().optional().nullable(),
    keyWord: On().min(1, "Keyword is required"),
    houseNumber: On().min(1, "House Number is required"),
    streetName: On().min(1, "Street Name is required"),
    buildingName: On().optional().nullable(),
    landmark: On().optional().nullable(),
    countryId: gl().nullable(),
    stateId: gl().nullable(),
    zipCode: On().min(1, "Zip Code is required").regex(/^[0-9-\s]+$/, "Zip Code must contain only digits, hyphens, and spaces"),
    digiPin: On().regex(/^[0-9]*$/, "Digi Pin must contain only digits").optional().nullable(),
    mapsUrl: On().optional().nullable(),
    languageId: gl().nullable(),
    phoneNumber1: On().min(1, "Phone Number 1 is required").regex(/^[0-9]*$/, "Phone Number must contain only digits"),
    phoneNumber2: On().regex(/^[0-9]*$/, "Phone Number must contain only digits").optional().nullable(),
    phoneNumber3: On().regex(/^[0-9]*$/, "Phone Number must contain only digits").optional().nullable(),
    fax: On().regex(/^[0-9]*$/, "Fax number must contain only digits").optional().nullable(),
    email1: Pk(),
    email2: Pk().optional().or(Gj("")),
    email3: Pk().optional().or(Gj("")),
    comments: On().optional().nullable(),
    salesStatusId: gl().nullable(),
    paymentId: On().optional().nullable(),
    taxInformationDto: LT(gze).min(1, "Add at least 1 tax record"),
    bankDetailDto: LT(yze).min(1, "Add at least 1 bank record")
})
  , xze = (e, t, n, r, i) => {
    const o = e.target.value;
    o && !t.test(o) && (i(`taxInformationDto.${r}.${n}`, {
        type: "manual",
        message: "Invalid characters detected"
    }),
    e.target.value = o.slice(0, -1))
}
  , S5 = [{
    id: 1,
    name: "United States"
}, {
    id: 2,
    name: "Canada"
}, {
    id: 3,
    name: "India"
}]
  , vze = ({maxRows: e=5}) => {
    const {control: t, formState: n, setError: r} = yh()
      , {errors: i} = n
      , {fields: o, append: a, remove: s} = Q6({
        control: t,
        name: "taxInformationDto"
    });
    return g.jsx(Gf, {
        spacing: 2,
        children: o.map( (c, u) => g.jsxs(je, {
            container: !0,
            spacing: 2,
            children: [g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `taxInformationDto.${u}.countryId`,
                    control: t,
                    render: ({field: f}) => {
                        const h = S5.find(m => m.id === f.value) ?? null;
                        return g.jsx(co, {
                            disablePortal: !0,
                            options: S5,
                            value: h,
                            getOptionLabel: m => m.name,
                            onChange: (m, y) => f.onChange(y ? y.id : null),
                            renderInput: m => g.jsx(ct, {
                                ...m,
                                label: "Country",
                                size: "small",
                                error: !!i?.taxInformationDto?.[u]?.countryId,
                                helperText: i?.taxInformationDto?.[u]?.countryId?.message,
                                fullWidth: !0
                            })
                        })
                    }
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `taxInformationDto.${u}.category`,
                    control: t,
                    render: ({field: f}) => g.jsx(ct, {
                        ...f,
                        label: "Category",
                        size: "small",
                        fullWidth: !0,
                        error: !!i?.taxInformationDto?.[u]?.category,
                        helperText: i?.taxInformationDto?.[u]?.category?.message
                    })
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `taxInformationDto.${u}.name`,
                    control: t,
                    render: ({field: f}) => g.jsx(ct, {
                        ...f,
                        label: "Name",
                        size: "small",
                        fullWidth: !0,
                        error: !!i?.taxInformationDto?.[u]?.name,
                        helperText: i?.taxInformationDto?.[u]?.name?.message
                    })
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `taxInformationDto.${u}.taxNumber`,
                    control: t,
                    render: ({field: f}) => g.jsx(ct, {
                        ...f,
                        label: "Tax Number",
                        size: "small",
                        fullWidth: !0,
                        error: !!i?.taxInformationDto?.[u]?.taxNumber,
                        helperText: i?.taxInformationDto?.[u]?.taxNumber?.message,
                        inputProps: {
                            pattern: "[0-9a-zA-Z\\-]*",
                            title: "Tax Number must contain only alphanumeric characters and hyphens"
                        },
                        onChange: h => {
                            f.onChange(h),
                            xze(h, /^[0-9a-zA-Z\-]*$/, "taxNumber", u, r)
                        }
                        ,
                        onBlur: () => {
                            const h = f.value;
                            h && !/^[0-9a-zA-Z\-]*$/.test(h) && r(`taxInformationDto.${u}.taxNumber`, {
                                type: "manual",
                                message: "Tax Number must contain only alphanumeric characters and hyphens"
                            })
                        }
                    })
                })
            }), g.jsxs(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: [g.jsx(In, {
                    size: "small",
                    color: "primary",
                    onClick: () => o.length < e && a({
                        id: Date.now(),
                        countryId: null,
                        category: "",
                        name: "",
                        taxNumber: ""
                    }),
                    disabled: o.length >= e,
                    sx: {
                        borderRadius: "8px",
                        border: "1px solid",
                        borderColor: "primary.main",
                        mr: 1
                    },
                    children: g.jsx(Go, {
                        fontSize: "small"
                    })
                }), g.jsx(In, {
                    size: "small",
                    color: "error",
                    onClick: () => o.length > 1 && s(u),
                    disabled: o.length === 1,
                    sx: {
                        borderRadius: "8px",
                        border: "1px solid",
                        borderColor: "error.main"
                    },
                    children: g.jsx(D1, {
                        fontSize: "small"
                    })
                })]
            })]
        }, c.id))
    })
}
  , m2 = (e, t, n, r, i) => {
    const o = e.target.value;
    o && !t.test(o) && (i(`bankDetailDto.${r}.${n}`, {
        type: "manual",
        message: "Invalid characters detected"
    }),
    e.target.value = o.slice(0, -1))
}
  , Sze = ({maxRows: e=5}) => {
    const {control: t, formState: n, setError: r} = yh()
      , {errors: i} = n
      , {fields: o, append: a, remove: s} = Q6({
        control: t,
        name: "bankDetailDto"
    });
    return g.jsx(Gf, {
        spacing: 2,
        children: o.map( (c, u) => g.jsxs(je, {
            container: !0,
            spacing: 2,
            children: [g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `bankDetailDto.${u}.bankName`,
                    control: t,
                    render: ({field: f}) => g.jsx(ct, {
                        ...f,
                        size: "small",
                        label: "Bank Name",
                        fullWidth: !0,
                        error: !!i?.bankDetailDto?.[u]?.bankName,
                        helperText: i?.bankDetailDto?.[u]?.bankName?.message
                    })
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `bankDetailDto.${u}.accountNumber`,
                    control: t,
                    render: ({field: f}) => g.jsx(ct, {
                        ...f,
                        size: "small",
                        label: "Account Number",
                        fullWidth: !0,
                        error: !!i?.bankDetailDto?.[u]?.accountNumber,
                        helperText: i?.bankDetailDto?.[u]?.accountNumber?.message,
                        inputProps: {
                            pattern: "[0-9]+",
                            title: "Account Number must contain only digits"
                        },
                        onChange: h => {
                            f.onChange(h),
                            m2(h, /^[0-9]*$/, "accountNumber", u, r)
                        }
                        ,
                        onBlur: () => {
                            const h = f.value;
                            h && !/^[0-9]+$/.test(h) && r(`bankDetailDto.${u}.accountNumber`, {
                                type: "manual",
                                message: "Account Number must contain only digits"
                            })
                        }
                    })
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `bankDetailDto.${u}.routingNumber`,
                    control: t,
                    render: ({field: f}) => g.jsx(ct, {
                        ...f,
                        size: "small",
                        label: "Routing Number",
                        fullWidth: !0,
                        error: !!i?.bankDetailDto?.[u]?.routingNumber,
                        helperText: i?.bankDetailDto?.[u]?.routingNumber?.message,
                        inputProps: {
                            pattern: "[0-9]*",
                            title: "Routing Number must contain only digits"
                        },
                        onChange: h => {
                            f.onChange(h),
                            m2(h, /^[0-9]*$/, "routingNumber", u, r)
                        }
                        ,
                        onBlur: () => {
                            const h = f.value;
                            h && !/^[0-9]*$/.test(h) && r(`bankDetailDto.${u}.routingNumber`, {
                                type: "manual",
                                message: "Routing Number must contain only digits"
                            })
                        }
                    })
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `bankDetailDto.${u}.accountName`,
                    control: t,
                    render: ({field: f}) => g.jsx(ct, {
                        ...f,
                        size: "small",
                        label: "Account Name",
                        fullWidth: !0
                    })
                })
            }), g.jsx(je, {
                size: {
                    xs: 12,
                    sm: 4
                },
                children: g.jsx(un, {
                    name: `bankDetailDto.${u}.phoneNumber`,
                    control: t,
                    render: ({field: f}) => g.jsx(ct, {
                        ...f,
                        size: "small",
                        label: "Phone Number",
                        fullWidth: !0,
                        error: !!i?.bankDetailDto?.[u]?.phoneNumber,
                        helperText: i?.bankDetailDto?.[u]?.phoneNumber?.message,
                        inputProps: {
                            pattern: "[0-9+\\-()s]*",
                            title: "Phone Number must contain only digits and symbols like +, -, (, )"
                        },
                        onChange: h => {
                            f.onChange(h),
                            m2(h, /^[0-9+\-()\s]*$/, "phoneNumber", u, r)
                        }
                        ,
                        onBlur: () => {
                            const h = f.value;
                            h && !/^[0-9+\-()\s]*$/.test(h) && r(`bankDetailDto.${u}.phoneNumber`, {
                                type: "manual",
                                message: "Phone Number must contain only digits and symbols like +, -, (, )"
                            })
                        }
                    })
                })
            }), g.jsxs(Be, {
                sx: {
                    display: "flex",
                    alignItems: "center",
                    height: "100%",
                    gap: 1
                },
                children: [g.jsx(In, {
                    size: "small",
                    color: "primary",
                    onClick: () => o.length < e && a({
                        id: Date.now(),
                        bankName: "",
                        accountNumber: "",
                        routingNumber: "",
                        accountName: "",
                        phoneNumber: "",
                        primary: !1
                    }),
                    disabled: o.length >= e,
                    sx: {
                        borderRadius: "8px",
                        border: "1px solid",
                        borderColor: "primary.main"
                    },
                    children: g.jsx(Go, {
                        fontSize: "small"
                    })
                }), g.jsx(In, {
                    size: "small",
                    color: "error",
                    onClick: () => o.length > 1 && s(u),
                    disabled: o.length === 1,
                    sx: {
                        borderRadius: "8px",
                        border: "1px solid",
                        borderColor: "error.main"
                    },
                    children: g.jsx(D1, {
                        fontSize: "small"
                    })
                })]
            })]
        }, c.id))
    })
}
  , _7 = ({onCancel: e, initialData: t=null, mode: n="add", vendorId: r=0}) => {
    const i = uh()
      , o = (V, Y, W, te) => {
        const K = V.target.value;
        K && !Y.test(K) && (te(W, {
            type: "manual",
            message: "Invalid characters detected"
        }),
        V.target.value = K.slice(0, -1))
    }
      , a = [{
        id: Date.now(),
        countryId: null,
        category: "",
        name: "",
        taxNumber: ""
    }]
      , s = [{
        id: Date.now(),
        bankName: "",
        accountNumber: "",
        primary: !1,
        routingNumber: "",
        accountName: "",
        phoneNumber: ""
    }]
      , c = t ? {
        ...t,
        paymentId: t.paymentId !== null && t.paymentId !== void 0 ? String(t.paymentId) : null,
        countryId: t.countryId ?? null,
        stateId: t.stateId ?? null,
        languageId: t.languageId ?? null,
        salesStatusId: t.salesStatusId ?? null
    } : null
      , u = c || {
        vendorId: 0,
        companyName1: "",
        companyName2: "",
        dba: "",
        keyWord: "",
        houseNumber: "",
        streetName: "",
        buildingName: "",
        landmark: "",
        countryId: null,
        stateId: null,
        zipCode: "",
        digiPin: "",
        mapsUrl: "",
        languageId: null,
        phoneNumber1: "",
        phoneNumber2: "",
        phoneNumber3: "",
        fax: "",
        email1: "",
        email2: "",
        email3: "",
        comments: "",
        salesStatusId: null,
        paymentId: null,
        taxInformationDto: a,
        bankDetailDto: s
    }
      , f = MA({
        resolver: LA(bze),
        defaultValues: u,
        mode: "onTouched"
    })
      , {control: h, handleSubmit: m, reset: y, watch: b, formState: v, setError: S} = f
      , {errors: C, isSubmitting: w} = v
      , k = b("countryId")
      , T = G_.filter(V => V.countryId === k)
      , [E,P] = A.useState(!1)
      , [D,$] = A.useState("")
      , [z,O] = A.useState("success")
      , [I,M] = A.useState(!1)
      , [B,L] = A.useState(!1)
      , {data: F=[]} = $6()
      , {data: j=[]} = I6()
      , {mutate: N} = jye()
      , {mutate: H} = Bye();
    console.log(v);
    const Z = V => {
        let Y = !1;
        return V.zipCode && !/^[0-9-\s]+$/.test(V.zipCode) && (S("zipCode", {
            type: "manual",
            message: "Zip Code must contain only digits, hyphens, and spaces"
        }),
        Y = !0),
        V.digiPin && !/^[0-9]*$/.test(V.digiPin) && (S("digiPin", {
            type: "manual",
            message: "Digi Pin must contain only digits"
        }),
        Y = !0),
        V.phoneNumber1 && !/^[0-9+\-()\s]+$/.test(V.phoneNumber1) && (S("phoneNumber1", {
            type: "manual",
            message: "Phone Number must contain only digits and symbols like +, -, (, )"
        }),
        Y = !0),
        V.bankDetailDto.forEach( (W, te) => {
            W.accountNumber && !/^[0-9]+$/.test(W.accountNumber) && (S(`bankDetailDto.${te}.accountNumber`, {
                type: "manual",
                message: "Account Number must contain only digits"
            }),
            Y = !0),
            W.routingNumber && !/^[0-9]*$/.test(W.routingNumber) && (S(`bankDetailDto.${te}.routingNumber`, {
                type: "manual",
                message: "Routing Number must contain only digits"
            }),
            Y = !0)
        }
        ),
        V.taxInformationDto.forEach( (W, te) => {
            W.taxNumber && !/^[0-9a-zA-Z\-]*$/.test(W.taxNumber) && (S(`taxInformationDto.${te}.taxNumber`, {
                type: "manual",
                message: "Tax Number must contain only alphanumeric characters and hyphens"
            }),
            Y = !0)
        }
        ),
        !Y
    }
      , q = V => {
        if (!Z(V)) {
            $("Please correct validation errors before submitting"),
            O("error"),
            P(!0);
            return
        }
        M(!0),
        L(!0);
        const Y = {
            ...V,
            dba: V.dba ?? "",
            buildingName: V.buildingName ?? "",
            landmark: V.landmark ?? "",
            comments: V.comments ?? "",
            companyName1: V.companyName1 ?? "",
            companyName2: V.companyName2 ?? "",
            keyWord: V.keyWord ?? "",
            houseNumber: V.houseNumber ?? "",
            streetName: V.streetName ?? "",
            zipCode: V.zipCode ?? "",
            digiPin: V.digiPin ?? "",
            mapsUrl: V.mapsUrl ?? "",
            phoneNumber1: V.phoneNumber1 ?? "",
            phoneNumber2: V.phoneNumber2 ?? "",
            phoneNumber3: V.phoneNumber3 ?? "",
            paymentId: V.paymentId ? Number(V.paymentId) : null,
            fax: V.fax ?? "",
            email1: V.email1 ?? "",
            email2: V.email2 ?? "",
            email3: V.email3 ?? "",
            taxInformationDto: (V.taxInformationDto || []).map(te => ({
                ...te,
                countryId: te.countryId ?? 0,
                category: te.category ?? "",
                taxNumber: te.taxNumber ?? "",
                name: te.name ?? ""
            })),
            bankDetailDto: (V.bankDetailDto || []).map(te => ({
                ...te,
                bankName: te.bankName ?? "",
                accountNumber: te.accountNumber ?? "",
                routingNumber: te.routingNumber ?? "",
                accountName: te.accountName ?? "",
                phoneNumber: te.phoneNumber ?? "",
                primary: te.primary ?? !1
            }))
        }
          , W = r || c?.vendorId || V.vendorId || 0;
        if (n === "edit") {
            if (!W) {
                M(!1),
                L(!1),
                $("Missing vendor ID for update"),
                O("error"),
                P(!0);
                return
            }
            N({
                id: W,
                data: Y
            }, {
                onSuccess: () => {
                    i.invalidateQueries({
                        queryKey: ["GetVendorFormById", W]
                    }),
                    i.invalidateQueries({
                        queryKey: ["readVendorForm"]
                    }),
                    $("Vendor Form updated successfully!"),
                    O("success"),
                    P(!0),
                    setTimeout( () => {
                        e && e()
                    }
                    , 1e3)
                }
                ,
                onError: te => {
                    $(`Failed to update: ${te?.message ?? "Unknown error"}`),
                    O("error"),
                    P(!0)
                }
                ,
                onSettled: () => {
                    M(!1),
                    L(!1)
                }
            })
        } else
            H(Y, {
                onSuccess: () => {
                    i.invalidateQueries({
                        queryKey: ["readVendorForm"]
                    }),
                    $("Vendor submitted successfully!"),
                    O("success"),
                    P(!0),
                    y(u),
                    setTimeout( () => {
                        e && e()
                    }
                    , 1e3)
                }
                ,
                onError: te => {
                    $(`Failed to submit: ${te?.message ?? "Unknown error"}`),
                    O("error"),
                    P(!0)
                }
                ,
                onSettled: () => {
                    M(!1),
                    L(!1)
                }
            })
    }
    ;
    return g.jsxs(Be, {
        sx: {
            maxWidth: "100%",
            width: "100%"
        },
        children: [g.jsxs(Be, {
            sx: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                mb: 2
            },
            children: [g.jsx(Ae, {
                variant: "h5",
                children: n === "add" ? "Add Vendor" : "Edit Vendor"
            }), g.jsx(Mt, {
                variant: "outlined",
                color: "primary",
                onClick: e,
                disabled: B,
                size: "small",
                sx: {
                    borderRadius: "8px",
                    minWidth: "100px"
                },
                children: "Back"
            })]
        }), g.jsx(TA, {
            ...f,
            children: g.jsxs("form", {
                noValidate: !0,
                onSubmit: m(q),
                children: [g.jsxs(je, {
                    container: !0,
                    spacing: 2,
                    children: [g.jsx(je, {
                        size: {
                            xs: 12
                        },
                        children: g.jsx(Ae, {
                            variant: "body1",
                            gutterBottom: !0,
                            children: "Name"
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "companyName1",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Company Name 1",
                                error: !!C.companyName1,
                                helperText: C.companyName1?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "companyName2",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Company Name 2",
                                error: !!C.companyName2,
                                helperText: C.companyName2?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "dba",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "DBA (Doing Business As)",
                                error: !!C.dba,
                                helperText: C.dba?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "keyWord",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Keyword",
                                error: !!C.keyWord,
                                helperText: C.keyWord?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12
                        },
                        children: g.jsx(Ae, {
                            variant: "body1",
                            gutterBottom: !0,
                            children: "Address"
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "houseNumber",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "House Number",
                                error: !!C.houseNumber,
                                helperText: C.houseNumber?.message,
                                inputProps: {
                                    pattern: "[0-9a-zA-Z\\-/s]+",
                                    title: "House Number can contain only alphanumeric characters, hyphens, and slashes"
                                }
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "streetName",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Street Name",
                                error: !!C.streetName,
                                helperText: C.streetName?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "buildingName",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Building Name",
                                error: !!C.buildingName,
                                helperText: C.buildingName?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "landmark",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "landmark",
                                error: !!C.landmark,
                                helperText: C.landmark?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "countryId",
                            control: h,
                            render: ({field: V}) => g.jsx(co, {
                                options: $m,
                                value: $m.find(Y => Y.id === V.value) || null,
                                getOptionLabel: Y => Y.name,
                                onChange: (Y, W) => V.onChange(W ? W.id : null),
                                renderInput: Y => g.jsx(ct, {
                                    ...Y,
                                    label: "Country",
                                    size: "small",
                                    error: !!C.countryId,
                                    helperText: C.countryId?.message
                                })
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "stateId",
                            control: h,
                            render: ({field: V}) => g.jsx(co, {
                                options: T,
                                value: T.find(Y => Y.id === V.value) || null,
                                getOptionLabel: Y => Y.name,
                                onChange: (Y, W) => V.onChange(W ? W.id : null),
                                renderInput: Y => g.jsx(ct, {
                                    ...Y,
                                    label: "State",
                                    size: "small",
                                    error: !!C.stateId,
                                    helperText: C.stateId?.message
                                })
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "zipCode",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Zip Code",
                                error: !!C.zipCode,
                                helperText: C.zipCode?.message,
                                inputProps: {
                                    pattern: "[0-9-\\s]+",
                                    title: "Zip Code must contain only digits, hyphens, and spaces"
                                },
                                onChange: Y => {
                                    V.onChange(Y),
                                    o(Y, /^[0-9\-\s]*$/, "zipCode", S)
                                }
                                ,
                                onBlur: () => {
                                    const Y = V.value;
                                    Y && !/^[0-9\-\s]+$/.test(Y) && S("zipCode", {
                                        type: "manual",
                                        message: "Zip Code must contain only digits, hyphens, and spaces"
                                    })
                                }
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "digiPin",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Digi Pin",
                                error: !!C.digiPin,
                                helperText: C.digiPin?.message,
                                inputProps: {
                                    pattern: "[0-9]*",
                                    title: "Digi Pin must contain only digits"
                                },
                                onChange: Y => {
                                    V.onChange(Y),
                                    o(Y, /^[0-9]*$/, "digiPin", S)
                                }
                                ,
                                onBlur: () => {
                                    const Y = V.value;
                                    Y && !/^[0-9]*$/.test(Y) && S("digiPin", {
                                        type: "manual",
                                        message: "Digi Pin must contain only digits"
                                    })
                                }
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "mapsUrl",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Maps URL",
                                error: !!C.mapsUrl,
                                helperText: C.mapsUrl?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12
                        },
                        children: g.jsx(Ae, {
                            variant: "body1",
                            gutterBottom: !0,
                            children: "Communication"
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "languageId",
                            control: h,
                            render: ({field: V}) => g.jsx(co, {
                                options: j,
                                value: j.find(Y => Y.languageId === V.value) || null,
                                getOptionLabel: Y => `${Y.languageDesc} (${Y.languageCode})`,
                                onChange: (Y, W) => V.onChange(W ? W.languageId : null),
                                renderInput: Y => g.jsx(ct, {
                                    ...Y,
                                    label: "Language",
                                    size: "small",
                                    error: !!C.languageId,
                                    helperText: C.languageId?.message
                                })
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "phoneNumber1",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Phone Number 1",
                                error: !!C.phoneNumber1,
                                helperText: C.phoneNumber1?.message,
                                inputProps: {
                                    pattern: "[0-9+\\-()s]+",
                                    title: "Phone Number must contain only digits and symbols like +, -, (, )"
                                },
                                onChange: Y => {
                                    V.onChange(Y),
                                    o(Y, /^[0-9+\-()\s]*$/, "phoneNumber1", S)
                                }
                                ,
                                onBlur: () => {
                                    const Y = V.value;
                                    Y && !/^[0-9+\-()\s]+$/.test(Y) && S("phoneNumber1", {
                                        type: "manual",
                                        message: "Phone Number must contain only digits and symbols like +, -, (, )"
                                    })
                                }
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "phoneNumber2",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Phone Number 2",
                                error: !!C.phoneNumber2,
                                helperText: C.phoneNumber2?.message,
                                inputProps: {
                                    pattern: "[0-9+\\-()s]*",
                                    title: "Phone Number must contain only digits and symbols like +, -, (, )"
                                },
                                onChange: Y => {
                                    V.onChange(Y),
                                    o(Y, /^[0-9+\-()\s]*$/, "phoneNumber2", S)
                                }
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "phoneNumber3",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Phone Number 3",
                                error: !!C.phoneNumber3,
                                helperText: C.phoneNumber3?.message,
                                inputProps: {
                                    pattern: "[0-9+\\-()s]*",
                                    title: "Phone Number must contain only digits and symbols like +, -, (, )"
                                },
                                onChange: Y => {
                                    V.onChange(Y),
                                    o(Y, /^[0-9+\-()\s]*$/, "phoneNumber3", S)
                                }
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "fax",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Fax",
                                error: !!C.fax,
                                helperText: C.fax?.message,
                                inputProps: {
                                    pattern: "[0-9+\\-()s]*",
                                    title: "Fax number must contain only digits and symbols like +, -, (, )"
                                },
                                onChange: Y => {
                                    V.onChange(Y),
                                    o(Y, /^[0-9+\-()\s]*$/, "fax", S)
                                }
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "email1",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Email 1",
                                error: !!C.email1,
                                helperText: C.email1?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "email2",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Email 2",
                                error: !!C.email2,
                                helperText: C.email2?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "email3",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Email 3",
                                error: !!C.email3,
                                helperText: C.email3?.message
                            })
                        })
                    }), g.jsxs(je, {
                        size: {
                            xs: 12
                        },
                        children: [g.jsx(Ae, {
                            variant: "body1",
                            gutterBottom: !0,
                            children: "Tax Information"
                        }), g.jsx(vze, {
                            maxRows: 5
                        })]
                    }), g.jsxs(je, {
                        size: {
                            xs: 12
                        },
                        children: [g.jsx(Ae, {
                            variant: "body1",
                            gutterBottom: !0,
                            children: "Bank Details"
                        }), g.jsx(Sze, {
                            maxRows: 5
                        })]
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "comments",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                label: "Comments",
                                error: !!C.comments,
                                helperText: C.comments?.message
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "salesStatusId",
                            control: h,
                            render: ({field: V}) => g.jsx(co, {
                                options: F,
                                value: F.find(Y => Y.salesStatusId === V.value) || null,
                                getOptionLabel: Y => `${Y.salesStatusDesc} (${Y.salesStatusCode})`,
                                onChange: (Y, W) => V.onChange(W ? W.salesStatusId : null),
                                renderInput: Y => g.jsx(ct, {
                                    ...Y,
                                    label: "Status",
                                    size: "small",
                                    error: !!C.salesStatusId,
                                    helperText: C.salesStatusId?.message
                                })
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(un, {
                            name: "paymentId",
                            control: h,
                            render: ({field: V}) => g.jsx(ct, {
                                ...V,
                                fullWidth: !0,
                                size: "small",
                                type: "text",
                                label: "Payment Terms",
                                error: !!C.paymentId,
                                helperText: C.paymentId?.message,
                                value: V.value !== null && V.value !== void 0 ? V.value : "",
                                onChange: Y => {
                                    V.onChange(Y.target.value)
                                }
                            })
                        })
                    }), g.jsxs(je, {
                        size: {
                            xs: 12
                        },
                        children: [g.jsx(Mt, {
                            variant: "contained",
                            color: "primary",
                            type: "submit",
                            disabled: w || B,
                            size: "small",
                            sx: {
                                borderRadius: "8px",
                                minWidth: "100px"
                            },
                            children: w || B ? g.jsx(Jr, {
                                size: 20,
                                color: "inherit"
                            }) : n === "add" ? "Submit" : "Update"
                        }), g.jsx(Mt, {
                            variant: "outlined",
                            color: "secondary",
                            onClick: () => y(u),
                            disabled: w || B,
                            size: "small",
                            type: "button",
                            sx: {
                                ml: 2,
                                borderRadius: "8px",
                                minWidth: "100px"
                            },
                            children: "Reset"
                        })]
                    })]
                }), g.jsx(jg, {
                    open: I,
                    sx: {
                        color: "#fff",
                        zIndex: V => V.zIndex.drawer + 1
                    },
                    children: g.jsxs(Be, {
                        sx: {
                            display: "flex",
                            flexDirection: "column",
                            alignItems: "center",
                            gap: 2
                        },
                        children: [g.jsx(Jr, {
                            color: "inherit",
                            size: 50
                        }), g.jsx(Ae, {
                            variant: "h6",
                            color: "white",
                            children: B ? "Saving vendor data..." : "Processing..."
                        })]
                    })
                }), g.jsx(hh, {
                    open: E,
                    autoHideDuration: 3e3,
                    onClose: () => P(!1),
                    anchorOrigin: {
                        vertical: "bottom",
                        horizontal: "center"
                    },
                    sx: {
                        zIndex: V => (V.zIndex?.snackbar ?? V.zIndex.modal) + 1
                    },
                    children: g.jsx(Mc, {
                        variant: "filled",
                        onClose: () => P(!1),
                        severity: z,
                        sx: {
                            width: "100%"
                        },
                        children: D
                    })
                })]
            })
        })]
    })
}
;
function C5(e) {
    const {children: t, value: n, index: r, ...i} = e;
    return g.jsx("div", {
        role: "tabpanel",
        hidden: n !== r,
        id: `product-tabpanel-${r}`,
        "aria-labelledby": `product-tab-${r}`,
        ...i,
        children: n === r && g.jsx(Be, {
            sx: {
                py: 3
            },
            children: t
        })
    })
}
const Cze = ({onBack: e, onEdit: t, vendorId: n}) => {
    const [r,i] = A.useState(0)
      , {data: o=null} = Nye(n)
      , a = (c, u) => {
        i(u)
    }
      , s = (c, u) => g.jsxs(Be, {
        sx: {
            display: "flex",
            py: 1
        },
        children: [g.jsx(Be, {
            sx: {
                flex: "0 0 17%"
            },
            children: g.jsx(Ae, {
                variant: "caption",
                color: "textSecondary",
                children: c
            })
        }), g.jsx(Be, {
            sx: {
                flex: "1 1 auto"
            },
            children: g.jsx(Ae, {
                variant: "body2",
                color: "textPrimary",
                children: u || "-"
            })
        })]
    });
    return g.jsxs(Be, {
        sx: {
            height: "100%",
            display: "flex",
            flexDirection: "column"
        },
        children: [g.jsxs(Be, {
            sx: {
                p: 2,
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                backgroundColor: "white",
                borderBottom: 1,
                borderColor: "divider"
            },
            children: [g.jsx(Ae, {
                variant: "h6",
                children: "Vendor Details"
            }), g.jsxs(Be, {
                sx: {
                    display: "flex",
                    gap: 2
                },
                children: [g.jsx(Mt, {
                    variant: "outlined",
                    startIcon: g.jsx(rg, {}),
                    onClick: () => t(o),
                    size: "small",
                    children: "Edit"
                }), g.jsx(Mt, {
                    variant: "outlined",
                    onClick: e,
                    size: "small",
                    children: "Back"
                })]
            })]
        }), g.jsxs(Be, {
            component: yn,
            sx: {
                flex: 1,
                display: "flex",
                flexDirection: "column"
            },
            children: [g.jsxs(d3, {
                value: r,
                onChange: a,
                sx: {
                    borderBottom: 1,
                    borderColor: "divider",
                    px: 2
                },
                children: [g.jsx(xm, {
                    label: "Overview"
                }), g.jsx(xm, {
                    label: "Design view"
                })]
            }), g.jsxs(Be, {
                sx: {
                    flex: 1,
                    overflowY: "auto",
                    px: 3
                },
                children: [g.jsxs(C5, {
                    value: r,
                    index: 0,
                    children: [g.jsx(Ae, {
                        variant: "body2",
                        color: "textPrimary",
                        fontWeight: "bold",
                        children: "Name"
                    }), g.jsxs(Ae, {
                        variant: "body2",
                        color: "text.secondary",
                        children: [s("Company Name 1", o?.companyName1), s("Company Name 2", o?.companyName2), s("DBA (Doing Business As)", o?.dba), s("Keyword", o?.keyWord)]
                    }), g.jsx(Be, {
                        sx: {
                            my: 2
                        }
                    }), g.jsx(Ae, {
                        variant: "body2",
                        color: "textPrimary",
                        fontWeight: "bold",
                        children: "Address"
                    }), g.jsxs(Ae, {
                        variant: "body2",
                        color: "text.secondary",
                        children: [s("House Number", o?.houseNumber), s("Street Name", o?.streetName), s("Building Name", o?.buildingName), s("Landmark", o?.landmark), s("Country", $m.find(c => c.id === o?.countryId)?.name || "-"), s("State", G_.find(c => c.id === o?.stateId)?.name || "-"), s("Zip Code", o?.zipCode), s("Digi Pin", o?.digiPin), s("Maps URL", o?.mapsUrl)]
                    }), g.jsx(Be, {
                        sx: {
                            my: 2
                        }
                    }), g.jsx(Ae, {
                        variant: "body2",
                        color: "textPrimary",
                        fontWeight: "bold",
                        children: "Communication"
                    }), g.jsxs(Ae, {
                        variant: "body2",
                        color: "text.secondary",
                        children: [s("Language", o?.languageId), s("Phone Number 1", o?.phoneNumber1), s("Phone Number 2", o?.phoneNumber2), s("Phone Number 3", o?.phoneNumber3), s("Fax", o?.fax), s("Email 1", o?.email1), s("Email 2", o?.email2), s("Email 3", o?.email3)]
                    }), g.jsx(Be, {
                        sx: {
                            my: 3
                        }
                    }), g.jsx(Ae, {
                        variant: "body2",
                        color: "textPrimary",
                        fontWeight: "bold",
                        children: "Tax Information"
                    }), g.jsx(Ha, {
                        component: yn,
                        children: g.jsxs(Ua, {
                            size: "small",
                            children: [g.jsx(qa, {
                                children: g.jsxs(gn, {
                                    children: [g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Country"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Category"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Name"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Tax Number"
                                    })]
                                })
                            }), g.jsxs(Va, {
                                children: [(o?.taxInformationDto ?? []).map(c => g.jsxs(gn, {
                                    sx: {
                                        "&:hover": {
                                            backgroundColor: "#f1f1fa",
                                            cursor: "pointer"
                                        }
                                    },
                                    children: [g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.countryId
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.category
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.name
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.taxNumber
                                    })]
                                }, c.taxInformationId)), (!o?.taxInformationDto || o?.taxInformationDto.length === 0) && g.jsx(gn, {
                                    children: g.jsx(Me, {
                                        colSpan: 5,
                                        align: "center",
                                        sx: {
                                            py: 2
                                        },
                                        children: "No data found."
                                    })
                                })]
                            })]
                        })
                    }), g.jsx(Be, {
                        sx: {
                            my: 3
                        }
                    }), g.jsx(Ae, {
                        variant: "body2",
                        color: "textPrimary",
                        fontWeight: "bold",
                        children: "Bank Details"
                    }), g.jsx(Ha, {
                        component: yn,
                        children: g.jsxs(Ua, {
                            size: "small",
                            children: [g.jsx(qa, {
                                children: g.jsxs(gn, {
                                    children: [g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Bank Name"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Account Number"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Routing Number"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Account Name"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Phone Number"
                                    })]
                                })
                            }), g.jsxs(Va, {
                                children: [(o?.bankDetailDto ?? []).map(c => g.jsxs(gn, {
                                    sx: {
                                        "&:hover": {
                                            backgroundColor: "#f1f1fa",
                                            cursor: "pointer"
                                        }
                                    },
                                    children: [g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.bankName
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.accountNumber
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.routingNumber
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.accountName
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: c.phoneNumber
                                    })]
                                }, c.bankId)), (!o?.bankDetailDto || o?.bankDetailDto.length === 0) && g.jsx(gn, {
                                    children: g.jsx(Me, {
                                        colSpan: 5,
                                        align: "center",
                                        sx: {
                                            py: 2
                                        },
                                        children: "No data found."
                                    })
                                })]
                            })]
                        })
                    }), g.jsxs(Ae, {
                        variant: "body2",
                        color: "text.secondary",
                        children: [s("Comments", o?.comments), s("Status", o?.salesStatusId), s("Payment Terms", o?.paymentId)]
                    })]
                }), g.jsxs(C5, {
                    value: r,
                    index: 1,
                    children: [g.jsxs(yn, {
                        elevation: 2,
                        sx: {
                            p: 3,
                            mb: 3,
                            bgcolor: "#f9fafb",
                            borderRadius: 2
                        },
                        children: [g.jsx(Ae, {
                            variant: "h6",
                            sx: {
                                mb: 2,
                                color: "primary.main"
                            },
                            children: "Name"
                        }), g.jsxs(je, {
                            container: !0,
                            spacing: 2,
                            children: [g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Company Name 1"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.companyName1 || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Company Name 2"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.companyName2 || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "DBA (Doing Business As)"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.dba || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Keyword"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.keyWord || "-"
                                })]
                            })]
                        })]
                    }), g.jsxs(yn, {
                        elevation: 2,
                        sx: {
                            p: 3,
                            mb: 3,
                            bgcolor: "#f9fafb",
                            borderRadius: 2
                        },
                        children: [g.jsx(Ae, {
                            variant: "h6",
                            sx: {
                                mb: 2,
                                color: "primary.main"
                            },
                            children: "Address"
                        }), g.jsxs(je, {
                            container: !0,
                            spacing: 2,
                            children: [g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "House Number"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.houseNumber || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Street Name"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.streetName || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Building Name"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.buildingName || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Landmark"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.landmark || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Country"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: $m.find(c => c.id === o?.countryId)?.name || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "State"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: G_.find(c => c.id === o?.stateId)?.name || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Zip Code"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.zipCode || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Digi Pin"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.digiPin || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Maps URL"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.mapsUrl || "-"
                                })]
                            })]
                        })]
                    }), g.jsxs(yn, {
                        elevation: 2,
                        sx: {
                            p: 3,
                            mb: 3,
                            bgcolor: "#f9fafb",
                            borderRadius: 2
                        },
                        children: [g.jsx(Ae, {
                            variant: "h6",
                            sx: {
                                mb: 2,
                                color: "primary.main"
                            },
                            children: "Communication"
                        }), g.jsxs(je, {
                            container: !0,
                            spacing: 2,
                            children: [g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Language"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.languageId || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Phone Number 1"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.phoneNumber1 || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Phone Number 2"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.phoneNumber2 || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Phone Number 3"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.phoneNumber3 || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Fax"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.fax || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Email 1"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.email1 || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Email 2"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.email2 || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Email 3"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.email3 || "-"
                                })]
                            })]
                        })]
                    }), g.jsxs(yn, {
                        elevation: 2,
                        sx: {
                            p: 3,
                            mb: 3,
                            bgcolor: "#f9fafb",
                            borderRadius: 2
                        },
                        children: [g.jsx(Ae, {
                            variant: "h6",
                            sx: {
                                mb: 2,
                                color: "primary.main"
                            },
                            children: "Tax Information"
                        }), g.jsx(Ha, {
                            component: yn,
                            sx: {
                                boxShadow: "none",
                                bgcolor: "transparent"
                            },
                            children: g.jsxs(Ua, {
                                size: "small",
                                children: [g.jsx(qa, {
                                    children: g.jsxs(gn, {
                                        children: [g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Country"
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Category"
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Name"
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Tax Number"
                                        })]
                                    })
                                }), g.jsxs(Va, {
                                    children: [(o?.taxInformationDto ?? []).map(c => g.jsxs(gn, {
                                        sx: {
                                            "&:hover": {
                                                backgroundColor: "#f1f1fa",
                                                cursor: "pointer"
                                            }
                                        },
                                        children: [g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: $m.find(u => u.id === c.countryId)?.name || "-"
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: c.category
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: c.name
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: c.taxNumber
                                        })]
                                    }, c.taxInformationId)), (!o?.taxInformationDto || o?.taxInformationDto.length === 0) && g.jsx(gn, {
                                        children: g.jsx(Me, {
                                            colSpan: 4,
                                            align: "center",
                                            sx: {
                                                py: 2
                                            },
                                            children: "No data found."
                                        })
                                    })]
                                })]
                            })
                        })]
                    }), g.jsxs(yn, {
                        elevation: 2,
                        sx: {
                            p: 3,
                            mb: 3,
                            bgcolor: "#f9fafb",
                            borderRadius: 2
                        },
                        children: [g.jsx(Ae, {
                            variant: "h6",
                            sx: {
                                mb: 2,
                                color: "primary.main"
                            },
                            children: "Bank Details"
                        }), g.jsx(Ha, {
                            component: yn,
                            sx: {
                                boxShadow: "none",
                                bgcolor: "transparent"
                            },
                            children: g.jsxs(Ua, {
                                size: "small",
                                children: [g.jsx(qa, {
                                    children: g.jsxs(gn, {
                                        children: [g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Bank Name"
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Account Number"
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Routing Number"
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Account Name"
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1,
                                                fontWeight: "bold"
                                            },
                                            children: "Phone Number"
                                        })]
                                    })
                                }), g.jsxs(Va, {
                                    children: [(o?.bankDetailDto ?? []).map(c => g.jsxs(gn, {
                                        sx: {
                                            "&:hover": {
                                                backgroundColor: "#f1f1fa",
                                                cursor: "pointer"
                                            }
                                        },
                                        children: [g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: c.bankName
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: c.accountNumber
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: c.routingNumber
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: c.accountName
                                        }), g.jsx(Me, {
                                            sx: {
                                                py: 1
                                            },
                                            children: c.phoneNumber
                                        })]
                                    }, c.bankId)), (!o?.bankDetailDto || o?.bankDetailDto.length === 0) && g.jsx(gn, {
                                        children: g.jsx(Me, {
                                            colSpan: 5,
                                            align: "center",
                                            sx: {
                                                py: 2
                                            },
                                            children: "No data found."
                                        })
                                    })]
                                })]
                            })
                        })]
                    }), g.jsxs(yn, {
                        elevation: 2,
                        sx: {
                            p: 3,
                            mb: 3,
                            bgcolor: "#f9fafb",
                            borderRadius: 2
                        },
                        children: [g.jsx(Ae, {
                            variant: "h6",
                            sx: {
                                mb: 2,
                                color: "primary.main"
                            },
                            children: "Other Details"
                        }), g.jsxs(je, {
                            container: !0,
                            spacing: 2,
                            children: [g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Comments"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.comments || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Status"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.salesStatusId || "-"
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 12,
                                    sm: 6,
                                    md: 4,
                                    lg: 3
                                },
                                children: [g.jsx(Ae, {
                                    variant: "caption",
                                    color: "textSecondary",
                                    children: "Payment Terms"
                                }), g.jsx(Ae, {
                                    variant: "body2",
                                    children: o?.paymentId || "-"
                                })]
                            })]
                        })]
                    })]
                })]
            })]
        })]
    })
}
  , wze = e => e ? {
    ...e,
    paymentId: e.paymentId !== null && e.paymentId !== void 0 ? String(e.paymentId) : null,
    countryId: e.countryId ?? null,
    stateId: e.stateId ?? null,
    languageId: e.languageId ?? null,
    salesStatusId: e.salesStatusId ?? null,
    taxInformationDto: e.taxInformationDto || [],
    bankDetailDto: e.bankDetailDto || []
} : null
  , kze = ({onEdit: e}) => {
    const {data: t=[], isLoading: n} = Fye()
      , [r,i] = A.useState([])
      , [o,a] = A.useState("asc")
      , [s,c] = A.useState("vendorId");
    A.useEffect( () => {
        Array.isArray(t) ? i(t) : (console.warn("Unexpected data:", t),
        i([]))
    }
    , [t]);
    const u = N => {
        a(s === N && o === "asc" ? "desc" : "asc"),
        c(N)
    }
    ;
    function f(N, H) {
        return N === "desc" ? (Z, q) => h(Z, q, H) : (Z, q) => -h(Z, q, H)
    }
    function h(N, H, Z) {
        const q = N[Z]
          , V = H[Z];
        return V < q ? -1 : V > q ? 1 : 0
    }
    const [m,y] = A.useState("")
      , [b,v] = A.useState(!1)
      , [S,C] = A.useState("add")
      , [w,k] = A.useState(null)
      , [T,E] = A.useState(!1)
      , [P,D] = A.useState(0)
      , [$,z] = A.useState(10)
      , O = (N, H=null) => {
        C(N),
        k(H),
        v(!0)
    }
      , I = (N, H) => {
        D(H)
    }
      , M = N => {
        z(parseInt(N.target.value, 10)),
        D(0)
    }
      , B = Array.isArray(r) ? r.filter(N => {
        const H = m.toLowerCase();
        return N.companyName1.toLowerCase().includes(H) || N.companyName2.toLowerCase().includes(H) || N.phoneNumber1.toLowerCase().includes(H) || N.email1.toLowerCase().includes(H)
    }
    ) : []
      , F = [...B].sort(f(o, s)).slice(P * $, P * $ + $)
      , j = () => Array($).fill(0).map( (N, H) => g.jsxs(gn, {
        children: [g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "80%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "70%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "60%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "90%",
                height: 24,
                animation: "wave"
            })
        })]
    }, `skeleton-${H}`));
    return g.jsxs(Be, {
        children: [!b && !w && g.jsxs(g.Fragment, {
            children: [g.jsxs(Be, {
                display: "flex",
                justifyContent: "space-between",
                sx: {
                    p: 2,
                    mt: 0
                },
                children: [n ? g.jsx(Fn, {
                    variant: "rectangular",
                    width: 250,
                    height: 40,
                    animation: "wave"
                }) : g.jsx(ct, {
                    label: "Search",
                    placeholder: "search",
                    variant: "outlined",
                    size: "small",
                    value: m,
                    onChange: N => y(N.target.value),
                    sx: {
                        width: 250
                    }
                }), g.jsx(Mt, {
                    variant: "contained",
                    startIcon: n ? g.jsx(Jr, {
                        size: 16,
                        color: "inherit"
                    }) : g.jsx(Go, {}),
                    size: "small",
                    sx: {
                        borderRadius: "10px",
                        minWidth: "100px",
                        textTransform: "none"
                    },
                    onClick: () => O("add"),
                    disabled: n,
                    children: n ? "Loading..." : "Add New"
                })]
            }), g.jsxs(Ha, {
                component: yn,
                children: [g.jsxs(Ua, {
                    size: "small",
                    children: [g.jsx(qa, {
                        children: g.jsxs(gn, {
                            children: [g.jsx(Me, {
                                sx: {
                                    py: 1,
                                    fontWeight: "bold"
                                },
                                children: n ? g.jsx(Fn, {
                                    variant: "text",
                                    width: "70%",
                                    height: 24,
                                    animation: "wave"
                                }) : g.jsx(Fi, {
                                    active: s === "companyName1",
                                    direction: s === "companyName1" ? o : "asc",
                                    onClick: () => u("companyName1"),
                                    disabled: n,
                                    children: "Company Name 1"
                                })
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1,
                                    fontWeight: "bold"
                                },
                                children: n ? g.jsx(Fn, {
                                    variant: "text",
                                    width: "70%",
                                    height: 24,
                                    animation: "wave"
                                }) : g.jsx(Fi, {
                                    active: s === "companyName2",
                                    direction: s === "companyName2" ? o : "asc",
                                    onClick: () => u("companyName2"),
                                    disabled: n,
                                    children: "Company Name 2"
                                })
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1,
                                    fontWeight: "bold"
                                },
                                children: n ? g.jsx(Fn, {
                                    variant: "text",
                                    width: "70%",
                                    height: 24,
                                    animation: "wave"
                                }) : g.jsx(Fi, {
                                    active: s === "phoneNumber1",
                                    direction: s === "phoneNumber1" ? o : "asc",
                                    onClick: () => u("phoneNumber1"),
                                    disabled: n,
                                    children: "Phone Number 1"
                                })
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1,
                                    fontWeight: "bold"
                                },
                                children: n ? g.jsx(Fn, {
                                    variant: "text",
                                    width: "70%",
                                    height: 24,
                                    animation: "wave"
                                }) : g.jsx(Fi, {
                                    active: s === "email1",
                                    direction: s === "email1" ? o : "asc",
                                    onClick: () => u("email1"),
                                    disabled: n,
                                    children: "Email 1"
                                })
                            })]
                        })
                    }), g.jsx(Va, {
                        children: n ? j() : g.jsxs(g.Fragment, {
                            children: [F.map(N => g.jsxs(gn, {
                                onClick: () => k(N),
                                sx: {
                                    "&:hover": {
                                        backgroundColor: "#f1f1fa",
                                        cursor: "pointer"
                                    }
                                },
                                children: [g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.companyName1
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.companyName2
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.phoneNumber1
                                }), g.jsx(Me, {
                                    sx: {
                                        py: 1
                                    },
                                    children: N.email1
                                })]
                            }, N.vendorId)), !n && F.length === 0 && g.jsx(gn, {
                                children: g.jsx(Me, {
                                    colSpan: 5,
                                    align: "center",
                                    sx: {
                                        py: 2
                                    },
                                    children: "No data found."
                                })
                            })]
                        })
                    })]
                }), g.jsx(Bg, {
                    component: "div",
                    count: n ? 0 : B.length,
                    page: P,
                    onPageChange: I,
                    rowsPerPage: $,
                    onRowsPerPageChange: M,
                    disabled: n
                })]
            })]
        }), w && !b && g.jsx(Be, {
            children: g.jsx(Cze, {
                onBack: () => k(null),
                onEdit: N => e ? e(N) : N && O("edit", N),
                vendorId: w.vendorId
            })
        }), b && g.jsx(Be, {
            sx: {
                backgroundColor: "white",
                p: 2,
                borderRadius: 1
            },
            children: g.jsx(_7, {
                onCancel: () => v(!1),
                initialData: S === "edit" && w ? wze(w) : null,
                mode: S === "edit" ? "edit" : "add",
                vendorId: w ? w.vendorId : 0
            })
        }), T && g.jsxs(Be, {
            sx: {
                position: "fixed",
                top: "64px",
                right: 0,
                bottom: 0,
                width: "100%",
                backgroundColor: "white",
                boxShadow: 1,
                overflowY: "auto",
                p: 2,
                zIndex: 1200
            },
            children: [g.jsx(T7, {}), g.jsx(Mt, {
                variant: "outlined",
                onClick: () => E(!1),
                sx: {
                    position: "absolute",
                    top: 16,
                    right: 16
                },
                children: "Close"
            })]
        })]
    })
}
  , w5 = "/Login_left_image.png"
  , rf = [{
    title: g.jsxs(g.Fragment, {
        children: ["AI Based DATA", g.jsx("br", {}), "Transformation"]
    }),
    subtitle: "Sign in to access your intelligent data transformation workspace.",
    info: "Monitor, manage, and optimize your pipelines with real-time insights, AI-driven recommendations, and seamless automation  all in one place.",
    bg: w5
}, {
    title: g.jsxs(g.Fragment, {
        children: ["Smarter AI Integration", g.jsx("br", {}), "For Your Data"]
    }),
    subtitle: "Experience next-level automation with integrated analytics and control.",
    info: "Get AI-powered insights and execute workflows instantly with ease.",
    bg: w5
}];
function Tze() {
    const [e,t] = A.useState(0)
      , n = rf.length
      , r = () => {
        t(o => o === n - 1 ? 0 : o + 1)
    }
      , i = () => {
        t(o => o === 0 ? n - 1 : o - 1)
    }
    ;
    return A.useEffect( () => {
        rf.forEach(o => {
            const a = new Image;
            a.src = o.bg
        }
        )
    }
    , []),
    g.jsxs(Be, {
        sx: {
            height: "100%",
            width: "100%",
            position: "relative",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            overflow: "hidden"
        },
        children: [g.jsx(Be, {
            component: "img",
            src: rf[e].bg,
            alt: "Background",
            sx: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                objectFit: "cover",
                zIndex: 0,
                filter: "brightness(1.23)"
            }
        }), g.jsx(Be, {
            sx: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                background: "linear-gradient(to bottom, rgba(0,0,0,0.3), rgba(15,23,42,0.7))",
                zIndex: 1
            }
        }), g.jsxs(Be, {
            sx: {
                position: "relative",
                zIndex: 2,
                height: "100%",
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                px: {
                    xs: 3,
                    md: 6
                },
                textShadow: "0 2px 4px rgba(0,0,0,0.5)"
            },
            children: [g.jsx(Ae, {
                variant: "h2",
                fontWeight: "bold",
                color: "common.white",
                sx: {
                    mb: 2,
                    fontSize: {
                        xs: "2rem",
                        md: "2.5rem"
                    },
                    lineHeight: 1.2
                },
                children: rf[e].title
            }), g.jsx(Ae, {
                variant: "h6",
                color: "common.white",
                sx: {
                    mb: 1,
                    opacity: .9
                },
                children: rf[e].subtitle
            }), g.jsx(Ae, {
                variant: "body1",
                color: "info.light",
                sx: {
                    opacity: .95,
                    maxWidth: 600
                },
                children: rf[e].info
            })]
        }), g.jsx(sce, {
            variant: "dots",
            steps: n,
            position: "static",
            activeStep: e,
            sx: {
                position: "absolute",
                bottom: 12,
                left: 0,
                right: 0,
                bgcolor: "transparent",
                zIndex: 3,
                justifyContent: "center",
                ".MuiMobileStepper-dot": {
                    bgcolor: "info.light",
                    width: 10,
                    height: 10
                },
                ".MuiMobileStepper-dotActive": {
                    bgcolor: "primary.main"
                }
            },
            nextButton: g.jsx(Mt, {
                size: "small",
                onClick: r,
                sx: {
                    color: "#fff",
                    minWidth: 0,
                    px: 1
                },
                "aria-label": "Next slide",
                children: g.jsx(N1e, {})
            }),
            backButton: g.jsx(Mt, {
                size: "small",
                onClick: i,
                sx: {
                    color: "#fff",
                    minWidth: 0,
                    px: 1
                },
                "aria-label": "Previous slide",
                children: g.jsx(F1e, {})
            })
        })]
    })
}
const _ze = "/assets/Login_left_image-y8bxGDxV.png"
  , Eze = "https://zitatech-ai-dev.azurewebsites.net"
  , Aze = async e => {
    const t = await wr.post(`${Eze}/api/login/`, e);
    return localStorage.setItem("access_token", t.data.access),
    localStorage.setItem("refresh_token", t.data.refresh),
    t.data
}
;
function Mze() {
    const [e,t] = A.useState("")
      , [n,r] = A.useState("")
      , [i,o] = A.useState(null)
      , [a,s] = A.useState(!1)
      , {login: c} = Qme()
      , u = Os()
      , f = async h => {
        h.preventDefault(),
        o(null),
        s(!0);
        try {
            const m = await Aze({
                username: e,
                password: n
            });
            c(m.access),
            s(!1),
            u("/home")
        } catch (m) {
            s(!1),
            o("Invalid username or password"),
            console.error("Login failed", m)
        }
    }
    ;
    return g.jsxs(Be, {
        className: "login-page",
        sx: {
            minHeight: "100vh",
            bgcolor: "background.default",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            position: "relative"
        },
        children: [g.jsxs(yn, {
            elevation: 4,
            sx: {
                display: "flex",
                flexDirection: {
                    xs: "column",
                    md: "row"
                },
                width: {
                    xs: "95vw",
                    md: "950px"
                },
                minHeight: {
                    md: 550
                },
                overflow: "hidden",
                mb: 12
            },
            children: [g.jsx(Be, {
                sx: {
                    flex: 1,
                    minWidth: {
                        xs: "100%",
                        md: "44%"
                    },
                    backgroundImage: `url(${_ze})`,
                    backgroundSize: "cover",
                    backgroundPosition: "center",
                    display: {
                        xs: "none",
                        md: "block"
                    },
                    position: "relative"
                },
                children: g.jsx(Be, {
                    sx: {
                        position: "absolute",
                        width: "100%",
                        height: "100%"
                    },
                    children: g.jsx(Tze, {})
                })
            }), g.jsxs(Be, {
                sx: {
                    flex: 1,
                    minWidth: {
                        xs: "100%",
                        md: "50%"
                    },
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    px: {
                        xs: 3,
                        md: 5
                    },
                    py: {
                        xs: 3,
                        md: 5
                    },
                    bgcolor: "background.paper",
                    height: {
                        md: "80%"
                    }
                },
                children: [g.jsxs(Be, {
                    sx: {
                        mb: 2
                    },
                    children: [g.jsx("img", {
                        src: "/Zitatech-Logo.svg",
                        alt: "ZitaTech",
                        style: {
                            width: "180px",
                            height: "auto",
                            marginBottom: 8
                        }
                    }), g.jsx(Ae, {
                        variant: "h5",
                        sx: {
                            color: "#151817ff"
                        },
                        children: "Welcome Back"
                    }), g.jsx(Ae, {
                        variant: "body2",
                        color: "textSecondary",
                        sx: {
                            mb: 1
                        },
                        children: "Enter your username and password to sign in"
                    })]
                }), i && g.jsx(Mc, {
                    severity: "error",
                    sx: {
                        mb: 2
                    },
                    children: i
                }), g.jsxs(Be, {
                    component: "form",
                    onSubmit: f,
                    sx: {
                        mt: 1
                    },
                    children: [g.jsx(ct, {
                        margin: "normal",
                        required: !0,
                        fullWidth: !0,
                        size: "small",
                        id: "email",
                        label: "Username",
                        name: "email",
                        autoComplete: "email",
                        autoFocus: !0,
                        value: e,
                        onChange: h => t(h.target.value)
                    }), g.jsx(ct, {
                        margin: "normal",
                        required: !0,
                        fullWidth: !0,
                        size: "small",
                        name: "password",
                        label: "Password",
                        type: "password",
                        id: "password",
                        autoComplete: "current-password",
                        value: n,
                        onChange: h => r(h.target.value)
                    }), g.jsx(Use, {
                        control: g.jsx(Eae, {
                            value: "remember",
                            color: "primary",
                            size: "small"
                        }),
                        label: "Remember me"
                    }), g.jsx(Mt, {
                        type: "submit",
                        fullWidth: !0,
                        variant: "contained",
                        size: "small",
                        disabled: a,
                        sx: {
                            mt: 3,
                            mb: 2,
                            borderRadius: "8px",
                            minWidth: "100px",
                            position: "relative",
                            height: "36px"
                        },
                        children: a ? g.jsxs(g.Fragment, {
                            children: [g.jsx(Jr, {
                                size: 24,
                                sx: {
                                    position: "absolute",
                                    top: "50%",
                                    left: "50%",
                                    marginTop: "-12px",
                                    marginLeft: "-12px",
                                    color: "white"
                                }
                            }), g.jsx("span", {
                                style: {
                                    opacity: 0
                                },
                                children: "Sign In"
                            })]
                        }) : "Sign In"
                    })]
                })]
            })]
        }), g.jsx(Be, {
            component: "footer",
            sx: {
                position: "fixed",
                left: 0,
                bottom: 0,
                width: "100vw",
                bgcolor: "#1565C0",
                color: "#fff",
                py: 1.5,
                textAlign: "center",
                boxShadow: 2
            },
            children: g.jsx(Ae, {
                variant: "caption",
                sx: {
                    fontSize: "1rem"
                },
                children: "Copyright 2025  ZitaTech Inc. All Rights Reserved"
            })
        })]
    })
}
let gx = !1
  , Y_ = [];
const Pze = e => Y_.push(e)
  , Rze = e => {
    Y_.forEach(t => t(e)),
    Y_ = []
}
  , Wi = wr.create({
    baseURL: "https://zitatech-ai-dev.azurewebsites.net",
    headers: {
        "Cache-Control": "no-cache"
    }
});
Wi.interceptors.response.use(e => e, async e => {
    const t = e.config;
    if (e.response?.status === 401 && !t._retry) {
        if (t.url === "/api/token/refresh/")
            return localStorage.removeItem("access_token"),
            localStorage.removeItem("refresh_token"),
            window.location.href = "/login",
            Promise.reject(e);
        if (t._retry = !0,
        gx)
            return new Promise(r => {
                Pze(i => {
                    t.headers.Authorization = `Bearer ${i}`,
                    r(Wi(t))
                }
                )
            }
            );
        gx = !0;
        const n = localStorage.getItem("refresh_token");
        if (!n)
            return window.location.href = "/login",
            Promise.reject(e);
        try {
            const i = (await Dze({
                refresh: n
            })).access;
            return t.headers.Authorization = `Bearer ${i}`,
            Rze(i),
            gx = !1,
            Wi(t)
        } catch (r) {
            return localStorage.removeItem("access_token"),
            localStorage.removeItem("refresh_token"),
            gx = !1,
            window.location.href = "/login",
            Promise.reject(r)
        }
    }
    return Promise.reject(e)
}
);
const Dze = async e => {
    const t = await Wi.post("/api/token/refresh/", e);
    return t.data.access && localStorage.setItem("access_token", t.data.access),
    t.data.refresh && localStorage.setItem("refresh_token", t.data.refresh),
    t.data
}
  , k5 = async e => (await Wi.get(`/api/conversation/chat-history/?archived=${e}`, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , Oze = async e => (await Wi.get(`/api/conversation/conversation/${e}/`, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , Ize = async e => (await Wi.get(`/api/duplicates/runs/${e}/`, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , T5 = async e => (await Wi.post("/api/conversation/converse/", e, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , $ze = async e => (await Wi.patch(`/api/conversation/archive/?conversation_ids=${e}`, {}, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , Lze = async e => (await Wi.patch(`/api/conversation/restore/?conversation_ids=${e}`, {}, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , jze = async e => (await Wi.delete(`/api/conversation/delete/?conversation_ids=${e}`, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , Bze = async e => (await Wi.post("/api/conversation/projects/create/", e, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , _5 = async () => (await Wi.get("/api/conversation/projects/", {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , zze = async e => (await Wi.delete(`/api/conversation/projects/${e}/delete/`, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data
  , Fze = async (e, t) => (await Wi.patch(`/api/conversation/projects/${e}/update/`, {
    name: t
}, {
    headers: {
        Authorization: `Bearer ${localStorage.getItem("access_token")}`
    }
})).data;
function E5(e, t) {
    const n = String(e);
    if (typeof t != "string")
        throw new TypeError("Expected character");
    let r = 0
      , i = n.indexOf(t);
    for (; i !== -1; )
        r++,
        i = n.indexOf(t, i + t.length);
    return r
}
function Nze(e) {
    if (typeof e != "string")
        throw new TypeError("Expected a string");
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
}
function Uze(e, t, n) {
    const i = L1((n || {}).ignore || [])
      , o = Vze(t);
    let a = -1;
    for (; ++a < o.length; )
        r8(e, "text", s);
    function s(u, f) {
        let h = -1, m;
        for (; ++h < f.length; ) {
            const y = f[h]
              , b = m ? m.children : void 0;
            if (i(y, b ? b.indexOf(y) : void 0, m))
                return;
            m = y
        }
        if (m)
            return c(u, f)
    }
    function c(u, f) {
        const h = f[f.length - 1]
          , m = o[a][0]
          , y = o[a][1];
        let b = 0;
        const S = h.children.indexOf(u);
        let C = !1
          , w = [];
        m.lastIndex = 0;
        let k = m.exec(u.value);
        for (; k; ) {
            const T = k.index
              , E = {
                index: k.index,
                input: k.input,
                stack: [...f, u]
            };
            let P = y(...k, E);
            if (typeof P == "string" && (P = P.length > 0 ? {
                type: "text",
                value: P
            } : void 0),
            P === !1 ? m.lastIndex = T + 1 : (b !== T && w.push({
                type: "text",
                value: u.value.slice(b, T)
            }),
            Array.isArray(P) ? w.push(...P) : P && w.push(P),
            b = T + k[0].length,
            C = !0),
            !m.global)
                break;
            k = m.exec(u.value)
        }
        return C ? (b < u.value.length && w.push({
            type: "text",
            value: u.value.slice(b)
        }),
        h.children.splice(S, 1, ...w)) : w = [u],
        S + w.length
    }
}
function Vze(e) {
    const t = [];
    if (!Array.isArray(e))
        throw new TypeError("Expected find and replace tuple or list of tuples");
    const n = !e[0] || Array.isArray(e[0]) ? e : [e];
    let r = -1;
    for (; ++r < n.length; ) {
        const i = n[r];
        t.push([Hze(i[0]), qze(i[1])])
    }
    return t
}
function Hze(e) {
    return typeof e == "string" ? new RegExp(Nze(e),"g") : e
}
function qze(e) {
    return typeof e == "function" ? e : function() {
        return e
    }
}
const g2 = "phrasing"
  , y2 = ["autolink", "link", "image", "label"];
function Wze() {
    return {
        transforms: [Jze],
        enter: {
            literalAutolink: Yze,
            literalAutolinkEmail: b2,
            literalAutolinkHttp: b2,
            literalAutolinkWww: b2
        },
        exit: {
            literalAutolink: Xze,
            literalAutolinkEmail: Kze,
            literalAutolinkHttp: Zze,
            literalAutolinkWww: Qze
        }
    }
}
function Gze() {
    return {
        unsafe: [{
            character: "@",
            before: "[+\\-.\\w]",
            after: "[\\-.\\w]",
            inConstruct: g2,
            notInConstruct: y2
        }, {
            character: ".",
            before: "[Ww]",
            after: "[\\-.\\w]",
            inConstruct: g2,
            notInConstruct: y2
        }, {
            character: ":",
            before: "[ps]",
            after: "\\/",
            inConstruct: g2,
            notInConstruct: y2
        }]
    }
}
function Yze(e) {
    this.enter({
        type: "link",
        title: null,
        url: "",
        children: []
    }, e)
}
function b2(e) {
    this.config.enter.autolinkProtocol.call(this, e)
}
function Zze(e) {
    this.config.exit.autolinkProtocol.call(this, e)
}
function Qze(e) {
    this.config.exit.data.call(this, e);
    const t = this.stack[this.stack.length - 1];
    t.type,
    t.url = "http://" + this.sliceSerialize(e)
}
function Kze(e) {
    this.config.exit.autolinkEmail.call(this, e)
}
function Xze(e) {
    this.exit(e)
}
function Jze(e) {
    Uze(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, e5e], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)","gu"), t5e]], {
        ignore: ["link", "linkReference"]
    })
}
function e5e(e, t, n, r, i) {
    let o = "";
    if (!E7(i) || (/^w/i.test(t) && (n = t + n,
    t = "",
    o = "http://"),
    !n5e(n)))
        return !1;
    const a = r5e(n + r);
    if (!a[0])
        return !1;
    const s = {
        type: "link",
        title: null,
        url: o + t + a[0],
        children: [{
            type: "text",
            value: t + a[0]
        }]
    };
    return a[1] ? [s, {
        type: "text",
        value: a[1]
    }] : s
}
function t5e(e, t, n, r) {
    return !E7(r, !0) || /[-\d_]$/.test(n) ? !1 : {
        type: "link",
        title: null,
        url: "mailto:" + t + "@" + n,
        children: [{
            type: "text",
            value: t + "@" + n
        }]
    }
}
function n5e(e) {
    const t = e.split(".");
    return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])))
}
function r5e(e) {
    const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
    if (!t)
        return [e, void 0];
    e = e.slice(0, t.index);
    let n = t[0]
      , r = n.indexOf(")");
    const i = E5(e, "(");
    let o = E5(e, ")");
    for (; r !== -1 && i > o; )
        e += n.slice(0, r + 1),
        n = n.slice(r + 1),
        r = n.indexOf(")"),
        o++;
    return [e, n]
}
function E7(e, t) {
    const n = e.input.charCodeAt(e.index - 1);
    return (e.index === 0 || Gu(n) || O1(n)) && (!t || n !== 47)
}
A7.peek = f5e;
function i5e() {
    this.buffer()
}
function o5e(e) {
    this.enter({
        type: "footnoteReference",
        identifier: "",
        label: ""
    }, e)
}
function a5e() {
    this.buffer()
}
function s5e(e) {
    this.enter({
        type: "footnoteDefinition",
        identifier: "",
        label: "",
        children: []
    }, e)
}
function l5e(e) {
    const t = this.resume()
      , n = this.stack[this.stack.length - 1];
    n.type,
    n.identifier = Ga(this.sliceSerialize(e)).toLowerCase(),
    n.label = t
}
function c5e(e) {
    this.exit(e)
}
function u5e(e) {
    const t = this.resume()
      , n = this.stack[this.stack.length - 1];
    n.type,
    n.identifier = Ga(this.sliceSerialize(e)).toLowerCase(),
    n.label = t
}
function d5e(e) {
    this.exit(e)
}
function f5e() {
    return "["
}
function A7(e, t, n, r) {
    const i = n.createTracker(r);
    let o = i.move("[^");
    const a = n.enter("footnoteReference")
      , s = n.enter("reference");
    return o += i.move(n.safe(n.associationId(e), {
        after: "]",
        before: o
    })),
    s(),
    a(),
    o += i.move("]"),
    o
}
function h5e() {
    return {
        enter: {
            gfmFootnoteCallString: i5e,
            gfmFootnoteCall: o5e,
            gfmFootnoteDefinitionLabelString: a5e,
            gfmFootnoteDefinition: s5e
        },
        exit: {
            gfmFootnoteCallString: l5e,
            gfmFootnoteCall: c5e,
            gfmFootnoteDefinitionLabelString: u5e,
            gfmFootnoteDefinition: d5e
        }
    }
}
function p5e(e) {
    let t = !1;
    return e && e.firstLineBlank && (t = !0),
    {
        handlers: {
            footnoteDefinition: n,
            footnoteReference: A7
        },
        unsafe: [{
            character: "[",
            inConstruct: ["label", "phrasing", "reference"]
        }]
    };
    function n(r, i, o, a) {
        const s = o.createTracker(a);
        let c = s.move("[^");
        const u = o.enter("footnoteDefinition")
          , f = o.enter("label");
        return c += s.move(o.safe(o.associationId(r), {
            before: c,
            after: "]"
        })),
        f(),
        c += s.move("]:"),
        r.children && r.children.length > 0 && (s.shift(4),
        c += s.move((t ? `
` : " ") + o.indentLines(o.containerFlow(r, s.current()), t ? M7 : m5e))),
        u(),
        c
    }
}
function m5e(e, t, n) {
    return t === 0 ? e : M7(e, t, n)
}
function M7(e, t, n) {
    return (n ? "" : "    ") + e
}
const g5e = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"];
P7.peek = S5e;
function y5e() {
    return {
        canContainEols: ["delete"],
        enter: {
            strikethrough: x5e
        },
        exit: {
            strikethrough: v5e
        }
    }
}
function b5e() {
    return {
        unsafe: [{
            character: "~",
            inConstruct: "phrasing",
            notInConstruct: g5e
        }],
        handlers: {
            delete: P7
        }
    }
}
function x5e(e) {
    this.enter({
        type: "delete",
        children: []
    }, e)
}
function v5e(e) {
    this.exit(e)
}
function P7(e, t, n, r) {
    const i = n.createTracker(r)
      , o = n.enter("strikethrough");
    let a = i.move("~~");
    return a += n.containerPhrasing(e, {
        ...i.current(),
        before: a,
        after: "~"
    }),
    a += i.move("~~"),
    o(),
    a
}
function S5e() {
    return "~"
}
function C5e(e) {
    return e.length
}
function w5e(e, t) {
    const n = t || {}
      , r = (n.align || []).concat()
      , i = n.stringLength || C5e
      , o = []
      , a = []
      , s = []
      , c = [];
    let u = 0
      , f = -1;
    for (; ++f < e.length; ) {
        const v = []
          , S = [];
        let C = -1;
        for (e[f].length > u && (u = e[f].length); ++C < e[f].length; ) {
            const w = k5e(e[f][C]);
            if (n.alignDelimiters !== !1) {
                const k = i(w);
                S[C] = k,
                (c[C] === void 0 || k > c[C]) && (c[C] = k)
            }
            v.push(w)
        }
        a[f] = v,
        s[f] = S
    }
    let h = -1;
    if (typeof r == "object" && "length"in r)
        for (; ++h < u; )
            o[h] = A5(r[h]);
    else {
        const v = A5(r);
        for (; ++h < u; )
            o[h] = v
    }
    h = -1;
    const m = []
      , y = [];
    for (; ++h < u; ) {
        const v = o[h];
        let S = ""
          , C = "";
        v === 99 ? (S = ":",
        C = ":") : v === 108 ? S = ":" : v === 114 && (C = ":");
        let w = n.alignDelimiters === !1 ? 1 : Math.max(1, c[h] - S.length - C.length);
        const k = S + "-".repeat(w) + C;
        n.alignDelimiters !== !1 && (w = S.length + w + C.length,
        w > c[h] && (c[h] = w),
        y[h] = w),
        m[h] = k
    }
    a.splice(1, 0, m),
    s.splice(1, 0, y),
    f = -1;
    const b = [];
    for (; ++f < a.length; ) {
        const v = a[f]
          , S = s[f];
        h = -1;
        const C = [];
        for (; ++h < u; ) {
            const w = v[h] || "";
            let k = ""
              , T = "";
            if (n.alignDelimiters !== !1) {
                const E = c[h] - (S[h] || 0)
                  , P = o[h];
                P === 114 ? k = " ".repeat(E) : P === 99 ? E % 2 ? (k = " ".repeat(E / 2 + .5),
                T = " ".repeat(E / 2 - .5)) : (k = " ".repeat(E / 2),
                T = k) : T = " ".repeat(E)
            }
            n.delimiterStart !== !1 && !h && C.push("|"),
            n.padding !== !1 && !(n.alignDelimiters === !1 && w === "") && (n.delimiterStart !== !1 || h) && C.push(" "),
            n.alignDelimiters !== !1 && C.push(k),
            C.push(w),
            n.alignDelimiters !== !1 && C.push(T),
            n.padding !== !1 && C.push(" "),
            (n.delimiterEnd !== !1 || h !== u - 1) && C.push("|")
        }
        b.push(n.delimiterEnd === !1 ? C.join("").replace(/ +$/, "") : C.join(""))
    }
    return b.join(`
`)
}
function k5e(e) {
    return e == null ? "" : String(e)
}
function A5(e) {
    const t = typeof e == "string" ? e.codePointAt(0) : 0;
    return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0
}
function T5e(e, t, n, r) {
    const i = n.enter("blockquote")
      , o = n.createTracker(r);
    o.move("> "),
    o.shift(2);
    const a = n.indentLines(n.containerFlow(e, o.current()), _5e);
    return i(),
    a
}
function _5e(e, t, n) {
    return ">" + (n ? "" : " ") + e
}
function E5e(e, t) {
    return M5(e, t.inConstruct, !0) && !M5(e, t.notInConstruct, !1)
}
function M5(e, t, n) {
    if (typeof t == "string" && (t = [t]),
    !t || t.length === 0)
        return n;
    let r = -1;
    for (; ++r < t.length; )
        if (e.includes(t[r]))
            return !0;
    return !1
}
function P5(e, t, n, r) {
    let i = -1;
    for (; ++i < n.unsafe.length; )
        if (n.unsafe[i].character === `
` && E5e(n.stack, n.unsafe[i]))
            return /[ \t]/.test(r.before) ? "" : " ";
    return `\\
`
}
function A5e(e, t) {
    const n = String(e);
    let r = n.indexOf(t)
      , i = r
      , o = 0
      , a = 0;
    if (typeof t != "string")
        throw new TypeError("Expected substring");
    for (; r !== -1; )
        r === i ? ++o > a && (a = o) : o = 1,
        i = r + t.length,
        r = n.indexOf(t, i);
    return a
}
function M5e(e, t) {
    return !!(t.options.fences === !1 && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value))
}
function P5e(e) {
    const t = e.options.fence || "`";
    if (t !== "`" && t !== "~")
        throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`");
    return t
}
function R5e(e, t, n, r) {
    const i = P5e(n)
      , o = e.value || ""
      , a = i === "`" ? "GraveAccent" : "Tilde";
    if (M5e(e, n)) {
        const h = n.enter("codeIndented")
          , m = n.indentLines(o, D5e);
        return h(),
        m
    }
    const s = n.createTracker(r)
      , c = i.repeat(Math.max(A5e(o, i) + 1, 3))
      , u = n.enter("codeFenced");
    let f = s.move(c);
    if (e.lang) {
        const h = n.enter(`codeFencedLang${a}`);
        f += s.move(n.safe(e.lang, {
            before: f,
            after: " ",
            encode: ["`"],
            ...s.current()
        })),
        h()
    }
    if (e.lang && e.meta) {
        const h = n.enter(`codeFencedMeta${a}`);
        f += s.move(" "),
        f += s.move(n.safe(e.meta, {
            before: f,
            after: `
`,
            encode: ["`"],
            ...s.current()
        })),
        h()
    }
    return f += s.move(`
`),
    o && (f += s.move(o + `
`)),
    f += s.move(c),
    u(),
    f
}
function D5e(e, t, n) {
    return (n ? "" : "    ") + e
}
function nP(e) {
    const t = e.options.quote || '"';
    if (t !== '"' && t !== "'")
        throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`");
    return t
}
function O5e(e, t, n, r) {
    const i = nP(n)
      , o = i === '"' ? "Quote" : "Apostrophe"
      , a = n.enter("definition");
    let s = n.enter("label");
    const c = n.createTracker(r);
    let u = c.move("[");
    return u += c.move(n.safe(n.associationId(e), {
        before: u,
        after: "]",
        ...c.current()
    })),
    u += c.move("]: "),
    s(),
    !e.url || /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"),
    u += c.move("<"),
    u += c.move(n.safe(e.url, {
        before: u,
        after: ">",
        ...c.current()
    })),
    u += c.move(">")) : (s = n.enter("destinationRaw"),
    u += c.move(n.safe(e.url, {
        before: u,
        after: e.title ? " " : `
`,
        ...c.current()
    }))),
    s(),
    e.title && (s = n.enter(`title${o}`),
    u += c.move(" " + i),
    u += c.move(n.safe(e.title, {
        before: u,
        after: i,
        ...c.current()
    })),
    u += c.move(i),
    s()),
    a(),
    u
}
function I5e(e) {
    const t = e.options.emphasis || "*";
    if (t !== "*" && t !== "_")
        throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`");
    return t
}
function bg(e) {
    return "&#x" + e.toString(16).toUpperCase() + ";"
}
function wv(e, t, n) {
    const r = Kf(e)
      , i = Kf(t);
    return r === void 0 ? i === void 0 ? n === "_" ? {
        inside: !0,
        outside: !0
    } : {
        inside: !1,
        outside: !1
    } : i === 1 ? {
        inside: !0,
        outside: !0
    } : {
        inside: !1,
        outside: !0
    } : r === 1 ? i === void 0 ? {
        inside: !1,
        outside: !1
    } : i === 1 ? {
        inside: !0,
        outside: !0
    } : {
        inside: !1,
        outside: !1
    } : i === void 0 ? {
        inside: !1,
        outside: !1
    } : i === 1 ? {
        inside: !0,
        outside: !1
    } : {
        inside: !1,
        outside: !1
    }
}
R7.peek = $5e;
function R7(e, t, n, r) {
    const i = I5e(n)
      , o = n.enter("emphasis")
      , a = n.createTracker(r)
      , s = a.move(i);
    let c = a.move(n.containerPhrasing(e, {
        after: i,
        before: s,
        ...a.current()
    }));
    const u = c.charCodeAt(0)
      , f = wv(r.before.charCodeAt(r.before.length - 1), u, i);
    f.inside && (c = bg(u) + c.slice(1));
    const h = c.charCodeAt(c.length - 1)
      , m = wv(r.after.charCodeAt(0), h, i);
    m.inside && (c = c.slice(0, -1) + bg(h));
    const y = a.move(i);
    return o(),
    n.attentionEncodeSurroundingInfo = {
        after: m.outside,
        before: f.outside
    },
    s + c + y
}
function $5e(e, t, n) {
    return n.options.emphasis || "*"
}
function L5e(e, t) {
    let n = !1;
    return XA(e, function(r) {
        if ("value"in r && /\r?\n|\r/.test(r.value) || r.type === "break")
            return n = !0,
            HT
    }),
    !!((!e.depth || e.depth < 3) && qA(e) && (t.options.setext || n))
}
function j5e(e, t, n, r) {
    const i = Math.max(Math.min(6, e.depth || 1), 1)
      , o = n.createTracker(r);
    if (L5e(e, n)) {
        const f = n.enter("headingSetext")
          , h = n.enter("phrasing")
          , m = n.containerPhrasing(e, {
            ...o.current(),
            before: `
`,
            after: `
`
        });
        return h(),
        f(),
        m + `
` + (i === 1 ? "=" : "-").repeat(m.length - (Math.max(m.lastIndexOf("\r"), m.lastIndexOf(`
`)) + 1))
    }
    const a = "#".repeat(i)
      , s = n.enter("headingAtx")
      , c = n.enter("phrasing");
    o.move(a + " ");
    let u = n.containerPhrasing(e, {
        before: "# ",
        after: `
`,
        ...o.current()
    });
    return /^[\t ]/.test(u) && (u = bg(u.charCodeAt(0)) + u.slice(1)),
    u = u ? a + " " + u : a,
    n.options.closeAtx && (u += " " + a),
    c(),
    s(),
    u
}
D7.peek = B5e;
function D7(e) {
    return e.value || ""
}
function B5e() {
    return "<"
}
O7.peek = z5e;
function O7(e, t, n, r) {
    const i = nP(n)
      , o = i === '"' ? "Quote" : "Apostrophe"
      , a = n.enter("image");
    let s = n.enter("label");
    const c = n.createTracker(r);
    let u = c.move("![");
    return u += c.move(n.safe(e.alt, {
        before: u,
        after: "]",
        ...c.current()
    })),
    u += c.move("]("),
    s(),
    !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"),
    u += c.move("<"),
    u += c.move(n.safe(e.url, {
        before: u,
        after: ">",
        ...c.current()
    })),
    u += c.move(">")) : (s = n.enter("destinationRaw"),
    u += c.move(n.safe(e.url, {
        before: u,
        after: e.title ? " " : ")",
        ...c.current()
    }))),
    s(),
    e.title && (s = n.enter(`title${o}`),
    u += c.move(" " + i),
    u += c.move(n.safe(e.title, {
        before: u,
        after: i,
        ...c.current()
    })),
    u += c.move(i),
    s()),
    u += c.move(")"),
    a(),
    u
}
function z5e() {
    return "!"
}
I7.peek = F5e;
function I7(e, t, n, r) {
    const i = e.referenceType
      , o = n.enter("imageReference");
    let a = n.enter("label");
    const s = n.createTracker(r);
    let c = s.move("![");
    const u = n.safe(e.alt, {
        before: c,
        after: "]",
        ...s.current()
    });
    c += s.move(u + "]["),
    a();
    const f = n.stack;
    n.stack = [],
    a = n.enter("reference");
    const h = n.safe(n.associationId(e), {
        before: c,
        after: "]",
        ...s.current()
    });
    return a(),
    n.stack = f,
    o(),
    i === "full" || !u || u !== h ? c += s.move(h + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += s.move("]"),
    c
}
function F5e() {
    return "!"
}
$7.peek = N5e;
function $7(e, t, n) {
    let r = e.value || ""
      , i = "`"
      , o = -1;
    for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
        i += "`";
    for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++o < n.unsafe.length; ) {
        const a = n.unsafe[o]
          , s = n.compilePattern(a);
        let c;
        if (a.atBreak)
            for (; c = s.exec(r); ) {
                let u = c.index;
                r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--,
                r = r.slice(0, u) + " " + r.slice(c.index + 1)
            }
    }
    return i + r + i
}
function N5e() {
    return "`"
}
function L7(e, t) {
    const n = qA(e);
    return !!(!t.options.resourceLink && e.url && !e.title && e.children && e.children.length === 1 && e.children[0].type === "text" && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url))
}
j7.peek = U5e;
function j7(e, t, n, r) {
    const i = nP(n)
      , o = i === '"' ? "Quote" : "Apostrophe"
      , a = n.createTracker(r);
    let s, c;
    if (L7(e, n)) {
        const f = n.stack;
        n.stack = [],
        s = n.enter("autolink");
        let h = a.move("<");
        return h += a.move(n.containerPhrasing(e, {
            before: h,
            after: ">",
            ...a.current()
        })),
        h += a.move(">"),
        s(),
        n.stack = f,
        h
    }
    s = n.enter("link"),
    c = n.enter("label");
    let u = a.move("[");
    return u += a.move(n.containerPhrasing(e, {
        before: u,
        after: "](",
        ...a.current()
    })),
    u += a.move("]("),
    c(),
    !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"),
    u += a.move("<"),
    u += a.move(n.safe(e.url, {
        before: u,
        after: ">",
        ...a.current()
    })),
    u += a.move(">")) : (c = n.enter("destinationRaw"),
    u += a.move(n.safe(e.url, {
        before: u,
        after: e.title ? " " : ")",
        ...a.current()
    }))),
    c(),
    e.title && (c = n.enter(`title${o}`),
    u += a.move(" " + i),
    u += a.move(n.safe(e.title, {
        before: u,
        after: i,
        ...a.current()
    })),
    u += a.move(i),
    c()),
    u += a.move(")"),
    s(),
    u
}
function U5e(e, t, n) {
    return L7(e, n) ? "<" : "["
}
B7.peek = V5e;
function B7(e, t, n, r) {
    const i = e.referenceType
      , o = n.enter("linkReference");
    let a = n.enter("label");
    const s = n.createTracker(r);
    let c = s.move("[");
    const u = n.containerPhrasing(e, {
        before: c,
        after: "]",
        ...s.current()
    });
    c += s.move(u + "]["),
    a();
    const f = n.stack;
    n.stack = [],
    a = n.enter("reference");
    const h = n.safe(n.associationId(e), {
        before: c,
        after: "]",
        ...s.current()
    });
    return a(),
    n.stack = f,
    o(),
    i === "full" || !u || u !== h ? c += s.move(h + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += s.move("]"),
    c
}
function V5e() {
    return "["
}
function rP(e) {
    const t = e.options.bullet || "*";
    if (t !== "*" && t !== "+" && t !== "-")
        throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`");
    return t
}
function H5e(e) {
    const t = rP(e)
      , n = e.options.bulletOther;
    if (!n)
        return t === "*" ? "-" : "*";
    if (n !== "*" && n !== "+" && n !== "-")
        throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
    if (n === t)
        throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different");
    return n
}
function q5e(e) {
    const t = e.options.bulletOrdered || ".";
    if (t !== "." && t !== ")")
        throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`");
    return t
}
function z7(e) {
    const t = e.options.rule || "*";
    if (t !== "*" && t !== "-" && t !== "_")
        throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`");
    return t
}
function W5e(e, t, n, r) {
    const i = n.enter("list")
      , o = n.bulletCurrent;
    let a = e.ordered ? q5e(n) : rP(n);
    const s = e.ordered ? a === "." ? ")" : "." : H5e(n);
    let c = t && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
    if (!e.ordered) {
        const f = e.children ? e.children[0] : void 0;
        if ((a === "*" || a === "-") && f && (!f.children || !f.children[0]) && n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0),
        z7(n) === a && f) {
            let h = -1;
            for (; ++h < e.children.length; ) {
                const m = e.children[h];
                if (m && m.type === "listItem" && m.children && m.children[0] && m.children[0].type === "thematicBreak") {
                    c = !0;
                    break
                }
            }
        }
    }
    c && (a = s),
    n.bulletCurrent = a;
    const u = n.containerFlow(e, r);
    return n.bulletLastUsed = a,
    n.bulletCurrent = o,
    i(),
    u
}
function G5e(e) {
    const t = e.options.listItemIndent || "one";
    if (t !== "tab" && t !== "one" && t !== "mixed")
        throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
    return t
}
function Y5e(e, t, n, r) {
    const i = G5e(n);
    let o = n.bulletCurrent || rP(n);
    t && t.type === "list" && t.ordered && (o = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + o);
    let a = o.length + 1;
    (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (a = Math.ceil(a / 4) * 4);
    const s = n.createTracker(r);
    s.move(o + " ".repeat(a - o.length)),
    s.shift(a);
    const c = n.enter("listItem")
      , u = n.indentLines(n.containerFlow(e, s.current()), f);
    return c(),
    u;
    function f(h, m, y) {
        return m ? (y ? "" : " ".repeat(a)) + h : (y ? o : o + " ".repeat(a - o.length)) + h
    }
}
function Z5e(e, t, n, r) {
    const i = n.enter("paragraph")
      , o = n.enter("phrasing")
      , a = n.containerPhrasing(e, r);
    return o(),
    i(),
    a
}
const Q5e = L1(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]);
function K5e(e, t, n, r) {
    return (e.children.some(function(a) {
        return Q5e(a)
    }) ? n.containerPhrasing : n.containerFlow).call(n, e, r)
}
function X5e(e) {
    const t = e.options.strong || "*";
    if (t !== "*" && t !== "_")
        throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`");
    return t
}
F7.peek = J5e;
function F7(e, t, n, r) {
    const i = X5e(n)
      , o = n.enter("strong")
      , a = n.createTracker(r)
      , s = a.move(i + i);
    let c = a.move(n.containerPhrasing(e, {
        after: i,
        before: s,
        ...a.current()
    }));
    const u = c.charCodeAt(0)
      , f = wv(r.before.charCodeAt(r.before.length - 1), u, i);
    f.inside && (c = bg(u) + c.slice(1));
    const h = c.charCodeAt(c.length - 1)
      , m = wv(r.after.charCodeAt(0), h, i);
    m.inside && (c = c.slice(0, -1) + bg(h));
    const y = a.move(i + i);
    return o(),
    n.attentionEncodeSurroundingInfo = {
        after: m.outside,
        before: f.outside
    },
    s + c + y
}
function J5e(e, t, n) {
    return n.options.strong || "*"
}
function eFe(e, t, n, r) {
    return n.safe(e.value, r)
}
function tFe(e) {
    const t = e.options.ruleRepetition || 3;
    if (t < 3)
        throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more");
    return t
}
function nFe(e, t, n) {
    const r = (z7(n) + (n.options.ruleSpaces ? " " : "")).repeat(tFe(n));
    return n.options.ruleSpaces ? r.slice(0, -1) : r
}
const N7 = {
    blockquote: T5e,
    break: P5,
    code: R5e,
    definition: O5e,
    emphasis: R7,
    hardBreak: P5,
    heading: j5e,
    html: D7,
    image: O7,
    imageReference: I7,
    inlineCode: $7,
    link: j7,
    linkReference: B7,
    list: W5e,
    listItem: Y5e,
    paragraph: Z5e,
    root: K5e,
    strong: F7,
    text: eFe,
    thematicBreak: nFe
};
function rFe() {
    return {
        enter: {
            table: iFe,
            tableData: R5,
            tableHeader: R5,
            tableRow: aFe
        },
        exit: {
            codeText: sFe,
            table: oFe,
            tableData: x2,
            tableHeader: x2,
            tableRow: x2
        }
    }
}
function iFe(e) {
    const t = e._align;
    this.enter({
        type: "table",
        align: t.map(function(n) {
            return n === "none" ? null : n
        }),
        children: []
    }, e),
    this.data.inTable = !0
}
function oFe(e) {
    this.exit(e),
    this.data.inTable = void 0
}
function aFe(e) {
    this.enter({
        type: "tableRow",
        children: []
    }, e)
}
function x2(e) {
    this.exit(e)
}
function R5(e) {
    this.enter({
        type: "tableCell",
        children: []
    }, e)
}
function sFe(e) {
    let t = this.resume();
    this.data.inTable && (t = t.replace(/\\([\\|])/g, lFe));
    const n = this.stack[this.stack.length - 1];
    n.type,
    n.value = t,
    this.exit(e)
}
function lFe(e, t) {
    return t === "|" ? t : e
}
function cFe(e) {
    const t = e || {}
      , n = t.tableCellPadding
      , r = t.tablePipeAlign
      , i = t.stringLength
      , o = n ? " " : "|";
    return {
        unsafe: [{
            character: "\r",
            inConstruct: "tableCell"
        }, {
            character: `
`,
            inConstruct: "tableCell"
        }, {
            atBreak: !0,
            character: "|",
            after: "[	 :-]"
        }, {
            character: "|",
            inConstruct: "tableCell"
        }, {
            atBreak: !0,
            character: ":",
            after: "-"
        }, {
            atBreak: !0,
            character: "-",
            after: "[:|-]"
        }],
        handlers: {
            inlineCode: m,
            table: a,
            tableCell: c,
            tableRow: s
        }
    };
    function a(y, b, v, S) {
        return u(f(y, v, S), y.align)
    }
    function s(y, b, v, S) {
        const C = h(y, v, S)
          , w = u([C]);
        return w.slice(0, w.indexOf(`
`))
    }
    function c(y, b, v, S) {
        const C = v.enter("tableCell")
          , w = v.enter("phrasing")
          , k = v.containerPhrasing(y, {
            ...S,
            before: o,
            after: o
        });
        return w(),
        C(),
        k
    }
    function u(y, b) {
        return w5e(y, {
            align: b,
            alignDelimiters: r,
            padding: n,
            stringLength: i
        })
    }
    function f(y, b, v) {
        const S = y.children;
        let C = -1;
        const w = []
          , k = b.enter("table");
        for (; ++C < S.length; )
            w[C] = h(S[C], b, v);
        return k(),
        w
    }
    function h(y, b, v) {
        const S = y.children;
        let C = -1;
        const w = []
          , k = b.enter("tableRow");
        for (; ++C < S.length; )
            w[C] = c(S[C], y, b, v);
        return k(),
        w
    }
    function m(y, b, v) {
        let S = N7.inlineCode(y, b, v);
        return v.stack.includes("tableCell") && (S = S.replace(/\|/g, "\\$&")),
        S
    }
}
function uFe() {
    return {
        exit: {
            taskListCheckValueChecked: D5,
            taskListCheckValueUnchecked: D5,
            paragraph: fFe
        }
    }
}
function dFe() {
    return {
        unsafe: [{
            atBreak: !0,
            character: "-",
            after: "[:|-]"
        }],
        handlers: {
            listItem: hFe
        }
    }
}
function D5(e) {
    const t = this.stack[this.stack.length - 2];
    t.type,
    t.checked = e.type === "taskListCheckValueChecked"
}
function fFe(e) {
    const t = this.stack[this.stack.length - 2];
    if (t && t.type === "listItem" && typeof t.checked == "boolean") {
        const n = this.stack[this.stack.length - 1];
        n.type;
        const r = n.children[0];
        if (r && r.type === "text") {
            const i = t.children;
            let o = -1, a;
            for (; ++o < i.length; ) {
                const s = i[o];
                if (s.type === "paragraph") {
                    a = s;
                    break
                }
            }
            a === n && (r.value = r.value.slice(1),
            r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++,
            r.position.start.offset++,
            n.position.start = Object.assign({}, r.position.start)))
        }
    }
    this.exit(e)
}
function hFe(e, t, n, r) {
    const i = e.children[0]
      , o = typeof e.checked == "boolean" && i && i.type === "paragraph"
      , a = "[" + (e.checked ? "x" : " ") + "] "
      , s = n.createTracker(r);
    o && s.move(a);
    let c = N7.listItem(e, t, n, {
        ...r,
        ...s.current()
    });
    return o && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)),
    c;
    function u(f) {
        return f + a
    }
}
function pFe() {
    return [Wze(), h5e(), y5e(), rFe(), uFe()]
}
function mFe(e) {
    return {
        extensions: [Gze(), p5e(e), b5e(), cFe(e), dFe()]
    }
}
const gFe = {
    tokenize: CFe,
    partial: !0
}
  , U7 = {
    tokenize: wFe,
    partial: !0
}
  , V7 = {
    tokenize: kFe,
    partial: !0
}
  , H7 = {
    tokenize: TFe,
    partial: !0
}
  , yFe = {
    tokenize: _Fe,
    partial: !0
}
  , q7 = {
    name: "wwwAutolink",
    tokenize: vFe,
    previous: G7
}
  , W7 = {
    name: "protocolAutolink",
    tokenize: SFe,
    previous: Y7
}
  , Pl = {
    name: "emailAutolink",
    tokenize: xFe,
    previous: Z7
}
  , Bs = {};
function bFe() {
    return {
        text: Bs
    }
}
let su = 48;
for (; su < 123; )
    Bs[su] = Pl,
    su++,
    su === 58 ? su = 65 : su === 91 && (su = 97);
Bs[43] = Pl;
Bs[45] = Pl;
Bs[46] = Pl;
Bs[95] = Pl;
Bs[72] = [Pl, W7];
Bs[104] = [Pl, W7];
Bs[87] = [Pl, q7];
Bs[119] = [Pl, q7];
function xFe(e, t, n) {
    const r = this;
    let i, o;
    return a;
    function a(h) {
        return !Z_(h) || !Z7.call(r, r.previous) || iP(r.events) ? n(h) : (e.enter("literalAutolink"),
        e.enter("literalAutolinkEmail"),
        s(h))
    }
    function s(h) {
        return Z_(h) ? (e.consume(h),
        s) : h === 64 ? (e.consume(h),
        c) : n(h)
    }
    function c(h) {
        return h === 46 ? e.check(yFe, f, u)(h) : h === 45 || h === 95 || Ai(h) ? (o = !0,
        e.consume(h),
        c) : f(h)
    }
    function u(h) {
        return e.consume(h),
        i = !0,
        c
    }
    function f(h) {
        return o && i && Ni(r.previous) ? (e.exit("literalAutolinkEmail"),
        e.exit("literalAutolink"),
        t(h)) : n(h)
    }
}
function vFe(e, t, n) {
    const r = this;
    return i;
    function i(a) {
        return a !== 87 && a !== 119 || !G7.call(r, r.previous) || iP(r.events) ? n(a) : (e.enter("literalAutolink"),
        e.enter("literalAutolinkWww"),
        e.check(gFe, e.attempt(U7, e.attempt(V7, o), n), n)(a))
    }
    function o(a) {
        return e.exit("literalAutolinkWww"),
        e.exit("literalAutolink"),
        t(a)
    }
}
function SFe(e, t, n) {
    const r = this;
    let i = ""
      , o = !1;
    return a;
    function a(h) {
        return (h === 72 || h === 104) && Y7.call(r, r.previous) && !iP(r.events) ? (e.enter("literalAutolink"),
        e.enter("literalAutolinkHttp"),
        i += String.fromCodePoint(h),
        e.consume(h),
        s) : n(h)
    }
    function s(h) {
        if (Ni(h) && i.length < 5)
            return i += String.fromCodePoint(h),
            e.consume(h),
            s;
        if (h === 58) {
            const m = i.toLowerCase();
            if (m === "http" || m === "https")
                return e.consume(h),
                c
        }
        return n(h)
    }
    function c(h) {
        return h === 47 ? (e.consume(h),
        o ? u : (o = !0,
        c)) : n(h)
    }
    function u(h) {
        return h === null || B0(h) || ir(h) || Gu(h) || O1(h) ? n(h) : e.attempt(U7, e.attempt(V7, f), n)(h)
    }
    function f(h) {
        return e.exit("literalAutolinkHttp"),
        e.exit("literalAutolink"),
        t(h)
    }
}
function CFe(e, t, n) {
    let r = 0;
    return i;
    function i(a) {
        return (a === 87 || a === 119) && r < 3 ? (r++,
        e.consume(a),
        i) : a === 46 && r === 3 ? (e.consume(a),
        o) : n(a)
    }
    function o(a) {
        return a === null ? n(a) : t(a)
    }
}
function wFe(e, t, n) {
    let r, i, o;
    return a;
    function a(u) {
        return u === 46 || u === 95 ? e.check(H7, c, s)(u) : u === null || ir(u) || Gu(u) || u !== 45 && O1(u) ? c(u) : (o = !0,
        e.consume(u),
        a)
    }
    function s(u) {
        return u === 95 ? r = !0 : (i = r,
        r = void 0),
        e.consume(u),
        a
    }
    function c(u) {
        return i || r || !o ? n(u) : t(u)
    }
}
function kFe(e, t) {
    let n = 0
      , r = 0;
    return i;
    function i(a) {
        return a === 40 ? (n++,
        e.consume(a),
        i) : a === 41 && r < n ? o(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? e.check(H7, t, o)(a) : a === null || ir(a) || Gu(a) ? t(a) : (e.consume(a),
        i)
    }
    function o(a) {
        return a === 41 && r++,
        e.consume(a),
        i
    }
}
function TFe(e, t, n) {
    return r;
    function r(s) {
        return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s),
        r) : s === 38 ? (e.consume(s),
        o) : s === 93 ? (e.consume(s),
        i) : s === 60 || s === null || ir(s) || Gu(s) ? t(s) : n(s)
    }
    function i(s) {
        return s === null || s === 40 || s === 91 || ir(s) || Gu(s) ? t(s) : r(s)
    }
    function o(s) {
        return Ni(s) ? a(s) : n(s)
    }
    function a(s) {
        return s === 59 ? (e.consume(s),
        r) : Ni(s) ? (e.consume(s),
        a) : n(s)
    }
}
function _Fe(e, t, n) {
    return r;
    function r(o) {
        return e.consume(o),
        i
    }
    function i(o) {
        return Ai(o) ? n(o) : t(o)
    }
}
function G7(e) {
    return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || ir(e)
}
function Y7(e) {
    return !Ni(e)
}
function Z7(e) {
    return !(e === 47 || Z_(e))
}
function Z_(e) {
    return e === 43 || e === 45 || e === 46 || e === 95 || Ai(e)
}
function iP(e) {
    let t = e.length
      , n = !1;
    for (; t--; ) {
        const r = e[t][1];
        if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
            n = !0;
            break
        }
        if (r._gfmAutolinkLiteralWalkedInto) {
            n = !1;
            break
        }
    }
    return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0),
    n
}
const EFe = {
    tokenize: $Fe,
    partial: !0
};
function AFe() {
    return {
        document: {
            91: {
                name: "gfmFootnoteDefinition",
                tokenize: DFe,
                continuation: {
                    tokenize: OFe
                },
                exit: IFe
            }
        },
        text: {
            91: {
                name: "gfmFootnoteCall",
                tokenize: RFe
            },
            93: {
                name: "gfmPotentialFootnoteCall",
                add: "after",
                tokenize: MFe,
                resolveTo: PFe
            }
        }
    }
}
function MFe(e, t, n) {
    const r = this;
    let i = r.events.length;
    const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let a;
    for (; i--; ) {
        const c = r.events[i][1];
        if (c.type === "labelImage") {
            a = c;
            break
        }
        if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
            break
    }
    return s;
    function s(c) {
        if (!a || !a._balanced)
            return n(c);
        const u = Ga(r.sliceSerialize({
            start: a.end,
            end: r.now()
        }));
        return u.codePointAt(0) !== 94 || !o.includes(u.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"),
        e.consume(c),
        e.exit("gfmFootnoteCallLabelMarker"),
        t(c))
    }
}
function PFe(e, t) {
    let n = e.length;
    for (; n--; )
        if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
            e[n][1];
            break
        }
    e[n + 1][1].type = "data",
    e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
    const r = {
        type: "gfmFootnoteCall",
        start: Object.assign({}, e[n + 3][1].start),
        end: Object.assign({}, e[e.length - 1][1].end)
    }
      , i = {
        type: "gfmFootnoteCallMarker",
        start: Object.assign({}, e[n + 3][1].end),
        end: Object.assign({}, e[n + 3][1].end)
    };
    i.end.column++,
    i.end.offset++,
    i.end._bufferIndex++;
    const o = {
        type: "gfmFootnoteCallString",
        start: Object.assign({}, i.end),
        end: Object.assign({}, e[e.length - 1][1].start)
    }
      , a = {
        type: "chunkString",
        contentType: "string",
        start: Object.assign({}, o.start),
        end: Object.assign({}, o.end)
    }
      , s = [e[n + 1], e[n + 2], ["enter", r, t], e[n + 3], e[n + 4], ["enter", i, t], ["exit", i, t], ["enter", o, t], ["enter", a, t], ["exit", a, t], ["exit", o, t], e[e.length - 2], e[e.length - 1], ["exit", r, t]];
    return e.splice(n, e.length - n + 1, ...s),
    e
}
function RFe(e, t, n) {
    const r = this
      , i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let o = 0, a;
    return s;
    function s(h) {
        return e.enter("gfmFootnoteCall"),
        e.enter("gfmFootnoteCallLabelMarker"),
        e.consume(h),
        e.exit("gfmFootnoteCallLabelMarker"),
        c
    }
    function c(h) {
        return h !== 94 ? n(h) : (e.enter("gfmFootnoteCallMarker"),
        e.consume(h),
        e.exit("gfmFootnoteCallMarker"),
        e.enter("gfmFootnoteCallString"),
        e.enter("chunkString").contentType = "string",
        u)
    }
    function u(h) {
        if (o > 999 || h === 93 && !a || h === null || h === 91 || ir(h))
            return n(h);
        if (h === 93) {
            e.exit("chunkString");
            const m = e.exit("gfmFootnoteCallString");
            return i.includes(Ga(r.sliceSerialize(m))) ? (e.enter("gfmFootnoteCallLabelMarker"),
            e.consume(h),
            e.exit("gfmFootnoteCallLabelMarker"),
            e.exit("gfmFootnoteCall"),
            t) : n(h)
        }
        return ir(h) || (a = !0),
        o++,
        e.consume(h),
        h === 92 ? f : u
    }
    function f(h) {
        return h === 91 || h === 92 || h === 93 ? (e.consume(h),
        o++,
        u) : u(h)
    }
}
function DFe(e, t, n) {
    const r = this
      , i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let o, a = 0, s;
    return c;
    function c(b) {
        return e.enter("gfmFootnoteDefinition")._container = !0,
        e.enter("gfmFootnoteDefinitionLabel"),
        e.enter("gfmFootnoteDefinitionLabelMarker"),
        e.consume(b),
        e.exit("gfmFootnoteDefinitionLabelMarker"),
        u
    }
    function u(b) {
        return b === 94 ? (e.enter("gfmFootnoteDefinitionMarker"),
        e.consume(b),
        e.exit("gfmFootnoteDefinitionMarker"),
        e.enter("gfmFootnoteDefinitionLabelString"),
        e.enter("chunkString").contentType = "string",
        f) : n(b)
    }
    function f(b) {
        if (a > 999 || b === 93 && !s || b === null || b === 91 || ir(b))
            return n(b);
        if (b === 93) {
            e.exit("chunkString");
            const v = e.exit("gfmFootnoteDefinitionLabelString");
            return o = Ga(r.sliceSerialize(v)),
            e.enter("gfmFootnoteDefinitionLabelMarker"),
            e.consume(b),
            e.exit("gfmFootnoteDefinitionLabelMarker"),
            e.exit("gfmFootnoteDefinitionLabel"),
            m
        }
        return ir(b) || (s = !0),
        a++,
        e.consume(b),
        b === 92 ? h : f
    }
    function h(b) {
        return b === 91 || b === 92 || b === 93 ? (e.consume(b),
        a++,
        f) : f(b)
    }
    function m(b) {
        return b === 58 ? (e.enter("definitionMarker"),
        e.consume(b),
        e.exit("definitionMarker"),
        i.includes(o) || i.push(o),
        An(e, y, "gfmFootnoteDefinitionWhitespace")) : n(b)
    }
    function y(b) {
        return t(b)
    }
}
function OFe(e, t, n) {
    return e.check(ey, t, e.attempt(EFe, t, n))
}
function IFe(e) {
    e.exit("gfmFootnoteDefinition")
}
function $Fe(e, t, n) {
    const r = this;
    return An(e, i, "gfmFootnoteDefinitionIndent", 5);
    function i(o) {
        const a = r.events[r.events.length - 1];
        return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? t(o) : n(o)
    }
}
function LFe(e) {
    let n = (e || {}).singleTilde;
    const r = {
        name: "strikethrough",
        tokenize: o,
        resolveAll: i
    };
    return n == null && (n = !0),
    {
        text: {
            126: r
        },
        insideSpan: {
            null: [r]
        },
        attentionMarkers: {
            null: [126]
        }
    };
    function i(a, s) {
        let c = -1;
        for (; ++c < a.length; )
            if (a[c][0] === "enter" && a[c][1].type === "strikethroughSequenceTemporary" && a[c][1]._close) {
                let u = c;
                for (; u--; )
                    if (a[u][0] === "exit" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._open && a[c][1].end.offset - a[c][1].start.offset === a[u][1].end.offset - a[u][1].start.offset) {
                        a[c][1].type = "strikethroughSequence",
                        a[u][1].type = "strikethroughSequence";
                        const f = {
                            type: "strikethrough",
                            start: Object.assign({}, a[u][1].start),
                            end: Object.assign({}, a[c][1].end)
                        }
                          , h = {
                            type: "strikethroughText",
                            start: Object.assign({}, a[u][1].end),
                            end: Object.assign({}, a[c][1].start)
                        }
                          , m = [["enter", f, s], ["enter", a[u][1], s], ["exit", a[u][1], s], ["enter", h, s]]
                          , y = s.parser.constructs.insideSpan.null;
                        y && Yo(m, m.length, 0, I1(y, a.slice(u + 1, c), s)),
                        Yo(m, m.length, 0, [["exit", h, s], ["enter", a[c][1], s], ["exit", a[c][1], s], ["exit", f, s]]),
                        Yo(a, u - 1, c - u + 3, m),
                        c = u + m.length - 2;
                        break
                    }
            }
        for (c = -1; ++c < a.length; )
            a[c][1].type === "strikethroughSequenceTemporary" && (a[c][1].type = "data");
        return a
    }
    function o(a, s, c) {
        const u = this.previous
          , f = this.events;
        let h = 0;
        return m;
        function m(b) {
            return u === 126 && f[f.length - 1][1].type !== "characterEscape" ? c(b) : (a.enter("strikethroughSequenceTemporary"),
            y(b))
        }
        function y(b) {
            const v = Kf(u);
            if (b === 126)
                return h > 1 ? c(b) : (a.consume(b),
                h++,
                y);
            if (h < 2 && !n)
                return c(b);
            const S = a.exit("strikethroughSequenceTemporary")
              , C = Kf(b);
            return S._open = !C || C === 2 && !!v,
            S._close = !v || v === 2 && !!C,
            s(b)
        }
    }
}
class jFe {
    constructor() {
        this.map = []
    }
    add(t, n, r) {
        BFe(this, t, n, r)
    }
    consume(t) {
        if (this.map.sort(function(o, a) {
            return o[0] - a[0]
        }),
        this.map.length === 0)
            return;
        let n = this.map.length;
        const r = [];
        for (; n > 0; )
            n -= 1,
            r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]),
            t.length = this.map[n][0];
        r.push(t.slice()),
        t.length = 0;
        let i = r.pop();
        for (; i; ) {
            for (const o of i)
                t.push(o);
            i = r.pop()
        }
        this.map.length = 0
    }
}
function BFe(e, t, n, r) {
    let i = 0;
    if (!(n === 0 && r.length === 0)) {
        for (; i < e.map.length; ) {
            if (e.map[i][0] === t) {
                e.map[i][1] += n,
                e.map[i][2].push(...r);
                return
            }
            i += 1
        }
        e.map.push([t, n, r])
    }
}
function zFe(e, t) {
    let n = !1;
    const r = [];
    for (; t < e.length; ) {
        const i = e[t];
        if (n) {
            if (i[0] === "enter")
                i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
            else if (i[1].type === "tableContent") {
                if (e[t - 1][1].type === "tableDelimiterMarker") {
                    const o = r.length - 1;
                    r[o] = r[o] === "left" ? "center" : "right"
                }
            } else if (i[1].type === "tableDelimiterRow")
                break
        } else
            i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
        t += 1
    }
    return r
}
function FFe() {
    return {
        flow: {
            null: {
                name: "table",
                tokenize: NFe,
                resolveAll: UFe
            }
        }
    }
}
function NFe(e, t, n) {
    const r = this;
    let i = 0, o = 0, a;
    return s;
    function s(O) {
        let I = r.events.length - 1;
        for (; I > -1; ) {
            const L = r.events[I][1].type;
            if (L === "lineEnding" || L === "linePrefix")
                I--;
            else
                break
        }
        const M = I > -1 ? r.events[I][1].type : null
          , B = M === "tableHead" || M === "tableRow" ? P : c;
        return B === P && r.parser.lazy[r.now().line] ? n(O) : B(O)
    }
    function c(O) {
        return e.enter("tableHead"),
        e.enter("tableRow"),
        u(O)
    }
    function u(O) {
        return O === 124 || (a = !0,
        o += 1),
        f(O)
    }
    function f(O) {
        return O === null ? n(O) : zt(O) ? o > 1 ? (o = 0,
        r.interrupt = !0,
        e.exit("tableRow"),
        e.enter("lineEnding"),
        e.consume(O),
        e.exit("lineEnding"),
        y) : n(O) : bn(O) ? An(e, f, "whitespace")(O) : (o += 1,
        a && (a = !1,
        i += 1),
        O === 124 ? (e.enter("tableCellDivider"),
        e.consume(O),
        e.exit("tableCellDivider"),
        a = !0,
        f) : (e.enter("data"),
        h(O)))
    }
    function h(O) {
        return O === null || O === 124 || ir(O) ? (e.exit("data"),
        f(O)) : (e.consume(O),
        O === 92 ? m : h)
    }
    function m(O) {
        return O === 92 || O === 124 ? (e.consume(O),
        h) : h(O)
    }
    function y(O) {
        return r.interrupt = !1,
        r.parser.lazy[r.now().line] ? n(O) : (e.enter("tableDelimiterRow"),
        a = !1,
        bn(O) ? An(e, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : b(O))
    }
    function b(O) {
        return O === 45 || O === 58 ? S(O) : O === 124 ? (a = !0,
        e.enter("tableCellDivider"),
        e.consume(O),
        e.exit("tableCellDivider"),
        v) : E(O)
    }
    function v(O) {
        return bn(O) ? An(e, S, "whitespace")(O) : S(O)
    }
    function S(O) {
        return O === 58 ? (o += 1,
        a = !0,
        e.enter("tableDelimiterMarker"),
        e.consume(O),
        e.exit("tableDelimiterMarker"),
        C) : O === 45 ? (o += 1,
        C(O)) : O === null || zt(O) ? T(O) : E(O)
    }
    function C(O) {
        return O === 45 ? (e.enter("tableDelimiterFiller"),
        w(O)) : E(O)
    }
    function w(O) {
        return O === 45 ? (e.consume(O),
        w) : O === 58 ? (a = !0,
        e.exit("tableDelimiterFiller"),
        e.enter("tableDelimiterMarker"),
        e.consume(O),
        e.exit("tableDelimiterMarker"),
        k) : (e.exit("tableDelimiterFiller"),
        k(O))
    }
    function k(O) {
        return bn(O) ? An(e, T, "whitespace")(O) : T(O)
    }
    function T(O) {
        return O === 124 ? b(O) : O === null || zt(O) ? !a || i !== o ? E(O) : (e.exit("tableDelimiterRow"),
        e.exit("tableHead"),
        t(O)) : E(O)
    }
    function E(O) {
        return n(O)
    }
    function P(O) {
        return e.enter("tableRow"),
        D(O)
    }
    function D(O) {
        return O === 124 ? (e.enter("tableCellDivider"),
        e.consume(O),
        e.exit("tableCellDivider"),
        D) : O === null || zt(O) ? (e.exit("tableRow"),
        t(O)) : bn(O) ? An(e, D, "whitespace")(O) : (e.enter("data"),
        $(O))
    }
    function $(O) {
        return O === null || O === 124 || ir(O) ? (e.exit("data"),
        D(O)) : (e.consume(O),
        O === 92 ? z : $)
    }
    function z(O) {
        return O === 92 || O === 124 ? (e.consume(O),
        $) : $(O)
    }
}
function UFe(e, t) {
    let n = -1, r = !0, i = 0, o = [0, 0, 0, 0], a = [0, 0, 0, 0], s = !1, c = 0, u, f, h;
    const m = new jFe;
    for (; ++n < e.length; ) {
        const y = e[n]
          , b = y[1];
        y[0] === "enter" ? b.type === "tableHead" ? (s = !1,
        c !== 0 && (O5(m, t, c, u, f),
        f = void 0,
        c = 0),
        u = {
            type: "table",
            start: Object.assign({}, b.start),
            end: Object.assign({}, b.end)
        },
        m.add(n, 0, [["enter", u, t]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0,
        h = void 0,
        o = [0, 0, 0, 0],
        a = [0, n + 1, 0, 0],
        s && (s = !1,
        f = {
            type: "tableBody",
            start: Object.assign({}, b.start),
            end: Object.assign({}, b.end)
        },
        m.add(n, 0, [["enter", f, t]])),
        i = b.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1,
        a[2] === 0 && (o[1] !== 0 && (a[0] = a[1],
        h = yx(m, t, o, i, void 0, h),
        o = [0, 0, 0, 0]),
        a[2] = n)) : b.type === "tableCellDivider" && (r ? r = !1 : (o[1] !== 0 && (a[0] = a[1],
        h = yx(m, t, o, i, void 0, h)),
        o = a,
        a = [o[1], n, 0, 0])) : b.type === "tableHead" ? (s = !0,
        c = n) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (c = n,
        o[1] !== 0 ? (a[0] = a[1],
        h = yx(m, t, o, i, n, h)) : a[1] !== 0 && (h = yx(m, t, a, i, n, h)),
        i = 0) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (a[3] = n)
    }
    for (c !== 0 && O5(m, t, c, u, f),
    m.consume(t.events),
    n = -1; ++n < t.events.length; ) {
        const y = t.events[n];
        y[0] === "enter" && y[1].type === "table" && (y[1]._align = zFe(t.events, n))
    }
    return e
}
function yx(e, t, n, r, i, o) {
    const a = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData"
      , s = "tableContent";
    n[0] !== 0 && (o.end = Object.assign({}, df(t.events, n[0])),
    e.add(n[0], 0, [["exit", o, t]]));
    const c = df(t.events, n[1]);
    if (o = {
        type: a,
        start: Object.assign({}, c),
        end: Object.assign({}, c)
    },
    e.add(n[1], 0, [["enter", o, t]]),
    n[2] !== 0) {
        const u = df(t.events, n[2])
          , f = df(t.events, n[3])
          , h = {
            type: s,
            start: Object.assign({}, u),
            end: Object.assign({}, f)
        };
        if (e.add(n[2], 0, [["enter", h, t]]),
        r !== 2) {
            const m = t.events[n[2]]
              , y = t.events[n[3]];
            if (m[1].end = Object.assign({}, y[1].end),
            m[1].type = "chunkText",
            m[1].contentType = "text",
            n[3] > n[2] + 1) {
                const b = n[2] + 1
                  , v = n[3] - n[2] - 1;
                e.add(b, v, [])
            }
        }
        e.add(n[3] + 1, 0, [["exit", h, t]])
    }
    return i !== void 0 && (o.end = Object.assign({}, df(t.events, i)),
    e.add(i, 0, [["exit", o, t]]),
    o = void 0),
    o
}
function O5(e, t, n, r, i) {
    const o = []
      , a = df(t.events, n);
    i && (i.end = Object.assign({}, a),
    o.push(["exit", i, t])),
    r.end = Object.assign({}, a),
    o.push(["exit", r, t]),
    e.add(n + 1, 0, o)
}
function df(e, t) {
    const n = e[t]
      , r = n[0] === "enter" ? "start" : "end";
    return n[1][r]
}
const VFe = {
    name: "tasklistCheck",
    tokenize: qFe
};
function HFe() {
    return {
        text: {
            91: VFe
        }
    }
}
function qFe(e, t, n) {
    const r = this;
    return i;
    function i(c) {
        return r.previous !== null || !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"),
        e.enter("taskListCheckMarker"),
        e.consume(c),
        e.exit("taskListCheckMarker"),
        o)
    }
    function o(c) {
        return ir(c) ? (e.enter("taskListCheckValueUnchecked"),
        e.consume(c),
        e.exit("taskListCheckValueUnchecked"),
        a) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"),
        e.consume(c),
        e.exit("taskListCheckValueChecked"),
        a) : n(c)
    }
    function a(c) {
        return c === 93 ? (e.enter("taskListCheckMarker"),
        e.consume(c),
        e.exit("taskListCheckMarker"),
        e.exit("taskListCheck"),
        s) : n(c)
    }
    function s(c) {
        return zt(c) ? t(c) : bn(c) ? e.check({
            tokenize: WFe
        }, t, n)(c) : n(c)
    }
}
function WFe(e, t, n) {
    return An(e, r, "whitespace");
    function r(i) {
        return i === null ? n(i) : t(i)
    }
}
function GFe(e) {
    return B9([bFe(), AFe(), LFe(e), FFe(), HFe()])
}
const YFe = {};
function ZFe(e) {
    const t = this
      , n = e || YFe
      , r = t.data()
      , i = r.micromarkExtensions || (r.micromarkExtensions = [])
      , o = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = [])
      , a = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
    i.push(GFe(n)),
    o.push(pFe()),
    a.push(mFe(n))
}
const QFe = A.memo( ({setInput: e}) => {
    const t = ["What are my top 10 sales by revenue?", "What are my top 10 purchase by revenue?"];
    return g.jsxs(Be, {
        sx: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            textAlign: "center",
            height: "100%",
            px: 2
        },
        children: [g.jsx(zu, {
            sx: {
                bgcolor: "#10a37f",
                width: 64,
                height: 64,
                mb: 2
            },
            children: "AI"
        }), g.jsx(Ae, {
            variant: "h4",
            fontWeight: "bold",
            gutterBottom: !0,
            children: "Welcome to Zitatech AI"
        }), g.jsx(Ae, {
            variant: "body1",
            color: "text.secondary",
            mb: 3,
            children: "Ask me anything to get started."
        }), g.jsx(Be, {
            sx: {
                display: "grid",
                gap: 2,
                gridTemplateColumns: {
                    xs: "1fr",
                    sm: "1fr 1fr"
                },
                maxWidth: 500
            },
            children: t.map( (n, r) => g.jsx(yn, {
                elevation: 0,
                sx: {
                    p: 2,
                    border: "1px solid #eee",
                    borderRadius: 2,
                    cursor: "pointer",
                    "&:hover": {
                        bgcolor: "#f9f9f9"
                    },
                    transition: "background-color 0.2s"
                },
                onClick: () => e(n),
                children: g.jsx(Ae, {
                    variant: "body2",
                    children: n
                })
            }, r))
        })]
    })
}
)
  , KFe = A.memo( ({conv: e, isActive: t, onSelect: n, onActionClick: r, isArchived: i, onRestore: o}) => g.jsxs(bm, {
    sx: {
        pl: 4,
        py: .75,
        borderRadius: 1.5,
        mb: .5,
        position: "relative",
        bgcolor: t ? "rgba(25, 118, 210, 0.12)" : "transparent",
        "&:hover": {
            bgcolor: t ? "rgba(25, 118, 210, 0.18)" : "rgba(0, 0, 0, 0.05)"
        },
        borderLeft: t ? "3px solid #1976d2" : "3px solid transparent",
        transition: "all 0.2s"
    },
    selected: t,
    onClick: n,
    children: [g.jsx(ha, {
        sx: {
            minWidth: 30
        },
        children: g.jsx(w9, {
            fontSize: "small",
            color: t ? "primary" : "action",
            sx: {
                opacity: t ? 1 : .7
            }
        })
    }), g.jsx(zo, {
        primary: g.jsx(Be, {
            sx: {
                display: "flex",
                alignItems: "center"
            },
            children: g.jsx(Ae, {
                sx: {
                    fontSize: 13,
                    color: t ? "primary.main" : "text.primary",
                    whiteSpace: "nowrap",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    maxWidth: 150,
                    mr: .5
                },
                children: e.first_message
            })
        }),
        secondary: g.jsx(Ae, {
            sx: {
                fontSize: 11,
                color: t ? "primary.light" : "text.secondary"
            },
            children: new Date(e.created_at).toLocaleDateString(void 0, {
                month: "short",
                day: "numeric",
                hour: "2-digit",
                minute: "2-digit"
            })
        })
    }), i && o && g.jsx(pc, {
        title: "Restore conversation",
        children: g.jsx(In, {
            size: "small",
            onClick: a => {
                a.preventDefault(),
                a.stopPropagation(),
                o()
            }
            ,
            sx: {
                mr: .5
            },
            children: g.jsx(jx, {
                fontSize: "small"
            })
        })
    }), !i && g.jsx(In, {
        size: "small",
        onClick: r,
        sx: {
            opacity: .7,
            "&:hover": {
                opacity: 1
            }
        },
        children: g.jsx(V1e, {
            fontSize: "small"
        })
    })]
}));
function XFe() {
    const e = n1("(max-width:600px)")
      , [t,n] = A.useState([])
      , [r,i] = A.useState([])
      , [o,a] = A.useState({})
      , [s,c] = A.useState(null)
      , [u,f] = A.useState("")
      , [h,m] = A.useState(!1)
      , [y,b] = A.useState(!1)
      , [v,S] = A.useState(!e)
      , [C,w] = A.useState(null)
      , k = A.useRef(null)
      , [T,E] = A.useState(!1)
      , [P,D] = A.useState(!1)
      , [$,z] = A.useState("")
      , [O,I] = A.useState("")
      , [M,B] = A.useState(null)
      , [L,F] = A.useState({})
      , [j,N] = A.useState(null)
      , [H,Z] = A.useState("")
      , [q,V] = A.useState(!1)
      , [Y,W] = A.useState("")
      , [te,K] = A.useState("success")
      , [ee,re] = A.useState("")
      , [ie,J] = A.useState(null)
      , [oe,we] = A.useState(null)
      , [xe,se] = A.useState({
        open: !1,
        conversationId: null,
        projectId: null
    })
      , [de,Se] = A.useState({
        open: !1,
        conversationId: null,
        projectId: null,
        isArchived: !1
    })
      , [Ce,Ye] = A.useState({
        open: !1,
        projectId: null,
        projectName: ""
    })
      , [ye,Ke] = A.useState({
        open: !1,
        projectId: null,
        projectName: ""
    })
      , [X,ce] = A.useState({
        anchorEl: null,
        conversationId: null,
        projectId: null,
        isArchived: !1
    })
      , fe = A.useCallback( (he, Le, it, Je) => {
        he.preventDefault(),
        he.stopPropagation(),
        ce({
            anchorEl: he.currentTarget,
            conversationId: Le,
            projectId: it,
            isArchived: Je
        })
    }
    , [])
      , Xe = A.useCallback( () => {
        ce({
            anchorEl: null,
            conversationId: null,
            projectId: null,
            isArchived: !1
        })
    }
    , [])
      , Oe = A.useCallback(he => he.trim() ? he.trim().length < 3 ? (Z("Project name must be at least 3 characters"),
    !1) : (T && t && E(!1),
    Z(""),
    !0) : (Z("Project name is required"),
    !1), [])
      , Re = A.useCallback( (he, Le) => {
        W(he),
        K(Le),
        V(!0)
    }
    , [])
      , le = A.useCallback(async he => {
        if (M === he) {
            B(null);
            return
        }
        if (B(he),
        !L[he])
            try {
                const Le = await k5(T)
                  , it = Array.isArray(Le) ? Le.filter(Je => Je.project_id === he) : [];
                F(Je => ({
                    ...Je,
                    [he]: it
                }))
            } catch (Le) {
                console.error("Error loading conversations for project", he, Le),
                Re("Failed to load conversations", "error")
            }
    }
    , [M, L, T, Re])
      , ke = A.useCallback(async () => {
        if (!Oe($))
            return;
        const he = {
            name: $,
            description: O
        };
        try {
            const Le = await Bze(he);
            Re("Project created successfully!", "success");
            const it = await _5();
            i(Array.isArray(it) ? it : [it]),
            D(!1),
            z(""),
            I(""),
            B(Number(Le))
        } catch (Le) {
            console.error("Error creating project:", Le),
            Re("Failed to create project. Please try again.", "error")
        }
    }
    , [$, O, Oe, Re])
      , He = A.useCallback( () => {
        D(!1),
        z(""),
        I(""),
        Z("")
    }
    , [])
      , st = A.useCallback( () => {
        V(!1)
    }
    , [])
      , lt = A.useCallback( () => {
        J(null)
    }
    , [])
      , et = A.useCallback( (he, Le) => {
        he.preventDefault(),
        he.stopPropagation(),
        we({
            mouseX: he.clientX,
            mouseY: he.clientY,
            projectId: Le
        })
    }
    , [])
      , Ht = A.useCallback( () => {
        we(null)
    }
    , [])
      , Ft = A.useCallback( (he, Le) => {
        se({
            open: !0,
            conversationId: he,
            projectId: Le
        }),
        lt()
    }
    , [lt])
      , Pt = A.useCallback(async () => {
        xe.conversationId && xe.projectId && (await jze(xe.conversationId),
        F(he => ({
            ...he,
            [xe.projectId]: he[xe.projectId]?.filter(Le => Le.conversation_id !== xe.conversationId) || []
        })),
        Re("Conversation deleted", "success"),
        s === xe.conversationId && c(0)),
        se({
            open: !1,
            conversationId: null,
            projectId: null
        })
    }
    , [xe, s, Re])
      , nt = A.useCallback( (he, Le, it) => {
        Se({
            open: !0,
            conversationId: he,
            projectId: Le,
            isArchived: it
        }),
        lt()
    }
    , [lt])
      , ut = A.useCallback(async () => {
        if (de.conversationId)
            try {
                de.isArchived ? await Lze(de.conversationId) : await $ze(de.conversationId),
                de.projectId && (F(he => ({
                    ...he,
                    [de.projectId]: he[de.projectId]?.map(Le => Le.conversation_id === de.conversationId ? {
                        ...Le,
                        is_archived: !de.isArchived
                    } : Le) || []
                })),
                !de.isArchived && s === de.conversationId && c(0)),
                Re(de.isArchived ? "Conversation unarchived" : "Conversation archived", "success")
            } catch (he) {
                console.error("Error archiving conversation:", he),
                Re("Failed to archive conversation", "error")
            }
        Se({
            open: !1,
            conversationId: null,
            projectId: null,
            isArchived: !1
        })
    }
    , [de, Re])
      , Lt = A.useCallback(he => {
        const Le = r.find(it => it.id === he);
        Le && Ye({
            open: !0,
            projectId: he,
            projectName: Le.name
        }),
        Ht()
    }
    , [r, Ht])
      , tn = A.useCallback(async () => {
        if (Ce.projectId)
            try {
                await zze(Ce.projectId),
                i(he => he.filter(Le => Le.id !== Ce.projectId)),
                j === Ce.projectId && (c(0),
                N(null)),
                Re("Project deleted", "success")
            } catch (he) {
                console.error("Error deleting project:", he),
                Re("Failed to delete project", "error")
            }
        Ye({
            open: !1,
            projectId: null,
            projectName: ""
        })
    }
    , [Ce, j, Re])
      , Xt = A.useCallback(he => {
        const Le = r.find(it => it.id === he);
        Le && Ke({
            open: !0,
            projectId: he,
            projectName: Le.name
        }),
        Ht()
    }
    , [r, Ht])
      , Mn = A.useCallback(async () => {
        if (ye.projectId && ye.projectName.trim())
            try {
                await Fze(ye.projectId, ye.projectName),
                i(he => he.map(Le => Le.id === ye.projectId ? {
                    ...Le,
                    name: ye.projectName
                } : Le)),
                Re("Project renamed", "success")
            } catch (he) {
                console.error("Error renaming project:", he),
                Re("Failed to rename project", "error")
            }
        Ke({
            open: !1,
            projectId: null,
            projectName: ""
        })
    }
    , [ye, Re])
      , Pn = A.useCallback( (he, Le=!1) => {
        if (!he)
            return [];
        const it = Le ? he.filter(Je => Je.is_archived) : he.filter(Je => !Je.is_archived);
        return ee.trim() ? it.filter(Je => Je.first_message.toLowerCase().includes(ee.toLowerCase())) : it
    }
    , [ee])
      , wn = A.useCallback( () => ee.trim() ? r.filter(he => he.name.toLowerCase().includes(ee.toLowerCase()) || L[he.id] && L[he.id].some(Le => Le.first_message.toLowerCase().includes(ee.toLowerCase()))) : r, [r, L, ee])
      , Kn = A.useCallback( () => {
        re("")
    }
    , []);
    A.useEffect( () => {
        async function he() {
            try {
                const Le = await _5();
                i(Array.isArray(Le) ? Le : [Le])
            } catch (Le) {
                console.error("Failed to fetch projects:", Le),
                Re("Failed to load projects", "error")
            }
        }
        he()
    }
    , [Re]),
    A.useEffect( () => {
        async function he() {
            try {
                const Le = await k5(T)
                  , it = Array.isArray(Le) ? Le : [Le];
                n(it),
                F(Je => {
                    const Jt = {};
                    for (const dn of it)
                        (Jt[dn.project_id] ||= []).push(dn);
                    const qt = {
                        ...Je
                    };
                    return Object.keys(Je).forEach(dn => {
                        const Ir = Number(dn);
                        qt[Ir] = Jt[Ir] || []
                    }
                    ),
                    M !== null && qt[M] === void 0 && (qt[M] = Jt[M] || []),
                    qt
                }
                )
            } catch (Le) {
                console.error("Failed to fetch conversations:", Le),
                Re("Failed to load conversations", "error")
            }
        }
        he()
    }
    , [T, M, Re]),
    A.useEffect( () => {
        At(0)
    }
    , []),
    A.useEffect( () => {
        if (s && s !== C) {
            async function he() {
                try {
                    const it = (await Oze(s)).messages.flatMap(Je => [{
                        id: Number(Je.id) * 2,
                        sender: "user",
                        text: Je.text,
                        timestamp: new Date(Je.created_at).getTime()
                    }, {
                        id: Number(Je.id) * 2 + 1,
                        sender: "bot",
                        text: Je.response,
                        timestamp: new Date(Je.created_at).getTime()
                    }]);
                    a(Je => ({
                        ...Je,
                        [Number(s)]: it
                    }))
                } catch (Le) {
                    console.error("Error fetching conversation detail", Le),
                    Re("Failed to load conversation", "error")
                }
            }
            he()
        }
    }
    , [s, C, Re]),
    A.useEffect( () => {
        k.current?.scrollIntoView({
            behavior: "smooth"
        })
    }
    , [o, s, y, h]);
    const vr = s ? o[s] || [] : []
      , mr = async () => {
        if (!u.trim())
            return;
        const he = {
            id: Date.now(),
            sender: "user",
            text: u,
            timestamp: Date.now()
        };
        s && s !== 0 && a(it => ({
            ...it,
            [s]: [...it[s] || [], he]
        }));
        const Le = u;
        if (f(""),
        b(!0),
        s === 0)
            try {
                a(qt => ({
                    ...qt,
                    0: [he]
                }));
                const it = await T5({
                    conversation_id: -1,
                    project_id: j || 0,
                    query: Le
                })
                  , Je = it.conversation_id
                  , Jt = {
                    conversation_id: it.conversation_id,
                    project_id: it.project_id,
                    project_name: r.find(qt => qt.id === it.project_id)?.name || "Unknown Project",
                    first_message: it.query ?? Le,
                    created_at: new Date().toISOString(),
                    is_archived: !1
                };
                n(qt => [Jt, ...qt]),
                j && F(qt => ({
                    ...qt,
                    [j]: [Jt, ...qt[j] || []]
                })),
                a(qt => {
                    const dn = {
                        ...qt
                    };
                    return dn[Je] = [he],
                    delete dn[0],
                    dn
                }
                ),
                w(Je),
                c(Je),
                m(!0),
                b(!1),
                setTimeout( () => {
                    m(!1);
                    const qt = {
                        id: Date.now() + 1,
                        sender: "bot",
                        text: it.response ?? "Bot replied!",
                        timestamp: Date.now()
                    };
                    a(dn => ({
                        ...dn,
                        [Je]: [...dn[Je] || [], qt]
                    })),
                    setTimeout( () => {
                        w(null)
                    }
                    , 500)
                }
                , 800),
                e && S(!1)
            } catch (it) {
                b(!1),
                console.error("Failed to create conversation", it),
                Re("Failed to create conversation", "error")
            }
        else if (s)
            try {
                const it = await T5({
                    conversation_id: s,
                    project_id: j || 0,
                    query: Le
                });
                m(!0),
                b(!1),
                setTimeout( () => {
                    m(!1);
                    const Je = {
                        id: Date.now() + 1,
                        sender: "bot",
                        text: it.response ?? "Bot replied!",
                        timestamp: Date.now()
                    };
                    a(Jt => ({
                        ...Jt,
                        [s]: [...Jt[s] || [], Je]
                    }))
                }
                , 800),
                e && S(!1)
            } catch (it) {
                b(!1),
                console.error("Failed to send message", it),
                Re("Failed to send message", "error")
            }
    }
      , kn = he => {
        he.target.files && he.target.files.length > 0 && Re("File upload not implemented yet", "info")
    }
      , At = A.useCallback(he => {
        a(it => ({
            ...it,
            0: []
        })),
        N(he),
        c(0),
        e && S(!1)
    }
    , [e])
      , nr = g.jsxs(Be, {
        sx: {
            width: {
                xs: "100vw",
                sm: 260
            },
            minWidth: {
                sm: 220
            },
            borderRight: {
                sm: "1px solid #e5e5e5"
            },
            borderBottom: {
                xs: "1px solid #e5e5e5",
                sm: "none"
            },
            display: "flex",
            flexDirection: "column",
            overflow: "hidden",
            flexShrink: 0,
            bgcolor: "background.paper",
            height: "80%"
        },
        children: [g.jsx(PN, {
            position: "static",
            color: "transparent",
            elevation: 0,
            children: g.jsxs(YE, {
                variant: "dense",
                children: [e && g.jsx(In, {
                    edge: "start",
                    size: "large",
                    onClick: () => S(!1),
                    sx: {
                        mr: 1
                    },
                    "aria-label": "Close",
                    children: g.jsx(R1e, {})
                }), g.jsx(Ae, {
                    variant: "h3",
                    sx: {
                        flexGrow: 1,
                        fontSize: 18
                    },
                    children: "Chat History"
                })]
            })
        }), g.jsxs(Be, {
            sx: {
                p: 1.5,
                borderBottom: "1px solid #ddd"
            },
            children: [g.jsx(Mt, {
                fullWidth: !0,
                variant: "contained",
                size: "small",
                startIcon: g.jsx(Go, {}),
                onClick: () => D(!0),
                sx: {
                    textTransform: "none",
                    bgcolor: "#1976d2",
                    "&:hover": {
                        bgcolor: "#556370ff"
                    },
                    mb: 1.5
                },
                children: "New Project"
            }), g.jsx(ct, {
                size: "small",
                placeholder: "Search conversations...",
                value: ee,
                onChange: he => re(he.target.value),
                InputProps: {
                    startAdornment: g.jsx(v0, {
                        position: "start",
                        children: g.jsx(C9, {
                            fontSize: "small"
                        })
                    }),
                    endAdornment: ee ? g.jsx(v0, {
                        position: "end",
                        children: g.jsx(In, {
                            size: "small",
                            onClick: Kn,
                            "aria-label": "Clear search",
                            children: g.jsx(zE, {
                                label: `${wn().length} results`,
                                size: "small",
                                onDelete: Kn,
                                sx: {
                                    height: 24,
                                    fontSize: 12
                                }
                            })
                        })
                    }) : null,
                    sx: {
                        borderRadius: 1
                    }
                }
            })]
        }), g.jsx(Be, {
            sx: {
                mt: 1,
                ml: 2,
                mb: 1,
                width: "100%"
            },
            children: g.jsxs(sae, {
                size: "small",
                variant: "outlined",
                children: [g.jsx(Mt, {
                    startIcon: g.jsx(w9, {
                        fontSize: "small"
                    }),
                    variant: T ? "outlined" : "contained",
                    onClick: () => E(!1),
                    children: "Active"
                }), g.jsx(Mt, {
                    startIcon: g.jsx(Jb, {
                        fontSize: "small"
                    }),
                    variant: T ? "contained" : "outlined",
                    onClick: () => E(!0),
                    children: "Archived"
                })]
            })
        }), g.jsx(Fu, {
            sx: {
                flexGrow: 1,
                overflowY: "auto",
                p: .5,
                "&::-webkit-scrollbar": {
                    width: "8px"
                },
                "&::-webkit-scrollbar-thumb": {
                    backgroundColor: "rgba(0,0,0,0.1)",
                    borderRadius: "4px"
                },
                "&::-webkit-scrollbar-track": {
                    backgroundColor: "transparent"
                }
            },
            children: r.length === 0 ? g.jsx(Ae, {
                variant: "body2",
                color: "text.secondary",
                sx: {
                    p: 2,
                    textAlign: "center"
                },
                children: "No projects yet. Create your first project!"
            }) : wn().length === 0 ? g.jsx(Ae, {
                variant: "body2",
                color: "text.secondary",
                sx: {
                    p: 2,
                    textAlign: "center"
                },
                children: "No matching results"
            }) : wn().map(he => g.jsxs(Be, {
                sx: {
                    mb: .5
                },
                children: [g.jsxs(bm, {
                    onClick: () => le(he.id),
                    onContextMenu: Le => et(Le, he.id),
                    sx: {
                        borderRadius: 2,
                        bgcolor: M === he.id ? "rgba(25, 118, 210, 0.08)" : "transparent",
                        "&:hover": {
                            bgcolor: M === he.id ? "rgba(25, 118, 210, 0.12)" : "rgba(0, 0, 0, 0.04)"
                        },
                        transition: "background-color 0.2s"
                    },
                    children: [g.jsx(ha, {
                        sx: {
                            minWidth: 36
                        },
                        children: g.jsx(UN, {
                            badgeContent: Pn(L[he.id], T).length,
                            color: "primary",
                            sx: {
                                "& .MuiBadge-badge": {
                                    fontSize: "9px",
                                    height: "16px",
                                    minWidth: "16px"
                                }
                            },
                            children: g.jsx(B1e, {
                                fontSize: "small",
                                color: M === he.id ? "primary" : "action",
                                sx: {
                                    transition: "color 0.2s"
                                }
                            })
                        })
                    }), g.jsx(zo, {
                        primary: he.name,
                        slotProps: {
                            primary: {
                                sx: {
                                    fontWeight: "medium",
                                    fontSize: 14,
                                    color: M === he.id ? "primary.main" : "inherit"
                                }
                            },
                            secondary: {
                                noWrap: !0,
                                sx: {
                                    fontSize: 12,
                                    opacity: .7
                                }
                            }
                        }
                    }), g.jsx(vc, {
                        in: !0,
                        children: M === he.id ? g.jsx(jA, {
                            fontSize: "small",
                            color: "primary"
                        }) : g.jsx(BA, {
                            fontSize: "small"
                        })
                    })]
                }), g.jsx(h0, {
                    in: M === he.id,
                    timeout: 300,
                    unmountOnExit: !0,
                    children: L[he.id] && Pn(L[he.id], T).length > 0 ? g.jsxs(g.Fragment, {
                        children: [!T && g.jsx(Mt, {
                            variant: "text",
                            size: "small",
                            startIcon: g.jsx(Go, {
                                fontSize: "small"
                            }),
                            onClick: () => At(he.id),
                            sx: {
                                ml: 4,
                                mb: 1,
                                textTransform: "none",
                                color: "primary.main",
                                "&:hover": {
                                    backgroundColor: "rgba(25, 118, 210, 0.08)"
                                }
                            },
                            children: "New Chat"
                        }), g.jsx(Fu, {
                            component: "div",
                            disablePadding: !0,
                            dense: !0,
                            children: Pn(L[he.id], T).map(Le => g.jsx(KFe, {
                                conv: Le,
                                isActive: s === Le.conversation_id,
                                onSelect: () => {
                                    c(Le.conversation_id),
                                    N(he.id),
                                    e && S(!1)
                                }
                                ,
                                onActionClick: it => fe(it, Le.conversation_id, he.id, Le.is_archived),
                                isArchived: !!Le.is_archived,
                                onRestore: Le.is_archived ? () => nt(Le.conversation_id, he.id, !0) : void 0
                            }, `conv-${Le.conversation_id}`))
                        })]
                    }) : g.jsxs(g.Fragment, {
                        children: [g.jsx(Ae, {
                            variant: "body2",
                            color: "text.secondary",
                            sx: {
                                p: 1,
                                pl: 4,
                                fontSize: 12,
                                fontStyle: "italic"
                            },
                            children: T ? "No archived conversations" : "No conversations yet"
                        }), !T && g.jsx(Mt, {
                            variant: "text",
                            size: "small",
                            startIcon: g.jsx(Go, {
                                fontSize: "small"
                            }),
                            onClick: () => At(he.id),
                            sx: {
                                ml: 4,
                                mb: 1,
                                textTransform: "none",
                                color: "primary.main"
                            },
                            children: "Start a new chat"
                        })]
                    })
                })]
            }, `project-${he.id}`))
        }), g.jsxs(vf, {
            anchorEl: X.anchorEl,
            open: !!X.anchorEl,
            onClose: Xe,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "right"
            },
            transformOrigin: {
                vertical: "top",
                horizontal: "right"
            },
            children: [X.isArchived ? g.jsxs(Yr, {
                onClick: () => {
                    X.conversationId && X.projectId && nt(X.conversationId, X.projectId, X.isArchived),
                    Xe()
                }
                ,
                dense: !0,
                children: [g.jsx(ha, {
                    children: g.jsx(jx, {
                        fontSize: "small"
                    })
                }), g.jsx(zo, {
                    children: "Unarchive conversation"
                })]
            }) : g.jsxs(Yr, {
                onClick: () => {
                    X.conversationId && X.projectId && nt(X.conversationId, X.projectId, X.isArchived),
                    Xe()
                }
                ,
                dense: !0,
                children: [g.jsx(ha, {
                    children: g.jsx(Jb, {
                        fontSize: "small"
                    })
                }), g.jsx(zo, {
                    children: "Archive conversation"
                })]
            }), g.jsxs(Yr, {
                onClick: () => {
                    X.conversationId && X.projectId && Ft(X.conversationId, X.projectId),
                    Xe()
                }
                ,
                sx: {
                    color: "error.main"
                },
                dense: !0,
                children: [g.jsx(ha, {
                    children: g.jsx(Dk, {
                        fontSize: "small",
                        color: "error"
                    })
                }), g.jsx(zo, {
                    children: "Delete conversation"
                })]
            })]
        }), g.jsxs(vf, {
            open: oe !== null,
            onClose: Ht,
            anchorReference: "anchorPosition",
            anchorPosition: oe !== null ? {
                top: oe.mouseY,
                left: oe.mouseX
            } : void 0,
            children: [g.jsxs(Yr, {
                onClick: () => {
                    oe && Xt(oe.projectId)
                }
                ,
                dense: !0,
                children: [g.jsx(ha, {
                    children: g.jsx(rg, {
                        fontSize: "small"
                    })
                }), g.jsx(zo, {
                    children: "Rename project"
                })]
            }), g.jsxs(Yr, {
                onClick: () => {
                    oe && Lt(oe.projectId)
                }
                ,
                sx: {
                    color: "error.main"
                },
                dense: !0,
                children: [g.jsx(ha, {
                    children: g.jsx(eB, {
                        fontSize: "small",
                        color: "error"
                    })
                }), g.jsx(zo, {
                    children: "Delete project"
                })]
            })]
        }), g.jsxs(vf, {
            open: ie !== null,
            onClose: lt,
            anchorReference: "anchorPosition",
            anchorPosition: ie !== null ? {
                top: ie.mouseY,
                left: ie.mouseX
            } : void 0,
            children: [ie && L[ie.projectId]?.find(he => he.conversation_id === ie.conversationId)?.is_archived ? g.jsxs(Yr, {
                onClick: () => {
                    ie && nt(ie.conversationId, ie.projectId, !0),
                    lt()
                }
                ,
                dense: !0,
                children: [g.jsx(ha, {
                    children: g.jsx(jx, {
                        fontSize: "small"
                    })
                }), g.jsx(zo, {
                    children: "Unarchive conversation"
                })]
            }) : g.jsxs(Yr, {
                onClick: () => {
                    ie && nt(ie.conversationId, ie.projectId, !1),
                    lt()
                }
                ,
                dense: !0,
                children: [g.jsx(ha, {
                    children: g.jsx(Jb, {
                        fontSize: "small"
                    })
                }), g.jsx(zo, {
                    children: "Archive conversation"
                })]
            }), g.jsxs(Yr, {
                onClick: () => {
                    ie && Ft(ie.conversationId, ie.projectId),
                    lt()
                }
                ,
                sx: {
                    color: "error.main"
                },
                dense: !0,
                children: [g.jsx(ha, {
                    children: g.jsx(Dk, {
                        fontSize: "small",
                        color: "error"
                    })
                }), g.jsx(zo, {
                    children: "Delete conversation"
                })]
            })]
        })]
    });
    return g.jsxs(Be, {
        sx: {
            display: "flex",
            flexDirection: {
                xs: "column",
                sm: "row"
            },
            height: {
                xs: "100vh",
                sm: "85vh"
            },
            overflow: "hidden",
            bgcolor: "background.default",
            color: "text.primary",
            position: "relative"
        },
        children: [g.jsxs(sc, {
            open: P,
            onClose: He,
            maxWidth: "sm",
            fullWidth: !0,
            children: [g.jsx(yu, {
                children: "Create New Project"
            }), g.jsx(cc, {
                children: g.jsxs(Be, {
                    sx: {
                        mt: 2,
                        display: "flex",
                        flexDirection: "column",
                        gap: 3
                    },
                    children: [g.jsx(ct, {
                        autoFocus: !0,
                        label: "Project Name",
                        fullWidth: !0,
                        variant: "outlined",
                        value: $,
                        onChange: he => {
                            const Le = he.target.value;
                            z(Le),
                            Oe(Le)
                        }
                        ,
                        onBlur: () => Oe($),
                        placeholder: "Enter a name for your project",
                        error: !!H,
                        helperText: H,
                        required: !0
                    }), g.jsx(ct, {
                        label: "Project Description",
                        fullWidth: !0,
                        multiline: !0,
                        rows: 3,
                        variant: "outlined",
                        value: O,
                        onChange: he => I(he.target.value),
                        placeholder: "Briefly describe what you're working on"
                    })]
                })
            }), g.jsxs(lc, {
                children: [g.jsx(Mt, {
                    onClick: He,
                    color: "inherit",
                    children: "Cancel"
                }), g.jsx(Mt, {
                    onClick: ke,
                    variant: "contained",
                    color: "primary",
                    disabled: !$.trim() || !!H,
                    children: "Create"
                })]
            })]
        }), g.jsxs(sc, {
            open: xe.open,
            onClose: () => se({
                ...xe,
                open: !1
            }),
            children: [g.jsx(yu, {
                children: "Delete Conversation"
            }), g.jsx(cc, {
                children: g.jsx(Px, {
                    children: "Are you sure you want to delete this conversation? This action cannot be undone."
                })
            }), g.jsxs(lc, {
                children: [g.jsx(Mt, {
                    onClick: () => se({
                        ...xe,
                        open: !1
                    }),
                    color: "primary",
                    children: "Cancel"
                }), g.jsx(Mt, {
                    onClick: Pt,
                    color: "error",
                    variant: "contained",
                    startIcon: g.jsx(Dk, {}),
                    children: "Delete"
                })]
            })]
        }), g.jsxs(sc, {
            open: de.open,
            onClose: () => Se({
                ...de,
                open: !1
            }),
            children: [g.jsx(yu, {
                children: de.isArchived ? "Unarchive Conversation" : "Archive Conversation"
            }), g.jsx(cc, {
                children: g.jsx(Px, {
                    children: de.isArchived ? "Are you sure you want to unarchive this conversation?" : "Are you sure you want to archive this conversation?"
                })
            }), g.jsxs(lc, {
                children: [g.jsx(Mt, {
                    onClick: () => Se({
                        ...de,
                        open: !1
                    }),
                    color: "primary",
                    children: "Cancel"
                }), g.jsx(Mt, {
                    onClick: ut,
                    color: "primary",
                    variant: "contained",
                    startIcon: de.isArchived ? g.jsx(jx, {}) : g.jsx(Jb, {}),
                    children: de.isArchived ? "Unarchive" : "Archive"
                })]
            })]
        }), g.jsxs(sc, {
            open: Ce.open,
            onClose: () => Ye({
                ...Ce,
                open: !1
            }),
            children: [g.jsx(yu, {
                children: "Delete Project"
            }), g.jsx(cc, {
                children: g.jsxs(Px, {
                    children: ['Are you sure you want to delete project "', Ce.projectName, '"? This will also delete all conversations in this project. This action cannot be undone.']
                })
            }), g.jsxs(lc, {
                children: [g.jsx(Mt, {
                    onClick: () => Ye({
                        ...Ce,
                        open: !1
                    }),
                    color: "primary",
                    children: "Cancel"
                }), g.jsx(Mt, {
                    onClick: tn,
                    color: "error",
                    variant: "contained",
                    startIcon: g.jsx(eB, {}),
                    children: "Delete Project"
                })]
            })]
        }), g.jsxs(sc, {
            open: ye.open,
            onClose: () => Ke({
                ...ye,
                open: !1
            }),
            children: [g.jsx(yu, {
                children: "Rename Project"
            }), g.jsx(cc, {
                children: g.jsx(ct, {
                    autoFocus: !0,
                    margin: "dense",
                    label: "Project Name",
                    type: "text",
                    fullWidth: !0,
                    value: ye.projectName,
                    onChange: he => Ke({
                        ...ye,
                        projectName: he.target.value
                    }),
                    error: !ye.projectName.trim(),
                    helperText: ye.projectName.trim() ? "" : "Project name cannot be empty"
                })
            }), g.jsxs(lc, {
                children: [g.jsx(Mt, {
                    onClick: () => Ke({
                        ...ye,
                        open: !1
                    }),
                    color: "primary",
                    children: "Cancel"
                }), g.jsx(Mt, {
                    onClick: Mn,
                    color: "primary",
                    variant: "contained",
                    disabled: !ye.projectName.trim(),
                    startIcon: g.jsx(rg, {}),
                    children: "Rename"
                })]
            })]
        }), g.jsx(hh, {
            open: q,
            autoHideDuration: 6e3,
            onClose: st,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "center"
            },
            children: g.jsx(Mc, {
                onClose: st,
                severity: te,
                sx: {
                    width: "100%"
                },
                variant: "filled",
                children: Y
            })
        }), e && !v && g.jsx(Be, {
            sx: {
                position: "absolute",
                top: 10,
                left: 10,
                zIndex: 10
            },
            children: g.jsx(In, {
                size: "large",
                color: "primary",
                onClick: () => S(!0),
                "aria-label": "Open chat history",
                sx: {
                    boxShadow: 1,
                    bgcolor: "background.paper"
                },
                children: g.jsx(S9, {})
            })
        }), e ? g.jsx(JN, {
            anchor: "left",
            open: v,
            onClose: () => S(!1),
            transitionDuration: 250,
            slotProps: {
                paper: {
                    sx: {
                        width: "100vw",
                        maxWidth: 360,
                        bgcolor: "background.paper"
                    }
                }
            },
            children: nr
        }) : nr, g.jsxs(Be, {
            sx: {
                flex: 1,
                display: "flex",
                flexDirection: "column",
                height: {
                    xs: "calc(100vh - 56px)",
                    sm: "80vh"
                },
                overflow: "hidden",
                minWidth: 0
            },
            children: [g.jsx(Be, {
                sx: {
                    flexGrow: 1,
                    overflowY: "auto",
                    overflowX: "hidden",
                    p: {
                        xs: 1,
                        sm: 2
                    },
                    bgcolor: "background.paper",
                    minHeight: 0
                },
                children: !s || vr.length === 0 ? g.jsxs(g.Fragment, {
                    children: [g.jsx(QFe, {
                        setInput: f
                    }), y && g.jsxs(Be, {
                        sx: {
                            display: "flex",
                            alignItems: "center",
                            mb: 1,
                            ml: 1
                        },
                        children: [g.jsx(Jr, {
                            size: 18,
                            sx: {
                                mr: 1
                            }
                        }), g.jsx(Ae, {
                            sx: {
                                fontStyle: "italic",
                                color: "grey.500"
                            },
                            children: "Preparing response..."
                        })]
                    }), h && g.jsx(Be, {
                        sx: {
                            mb: 1,
                            ml: 1
                        },
                        children: g.jsx(Ae, {
                            sx: {
                                color: "grey.500",
                                fontStyle: "italic"
                            },
                            children: "Bot is typing..."
                        })
                    })]
                }) : g.jsxs(g.Fragment, {
                    children: [vr.map( (he, Le) => g.jsxs(Be, {
                        sx: {
                            display: "flex",
                            justifyContent: he.sender === "user" ? "flex-end" : "flex-start",
                            mb: 2
                        },
                        children: [he.sender === "bot" && g.jsx(zu, {
                            sx: {
                                bgcolor: "#10a37f",
                                width: 32,
                                height: 32,
                                mr: 1,
                                fontSize: 14
                            },
                            children: "AI"
                        }), g.jsxs(yn, {
                            elevation: 2,
                            sx: {
                                p: 1.5,
                                maxWidth: {
                                    xs: "95%",
                                    sm: "80%"
                                },
                                bgcolor: he.sender === "user" ? "#1976d2" : "background.paper",
                                color: he.sender === "user" ? "white" : "text.secondary",
                                borderRadius: 3,
                                position: "relative",
                                wordBreak: "break-word",
                                boxShadow: he.sender === "user" ? 4 : 2,
                                transition: "background-color 0.2s"
                            },
                            children: [he.fileUrl ? g.jsx(Ae, {
                                variant: "body1",
                                color: he.sender === "user" ? "white" : "textPrimary",
                                children: g.jsx("a", {
                                    href: he.fileUrl,
                                    download: he.text,
                                    style: {
                                        color: he.sender === "user" ? "white" : "inherit"
                                    },
                                    children: he.text
                                })
                            }) : g.jsx(o8, {
                                remarkPlugins: [ZFe],
                                components: {
                                    code({node: it, inline: Je, className: Jt, children: qt, ...dn}) {
                                        const Ir = String(qt).trim()
                                          , Ki = (Jt || "").replace("language-", "");
                                        return !Je && (Ki === "mermaid" || Ir.startsWith("%%{")) ? g.jsx(Be, {
                                            sx: {
                                                my: 2,
                                                ml: 3
                                            },
                                            children: g.jsx(k7, {
                                                chart: Ir,
                                                config: {
                                                    startOnLoad: !0,
                                                    theme: "default"
                                                }
                                            })
                                        }) : g.jsx(Be, {
                                            component: "code",
                                            sx: {
                                                bgcolor: "#f5f5f5",
                                                px: .5,
                                                borderRadius: 1,
                                                fontFamily: "monospace"
                                            },
                                            ...dn,
                                            children: qt
                                        })
                                    },
                                    table: ({node: it, ...Je}) => g.jsx(Be, {
                                        sx: {
                                            my: 2,
                                            overflowX: "auto"
                                        },
                                        children: g.jsx(Be, {
                                            component: "table",
                                            sx: {
                                                borderCollapse: "collapse",
                                                width: "100%",
                                                minWidth: "550px",
                                                border: "1px solid",
                                                borderColor: "divider"
                                            },
                                            ...Je
                                        })
                                    }),
                                    thead: ({node: it, ...Je}) => g.jsx(Be, {
                                        component: "thead",
                                        sx: {
                                            bgcolor: he.sender === "user" ? "rgba(255, 255, 255, 0.1)" : "action.hover"
                                        },
                                        ...Je
                                    }),
                                    tbody: ({node: it, ...Je}) => g.jsx(Be, {
                                        component: "tbody",
                                        ...Je
                                    }),
                                    tr: ({node: it, ...Je}) => g.jsx(Be, {
                                        component: "tr",
                                        sx: {
                                            "&:nth-of-type(odd)": {
                                                bgcolor: he.sender === "user" ? "rgba(255, 255, 255, 0.05)" : "rgba(0, 0, 0, 0.02)"
                                            },
                                            borderBottom: "1px solid",
                                            borderColor: "divider"
                                        },
                                        ...Je
                                    }),
                                    th: ({node: it, ...Je}) => g.jsx(Be, {
                                        component: "th",
                                        sx: {
                                            p: 1.5,
                                            textAlign: "left",
                                            fontWeight: "bold",
                                            borderBottom: "2px solid",
                                            borderColor: "divider",
                                            color: he.sender === "user" ? "white" : "text.primary"
                                        },
                                        ...Je
                                    }),
                                    td: ({node: it, ...Je}) => g.jsx(Be, {
                                        component: "td",
                                        sx: {
                                            p: 1.5,
                                            borderBottom: "1px solid",
                                            borderColor: "divider",
                                            color: he.sender === "user" ? "white" : "text.secondary"
                                        },
                                        ...Je
                                    }),
                                    p: ({node: it, ...Je}) => g.jsx(Ae, {
                                        variant: "body1",
                                        component: "span",
                                        color: he.sender === "user" ? "white" : "textPrimary",
                                        sx: {
                                            wordBreak: "break-word"
                                        },
                                        ...Je
                                    }),
                                    ol: ({node: it, ...Je}) => g.jsx(Be, {
                                        component: "ol",
                                        sx: {
                                            pl: 2,
                                            mb: 1
                                        },
                                        ...Je
                                    }),
                                    ul: ({node: it, ...Je}) => g.jsx(Be, {
                                        component: "ul",
                                        sx: {
                                            pl: 2,
                                            mb: 1
                                        },
                                        ...Je
                                    }),
                                    li: ({node: it, ...Je}) => g.jsx(Ae, {
                                        component: "li",
                                        variant: "body2",
                                        sx: {
                                            pl: 1,
                                            mb: .5
                                        },
                                        color: he.sender === "user" ? "white" : "inherit",
                                        ...Je
                                    })
                                },
                                children: he.text
                            }), g.jsx(Be, {
                                sx: {
                                    display: "flex",
                                    alignItems: "center",
                                    mt: .5
                                },
                                children: g.jsx(Ae, {
                                    variant: "caption",
                                    color: he.sender === "user" ? "white" : "textSecondary",
                                    sx: {
                                        ml: .5
                                    },
                                    children: new Date(he.timestamp).toLocaleTimeString([], {
                                        hour: "2-digit",
                                        minute: "2-digit"
                                    })
                                })
                            })]
                        }), he.sender === "user" && g.jsx(zu, {
                            sx: {
                                bgcolor: "grey.600",
                                ml: 1,
                                width: 32,
                                height: 32,
                                fontSize: 14
                            },
                            children: "US"
                        })]
                    }, `${he.sender}-${he.id}-${Le}`)), y && g.jsxs(Be, {
                        sx: {
                            display: "flex",
                            alignItems: "center",
                            mb: 1,
                            ml: 1
                        },
                        children: [g.jsx(Jr, {
                            size: 18,
                            sx: {
                                mr: 1
                            }
                        }), g.jsx(Ae, {
                            sx: {
                                fontStyle: "italic",
                                color: "grey.500"
                            },
                            children: "Preparing response..."
                        })]
                    }), h && g.jsx(Be, {
                        sx: {
                            mb: 1,
                            ml: 1
                        },
                        children: g.jsx(Ae, {
                            sx: {
                                color: "grey.500",
                                fontStyle: "italic"
                            },
                            children: "Bot is typing..."
                        })
                    }), g.jsx("div", {
                        ref: k
                    })]
                })
            }), g.jsx(Wm, {}), g.jsx(Be, {
                sx: {
                    p: 2,
                    borderTop: "1px solid #e5e5e5",
                    bgcolor: "background.paper",
                    flexShrink: 0,
                    position: "relative"
                },
                children: g.jsxs(Be, {
                    sx: {
                        display: "flex",
                        alignItems: "center",
                        border: "1px solid #3157d3ff",
                        borderRadius: 3,
                        p: "2px 8px",
                        bgcolor: "background.paper"
                    },
                    children: [g.jsx(pc, {
                        title: "Attach file",
                        children: g.jsxs(In, {
                            component: "label",
                            size: "large",
                            children: [g.jsx(D1e, {}), g.jsx("input", {
                                type: "file",
                                hidden: !0,
                                onChange: kn
                            })]
                        })
                    }), g.jsx(ct, {
                        variant: "standard",
                        placeholder: "Type your message",
                        value: u,
                        onChange: he => f(he.target.value),
                        onKeyDown: he => he.key === "Enter" && !he.shiftKey && mr(),
                        multiline: !0,
                        maxRows: 4,
                        fullWidth: !0,
                        InputProps: {
                            disableUnderline: !0
                        },
                        sx: {
                            mx: 1
                        },
                        disabled: y
                    }), g.jsx(pc, {
                        title: "Send",
                        children: g.jsx("span", {
                            children: g.jsx(In, {
                                color: "primary",
                                onClick: mr,
                                disabled: !u.trim() || y,
                                children: g.jsx(q1e, {})
                            })
                        })
                    })]
                })
            })]
        })]
    })
}
function JFe() {
    const e = Ec()
      , t = Os()
      , n = e.state?.workflowId || "RN001"
      , r = e.state?.date || "2024-01-01"
      , i = e.state?.description || "N/A"
      , [o,a] = A.useState(null)
      , [s,c] = A.useState(0)
      , [u,f] = A.useState(10)
      , [h,m] = A.useState({})
      , [y,b] = A.useState("")
      , [v,S] = A.useState({});
    A.useEffect( () => {
        (async () => {
            try {
                const $ = await Ize(n);
                a($);
                const z = {}
                  , O = {};
                $.Sets.forEach(I => {
                    const M = I.Records.find(B => B.GoldenRecord);
                    z[I.SetID] = M ? M.MatNumber : null,
                    O[I.SetID] = !0
                }
                ),
                m(z),
                S(O)
            } catch ($) {
                console.error("Failed to fetch workflow data:", $)
            }
        }
        )()
    }
    , [n]);
    const C = (D, $) => {
        m(z => ({
            ...z,
            [D]: $
        }))
    }
      , w = async () => {
        try {
            const D = Object.entries(h).map(async ([$,z]) => {
                z && await fetch(`http://10.10.223.114:8000/api/duplicates/runs/${n}/sets/${$}/golden/${z}/`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${localStorage.getItem("access_token")}`
                    }
                })
            }
            );
            await Promise.all(D),
            b("Golden Records saved successfully!"),
            setTimeout( () => b(""), 3e3)
        } catch (D) {
            console.error("Failed to save golden records:", D)
        }
    }
      , k = (D, $) => {
        console.log(D, $),
        c($)
    }
      , T = D => {
        f(parseInt(D.target.value, 10)),
        c(0)
    }
      , E = D => {
        S($ => ({
            ...$,
            [D]: !$[D]
        }))
    }
    ;
    if (!o)
        return g.jsx(Be, {
            display: "flex",
            height: "100vh",
            overflow: "hidden",
            children: g.jsx(Be, {
                flexGrow: 1,
                display: "flex",
                flexDirection: "column",
                children: g.jsxs(Be, {
                    flexGrow: 1,
                    p: 4,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    children: [g.jsx(Jr, {}), g.jsx(Ae, {
                        sx: {
                            ml: 2
                        },
                        children: "Loading..."
                    })]
                })
            })
        });
    const P = o.Sets.slice(s * u, s * u + u);
    return g.jsx(Be, {
        display: "flex",
        height: "100vh",
        overflow: "hidden",
        children: g.jsx(Be, {
            flexGrow: 1,
            display: "flex",
            flexDirection: "column",
            children: g.jsxs(Be, {
                component: "main",
                p: 4,
                flexGrow: 1,
                minHeight: 0,
                children: [g.jsxs(Be, {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    mb: 3,
                    children: [g.jsx(Ae, {
                        variant: "h5",
                        fontWeight: "bold",
                        children: "Workflow Details"
                    }), g.jsxs(Be, {
                        children: [g.jsx(Mt, {
                            variant: "outlined",
                            color: "primary",
                            sx: {
                                mr: 2
                            },
                            onClick: () => t("/home"),
                            children: "Back"
                        }), g.jsx(Mt, {
                            variant: "contained",
                            color: "primary",
                            onClick: w,
                            children: "Save Golden Records"
                        })]
                    })]
                }), y && g.jsx(Mc, {
                    severity: "success",
                    sx: {
                        py: 2,
                        mb: 2
                    },
                    children: y
                }), g.jsx(X2, {
                    variant: "outlined",
                    sx: {
                        mb: 3
                    },
                    children: g.jsx(J2, {
                        sx: {
                            py: 2
                        },
                        children: g.jsxs(je, {
                            container: !0,
                            spacing: 2,
                            children: [g.jsxs(je, {
                                size: {
                                    xs: 4
                                },
                                children: [g.jsx(Ae, {
                                    variant: "subtitle2",
                                    color: "text.secondary",
                                    children: "Run ID"
                                }), g.jsx(Ae, {
                                    variant: "body1",
                                    children: o.RunID
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 4
                                },
                                children: [g.jsx(Ae, {
                                    variant: "subtitle2",
                                    color: "text.secondary",
                                    children: "Description"
                                }), g.jsx(Ae, {
                                    variant: "body1",
                                    children: i
                                })]
                            }), g.jsxs(je, {
                                size: {
                                    xs: 4
                                },
                                children: [g.jsx(Ae, {
                                    variant: "subtitle2",
                                    color: "text.secondary",
                                    children: "Date & Time"
                                }), g.jsx(Ae, {
                                    variant: "body1",
                                    children: r
                                })]
                            })]
                        })
                    })
                }), g.jsx(Ha, {
                    component: yn,
                    sx: {
                        maxHeight: "calc(80vh - 52px)",
                        overflowY: "auto"
                    },
                    children: g.jsxs(Ua, {
                        stickyHeader: !0,
                        size: "small",
                        children: [g.jsx(qa, {
                            children: g.jsxs(gn, {
                                sx: {
                                    fontWeight: "bold"
                                },
                                children: [g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "Mat Number"
                                }), g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "Material Description"
                                }), g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "% of Completion"
                                }), g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "Match %"
                                }), g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "Inventory"
                                }), g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "Open Sales Orders"
                                }), g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "Open Purchase Orders"
                                }), g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "Action"
                                }), g.jsx(Me, {
                                    sx: {
                                        fontWeight: "bold"
                                    },
                                    children: "Golden Record"
                                })]
                            })
                        }), g.jsx(Va, {
                            children: P.map(D => {
                                const $ = v[D.SetID] !== !1;
                                return g.jsxs(g.Fragment, {
                                    children: [g.jsx(gn, {
                                        children: g.jsx(Me, {
                                            colSpan: 9,
                                            sx: {
                                                backgroundColor: "#f5f5f5"
                                            },
                                            children: g.jsxs(Be, {
                                                display: "flex",
                                                alignItems: "center",
                                                justifyContent: "space-between",
                                                children: [g.jsxs(Ae, {
                                                    variant: "subtitle1",
                                                    fontWeight: "bold",
                                                    children: ["Set Id: ", D.SetID]
                                                }), g.jsx(In, {
                                                    size: "small",
                                                    onClick: () => E(D.SetID),
                                                    children: $ ? g.jsx(jA, {}) : g.jsx(BA, {})
                                                })]
                                            })
                                        })
                                    }, `header-${D.SetID}`), $ && D.Records.map(z => g.jsxs(gn, {
                                        children: [g.jsx(Me, {
                                            sx: {
                                                backgroundColor: h[D.SetID] === z.MatNumber ? "rgba(46, 125, 50, 0.15)" : "inherit"
                                            },
                                            children: z.MatNumber
                                        }), g.jsx(Me, {
                                            sx: {
                                                backgroundColor: h[D.SetID] === z.MatNumber ? "rgba(46, 125, 50, 0.15)" : "inherit"
                                            },
                                            children: z.MaterialDescription
                                        }), g.jsx(Me, {
                                            sx: {
                                                backgroundColor: h[D.SetID] === z.MatNumber ? "rgba(46, 125, 50, 0.15)" : "inherit"
                                            },
                                            children: z.Completion
                                        }), g.jsx(Me, {
                                            sx: {
                                                backgroundColor: h[D.SetID] === z.MatNumber ? "rgba(46, 125, 50, 0.15)" : "inherit"
                                            },
                                            children: z.MatchPercent
                                        }), g.jsx(Me, {
                                            sx: {
                                                backgroundColor: h[D.SetID] === z.MatNumber ? "rgba(46, 125, 50, 0.15)" : "inherit"
                                            },
                                            children: z.Inventory
                                        }), g.jsx(Me, {
                                            sx: {
                                                backgroundColor: h[D.SetID] === z.MatNumber ? "rgba(46, 125, 50, 0.15)" : "inherit"
                                            },
                                            children: z.OpenSalesOrders
                                        }), g.jsx(Me, {
                                            sx: {
                                                backgroundColor: h[D.SetID] === z.MatNumber ? "rgba(46, 125, 50, 0.15)" : "inherit"
                                            },
                                            children: z.OpenPurOrders
                                        }), g.jsx(Me, {
                                            sx: {
                                                backgroundColor: h[D.SetID] === z.MatNumber ? "rgba(46, 125, 50, 0.15)" : "inherit"
                                            },
                                            children: z.Action
                                        }), g.jsx(Me, {
                                            children: g.jsx($ce, {
                                                checked: h[D.SetID] === z.MatNumber,
                                                onChange: () => C(D.SetID, z.MatNumber),
                                                name: `golden-${D.SetID}`,
                                                color: "success"
                                            })
                                        })]
                                    }, `${o.RunID}-${D.SetID}-${z.MatNumber}`)), !$ && g.jsx(gn, {
                                        children: g.jsx(Me, {
                                            colSpan: 9,
                                            sx: {
                                                padding: 0,
                                                height: "3px"
                                            }
                                        })
                                    })]
                                })
                            }
                            )
                        })]
                    })
                }), g.jsx(Bg, {
                    rowsPerPageOptions: [5, 10, 25],
                    component: "div",
                    count: o.Sets.length,
                    rowsPerPage: u,
                    page: s,
                    onPageChange: k,
                    onRowsPerPageChange: T
                })]
            })
        })
    })
}
function v2(e) {
    const {children: t, value: n, index: r, ...i} = e;
    return g.jsx("div", {
        role: "tabpanel",
        hidden: n !== r,
        id: `product-tabpanel-${r}`,
        "aria-labelledby": `product-tab-${r}`,
        ...i,
        children: n === r && g.jsx(Be, {
            sx: {
                py: 3
            },
            children: t
        })
    })
}
const eNe = ({product: e, onBack: t, onEdit: n}) => {
    const [r,i] = A.useState(0)
      , o = (s, c) => {
        i(c)
    }
      , a = (s, c) => g.jsxs(Be, {
        sx: {
            display: "flex",
            py: 1
        },
        children: [g.jsx(Be, {
            sx: {
                flex: "0 0 33%"
            },
            children: g.jsxs(Ae, {
                variant: "subtitle1",
                color: "text.secondary",
                children: [s, ":"]
            })
        }), g.jsx(Be, {
            sx: {
                flex: "1 1 auto"
            },
            children: g.jsx(Ae, {
                variant: "body1",
                children: c || "-"
            })
        })]
    });
    return g.jsxs(Be, {
        sx: {
            height: "100%",
            display: "flex",
            flexDirection: "column"
        },
        children: [g.jsxs(Be, {
            sx: {
                p: 2,
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                backgroundColor: "white",
                borderBottom: 1,
                borderColor: "divider"
            },
            children: [g.jsx(Ae, {
                variant: "h6",
                children: "Product Details"
            }), g.jsxs(Be, {
                sx: {
                    display: "flex",
                    gap: 2
                },
                children: [g.jsx(Mt, {
                    variant: "outlined",
                    startIcon: g.jsx(rg, {}),
                    onClick: () => n(e),
                    size: "small",
                    children: "Edit"
                }), g.jsx(Mt, {
                    variant: "outlined",
                    onClick: t,
                    size: "small",
                    children: "Back"
                })]
            })]
        }), g.jsxs(Be, {
            component: yn,
            sx: {
                flex: 1,
                display: "flex",
                flexDirection: "column"
            },
            children: [g.jsxs(d3, {
                value: r,
                onChange: o,
                sx: {
                    borderBottom: 1,
                    borderColor: "divider",
                    px: 2
                },
                children: [g.jsx(xm, {
                    label: "Overview"
                }), g.jsx(xm, {
                    label: "Transactions"
                }), g.jsx(xm, {
                    label: "History"
                })]
            }), g.jsxs(Be, {
                sx: {
                    flex: 1,
                    overflowY: "auto",
                    px: 3
                },
                children: [g.jsxs(v2, {
                    value: r,
                    index: 0,
                    children: [a("Product ID", e.productId), a("Product Type", e.productType.productTypeDesc), a("Product Group", e.productGroup.productGroupDesc), a("Product Category", e.productCategory.productCategoryDesc), a("Language", e.languageId), a("Status", e.salesStatusId), a("Unit of Measurement", e.unitOfMeasurement), a("Short Description", e.shortDescription), a("Long Description", e.longDescription), g.jsx(Ae, {
                        variant: "h6",
                        sx: {
                            mt: 3,
                            mb: 1
                        },
                        children: "UOM Details"
                    }), e.productMasterUomDto && e.productMasterUomDto.length > 0 ? e.productMasterUomDto.map( (s, c) => g.jsxs(Be, {
                        sx: {
                            mb: 2,
                            p: 2,
                            border: "1px solid",
                            borderColor: "divider",
                            borderRadius: 1
                        },
                        children: [a("UOM", s.uom), a("Quantity", s.quantity), a("Price", s.quantity), a("Currency", s.primaryQty)]
                    }, c)) : g.jsx(Ae, {
                        variant: "body2",
                        color: "text.secondary",
                        children: "No UOM details available."
                    })]
                }), g.jsx(v2, {
                    value: r,
                    index: 1,
                    children: g.jsx(Ha, {
                        component: yn,
                        children: g.jsxs(Ua, {
                            size: "small",
                            children: [g.jsx(qa, {
                                children: g.jsxs(gn, {
                                    children: [g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Uom"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Quantity"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Primary Qty"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Length"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Width"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Height"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Length Uom"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Net Weight"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Gross Weight"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Weight Uom"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Volume"
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1,
                                            fontWeight: "bold"
                                        },
                                        children: "Volume Uom"
                                    })]
                                })
                            }), g.jsxs(Va, {
                                children: [e.productMasterUomDto.map(s => g.jsxs(gn, {
                                    sx: {
                                        "&:hover": {
                                            backgroundColor: "#f1f1fa",
                                            cursor: "pointer"
                                        }
                                    },
                                    children: [g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.uom
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.quantity
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.primaryQty
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.length
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.width
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.height
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.lengthUom
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.netWeight
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.grossWeight
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.weightUom
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.volume
                                    }), g.jsx(Me, {
                                        sx: {
                                            py: 1
                                        },
                                        children: s.volumeUom
                                    })]
                                }, s.uomDataId)), e.productMasterUomDto.length === 0 && g.jsx(gn, {
                                    children: g.jsx(Me, {
                                        colSpan: 5,
                                        align: "center",
                                        sx: {
                                            py: 2
                                        },
                                        children: "No data found."
                                    })
                                })]
                            })]
                        })
                    })
                }), g.jsx(v2, {
                    value: r,
                    index: 2,
                    children: g.jsx(Ae, {
                        variant: "body2",
                        color: "text.secondary",
                        children: "Product history will be displayed here"
                    })
                })]
            })]
        })]
    })
}
  , tNe = ({open: e, title: t="Confirm", message: n="Are you sure?", onConfirm: r, onCancel: i}) => g.jsxs(sc, {
    open: e,
    onClose: i,
    children: [g.jsx(yu, {
        children: t
    }), g.jsx(cc, {
        children: g.jsx(Px, {
            children: n
        })
    }), g.jsxs(lc, {
        children: [g.jsx(Mt, {
            onClick: i,
            color: "primary",
            children: "No"
        }), g.jsx(Mt, {
            onClick: r,
            color: "error",
            autoFocus: !0,
            children: "Yes"
        })]
    })]
})
  , nNe = ["localeText"]
  , Q_ = A.createContext(null)
  , Q7 = function(t) {
    const {localeText: n} = t
      , r = Qt(t, nNe)
      , {utils: i, localeText: o} = A.useContext(Q_) ?? {
        utils: void 0,
        localeText: void 0
    }
      , a = hr({
        props: r,
        name: "MuiLocalizationProvider"
    })
      , {children: s, dateAdapter: c, dateFormats: u, dateLibInstance: f, adapterLocale: h, localeText: m} = a
      , y = A.useMemo( () => ge({}, m, o, n), [m, o, n])
      , b = A.useMemo( () => {
        if (!c)
            return i || null;
        const C = new c({
            locale: h,
            formats: u,
            instance: f
        });
        if (!C.isMUIAdapter)
            throw new Error(["MUI X: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
        return C
    }
    , [c, h, u, f, i])
      , v = A.useMemo( () => b ? {
        minDate: b.date("1900-01-01T00:00:00.000"),
        maxDate: b.date("2099-12-31T00:00:00.000")
    } : null, [b])
      , S = A.useMemo( () => ({
        utils: b,
        defaultDates: v,
        localeText: y
    }), [v, b, y]);
    return g.jsx(Q_.Provider, {
        value: S,
        children: s
    })
}
  , rNe = e => ({
    components: {
        MuiLocalizationProvider: {
            defaultProps: {
                localeText: ge({}, e)
            }
        }
    }
})
  , K7 = e => {
    const {utils: t, formatKey: n, contextTranslation: r, propsTranslation: i} = e;
    return o => {
        const a = o !== null && t.isValid(o) ? t.format(o, n) : null;
        return (i ?? r)(o, t, a)
    }
}
  , X7 = {
    previousMonth: "Previous month",
    nextMonth: "Next month",
    openPreviousView: "Open previous view",
    openNextView: "Open next view",
    calendarViewSwitchingButtonAriaLabel: e => e === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
    start: "Start",
    end: "End",
    startDate: "Start date",
    startTime: "Start time",
    endDate: "End date",
    endTime: "End time",
    cancelButtonLabel: "Cancel",
    clearButtonLabel: "Clear",
    okButtonLabel: "OK",
    todayButtonLabel: "Today",
    datePickerToolbarTitle: "Select date",
    dateTimePickerToolbarTitle: "Select date & time",
    timePickerToolbarTitle: "Select time",
    dateRangePickerToolbarTitle: "Select date range",
    clockLabelText: (e, t, n, r) => `Select ${e}. ${!r && (t === null || !n.isValid(t)) ? "No time selected" : `Selected time is ${r ?? n.format(t, "fullTime")}`}`,
    hoursClockNumberText: e => `${e} hours`,
    minutesClockNumberText: e => `${e} minutes`,
    secondsClockNumberText: e => `${e} seconds`,
    selectViewText: e => `Select ${e}`,
    calendarWeekNumberHeaderLabel: "Week number",
    calendarWeekNumberHeaderText: "#",
    calendarWeekNumberAriaLabelText: e => `Week ${e}`,
    calendarWeekNumberText: e => `${e}`,
    openDatePickerDialogue: (e, t, n) => n || e !== null && t.isValid(e) ? `Choose date, selected date is ${n ?? t.format(e, "fullDate")}` : "Choose date",
    openTimePickerDialogue: (e, t, n) => n || e !== null && t.isValid(e) ? `Choose time, selected time is ${n ?? t.format(e, "fullTime")}` : "Choose time",
    fieldClearLabel: "Clear",
    timeTableLabel: "pick time",
    dateTableLabel: "pick date",
    fieldYearPlaceholder: e => "Y".repeat(e.digitAmount),
    fieldMonthPlaceholder: e => e.contentType === "letter" ? "MMMM" : "MM",
    fieldDayPlaceholder: () => "DD",
    fieldWeekDayPlaceholder: e => e.contentType === "letter" ? "EEEE" : "EE",
    fieldHoursPlaceholder: () => "hh",
    fieldMinutesPlaceholder: () => "mm",
    fieldSecondsPlaceholder: () => "ss",
    fieldMeridiemPlaceholder: () => "aa",
    year: "Year",
    month: "Month",
    day: "Day",
    weekDay: "Week day",
    hours: "Hours",
    minutes: "Minutes",
    seconds: "Seconds",
    meridiem: "Meridiem",
    empty: "Empty"
}
  , iNe = X7;
rNe(X7);
const dd = () => {
    const e = A.useContext(Q_);
    if (e === null)
        throw new Error(["MUI X: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join(`
`));
    if (e.utils === null)
        throw new Error(["MUI X: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join(`
`));
    const t = A.useMemo( () => ge({}, iNe, e.localeText), [e.localeText]);
    return A.useMemo( () => ge({}, e, {
        localeText: t
    }), [e, t])
}
  , pr = () => dd().utils
  , fy = () => dd().defaultDates
  , dS = e => {
    const t = pr()
      , n = A.useRef(void 0);
    return n.current === void 0 && (n.current = t.date(void 0, e)),
    n.current
}
  , Rl = () => dd().localeText
  , oNe = _t(g.jsx("path", {
    d: "M7 10l5 5 5-5z"
}))
  , aNe = _t(g.jsx("path", {
    d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}))
  , sNe = _t(g.jsx("path", {
    d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}))
  , lNe = _t(g.jsx("path", {
    d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
}));
_t(g.jsxs(A.Fragment, {
    children: [g.jsx("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), g.jsx("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
    })]
}));
_t(g.jsx("path", {
    d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
}));
_t(g.jsxs(A.Fragment, {
    children: [g.jsx("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), g.jsx("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
    })]
}));
const cNe = _t(g.jsx("path", {
    d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
function uNe(e) {
    return rt("MuiPickersArrowSwitcher", e)
}
ot("MuiPickersArrowSwitcher", ["root", "spacer", "button", "previousIconButton", "nextIconButton", "leftArrowIcon", "rightArrowIcon"]);
const dNe = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel", "labelId"]
  , fNe = ["ownerState"]
  , hNe = ["ownerState"]
  , pNe = ue("div", {
    name: "MuiPickersArrowSwitcher",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "flex"
})
  , mNe = ue("div", {
    name: "MuiPickersArrowSwitcher",
    slot: "Spacer",
    overridesResolver: (e, t) => t.spacer
})( ({theme: e}) => ({
    width: e.spacing(3)
}))
  , I5 = ue(In, {
    name: "MuiPickersArrowSwitcher",
    slot: "Button",
    overridesResolver: (e, t) => t.button
})({
    variants: [{
        props: {
            hidden: !0
        },
        style: {
            visibility: "hidden"
        }
    }]
})
  , gNe = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        spacer: ["spacer"],
        button: ["button"],
        previousIconButton: ["previousIconButton"],
        nextIconButton: ["nextIconButton"],
        leftArrowIcon: ["leftArrowIcon"],
        rightArrowIcon: ["rightArrowIcon"]
    }, uNe, t)
}
  , yNe = A.forwardRef(function(t, n) {
    const r = Si()
      , i = hr({
        props: t,
        name: "MuiPickersArrowSwitcher"
    })
      , {children: o, className: a, slots: s, slotProps: c, isNextDisabled: u, isNextHidden: f, onGoToNext: h, nextLabel: m, isPreviousDisabled: y, isPreviousHidden: b, onGoToPrevious: v, previousLabel: S, labelId: C} = i
      , w = Qt(i, dNe)
      , k = i
      , T = gNe(k)
      , E = {
        isDisabled: u,
        isHidden: f,
        goTo: h,
        label: m
    }
      , P = {
        isDisabled: y,
        isHidden: b,
        goTo: v,
        label: S
    }
      , D = s?.previousIconButton ?? I5
      , $ = _n({
        elementType: D,
        externalSlotProps: c?.previousIconButton,
        additionalProps: {
            size: "medium",
            title: P.label,
            "aria-label": P.label,
            disabled: P.isDisabled,
            edge: "end",
            onClick: P.goTo
        },
        ownerState: ge({}, k, {
            hidden: P.isHidden
        }),
        className: Ne(T.button, T.previousIconButton)
    })
      , z = s?.nextIconButton ?? I5
      , O = _n({
        elementType: z,
        externalSlotProps: c?.nextIconButton,
        additionalProps: {
            size: "medium",
            title: E.label,
            "aria-label": E.label,
            disabled: E.isDisabled,
            edge: "start",
            onClick: E.goTo
        },
        ownerState: ge({}, k, {
            hidden: E.isHidden
        }),
        className: Ne(T.button, T.nextIconButton)
    })
      , I = s?.leftArrowIcon ?? aNe
      , M = _n({
        elementType: I,
        externalSlotProps: c?.leftArrowIcon,
        additionalProps: {
            fontSize: "inherit"
        },
        ownerState: k,
        className: T.leftArrowIcon
    })
      , B = Qt(M, fNe)
      , L = s?.rightArrowIcon ?? sNe
      , F = _n({
        elementType: L,
        externalSlotProps: c?.rightArrowIcon,
        additionalProps: {
            fontSize: "inherit"
        },
        ownerState: k,
        className: T.rightArrowIcon
    })
      , j = Qt(F, hNe);
    return g.jsxs(pNe, ge({
        ref: n,
        className: Ne(T.root, a),
        ownerState: k
    }, w, {
        children: [g.jsx(D, ge({}, $, {
            children: r ? g.jsx(L, ge({}, j)) : g.jsx(I, ge({}, B))
        })), o ? g.jsx(Ae, {
            variant: "subtitle1",
            component: "span",
            id: C,
            children: o
        }) : g.jsx(mNe, {
            className: T.spacer,
            ownerState: k
        }), g.jsx(z, ge({}, O, {
            children: r ? g.jsx(I, ge({}, B)) : g.jsx(L, ge({}, j))
        }))]
    }))
})
  , qp = (e, t) => e.length !== t.length ? !1 : t.every(n => e.includes(n))
  , bNe = ({openTo: e, defaultOpenTo: t, views: n, defaultViews: r}) => {
    const i = n ?? r;
    let o;
    if (e != null)
        o = e;
    else if (i.includes(t))
        o = t;
    else if (i.length > 0)
        o = i[0];
    else
        throw new Error("MUI X: The `views` prop must contain at least one view.");
    return {
        views: i,
        openTo: o
    }
}
  , xNe = ["hours", "minutes", "seconds"]
  , vNe = e => xNe.includes(e)
  , $5 = (e, t) => t.getHours(e) * 3600 + t.getMinutes(e) * 60 + t.getSeconds(e)
  , SNe = (e, t) => (n, r) => e ? t.isAfter(n, r) : $5(n, t) > $5(r, t);
function J7({onChange: e, onViewChange: t, openTo: n, view: r, views: i, autoFocus: o, focusedView: a, onFocusedViewChange: s}) {
    const c = A.useRef(n)
      , u = A.useRef(i)
      , f = A.useRef(i.includes(n) ? n : i[0])
      , [h,m] = go({
        name: "useViews",
        state: "view",
        controlled: r,
        default: f.current
    })
      , y = A.useRef(o ? h : null)
      , [b,v] = go({
        name: "useViews",
        state: "focusedView",
        controlled: a,
        default: y.current
    });
    A.useEffect( () => {
        (c.current && c.current !== n || u.current && u.current.some(D => !i.includes(D))) && (m(i.includes(n) ? n : i[0]),
        u.current = i,
        c.current = n)
    }
    , [n, m, h, i]);
    const S = i.indexOf(h)
      , C = i[S - 1] ?? null
      , w = i[S + 1] ?? null
      , k = ft( (D, $) => {
        v($ ? D : z => D === z ? null : z),
        s?.(D, $)
    }
    )
      , T = ft(D => {
        k(D, !0),
        D !== h && (m(D),
        t && t(D))
    }
    )
      , E = ft( () => {
        w && T(w)
    }
    )
      , P = ft( (D, $, z) => {
        const O = $ === "finish"
          , I = z ? i.indexOf(z) < i.length - 1 : !!w;
        if (e(D, O && I ? "partial" : $, z),
        z && z !== h) {
            const B = i[i.indexOf(z) + 1];
            B && T(B)
        } else
            O && E()
    }
    );
    return {
        view: h,
        setView: T,
        focusedView: b,
        setFocusedView: k,
        nextView: w,
        previousView: C,
        defaultView: i.includes(n) ? n : i[0],
        goToNextView: E,
        setValueAndGoToNextView: P
    }
}
function CNe(e, {disableFuture: t, maxDate: n, timezone: r}) {
    const i = pr();
    return A.useMemo( () => {
        const o = i.date(void 0, r)
          , a = i.startOfMonth(t && i.isBefore(o, n) ? o : n);
        return !i.isAfter(a, e)
    }
    , [t, n, e, i, r])
}
function wNe(e, {disablePast: t, minDate: n, timezone: r}) {
    const i = pr();
    return A.useMemo( () => {
        const o = i.date(void 0, r)
          , a = i.startOfMonth(t && i.isAfter(o, n) ? o : n);
        return !i.isBefore(a, e)
    }
    , [t, n, e, i, r])
}
const xg = 36
  , fS = 2
  , hS = 320
  , kNe = 280
  , oP = 336
  , TNe = ue("div")({
    overflow: "hidden",
    width: hS,
    maxHeight: oP,
    display: "flex",
    flexDirection: "column",
    margin: "0 auto"
})
  , kv = (e, t, n) => {
    let r = t;
    return r = e.setHours(r, e.getHours(n)),
    r = e.setMinutes(r, e.getMinutes(n)),
    r = e.setSeconds(r, e.getSeconds(n)),
    r = e.setMilliseconds(r, e.getMilliseconds(n)),
    r
}
  , Lm = ({date: e, disableFuture: t, disablePast: n, maxDate: r, minDate: i, isDateDisabled: o, utils: a, timezone: s}) => {
    const c = kv(a, a.date(void 0, s), e);
    n && a.isBefore(i, c) && (i = c),
    t && a.isAfter(r, c) && (r = c);
    let u = e
      , f = e;
    for (a.isBefore(e, i) && (u = i,
    f = null),
    a.isAfter(e, r) && (f && (f = r),
    u = null); u || f; ) {
        if (u && a.isAfter(u, r) && (u = null),
        f && a.isBefore(f, i) && (f = null),
        u) {
            if (!o(u))
                return u;
            u = a.addDays(u, 1)
        }
        if (f) {
            if (!o(f))
                return f;
            f = a.addDays(f, -1)
        }
    }
    return null
}
  , _Ne = (e, t) => t == null || !e.isValid(t) ? null : t
  , _a = (e, t, n) => t == null || !e.isValid(t) ? n : t
  , ENe = (e, t, n) => !e.isValid(t) && t != null && !e.isValid(n) && n != null ? !0 : e.isEqual(t, n)
  , aP = (e, t) => {
    const r = [e.startOfYear(t)];
    for (; r.length < 12; ) {
        const i = r[r.length - 1];
        r.push(e.addMonths(i, 1))
    }
    return r
}
  , eG = (e, t, n) => n === "date" ? e.startOfDay(e.date(void 0, t)) : e.date(void 0, t)
  , ANe = ["year", "month", "day"]
  , L5 = e => ANe.includes(e)
  , sP = (e, {format: t, views: n}, r) => {
    if (t != null)
        return t;
    const i = e.formats;
    return qp(n, ["year"]) ? i.year : qp(n, ["month"]) ? i.month : qp(n, ["day"]) ? i.dayOfMonth : qp(n, ["month", "year"]) ? `${i.month} ${i.year}` : qp(n, ["day", "month"]) ? `${i.month} ${i.dayOfMonth}` : r ? /en/.test(e.getCurrentLocaleCode()) ? i.normalDateWithWeekday : i.normalDate : i.keyboardDate
}
  , MNe = (e, t) => {
    const n = e.startOfWeek(t);
    return [0, 1, 2, 3, 4, 5, 6].map(r => e.addDays(n, r))
}
  , lP = ({timezone: e, value: t, defaultValue: n, referenceDate: r, onChange: i, valueManager: o}) => {
    const a = pr()
      , s = A.useRef(n)
      , c = t ?? s.current ?? o.emptyValue
      , u = A.useMemo( () => o.getTimezone(a, c), [a, o, c])
      , f = ft(b => u == null ? b : o.setTimezone(a, u, b));
    let h;
    e ? h = e : u ? h = u : r ? h = a.getTimezone(r) : h = "default";
    const m = A.useMemo( () => o.setTimezone(a, h, c), [o, a, h, c])
      , y = ft( (b, ...v) => {
        const S = f(b);
        i?.(S, ...v)
    }
    );
    return {
        value: m,
        handleValueChange: y,
        timezone: h
    }
}
  , cP = ({name: e, timezone: t, value: n, defaultValue: r, referenceDate: i, onChange: o, valueManager: a}) => {
    const [s,c] = go({
        name: e,
        state: "value",
        controlled: n,
        default: r ?? a.emptyValue
    })
      , u = ft( (f, ...h) => {
        c(f),
        o?.(f, ...h)
    }
    );
    return lP({
        timezone: t,
        value: s,
        defaultValue: void 0,
        referenceDate: i,
        onChange: u,
        valueManager: a
    })
}
  , xs = {
    year: 1,
    month: 2,
    day: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7
}
  , PNe = e => Math.max(...e.map(t => xs[t.type] ?? 1))
  , Wp = (e, t, n) => {
    if (t === xs.year)
        return e.startOfYear(n);
    if (t === xs.month)
        return e.startOfMonth(n);
    if (t === xs.day)
        return e.startOfDay(n);
    let r = n;
    return t < xs.minutes && (r = e.setMinutes(r, 0)),
    t < xs.seconds && (r = e.setSeconds(r, 0)),
    t < xs.milliseconds && (r = e.setMilliseconds(r, 0)),
    r
}
  , RNe = ({props: e, utils: t, granularity: n, timezone: r, getTodayDate: i}) => {
    let o = i ? i() : Wp(t, n, eG(t, r));
    e.minDate != null && t.isAfterDay(e.minDate, o) && (o = Wp(t, n, e.minDate)),
    e.maxDate != null && t.isBeforeDay(e.maxDate, o) && (o = Wp(t, n, e.maxDate));
    const a = SNe(e.disableIgnoringDatePartForTimeValidation ?? !1, t);
    return e.minTime != null && a(e.minTime, o) && (o = Wp(t, n, e.disableIgnoringDatePartForTimeValidation ? e.minTime : kv(t, o, e.minTime))),
    e.maxTime != null && a(o, e.maxTime) && (o = Wp(t, n, e.disableIgnoringDatePartForTimeValidation ? e.maxTime : kv(t, o, e.maxTime))),
    o
}
  , tG = (e, t) => {
    const n = e.formatTokenMap[t];
    if (n == null)
        throw new Error([`MUI X: The token "${t}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join(`
`));
    return typeof n == "string" ? {
        type: n,
        contentType: n === "meridiem" ? "letter" : "digit",
        maxLength: void 0
    } : {
        type: n.sectionType,
        contentType: n.contentType,
        maxLength: n.maxLength
    }
}
  , DNe = e => {
    switch (e) {
    case "ArrowUp":
        return 1;
    case "ArrowDown":
        return -1;
    case "PageUp":
        return 5;
    case "PageDown":
        return -5;
    default:
        return 0
    }
}
  , pS = (e, t) => {
    const n = []
      , r = e.date(void 0, "default")
      , i = e.startOfWeek(r)
      , o = e.endOfWeek(r);
    let a = i;
    for (; e.isBefore(a, o); )
        n.push(a),
        a = e.addDays(a, 1);
    return n.map(s => e.formatByString(s, t))
}
  , nG = (e, t, n, r) => {
    switch (n) {
    case "month":
        return aP(e, e.date(void 0, t)).map(i => e.formatByString(i, r));
    case "weekDay":
        return pS(e, r);
    case "meridiem":
        {
            const i = e.date(void 0, t);
            return [e.startOfDay(i), e.endOfDay(i)].map(o => e.formatByString(o, r))
        }
    default:
        return []
    }
}
  , j5 = "s"
  , ONe = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
  , INe = e => {
    const t = e.date(void 0);
    return e.formatByString(e.setSeconds(t, 0), j5) === "0" ? ONe : Array.from({
        length: 10
    }).map( (r, i) => e.formatByString(e.setSeconds(t, i), j5))
}
  , td = (e, t) => {
    if (t[0] === "0")
        return e;
    const n = [];
    let r = "";
    for (let i = 0; i < e.length; i += 1) {
        r += e[i];
        const o = t.indexOf(r);
        o > -1 && (n.push(o.toString()),
        r = "")
    }
    return n.join("")
}
  , uP = (e, t) => t[0] === "0" ? e : e.split("").map(n => t[Number(n)]).join("")
  , B5 = (e, t) => {
    const n = td(e, t);
    return n !== " " && !Number.isNaN(Number(n))
}
  , rG = (e, t) => {
    let n = e;
    for (n = Number(n).toString(); n.length < t; )
        n = `0${n}`;
    return n
}
  , iG = (e, t, n, r, i) => {
    if (i.type === "day" && i.contentType === "digit-with-letter") {
        const a = e.setDate(n.longestMonth, t);
        return e.formatByString(a, i.format)
    }
    let o = t.toString();
    return i.hasLeadingZerosInInput && (o = rG(o, i.maxLength)),
    uP(o, r)
}
  , $Ne = (e, t, n, r, i, o, a, s) => {
    const c = DNe(r)
      , u = r === "Home"
      , f = r === "End"
      , h = n.value === "" || u || f
      , m = () => {
        const b = i[n.type]({
            currentDate: a,
            format: n.format,
            contentType: n.contentType
        })
          , v = w => iG(e, w, b, o, n)
          , S = n.type === "minutes" && s?.minutesStep ? s.minutesStep : 1;
        let C;
        if (h) {
            if (n.type === "year" && !f && !u)
                return e.formatByString(e.date(void 0, t), n.format);
            c > 0 || u ? C = b.minimum : C = b.maximum
        } else
            C = parseInt(td(n.value, o), 10) + c * S;
        return C % S !== 0 && ((c < 0 || u) && (C += S - (S + C) % S),
        (c > 0 || f) && (C -= C % S)),
        C > b.maximum ? v(b.minimum + (C - b.maximum - 1) % (b.maximum - b.minimum + 1)) : C < b.minimum ? v(b.maximum - (b.minimum - C - 1) % (b.maximum - b.minimum + 1)) : v(C)
    }
      , y = () => {
        const b = nG(e, t, n.type, n.format);
        if (b.length === 0)
            return n.value;
        if (h)
            return c > 0 || u ? b[0] : b[b.length - 1];
        const C = ((b.indexOf(n.value) + c) % b.length + b.length) % b.length;
        return b[C]
    }
    ;
    return n.contentType === "digit" || n.contentType === "digit-with-letter" ? m() : y()
}
  , dP = (e, t, n) => {
    let r = e.value || e.placeholder;
    const i = t === "non-input" ? e.hasLeadingZerosInFormat : e.hasLeadingZerosInInput;
    return t === "non-input" && e.hasLeadingZerosInInput && !e.hasLeadingZerosInFormat && (r = Number(td(r, n)).toString()),
    ["input-rtl", "input-ltr"].includes(t) && e.contentType === "digit" && !i && r.length === 1 && (r = `${r}`),
    t === "input-rtl" && (r = `${r}`),
    r
}
  , z5 = (e, t, n, r) => e.formatByString(e.parse(t, n), r)
  , LNe = (e, t) => e.formatByString(e.date(void 0, "system"), t).length === 4
  , oG = (e, t, n, r) => {
    if (t !== "digit")
        return !1;
    const i = e.date(void 0, "default");
    switch (n) {
    case "year":
        return e.lib === "dayjs" && r === "YY" ? !0 : e.formatByString(e.setYear(i, 1), r).startsWith("0");
    case "month":
        return e.formatByString(e.startOfYear(i), r).length > 1;
    case "day":
        return e.formatByString(e.startOfMonth(i), r).length > 1;
    case "weekDay":
        return e.formatByString(e.startOfWeek(i), r).length > 1;
    case "hours":
        return e.formatByString(e.setHours(i, 1), r).length > 1;
    case "minutes":
        return e.formatByString(e.setMinutes(i, 1), r).length > 1;
    case "seconds":
        return e.formatByString(e.setSeconds(i, 1), r).length > 1;
    default:
        throw new Error("Invalid section type")
    }
}
  , jNe = (e, t, n) => {
    const r = t.some(c => c.type === "day")
      , i = []
      , o = [];
    for (let c = 0; c < t.length; c += 1) {
        const u = t[c];
        r && u.type === "weekDay" || (i.push(u.format),
        o.push(dP(u, "non-input", n)))
    }
    const a = i.join(" ")
      , s = o.join(" ");
    return e.parse(s, a)
}
  , BNe = e => e.map(t => `${t.startSeparator}${t.value || t.placeholder}${t.endSeparator}`).join("")
  , zNe = (e, t, n) => {
    const i = e.map(o => {
        const a = dP(o, n ? "input-rtl" : "input-ltr", t);
        return `${o.startSeparator}${a}${o.endSeparator}`
    }
    ).join("");
    return n ? `${i}` : i
}
  , FNe = (e, t, n) => {
    const r = e.date(void 0, n)
      , i = e.endOfYear(r)
      , o = e.endOfDay(r)
      , {maxDaysInMonth: a, longestMonth: s} = aP(e, r).reduce( (c, u) => {
        const f = e.getDaysInMonth(u);
        return f > c.maxDaysInMonth ? {
            maxDaysInMonth: f,
            longestMonth: u
        } : c
    }
    , {
        maxDaysInMonth: 0,
        longestMonth: null
    });
    return {
        year: ({format: c}) => ({
            minimum: 0,
            maximum: LNe(e, c) ? 9999 : 99
        }),
        month: () => ({
            minimum: 1,
            maximum: e.getMonth(i) + 1
        }),
        day: ({currentDate: c}) => ({
            minimum: 1,
            maximum: c != null && e.isValid(c) ? e.getDaysInMonth(c) : a,
            longestMonth: s
        }),
        weekDay: ({format: c, contentType: u}) => {
            if (u === "digit") {
                const f = pS(e, c).map(Number);
                return {
                    minimum: Math.min(...f),
                    maximum: Math.max(...f)
                }
            }
            return {
                minimum: 1,
                maximum: 7
            }
        }
        ,
        hours: ({format: c}) => {
            const u = e.getHours(o);
            return td(e.formatByString(e.endOfDay(r), c), t) !== u.toString() ? {
                minimum: 1,
                maximum: Number(td(e.formatByString(e.startOfDay(r), c), t))
            } : {
                minimum: 0,
                maximum: u
            }
        }
        ,
        minutes: () => ({
            minimum: 0,
            maximum: e.getMinutes(o)
        }),
        seconds: () => ({
            minimum: 0,
            maximum: e.getSeconds(o)
        }),
        meridiem: () => ({
            minimum: 0,
            maximum: 1
        }),
        empty: () => ({
            minimum: 0,
            maximum: 0
        })
    }
}
  , NNe = (e, t, n, r) => {
    switch (t.type) {
    case "year":
        return e.setYear(r, e.getYear(n));
    case "month":
        return e.setMonth(r, e.getMonth(n));
    case "weekDay":
        {
            const i = pS(e, t.format)
              , o = e.formatByString(n, t.format)
              , a = i.indexOf(o)
              , c = i.indexOf(t.value) - a;
            return e.addDays(n, c)
        }
    case "day":
        return e.setDate(r, e.getDate(n));
    case "meridiem":
        {
            const i = e.getHours(n) < 12
              , o = e.getHours(r);
            return i && o >= 12 ? e.addHours(r, -12) : !i && o < 12 ? e.addHours(r, 12) : r
        }
    case "hours":
        return e.setHours(r, e.getHours(n));
    case "minutes":
        return e.setMinutes(r, e.getMinutes(n));
    case "seconds":
        return e.setSeconds(r, e.getSeconds(n));
    default:
        return r
    }
}
  , F5 = {
    year: 1,
    month: 2,
    day: 3,
    weekDay: 4,
    hours: 5,
    minutes: 6,
    seconds: 7,
    meridiem: 8,
    empty: 9
}
  , N5 = (e, t, n, r, i) => [...n].sort( (o, a) => F5[o.type] - F5[a.type]).reduce( (o, a) => !i || a.modified ? NNe(e, a, t, o) : o, r)
  , UNe = () => navigator.userAgent.toLowerCase().includes("android")
  , VNe = (e, t) => {
    const n = {};
    if (!t)
        return e.forEach( (c, u) => {
            const f = u === 0 ? null : u - 1
              , h = u === e.length - 1 ? null : u + 1;
            n[u] = {
                leftIndex: f,
                rightIndex: h
            }
        }
        ),
        {
            neighbors: n,
            startIndex: 0,
            endIndex: e.length - 1
        };
    const r = {}
      , i = {};
    let o = 0
      , a = 0
      , s = e.length - 1;
    for (; s >= 0; ) {
        a = e.findIndex( (c, u) => u >= o && c.endSeparator?.includes(" ") && c.endSeparator !== " / "),
        a === -1 && (a = e.length - 1);
        for (let c = a; c >= o; c -= 1)
            i[c] = s,
            r[s] = c,
            s -= 1;
        o = a + 1
    }
    return e.forEach( (c, u) => {
        const f = i[u]
          , h = f === 0 ? null : r[f - 1]
          , m = f === e.length - 1 ? null : r[f + 1];
        n[u] = {
            leftIndex: h,
            rightIndex: m
        }
    }
    ),
    {
        neighbors: n,
        startIndex: r[0],
        endIndex: r[e.length - 1]
    }
}
  , K_ = (e, t) => {
    if (e == null)
        return null;
    if (e === "all")
        return "all";
    if (typeof e == "string") {
        const n = t.findIndex(r => r.type === e);
        return n === -1 ? null : n
    }
    return e
}
  , HNe = (e, t) => {
    if (e.value)
        switch (e.type) {
        case "month":
            {
                if (e.contentType === "digit")
                    return t.format(t.setMonth(t.date(), Number(e.value) - 1), "month");
                const n = t.parse(e.value, e.format);
                return n ? t.format(n, "month") : void 0
            }
        case "day":
            return e.contentType === "digit" ? t.format(t.setDate(t.startOfYear(t.date()), Number(e.value)), "dayOfMonthFull") : e.value;
        case "weekDay":
            return;
        default:
            return
        }
}
  , qNe = (e, t) => {
    if (e.value)
        switch (e.type) {
        case "weekDay":
            return e.contentType === "letter" ? void 0 : Number(e.value);
        case "meridiem":
            {
                const n = t.parse(`01:00 ${e.value}`, `${t.formats.hours12h}:${t.formats.minutes} ${e.format}`);
                return n ? t.getHours(n) >= 12 ? 1 : 0 : void 0
            }
        case "day":
            return e.contentType === "digit-with-letter" ? parseInt(e.value, 10) : Number(e.value);
        case "month":
            {
                if (e.contentType === "digit")
                    return Number(e.value);
                const n = t.parse(e.value, e.format);
                return n ? t.getMonth(n) + 1 : void 0
            }
        default:
            return e.contentType !== "letter" ? Number(e.value) : void 0
        }
}
  , WNe = ["value", "referenceDate"]
  , Ps = {
    emptyValue: null,
    getTodayValue: eG,
    getInitialReferenceValue: e => {
        let {value: t, referenceDate: n} = e
          , r = Qt(e, WNe);
        return t != null && r.utils.isValid(t) ? t : n ?? RNe(r)
    }
    ,
    cleanValue: _Ne,
    areValuesEqual: ENe,
    isSameError: (e, t) => e === t,
    hasError: e => e != null,
    defaultErrorState: null,
    getTimezone: (e, t) => t == null || !e.isValid(t) ? null : e.getTimezone(t),
    setTimezone: (e, t, n) => n == null ? null : e.setTimezone(n, t)
}
  , GNe = {
    updateReferenceValue: (e, t, n) => t == null || !e.isValid(t) ? n : t,
    getSectionsFromValue: (e, t, n, r) => !e.isValid(t) && !!n ? n : r(t),
    getV7HiddenInputValueFromSections: BNe,
    getV6InputValueFromSections: zNe,
    getActiveDateManager: (e, t) => ({
        date: t.value,
        referenceDate: t.referenceValue,
        getSections: n => n,
        getNewValuesFromNewActiveDate: n => ({
            value: n,
            referenceValue: n == null || !e.isValid(n) ? t.referenceValue : n
        })
    }),
    parseValueStr: (e, t, n) => n(e.trim(), t)
};
function YNe(e, t) {
    return Array.isArray(t) ? t.every(n => e.indexOf(n) !== -1) : e.indexOf(t) !== -1
}
const ZNe = (e, t) => n => {
    (n.key === "Enter" || n.key === " ") && (e(n),
    n.preventDefault(),
    n.stopPropagation())
}
  , uo = (e=document) => {
    const t = e.activeElement;
    return t ? t.shadowRoot ? uo(t.shadowRoot) : t : null
}
  , QNe = "@media (pointer: fine)";
function KNe(e) {
    return rt("MuiPickersDay", e)
}
const lu = ot("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"])
  , XNe = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today", "isFirstVisibleCell", "isLastVisibleCell"]
  , JNe = e => {
    const {selected: t, disableMargin: n, disableHighlightToday: r, today: i, disabled: o, outsideCurrentMonth: a, showDaysOutsideCurrentMonth: s, classes: c} = e
      , u = a && !s;
    return tt({
        root: ["root", t && !u && "selected", o && "disabled", !n && "dayWithMargin", !r && i && "today", a && s && "dayOutsideMonth", u && "hiddenDaySpacingFiller"],
        hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
    }, KNe, c)
}
  , aG = ({theme: e}) => ge({}, e.typography.caption, {
    width: xg,
    height: xg,
    borderRadius: "50%",
    padding: 0,
    backgroundColor: "transparent",
    transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.short
    }),
    color: (e.vars || e).palette.text.primary,
    "@media (pointer: fine)": {
        "&:hover": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Ts(e.palette.primary.main, e.palette.action.hoverOpacity)
        }
    },
    "&:focus": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.focusOpacity})` : Ts(e.palette.primary.main, e.palette.action.focusOpacity),
        [`&.${lu.selected}`]: {
            willChange: "background-color",
            backgroundColor: (e.vars || e).palette.primary.dark
        }
    },
    [`&.${lu.selected}`]: {
        color: (e.vars || e).palette.primary.contrastText,
        backgroundColor: (e.vars || e).palette.primary.main,
        fontWeight: e.typography.fontWeightMedium,
        "&:hover": {
            willChange: "background-color",
            backgroundColor: (e.vars || e).palette.primary.dark
        }
    },
    [`&.${lu.disabled}:not(.${lu.selected})`]: {
        color: (e.vars || e).palette.text.disabled
    },
    [`&.${lu.disabled}&.${lu.selected}`]: {
        opacity: .6
    },
    variants: [{
        props: {
            disableMargin: !1
        },
        style: {
            margin: `0 ${fS}px`
        }
    }, {
        props: {
            outsideCurrentMonth: !0,
            showDaysOutsideCurrentMonth: !0
        },
        style: {
            color: (e.vars || e).palette.text.secondary
        }
    }, {
        props: {
            disableHighlightToday: !1,
            today: !0
        },
        style: {
            [`&:not(.${lu.selected})`]: {
                border: `1px solid ${(e.vars || e).palette.text.secondary}`
            }
        }
    }]
})
  , sG = (e, t) => {
    const {ownerState: n} = e;
    return [t.root, !n.disableMargin && t.dayWithMargin, !n.disableHighlightToday && n.today && t.today, !n.outsideCurrentMonth && n.showDaysOutsideCurrentMonth && t.dayOutsideMonth, n.outsideCurrentMonth && !n.showDaysOutsideCurrentMonth && t.hiddenDaySpacingFiller]
}
  , e3e = ue(Ka, {
    name: "MuiPickersDay",
    slot: "Root",
    overridesResolver: sG
})(aG)
  , t3e = ue("div", {
    name: "MuiPickersDay",
    slot: "Root",
    overridesResolver: sG
})( ({theme: e}) => ge({}, aG({
    theme: e
}), {
    opacity: 0,
    pointerEvents: "none"
}))
  , Gp = () => {}
  , n3e = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersDay"
    })
      , {autoFocus: i=!1, className: o, day: a, disabled: s=!1, disableHighlightToday: c=!1, disableMargin: u=!1, isAnimating: f, onClick: h, onDaySelect: m, onFocus: y=Gp, onBlur: b=Gp, onKeyDown: v=Gp, onMouseDown: S=Gp, onMouseEnter: C=Gp, outsideCurrentMonth: w, selected: k=!1, showDaysOutsideCurrentMonth: T=!1, children: E, today: P=!1} = r
      , D = Qt(r, XNe)
      , $ = ge({}, r, {
        autoFocus: i,
        disabled: s,
        disableHighlightToday: c,
        disableMargin: u,
        selected: k,
        showDaysOutsideCurrentMonth: T,
        today: P
    })
      , z = JNe($)
      , O = pr()
      , I = A.useRef(null)
      , M = Cn(I, n);
    Cr( () => {
        i && !s && !f && !w && I.current.focus()
    }
    , [i, s, f, w]);
    const B = F => {
        S(F),
        w && F.preventDefault()
    }
      , L = F => {
        s || m(a),
        w && F.currentTarget.focus(),
        h && h(F)
    }
    ;
    return w && !T ? g.jsx(t3e, {
        className: Ne(z.root, z.hiddenDaySpacingFiller, o),
        ownerState: $,
        role: D.role
    }) : g.jsx(e3e, ge({
        className: Ne(z.root, o),
        ref: M,
        centerRipple: !0,
        disabled: s,
        tabIndex: k ? 0 : -1,
        onKeyDown: F => v(F, a),
        onFocus: F => y(F, a),
        onBlur: F => b(F, a),
        onMouseEnter: F => C(F, a),
        onClick: L,
        onMouseDown: B
    }, D, {
        ownerState: $,
        children: E || O.format(a, "dayOfMonth")
    }))
})
  , r3e = A.memo(n3e)
  , hy = ({props: e, value: t, timezone: n, adapter: r}) => {
    if (t === null)
        return null;
    const {shouldDisableDate: i, shouldDisableMonth: o, shouldDisableYear: a, disablePast: s, disableFuture: c} = e
      , u = r.utils.date(void 0, n)
      , f = _a(r.utils, e.minDate, r.defaultDates.minDate)
      , h = _a(r.utils, e.maxDate, r.defaultDates.maxDate);
    switch (!0) {
    case !r.utils.isValid(t):
        return "invalidDate";
    case !!(i && i(t)):
        return "shouldDisableDate";
    case !!(o && o(t)):
        return "shouldDisableMonth";
    case !!(a && a(t)):
        return "shouldDisableYear";
    case !!(c && r.utils.isAfterDay(t, u)):
        return "disableFuture";
    case !!(s && r.utils.isBeforeDay(t, u)):
        return "disablePast";
    case !!(f && r.utils.isBeforeDay(t, f)):
        return "minDate";
    case !!(h && r.utils.isAfterDay(t, h)):
        return "maxDate";
    default:
        return null
    }
}
;
hy.valueManager = Ps;
const lG = ["disablePast", "disableFuture", "minDate", "maxDate", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear"]
  , i3e = ["disablePast", "disableFuture", "minTime", "maxTime", "shouldDisableTime", "minutesStep", "ampm", "disableIgnoringDatePartForTimeValidation"]
  , o3e = ["minDateTime", "maxDateTime"]
  , a3e = [...lG, ...i3e, ...o3e]
  , cG = e => a3e.reduce( (t, n) => (e.hasOwnProperty(n) && (t[n] = e[n]),
t), {});
function uG(e) {
    const {props: t, validator: n, value: r, timezone: i, onError: o} = e
      , a = dd()
      , s = A.useRef(n.valueManager.defaultErrorState)
      , c = n({
        adapter: a,
        value: r,
        timezone: i,
        props: t
    })
      , u = n.valueManager.hasError(c);
    A.useEffect( () => {
        o && !n.valueManager.isSameError(c, s.current) && o(c, r),
        s.current = c
    }
    , [n, o, c, r]);
    const f = ft(h => n({
        adapter: a,
        value: h,
        timezone: i,
        props: t
    }));
    return {
        validationError: c,
        hasValidationError: u,
        getValidationErrorForNewValue: f
    }
}
const s3e = ({utils: e, format: t}) => {
    let n = 10
      , r = t
      , i = e.expandFormat(t);
    for (; i !== r; )
        if (r = i,
        i = e.expandFormat(r),
        n -= 1,
        n < 0)
            throw new Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");
    return i
}
  , l3e = ({utils: e, expandedFormat: t}) => {
    const n = []
      , {start: r, end: i} = e.escapedCharacters
      , o = new RegExp(`(\\${r}[^\\${i}]*\\${i})+`,"g");
    let a = null;
    for (; a = o.exec(t); )
        n.push({
            start: a.index,
            end: o.lastIndex - 1
        });
    return n
}
  , c3e = (e, t, n, r) => {
    switch (n.type) {
    case "year":
        return t.fieldYearPlaceholder({
            digitAmount: e.formatByString(e.date(void 0, "default"), r).length,
            format: r
        });
    case "month":
        return t.fieldMonthPlaceholder({
            contentType: n.contentType,
            format: r
        });
    case "day":
        return t.fieldDayPlaceholder({
            format: r
        });
    case "weekDay":
        return t.fieldWeekDayPlaceholder({
            contentType: n.contentType,
            format: r
        });
    case "hours":
        return t.fieldHoursPlaceholder({
            format: r
        });
    case "minutes":
        return t.fieldMinutesPlaceholder({
            format: r
        });
    case "seconds":
        return t.fieldSecondsPlaceholder({
            format: r
        });
    case "meridiem":
        return t.fieldMeridiemPlaceholder({
            format: r
        });
    default:
        return r
    }
}
  , u3e = ({utils: e, date: t, shouldRespectLeadingZeros: n, localeText: r, localizedDigits: i, now: o, token: a, startSeparator: s}) => {
    if (a === "")
        throw new Error("MUI X: Should not call `commitToken` with an empty token");
    const c = tG(e, a)
      , u = oG(e, c.contentType, c.type, a)
      , f = n ? u : c.contentType === "digit"
      , h = t != null && e.isValid(t);
    let m = h ? e.formatByString(t, a) : ""
      , y = null;
    if (f)
        if (u)
            y = m === "" ? e.formatByString(o, a).length : m.length;
        else {
            if (c.maxLength == null)
                throw new Error(`MUI X: The token ${a} should have a 'maxDigitNumber' property on it's adapter`);
            y = c.maxLength,
            h && (m = uP(rG(td(m, i), y), i))
        }
    return ge({}, c, {
        format: a,
        maxLength: y,
        value: m,
        placeholder: c3e(e, r, c, a),
        hasLeadingZerosInFormat: u,
        hasLeadingZerosInInput: f,
        startSeparator: s,
        endSeparator: "",
        modified: !1
    })
}
  , d3e = e => {
    const {utils: t, expandedFormat: n, escapedParts: r} = e
      , i = t.date(void 0)
      , o = [];
    let a = "";
    const s = Object.keys(t.formatTokenMap).sort( (y, b) => b.length - y.length)
      , c = /^([a-zA-Z]+)/
      , u = new RegExp(`^(${s.join("|")})*$`)
      , f = new RegExp(`^(${s.join("|")})`)
      , h = y => r.find(b => b.start <= y && b.end >= y);
    let m = 0;
    for (; m < n.length; ) {
        const y = h(m)
          , b = y != null
          , v = c.exec(n.slice(m))?.[1];
        if (!b && v != null && u.test(v)) {
            let S = v;
            for (; S.length > 0; ) {
                const C = f.exec(S)[1];
                S = S.slice(C.length),
                o.push(u3e(ge({}, e, {
                    now: i,
                    token: C,
                    startSeparator: a
                }))),
                a = ""
            }
            m += v.length
        } else {
            const S = n[m];
            b && y?.start === m || y?.end === m || (o.length === 0 ? a += S : o[o.length - 1].endSeparator += S),
            m += 1
        }
    }
    return o.length === 0 && a.length > 0 && o.push({
        type: "empty",
        contentType: "letter",
        maxLength: null,
        format: "",
        value: "",
        placeholder: "",
        hasLeadingZerosInFormat: !1,
        hasLeadingZerosInInput: !1,
        startSeparator: a,
        endSeparator: "",
        modified: !1
    }),
    o
}
  , f3e = ({isRtl: e, formatDensity: t, sections: n}) => n.map(r => {
    const i = o => {
        let a = o;
        return e && a !== null && a.includes(" ") && (a = `${a}`),
        t === "spacious" && ["/", ".", "-"].includes(a) && (a = ` ${a} `),
        a
    }
    ;
    return r.startSeparator = i(r.startSeparator),
    r.endSeparator = i(r.endSeparator),
    r
}
)
  , U5 = e => {
    let t = s3e(e);
    e.isRtl && e.enableAccessibleFieldDOMStructure && (t = t.split(" ").reverse().join(" "));
    const n = l3e(ge({}, e, {
        expandedFormat: t
    }))
      , r = d3e(ge({}, e, {
        expandedFormat: t,
        escapedParts: n
    }));
    return f3e(ge({}, e, {
        sections: r
    }))
}
  , h3e = e => {
    const t = pr()
      , n = Rl()
      , r = dd()
      , i = Si()
      , {valueManager: o, fieldValueManager: a, valueType: s, validator: c, internalProps: u, internalProps: {value: f, defaultValue: h, referenceDate: m, onChange: y, format: b, formatDensity: v="dense", selectedSections: S, onSelectedSectionsChange: C, shouldRespectLeadingZeros: w=!1, timezone: k, enableAccessibleFieldDOMStructure: T=!1}} = e
      , {timezone: E, value: P, handleValueChange: D} = lP({
        timezone: k,
        value: f,
        defaultValue: h,
        referenceDate: m,
        onChange: y,
        valueManager: o
    })
      , $ = A.useMemo( () => INe(t), [t])
      , z = A.useMemo( () => FNe(t, $, E), [t, $, E])
      , O = A.useCallback( (K, ee=null) => a.getSectionsFromValue(t, K, ee, re => U5({
        utils: t,
        localeText: n,
        localizedDigits: $,
        format: b,
        date: re,
        formatDensity: v,
        shouldRespectLeadingZeros: w,
        enableAccessibleFieldDOMStructure: T,
        isRtl: i
    })), [a, b, n, $, i, w, t, v, T])
      , [I,M] = A.useState( () => {
        const K = O(P)
          , ee = {
            sections: K,
            value: P,
            referenceValue: o.emptyValue,
            tempValueStrAndroid: null
        }
          , re = PNe(K)
          , ie = o.getInitialReferenceValue({
            referenceDate: m,
            value: P,
            utils: t,
            props: u,
            granularity: re,
            timezone: E
        });
        return ge({}, ee, {
            referenceValue: ie
        })
    }
    )
      , [B,L] = go({
        controlled: S,
        default: null,
        name: "useField",
        state: "selectedSections"
    })
      , F = K => {
        L(K),
        C?.(K)
    }
      , j = A.useMemo( () => K_(B, I.sections), [B, I.sections])
      , N = j === "all" ? 0 : j
      , H = ({value: K, referenceValue: ee, sections: re}) => {
        if (M(J => ge({}, J, {
            sections: re,
            value: K,
            referenceValue: ee,
            tempValueStrAndroid: null
        })),
        o.areValuesEqual(t, I.value, K))
            return;
        const ie = {
            validationError: c({
                adapter: r,
                value: K,
                timezone: E,
                props: u
            })
        };
        D(K, ie)
    }
      , Z = (K, ee) => {
        const re = [...I.sections];
        return re[K] = ge({}, re[K], {
            value: ee,
            modified: !0
        }),
        re
    }
      , q = () => {
        H({
            value: o.emptyValue,
            referenceValue: I.referenceValue,
            sections: O(o.emptyValue)
        })
    }
      , V = () => {
        if (N == null)
            return;
        const K = I.sections[N]
          , ee = a.getActiveDateManager(t, I, K)
          , ie = ee.getSections(I.sections).filter(xe => xe.value !== "").length === (K.value === "" ? 0 : 1)
          , J = Z(N, "")
          , oe = ie ? null : t.getInvalidDate()
          , we = ee.getNewValuesFromNewActiveDate(oe);
        H(ge({}, we, {
            sections: J
        }))
    }
      , Y = K => {
        const ee = (J, oe) => {
            const we = t.parse(J, b);
            if (we == null || !t.isValid(we))
                return null;
            const xe = U5({
                utils: t,
                localeText: n,
                localizedDigits: $,
                format: b,
                date: we,
                formatDensity: v,
                shouldRespectLeadingZeros: w,
                enableAccessibleFieldDOMStructure: T,
                isRtl: i
            });
            return N5(t, we, xe, oe, !1)
        }
          , re = a.parseValueStr(K, I.referenceValue, ee)
          , ie = a.updateReferenceValue(t, re, I.referenceValue);
        H({
            value: re,
            referenceValue: ie,
            sections: O(re, I.sections)
        })
    }
      , W = ({activeSection: K, newSectionValue: ee, shouldGoToNextSection: re}) => {
        re && N < I.sections.length - 1 && F(N + 1);
        const ie = a.getActiveDateManager(t, I, K)
          , J = Z(N, ee)
          , oe = ie.getSections(J)
          , we = jNe(t, oe, $);
        let xe, se;
        if (we != null && t.isValid(we)) {
            const de = N5(t, we, oe, ie.referenceDate, !0);
            xe = ie.getNewValuesFromNewActiveDate(de),
            se = !0
        } else
            xe = ie.getNewValuesFromNewActiveDate(we),
            se = (we != null && !t.isValid(we)) != (ie.date != null && !t.isValid(ie.date));
        return se ? H(ge({}, xe, {
            sections: J
        })) : M(de => ge({}, de, xe, {
            sections: J,
            tempValueStrAndroid: null
        }))
    }
      , te = K => M(ee => ge({}, ee, {
        tempValueStrAndroid: K
    }));
    return A.useEffect( () => {
        const K = O(I.value);
        M(ee => ge({}, ee, {
            sections: K
        }))
    }
    , [b, t.locale, i]),
    A.useEffect( () => {
        let K;
        o.areValuesEqual(t, I.value, P) ? K = o.getTimezone(t, I.value) !== o.getTimezone(t, P) : K = !0,
        K && M(ee => ge({}, ee, {
            value: P,
            referenceValue: a.updateReferenceValue(t, P, ee.referenceValue),
            sections: O(P)
        }))
    }
    , [P]),
    {
        state: I,
        activeSectionIndex: N,
        parsedSelectedSections: j,
        setSelectedSections: F,
        clearValue: q,
        clearActiveSection: V,
        updateSectionValue: W,
        updateValueFromValueStr: Y,
        setTempAndroidValueStr: te,
        getSectionsFromValue: O,
        sectionsValueBoundaries: z,
        localizedDigits: $,
        timezone: E
    }
}
  , p3e = 5e3
  , of = e => e.saveQuery != null
  , m3e = ({sections: e, updateSectionValue: t, sectionsValueBoundaries: n, localizedDigits: r, setTempAndroidValueStr: i, timezone: o}) => {
    const a = pr()
      , [s,c] = A.useState(null)
      , u = ft( () => c(null));
    A.useEffect( () => {
        s != null && e[s.sectionIndex]?.type !== s.sectionType && u()
    }
    , [e, s, u]),
    A.useEffect( () => {
        if (s != null) {
            const b = setTimeout( () => u(), p3e);
            return () => {
                clearTimeout(b)
            }
        }
        return () => {}
    }
    , [s, u]);
    const f = ({keyPressed: b, sectionIndex: v}, S, C) => {
        const w = b.toLowerCase()
          , k = e[v];
        if (s != null && (!C || C(s.value)) && s.sectionIndex === v) {
            const E = `${s.value}${w}`
              , P = S(E, k);
            if (!of(P))
                return c({
                    sectionIndex: v,
                    value: E,
                    sectionType: k.type
                }),
                P
        }
        const T = S(w, k);
        return of(T) && !T.saveQuery ? (u(),
        null) : (c({
            sectionIndex: v,
            value: w,
            sectionType: k.type
        }),
        of(T) ? null : T)
    }
      , h = b => {
        const v = (w, k, T) => {
            const E = k.filter(P => P.toLowerCase().startsWith(T));
            return E.length === 0 ? {
                saveQuery: !1
            } : {
                sectionValue: E[0],
                shouldGoToNextSection: E.length === 1
            }
        }
          , S = (w, k, T, E) => {
            const P = D => nG(a, o, k.type, D);
            if (k.contentType === "letter")
                return v(k.format, P(k.format), w);
            if (T && E != null && tG(a, T).contentType === "letter") {
                const D = P(T)
                  , $ = v(T, D, w);
                return of($) ? {
                    saveQuery: !1
                } : ge({}, $, {
                    sectionValue: E($.sectionValue, D)
                })
            }
            return {
                saveQuery: !1
            }
        }
        ;
        return f(b, (w, k) => {
            switch (k.type) {
            case "month":
                {
                    const T = E => z5(a, E, a.formats.month, k.format);
                    return S(w, k, a.formats.month, T)
                }
            case "weekDay":
                {
                    const T = (E, P) => P.indexOf(E).toString();
                    return S(w, k, a.formats.weekday, T)
                }
            case "meridiem":
                return S(w, k);
            default:
                return {
                    saveQuery: !1
                }
            }
        }
        )
    }
      , m = b => {
        const v = (C, w) => {
            const k = td(C, r)
              , T = Number(k)
              , E = n[w.type]({
                currentDate: null,
                format: w.format,
                contentType: w.contentType
            });
            if (T > E.maximum)
                return {
                    saveQuery: !1
                };
            if (T < E.minimum)
                return {
                    saveQuery: !0
                };
            const P = T * 10 > E.maximum || k.length === E.maximum.toString().length;
            return {
                sectionValue: iG(a, T, E, r, w),
                shouldGoToNextSection: P
            }
        }
        ;
        return f(b, (C, w) => {
            if (w.contentType === "digit" || w.contentType === "digit-with-letter")
                return v(C, w);
            if (w.type === "month") {
                oG(a, "digit", "month", "MM");
                const k = v(C, {
                    type: w.type,
                    format: "MM",
                    hasLeadingZerosInInput: !0,
                    contentType: "digit",
                    maxLength: 2
                });
                if (of(k))
                    return k;
                const T = z5(a, k.sectionValue, "MM", w.format);
                return ge({}, k, {
                    sectionValue: T
                })
            }
            if (w.type === "weekDay") {
                const k = v(C, w);
                if (of(k))
                    return k;
                const T = pS(a, w.format)[Number(k.sectionValue) - 1];
                return ge({}, k, {
                    sectionValue: T
                })
            }
            return {
                saveQuery: !1
            }
        }
        , C => B5(C, r))
    }
    ;
    return {
        applyCharacterEditing: ft(b => {
            const v = e[b.sectionIndex]
              , C = B5(b.keyPressed, r) ? m(ge({}, b, {
                keyPressed: uP(b.keyPressed, r)
            })) : h(b);
            if (C == null) {
                i(null);
                return
            }
            t({
                activeSection: v,
                newSectionValue: C.sectionValue,
                shouldGoToNextSection: C.shouldGoToNextSection
            })
        }
        ),
        resetCharacterQuery: u
    }
}
  , g3e = e => {
    const {internalProps: {disabled: t, readOnly: n=!1}, forwardedProps: {sectionListRef: r, onBlur: i, onClick: o, onFocus: a, onInput: s, onPaste: c, focused: u, autoFocus: f=!1}, fieldValueManager: h, applyCharacterEditing: m, resetCharacterQuery: y, setSelectedSections: b, parsedSelectedSections: v, state: S, clearActiveSection: C, clearValue: w, updateSectionValue: k, updateValueFromValueStr: T, sectionOrder: E, areAllSectionsEmpty: P, sectionsValueBoundaries: D} = e
      , $ = A.useRef(null)
      , z = Cn(r, $)
      , O = Rl()
      , I = pr()
      , M = Gi()
      , [B,L] = A.useState(!1)
      , F = A.useMemo( () => ({
        syncSelectionToDOM: () => {
            if (!$.current)
                return;
            const se = document.getSelection();
            if (!se)
                return;
            if (v == null) {
                se.rangeCount > 0 && $.current.getRoot().contains(se.getRangeAt(0).startContainer) && se.removeAllRanges(),
                B && $.current.getRoot().blur();
                return
            }
            if (!$.current.getRoot().contains(uo(document)))
                return;
            const de = new window.Range;
            let Se;
            v === "all" ? Se = $.current.getRoot() : S.sections[v].type === "empty" ? Se = $.current.getSectionContainer(v) : Se = $.current.getSectionContent(v),
            de.selectNodeContents(Se),
            Se.focus(),
            se.removeAllRanges(),
            se.addRange(de)
        }
        ,
        getActiveSectionIndexFromDOM: () => {
            const se = uo(document);
            return !se || !$.current || !$.current.getRoot().contains(se) ? null : $.current.getSectionIndexFromDOMElement(se)
        }
        ,
        focusField: (se=0) => {
            if (!$.current || F.getActiveSectionIndexFromDOM() != null)
                return;
            const de = K_(se, S.sections);
            L(!0),
            $.current.getSectionContent(de).focus()
        }
        ,
        setSelectedSections: se => {
            if (!$.current)
                return;
            const de = K_(se, S.sections);
            L((de === "all" ? 0 : de) !== null),
            b(se)
        }
        ,
        isFieldFocused: () => {
            const se = uo(document);
            return !!$.current && $.current.getRoot().contains(se)
        }
    }), [v, b, S.sections, B])
      , j = ft(se => {
        if (!$.current)
            return;
        const de = S.sections[se];
        $.current.getSectionContent(se).innerHTML = de.value || de.placeholder,
        F.syncSelectionToDOM()
    }
    )
      , N = ft( (se, ...de) => {
        se.isDefaultPrevented() || !$.current || (L(!0),
        o?.(se, ...de),
        v === "all" ? setTimeout( () => {
            const Se = document.getSelection().getRangeAt(0).startOffset;
            if (Se === 0) {
                b(E.startIndex);
                return
            }
            let Ce = 0
              , Ye = 0;
            for (; Ye < Se && Ce < S.sections.length; ) {
                const ye = S.sections[Ce];
                Ce += 1,
                Ye += `${ye.startSeparator}${ye.value || ye.placeholder}${ye.endSeparator}`.length
            }
            b(Ce - 1)
        }
        ) : B ? $.current.getRoot().contains(se.target) || b(E.startIndex) : (L(!0),
        b(E.startIndex)))
    }
    )
      , H = ft(se => {
        if (s?.(se),
        !$.current || v !== "all")
            return;
        const Se = se.target.textContent ?? "";
        $.current.getRoot().innerHTML = S.sections.map(Ce => `${Ce.startSeparator}${Ce.value || Ce.placeholder}${Ce.endSeparator}`).join(""),
        F.syncSelectionToDOM(),
        Se.length === 0 || Se.charCodeAt(0) === 10 ? (y(),
        w(),
        b("all")) : Se.length > 1 ? T(Se) : (v === "all" && b(0),
        m({
            keyPressed: Se,
            sectionIndex: 0
        }))
    }
    )
      , Z = ft(se => {
        if (c?.(se),
        n || v !== "all") {
            se.preventDefault();
            return
        }
        const de = se.clipboardData.getData("text");
        se.preventDefault(),
        y(),
        T(de)
    }
    )
      , q = ft( (...se) => {
        if (a?.(...se),
        B || !$.current)
            return;
        L(!0),
        $.current.getSectionIndexFromDOMElement(uo(document)) != null || b(E.startIndex)
    }
    )
      , V = ft( (...se) => {
        i?.(...se),
        setTimeout( () => {
            if (!$.current)
                return;
            const de = uo(document);
            !$.current.getRoot().contains(de) && (L(!1),
            b(null))
        }
        )
    }
    )
      , Y = ft(se => de => {
        de.isDefaultPrevented() || b(se)
    }
    )
      , W = ft(se => {
        se.preventDefault()
    }
    )
      , te = ft(se => () => {
        b(se)
    }
    )
      , K = ft(se => {
        if (se.preventDefault(),
        n || t || typeof v != "number")
            return;
        const de = S.sections[v]
          , Se = se.clipboardData.getData("text")
          , Ce = /^[a-zA-Z]+$/.test(Se)
          , Ye = /^[0-9]+$/.test(Se)
          , ye = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(Se);
        de.contentType === "letter" && Ce || de.contentType === "digit" && Ye || de.contentType === "digit-with-letter" && ye ? (y(),
        k({
            activeSection: de,
            newSectionValue: Se,
            shouldGoToNextSection: !0
        })) : !Ce && !Ye && (y(),
        T(Se))
    }
    )
      , ee = ft(se => {
        se.preventDefault(),
        se.dataTransfer.dropEffect = "none"
    }
    )
      , re = ft(se => {
        if (!$.current)
            return;
        const de = se.target
          , Se = de.textContent ?? ""
          , Ce = $.current.getSectionIndexFromDOMElement(de)
          , Ye = S.sections[Ce];
        if (n || !$.current) {
            j(Ce);
            return
        }
        if (Se.length === 0) {
            if (Ye.value === "") {
                j(Ce);
                return
            }
            const ye = se.nativeEvent.inputType;
            if (ye === "insertParagraph" || ye === "insertLineBreak") {
                j(Ce);
                return
            }
            y(),
            C();
            return
        }
        m({
            keyPressed: Se,
            sectionIndex: Ce
        }),
        j(Ce)
    }
    );
    Cr( () => {
        if (!(!B || !$.current)) {
            if (v === "all")
                $.current.getRoot().focus();
            else if (typeof v == "number") {
                const se = $.current.getSectionContent(v);
                se && se.focus()
            }
        }
    }
    , [v, B]);
    const ie = A.useMemo( () => S.sections.reduce( (se, de) => (se[de.type] = D[de.type]({
        currentDate: null,
        contentType: de.contentType,
        format: de.format
    }),
    se), {}), [D, S.sections])
      , J = v === "all"
      , oe = A.useMemo( () => S.sections.map( (se, de) => {
        const Se = !J && !t && !n;
        return {
            container: {
                "data-sectionindex": de,
                onClick: Y(de)
            },
            content: {
                tabIndex: J || de > 0 ? -1 : 0,
                contentEditable: !J && !t && !n,
                role: "spinbutton",
                id: `${M}-${se.type}`,
                "aria-labelledby": `${M}-${se.type}`,
                "aria-readonly": n,
                "aria-valuenow": qNe(se, I),
                "aria-valuemin": ie[se.type].minimum,
                "aria-valuemax": ie[se.type].maximum,
                "aria-valuetext": se.value ? HNe(se, I) : O.empty,
                "aria-label": O[se.type],
                "aria-disabled": t,
                spellCheck: Se ? !1 : void 0,
                autoCapitalize: Se ? "off" : void 0,
                autoCorrect: Se ? "off" : void 0,
                [parseInt(A.version, 10) >= 17 ? "enterKeyHint" : "enterkeyhint"]: Se ? "next" : void 0,
                children: se.value || se.placeholder,
                onInput: re,
                onPaste: K,
                onFocus: te(de),
                onDragOver: ee,
                onMouseUp: W,
                inputMode: se.contentType === "letter" ? "text" : "numeric"
            },
            before: {
                children: se.startSeparator
            },
            after: {
                children: se.endSeparator
            }
        }
    }
    ), [S.sections, te, K, ee, re, Y, W, t, n, J, O, I, ie, M])
      , we = ft(se => {
        T(se.target.value)
    }
    )
      , xe = A.useMemo( () => P ? "" : h.getV7HiddenInputValueFromSections(S.sections), [P, S.sections, h]);
    return A.useEffect( () => {
        if ($.current == null)
            throw new Error(["MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`", "You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.", "", "If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:", "", "<DatePicker slots={{ textField: MyCustomTextField }} />", "", "Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element"].join(`
`));
        f && $.current && $.current.getSectionContent(E.startIndex).focus()
    }
    , []),
    {
        interactions: F,
        returnedValue: {
            autoFocus: f,
            readOnly: n,
            focused: u ?? B,
            sectionListRef: z,
            onBlur: V,
            onClick: N,
            onFocus: q,
            onInput: H,
            onPaste: Z,
            enableAccessibleFieldDOMStructure: !0,
            elements: oe,
            tabIndex: v === 0 ? -1 : 0,
            contentEditable: J,
            value: xe,
            onChange: we,
            areAllSectionsEmpty: P
        }
    }
}
  , gf = e => e.replace(/[\u2066\u2067\u2068\u2069]/g, "")
  , y3e = (e, t, n) => {
    let r = 0
      , i = n ? 1 : 0;
    const o = [];
    for (let a = 0; a < e.length; a += 1) {
        const s = e[a]
          , c = dP(s, n ? "input-rtl" : "input-ltr", t)
          , u = `${s.startSeparator}${c}${s.endSeparator}`
          , f = gf(u).length
          , h = u.length
          , m = gf(c)
          , y = i + (m === "" ? 0 : c.indexOf(m[0])) + s.startSeparator.length
          , b = y + m.length;
        o.push(ge({}, s, {
            start: r,
            end: r + f,
            startInInput: y,
            endInInput: b
        })),
        r += f,
        i += h
    }
    return o
}
  , b3e = e => {
    const t = Si()
      , n = A.useRef(void 0)
      , r = A.useRef(void 0)
      , {forwardedProps: {onFocus: i, onClick: o, onPaste: a, onBlur: s, inputRef: c, placeholder: u}, internalProps: {readOnly: f=!1, disabled: h=!1}, parsedSelectedSections: m, activeSectionIndex: y, state: b, fieldValueManager: v, valueManager: S, applyCharacterEditing: C, resetCharacterQuery: w, updateSectionValue: k, updateValueFromValueStr: T, clearActiveSection: E, clearValue: P, setTempAndroidValueStr: D, setSelectedSections: $, getSectionsFromValue: z, areAllSectionsEmpty: O, localizedDigits: I} = e
      , M = A.useRef(null)
      , B = Cn(c, M)
      , L = A.useMemo( () => y3e(b.sections, I, t), [b.sections, I, t])
      , F = A.useMemo( () => ({
        syncSelectionToDOM: () => {
            if (!M.current)
                return;
            if (m == null) {
                M.current.scrollLeft && (M.current.scrollLeft = 0);
                return
            }
            if (M.current !== uo(document))
                return;
            const re = M.current.scrollTop;
            if (m === "all")
                M.current.select();
            else {
                const ie = L[m]
                  , J = ie.type === "empty" ? ie.startInInput - ie.startSeparator.length : ie.startInInput
                  , oe = ie.type === "empty" ? ie.endInInput + ie.endSeparator.length : ie.endInInput;
                (J !== M.current.selectionStart || oe !== M.current.selectionEnd) && M.current === uo(document) && M.current.setSelectionRange(J, oe),
                clearTimeout(r.current),
                r.current = setTimeout( () => {
                    M.current && M.current === uo(document) && M.current.selectionStart === M.current.selectionEnd && (M.current.selectionStart !== J || M.current.selectionEnd !== oe) && F.syncSelectionToDOM()
                }
                )
            }
            M.current.scrollTop = re
        }
        ,
        getActiveSectionIndexFromDOM: () => {
            const re = M.current.selectionStart ?? 0
              , ie = M.current.selectionEnd ?? 0;
            if (re === 0 && ie === 0)
                return null;
            const J = re <= L[0].startInInput ? 1 : L.findIndex(oe => oe.startInInput - oe.startSeparator.length > re);
            return J === -1 ? L.length - 1 : J - 1
        }
        ,
        focusField: (re=0) => {
            uo(document) !== M.current && (M.current?.focus(),
            $(re))
        }
        ,
        setSelectedSections: re => $(re),
        isFieldFocused: () => M.current === uo(document)
    }), [M, m, L, $])
      , j = () => {
        const re = M.current.selectionStart ?? 0;
        let ie;
        re <= L[0].startInInput || re >= L[L.length - 1].endInInput ? ie = 1 : ie = L.findIndex(oe => oe.startInInput - oe.startSeparator.length > re);
        const J = ie === -1 ? L.length - 1 : ie - 1;
        $(J)
    }
      , N = ft( (...re) => {
        i?.(...re);
        const ie = M.current;
        clearTimeout(n.current),
        n.current = setTimeout( () => {
            !ie || ie !== M.current || y == null && (ie.value.length && Number(ie.selectionEnd) - Number(ie.selectionStart) === ie.value.length ? $("all") : j())
        }
        )
    }
    )
      , H = ft( (re, ...ie) => {
        re.isDefaultPrevented() || (o?.(re, ...ie),
        j())
    }
    )
      , Z = ft(re => {
        if (a?.(re),
        re.preventDefault(),
        f || h)
            return;
        const ie = re.clipboardData.getData("text");
        if (typeof m == "number") {
            const J = b.sections[m]
              , oe = /^[a-zA-Z]+$/.test(ie)
              , we = /^[0-9]+$/.test(ie)
              , xe = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(ie);
            if (J.contentType === "letter" && oe || J.contentType === "digit" && we || J.contentType === "digit-with-letter" && xe) {
                w(),
                k({
                    activeSection: J,
                    newSectionValue: ie,
                    shouldGoToNextSection: !0
                });
                return
            }
            if (oe || we)
                return
        }
        w(),
        T(ie)
    }
    )
      , q = ft( (...re) => {
        s?.(...re),
        $(null)
    }
    )
      , V = ft(re => {
        if (f)
            return;
        const ie = re.target.value;
        if (ie === "") {
            w(),
            P();
            return
        }
        const J = re.nativeEvent.data
          , oe = J && J.length > 1
          , we = oe ? J : ie
          , xe = gf(we);
        if (m === "all" && $(y),
        y == null || oe) {
            T(oe ? J : xe);
            return
        }
        let se;
        if (m === "all" && xe.length === 1)
            se = xe;
        else {
            const de = gf(v.getV6InputValueFromSections(L, I, t));
            let Se = -1
              , Ce = -1;
            for (let X = 0; X < de.length; X += 1)
                Se === -1 && de[X] !== xe[X] && (Se = X),
                Ce === -1 && de[de.length - X - 1] !== xe[xe.length - X - 1] && (Ce = X);
            const Ye = L[y];
            if (Se < Ye.start || de.length - Ce - 1 > Ye.end)
                return;
            const Ke = xe.length - de.length + Ye.end - gf(Ye.endSeparator || "").length;
            se = xe.slice(Ye.start + gf(Ye.startSeparator || "").length, Ke)
        }
        if (se.length === 0) {
            UNe() && D(we),
            w(),
            E();
            return
        }
        C({
            keyPressed: se,
            sectionIndex: y
        })
    }
    )
      , Y = A.useMemo( () => u !== void 0 ? u : v.getV6InputValueFromSections(z(S.emptyValue), I, t), [u, v, z, S.emptyValue, I, t])
      , W = A.useMemo( () => b.tempValueStrAndroid ?? v.getV6InputValueFromSections(b.sections, I, t), [b.sections, v, b.tempValueStrAndroid, I, t]);
    A.useEffect( () => (M.current && M.current === uo(document) && $("all"),
    () => {
        clearTimeout(n.current),
        clearTimeout(r.current)
    }
    ), []);
    const te = A.useMemo( () => y == null || b.sections[y].contentType === "letter" ? "text" : "numeric", [y, b.sections])
      , ee = !(M.current && M.current === uo(document)) && O;
    return {
        interactions: F,
        returnedValue: {
            readOnly: f,
            onBlur: q,
            onClick: H,
            onFocus: N,
            onPaste: Z,
            inputRef: B,
            enableAccessibleFieldDOMStructure: !1,
            placeholder: Y,
            inputMode: te,
            autoComplete: "off",
            value: ee ? "" : W,
            onChange: V
        }
    }
}
  , x3e = e => {
    const t = pr()
      , {internalProps: n, internalProps: {unstableFieldRef: r, minutesStep: i, enableAccessibleFieldDOMStructure: o=!1, disabled: a=!1, readOnly: s=!1}, forwardedProps: {onKeyDown: c, error: u, clearable: f, onClear: h}, fieldValueManager: m, valueManager: y, validator: b} = e
      , v = Si()
      , S = h3e(e)
      , {state: C, activeSectionIndex: w, parsedSelectedSections: k, setSelectedSections: T, clearValue: E, clearActiveSection: P, updateSectionValue: D, setTempAndroidValueStr: $, sectionsValueBoundaries: z, localizedDigits: O, timezone: I} = S
      , M = m3e({
        sections: C.sections,
        updateSectionValue: D,
        sectionsValueBoundaries: z,
        localizedDigits: O,
        setTempAndroidValueStr: $,
        timezone: I
    })
      , {resetCharacterQuery: B} = M
      , L = y.areValuesEqual(t, C.value, y.emptyValue)
      , F = o ? g3e : b3e
      , j = A.useMemo( () => VNe(C.sections, v && !o), [C.sections, v, o])
      , {returnedValue: N, interactions: H} = F(ge({}, e, S, M, {
        areAllSectionsEmpty: L,
        sectionOrder: j
    }))
      , Z = ft(K => {
        if (c?.(K),
        !a)
            switch (!0) {
            case ((K.ctrlKey || K.metaKey) && String.fromCharCode(K.keyCode) === "A" && !K.shiftKey && !K.altKey):
                {
                    K.preventDefault(),
                    T("all");
                    break
                }
            case K.key === "ArrowRight":
                {
                    if (K.preventDefault(),
                    k == null)
                        T(j.startIndex);
                    else if (k === "all")
                        T(j.endIndex);
                    else {
                        const ee = j.neighbors[k].rightIndex;
                        ee !== null && T(ee)
                    }
                    break
                }
            case K.key === "ArrowLeft":
                {
                    if (K.preventDefault(),
                    k == null)
                        T(j.endIndex);
                    else if (k === "all")
                        T(j.startIndex);
                    else {
                        const ee = j.neighbors[k].leftIndex;
                        ee !== null && T(ee)
                    }
                    break
                }
            case K.key === "Delete":
                {
                    if (K.preventDefault(),
                    s)
                        break;
                    k == null || k === "all" ? E() : P(),
                    B();
                    break
                }
            case ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(K.key):
                {
                    if (K.preventDefault(),
                    s || w == null)
                        break;
                    k === "all" && T(w);
                    const ee = C.sections[w]
                      , re = m.getActiveDateManager(t, C, ee)
                      , ie = $Ne(t, I, ee, K.key, z, O, re.date, {
                        minutesStep: i
                    });
                    D({
                        activeSection: ee,
                        newSectionValue: ie,
                        shouldGoToNextSection: !1
                    });
                    break
                }
            }
    }
    );
    Cr( () => {
        H.syncSelectionToDOM()
    }
    );
    const {hasValidationError: q} = uG({
        props: n,
        validator: b,
        timezone: I,
        value: C.value,
        onError: n.onError
    })
      , V = A.useMemo( () => u !== void 0 ? u : q, [q, u]);
    A.useEffect( () => {
        !V && w == null && B()
    }
    , [C.referenceValue, w, V]),
    A.useEffect( () => {
        C.tempValueStrAndroid != null && w != null && (B(),
        P())
    }
    , [C.sections]),
    A.useImperativeHandle(r, () => ({
        getSections: () => C.sections,
        getActiveSectionIndex: H.getActiveSectionIndexFromDOM,
        setSelectedSections: H.setSelectedSections,
        focusField: H.focusField,
        isFieldFocused: H.isFieldFocused
    }));
    const Y = ft( (K, ...ee) => {
        K.preventDefault(),
        h?.(K, ...ee),
        E(),
        H.isFieldFocused() ? T(j.startIndex) : H.focusField(0)
    }
    )
      , W = {
        onKeyDown: Z,
        onClear: Y,
        error: V,
        clearable: !!(f && !L && !s && !a)
    }
      , te = {
        disabled: a,
        readOnly: s
    };
    return ge({}, e.forwardedProps, W, te, N)
}
  , v3e = ["clearable", "onClear", "InputProps", "sx", "slots", "slotProps"]
  , S3e = ["ownerState"]
  , C3e = e => {
    const t = Rl()
      , {clearable: n, onClear: r, InputProps: i, sx: o, slots: a, slotProps: s} = e
      , c = Qt(e, v3e)
      , u = a?.clearButton ?? In
      , f = _n({
        elementType: u,
        externalSlotProps: s?.clearButton,
        ownerState: {},
        className: "clearButton",
        additionalProps: {
            title: t.fieldClearLabel
        }
    })
      , h = Qt(f, S3e)
      , m = a?.clearIcon ?? cNe
      , y = _n({
        elementType: m,
        externalSlotProps: s?.clearIcon,
        ownerState: {}
    });
    return ge({}, c, {
        InputProps: ge({}, i, {
            endAdornment: g.jsxs(A.Fragment, {
                children: [n && g.jsx(v0, {
                    position: "end",
                    sx: {
                        marginRight: i?.endAdornment ? -1 : -1.5
                    },
                    children: g.jsx(u, ge({}, h, {
                        onClick: r,
                        children: g.jsx(m, ge({
                            fontSize: "small"
                        }, y))
                    }))
                }), i?.endAdornment]
            })
        }),
        sx: [{
            "& .clearButton": {
                opacity: 1
            },
            "@media (pointer: fine)": {
                "& .clearButton": {
                    opacity: 0
                },
                "&:hover, &:focus-within": {
                    ".clearButton": {
                        opacity: 1
                    }
                }
            }
        }, ...Array.isArray(o) ? o : [o]]
    })
}
  , w3e = ["value", "defaultValue", "referenceDate", "format", "formatDensity", "onChange", "timezone", "onError", "shouldRespectLeadingZeros", "selectedSections", "onSelectedSectionsChange", "unstableFieldRef", "enableAccessibleFieldDOMStructure", "disabled", "readOnly", "dateSeparator"]
  , k3e = (e, t) => A.useMemo( () => {
    const n = ge({}, e)
      , r = {}
      , i = o => {
        n.hasOwnProperty(o) && (r[o] = n[o],
        delete n[o])
    }
    ;
    return w3e.forEach(i),
    lG.forEach(i),
    {
        forwardedProps: n,
        internalProps: r
    }
}
, [e, t])
  , T3e = A.createContext(null);
function dG(e) {
    const {contextValue: t, localeText: n, children: r} = e;
    return g.jsx(T3e.Provider, {
        value: t,
        children: g.jsx(Q7, {
            localeText: n,
            children: r
        })
    })
}
const _3e = e => {
    const t = pr()
      , n = fy();
    return ge({}, e, {
        disablePast: e.disablePast ?? !1,
        disableFuture: e.disableFuture ?? !1,
        format: e.format ?? t.formats.keyboardDate,
        minDate: _a(t, e.minDate, n.minDate),
        maxDate: _a(t, e.maxDate, n.maxDate)
    })
}
  , E3e = e => {
    const t = _3e(e)
      , {forwardedProps: n, internalProps: r} = k3e(t, "date");
    return x3e({
        forwardedProps: n,
        internalProps: r,
        valueManager: Ps,
        fieldValueManager: GNe,
        validator: hy,
        valueType: "date"
    })
}
;
function A3e(e) {
    return rt("MuiPickersTextField", e)
}
ot("MuiPickersTextField", ["root", "focused", "disabled", "error", "required"]);
function M3e(e) {
    return rt("MuiPickersInputBase", e)
}
const Mf = ot("MuiPickersInputBase", ["root", "focused", "disabled", "error", "notchedOutline", "sectionContent", "sectionBefore", "sectionAfter", "adornedStart", "adornedEnd", "input"]);
function P3e(e) {
    return rt("MuiPickersSectionList", e)
}
const Yp = ot("MuiPickersSectionList", ["root", "section", "sectionContent"])
  , R3e = ["slots", "slotProps", "elements", "sectionListRef"]
  , fG = ue("div", {
    name: "MuiPickersSectionList",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    direction: "ltr /*! @noflip */",
    outline: "none"
})
  , hG = ue("span", {
    name: "MuiPickersSectionList",
    slot: "Section",
    overridesResolver: (e, t) => t.section
})({})
  , pG = ue("span", {
    name: "MuiPickersSectionList",
    slot: "SectionSeparator",
    overridesResolver: (e, t) => t.sectionSeparator
})({
    whiteSpace: "pre"
})
  , mG = ue("span", {
    name: "MuiPickersSectionList",
    slot: "SectionContent",
    overridesResolver: (e, t) => t.sectionContent
})({
    outline: "none"
})
  , D3e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        section: ["section"],
        sectionContent: ["sectionContent"]
    }, P3e, t)
}
;
function O3e(e) {
    const {slots: t, slotProps: n, element: r, classes: i} = e
      , o = t?.section ?? hG
      , a = _n({
        elementType: o,
        externalSlotProps: n?.section,
        externalForwardedProps: r.container,
        className: i.section,
        ownerState: {}
    })
      , s = t?.sectionContent ?? mG
      , c = _n({
        elementType: s,
        externalSlotProps: n?.sectionContent,
        externalForwardedProps: r.content,
        additionalProps: {
            suppressContentEditableWarning: !0
        },
        className: i.sectionContent,
        ownerState: {}
    })
      , u = t?.sectionSeparator ?? pG
      , f = _n({
        elementType: u,
        externalSlotProps: n?.sectionSeparator,
        externalForwardedProps: r.before,
        ownerState: {
            position: "before"
        }
    })
      , h = _n({
        elementType: u,
        externalSlotProps: n?.sectionSeparator,
        externalForwardedProps: r.after,
        ownerState: {
            position: "after"
        }
    });
    return g.jsxs(o, ge({}, a, {
        children: [g.jsx(u, ge({}, f)), g.jsx(s, ge({}, c)), g.jsx(u, ge({}, h))]
    }))
}
const I3e = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersSectionList"
    })
      , {slots: i, slotProps: o, elements: a, sectionListRef: s} = r
      , c = Qt(r, R3e)
      , u = D3e(r)
      , f = A.useRef(null)
      , h = Cn(n, f)
      , m = v => {
        if (!f.current)
            throw new Error(`MUI X: Cannot call sectionListRef.${v} before the mount of the component.`);
        return f.current
    }
    ;
    A.useImperativeHandle(s, () => ({
        getRoot() {
            return m("getRoot")
        },
        getSectionContainer(v) {
            return m("getSectionContainer").querySelector(`.${Yp.section}[data-sectionindex="${v}"]`)
        },
        getSectionContent(v) {
            return m("getSectionContent").querySelector(`.${Yp.section}[data-sectionindex="${v}"] .${Yp.sectionContent}`)
        },
        getSectionIndexFromDOMElement(v) {
            const S = m("getSectionIndexFromDOMElement");
            if (v == null || !S.contains(v))
                return null;
            let C = null;
            return v.classList.contains(Yp.section) ? C = v : v.classList.contains(Yp.sectionContent) && (C = v.parentElement),
            C == null ? null : Number(C.dataset.sectionindex)
        }
    }));
    const y = i?.root ?? fG
      , b = _n({
        elementType: y,
        externalSlotProps: o?.root,
        externalForwardedProps: c,
        additionalProps: {
            ref: h,
            suppressContentEditableWarning: !0
        },
        className: u.root,
        ownerState: {}
    });
    return g.jsx(y, ge({}, b, {
        children: b.contentEditable ? a.map( ({content: v, before: S, after: C}) => `${S.children}${v.children}${C.children}`).join("") : g.jsx(A.Fragment, {
            children: a.map( (v, S) => g.jsx(O3e, {
                slots: i,
                slotProps: o,
                element: v,
                classes: u
            }, S))
        })
    }))
})
  , $3e = ["elements", "areAllSectionsEmpty", "defaultValue", "label", "value", "onChange", "id", "autoFocus", "endAdornment", "startAdornment", "renderSuffix", "slots", "slotProps", "contentEditable", "tabIndex", "onInput", "onPaste", "onKeyDown", "fullWidth", "name", "readOnly", "inputProps", "inputRef", "sectionListRef"]
  , L3e = e => Math.round(e * 1e5) / 1e5
  , mS = ue("div", {
    name: "MuiPickersInputBase",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})( ({theme: e}) => ge({}, e.typography.body1, {
    color: (e.vars || e).palette.text.primary,
    cursor: "text",
    padding: 0,
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    boxSizing: "border-box",
    letterSpacing: `${L3e(.15 / 16)}em`,
    variants: [{
        props: {
            fullWidth: !0
        },
        style: {
            width: "100%"
        }
    }]
}))
  , fP = ue(fG, {
    name: "MuiPickersInputBase",
    slot: "SectionsContainer",
    overridesResolver: (e, t) => t.sectionsContainer
})( ({theme: e}) => ({
    padding: "4px 0 5px",
    fontFamily: e.typography.fontFamily,
    fontSize: "inherit",
    lineHeight: "1.4375em",
    flexGrow: 1,
    outline: "none",
    display: "flex",
    flexWrap: "nowrap",
    overflow: "hidden",
    letterSpacing: "inherit",
    width: "182px",
    variants: [{
        props: {
            isRtl: !0
        },
        style: {
            textAlign: "right /*! @noflip */"
        }
    }, {
        props: {
            size: "small"
        },
        style: {
            paddingTop: 1
        }
    }, {
        props: {
            adornedStart: !1,
            focused: !1,
            filled: !1
        },
        style: {
            color: "currentColor",
            opacity: 0
        }
    }, {
        props: ({adornedStart: t, focused: n, filled: r, label: i}) => !t && !n && !r && i == null,
        style: e.vars ? {
            opacity: e.vars.opacity.inputPlaceholder
        } : {
            opacity: e.palette.mode === "light" ? .42 : .5
        }
    }]
}))
  , j3e = ue(hG, {
    name: "MuiPickersInputBase",
    slot: "Section",
    overridesResolver: (e, t) => t.section
})( ({theme: e}) => ({
    fontFamily: e.typography.fontFamily,
    fontSize: "inherit",
    letterSpacing: "inherit",
    lineHeight: "1.4375em",
    display: "inline-block",
    whiteSpace: "nowrap"
}))
  , B3e = ue(mG, {
    name: "MuiPickersInputBase",
    slot: "SectionContent",
    overridesResolver: (e, t) => t.content
})( ({theme: e}) => ({
    fontFamily: e.typography.fontFamily,
    lineHeight: "1.4375em",
    letterSpacing: "inherit",
    width: "fit-content",
    outline: "none"
}))
  , z3e = ue(pG, {
    name: "MuiPickersInputBase",
    slot: "Separator",
    overridesResolver: (e, t) => t.separator
})( () => ({
    whiteSpace: "pre",
    letterSpacing: "inherit"
}))
  , F3e = ue("input", {
    name: "MuiPickersInputBase",
    slot: "Input",
    overridesResolver: (e, t) => t.hiddenInput
})(ge({}, Lce))
  , N3e = e => {
    const {focused: t, disabled: n, error: r, classes: i, fullWidth: o, readOnly: a, color: s, size: c, endAdornment: u, startAdornment: f} = e
      , h = {
        root: ["root", t && !n && "focused", n && "disabled", a && "readOnly", r && "error", o && "fullWidth", `color${Te(s)}`, c === "small" && "inputSizeSmall", !!f && "adornedStart", !!u && "adornedEnd"],
        notchedOutline: ["notchedOutline"],
        input: ["input"],
        sectionsContainer: ["sectionsContainer"],
        sectionContent: ["sectionContent"],
        sectionBefore: ["sectionBefore"],
        sectionAfter: ["sectionAfter"]
    };
    return tt(h, M3e, i)
}
  , hP = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersInputBase"
    })
      , {elements: i, areAllSectionsEmpty: o, value: a, onChange: s, id: c, endAdornment: u, startAdornment: f, renderSuffix: h, slots: m, slotProps: y, contentEditable: b, tabIndex: v, onInput: S, onPaste: C, onKeyDown: w, name: k, readOnly: T, inputProps: E, inputRef: P, sectionListRef: D} = r
      , $ = Qt(r, $3e)
      , z = A.useRef(null)
      , O = Cn(n, z)
      , I = Cn(E?.ref, P)
      , M = Si()
      , B = To();
    if (!B)
        throw new Error("MUI X: PickersInputBase should always be used inside a PickersTextField component");
    const L = q => {
        if (B.disabled) {
            q.stopPropagation();
            return
        }
        B.onFocus?.(q)
    }
    ;
    A.useEffect( () => {
        B && B.setAdornedStart(!!f)
    }
    , [B, f]),
    A.useEffect( () => {
        B && (o ? B.onEmpty() : B.onFilled())
    }
    , [B, o]);
    const F = ge({}, r, B, {
        isRtl: M
    })
      , j = N3e(F)
      , N = m?.root || mS
      , H = _n({
        elementType: N,
        externalSlotProps: y?.root,
        externalForwardedProps: $,
        additionalProps: {
            "aria-invalid": B.error,
            ref: O
        },
        className: j.root,
        ownerState: F
    })
      , Z = m?.input || fP;
    return g.jsxs(N, ge({}, H, {
        children: [f, g.jsx(I3e, {
            sectionListRef: D,
            elements: i,
            contentEditable: b,
            tabIndex: v,
            className: j.sectionsContainer,
            onFocus: L,
            onBlur: B.onBlur,
            onInput: S,
            onPaste: C,
            onKeyDown: w,
            slots: {
                root: Z,
                section: j3e,
                sectionContent: B3e,
                sectionSeparator: z3e
            },
            slotProps: {
                root: {
                    ownerState: F
                },
                sectionContent: {
                    className: Mf.sectionContent
                },
                sectionSeparator: ({position: q}) => ({
                    className: q === "before" ? Mf.sectionBefore : Mf.sectionAfter
                })
            }
        }), u, h ? h(ge({}, B)) : null, g.jsx(F3e, ge({
            name: k,
            className: j.input,
            value: a,
            onChange: s,
            id: c,
            "aria-hidden": "true",
            tabIndex: -1,
            readOnly: T,
            required: B.required,
            disabled: B.disabled
        }, E, {
            ref: I
        }))]
    }))
});
function U3e(e) {
    return rt("MuiPickersOutlinedInput", e)
}
const Ia = ge({}, Mf, ot("MuiPickersOutlinedInput", ["root", "notchedOutline", "input"]))
  , V3e = ["children", "className", "label", "notched", "shrink"]
  , H3e = ue("fieldset", {
    name: "MuiPickersOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (e, t) => t.notchedOutline
})( ({theme: e}) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
        textAlign: "left",
        position: "absolute",
        bottom: 0,
        right: 0,
        top: -5,
        left: 0,
        margin: 0,
        padding: "0 8px",
        pointerEvents: "none",
        borderRadius: "inherit",
        borderStyle: "solid",
        borderWidth: 1,
        overflow: "hidden",
        minWidth: "0%",
        borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
    }
}
)
  , V5 = ue("span")( ({theme: e}) => ({
    fontFamily: e.typography.fontFamily,
    fontSize: "inherit"
}))
  , q3e = ue("legend")( ({theme: e}) => ({
    float: "unset",
    width: "auto",
    overflow: "hidden",
    variants: [{
        props: {
            withLabel: !1
        },
        style: {
            padding: 0,
            lineHeight: "11px",
            transition: e.transitions.create("width", {
                duration: 150,
                easing: e.transitions.easing.easeOut
            })
        }
    }, {
        props: {
            withLabel: !0
        },
        style: {
            display: "block",
            padding: 0,
            height: 11,
            fontSize: "0.75em",
            visibility: "hidden",
            maxWidth: .01,
            transition: e.transitions.create("max-width", {
                duration: 50,
                easing: e.transitions.easing.easeOut
            }),
            whiteSpace: "nowrap",
            "& > span": {
                paddingLeft: 5,
                paddingRight: 5,
                display: "inline-block",
                opacity: 0,
                visibility: "visible"
            }
        }
    }, {
        props: {
            withLabel: !0,
            notched: !0
        },
        style: {
            maxWidth: "100%",
            transition: e.transitions.create("max-width", {
                duration: 100,
                easing: e.transitions.easing.easeOut,
                delay: 50
            })
        }
    }]
}));
function W3e(e) {
    const {className: t, label: n} = e
      , r = Qt(e, V3e)
      , i = n != null && n !== ""
      , o = ge({}, e, {
        withLabel: i
    });
    return g.jsx(H3e, ge({
        "aria-hidden": !0,
        className: t
    }, r, {
        ownerState: o,
        children: g.jsx(q3e, {
            ownerState: o,
            children: i ? g.jsx(V5, {
                children: n
            }) : g.jsx(V5, {
                className: "notranslate",
                children: ""
            })
        })
    }))
}
const G3e = ["label", "autoFocus", "ownerState", "notched"]
  , Y3e = ue(mS, {
    name: "MuiPickersOutlinedInput",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})( ({theme: e}) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
        padding: "0 14px",
        borderRadius: (e.vars || e).shape.borderRadius,
        [`&:hover .${Ia.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.text.primary
        },
        "@media (hover: none)": {
            [`&:hover .${Ia.notchedOutline}`]: {
                borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
            }
        },
        [`&.${Ia.focused} .${Ia.notchedOutline}`]: {
            borderStyle: "solid",
            borderWidth: 2
        },
        [`&.${Ia.disabled}`]: {
            [`& .${Ia.notchedOutline}`]: {
                borderColor: (e.vars || e).palette.action.disabled
            },
            "*": {
                color: (e.vars || e).palette.action.disabled
            }
        },
        [`&.${Ia.error} .${Ia.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.error.main
        },
        variants: Object.keys((e.vars ?? e).palette).filter(n => (e.vars ?? e).palette[n]?.main ?? !1).map(n => ({
            props: {
                color: n
            },
            style: {
                [`&.${Ia.focused}:not(.${Ia.error}) .${Ia.notchedOutline}`]: {
                    borderColor: (e.vars || e).palette[n].main
                }
            }
        }))
    }
}
)
  , Z3e = ue(fP, {
    name: "MuiPickersOutlinedInput",
    slot: "SectionsContainer",
    overridesResolver: (e, t) => t.sectionsContainer
})({
    padding: "16.5px 0",
    variants: [{
        props: {
            size: "small"
        },
        style: {
            padding: "8.5px 0"
        }
    }]
})
  , Q3e = e => {
    const {classes: t} = e
      , r = tt({
        root: ["root"],
        notchedOutline: ["notchedOutline"],
        input: ["input"]
    }, U3e, t);
    return ge({}, t, r)
}
  , gG = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersOutlinedInput"
    })
      , {label: i, ownerState: o, notched: a} = r
      , s = Qt(r, G3e)
      , c = To()
      , u = ge({}, r, o, c, {
        color: c?.color || "primary"
    })
      , f = Q3e(u);
    return g.jsx(hP, ge({
        slots: {
            root: Y3e,
            input: Z3e
        },
        renderSuffix: h => g.jsx(W3e, {
            shrink: !!(a || h.adornedStart || h.focused || h.filled),
            notched: !!(a || h.adornedStart || h.focused || h.filled),
            className: f.notchedOutline,
            label: i != null && i !== "" && c?.required ? g.jsxs(A.Fragment, {
                children: [i, "", "*"]
            }) : i,
            ownerState: u
        })
    }, s, {
        label: i,
        classes: f,
        ref: n
    }))
});
gG.muiName = "Input";
function K3e(e) {
    return rt("MuiPickersFilledInput", e)
}
const cu = ge({}, Mf, ot("MuiPickersFilledInput", ["root", "underline", "input"]))
  , X3e = ["label", "autoFocus", "disableUnderline", "ownerState"]
  , J3e = ue(mS, {
    name: "MuiPickersFilledInput",
    slot: "Root",
    overridesResolver: (e, t) => t.root,
    shouldForwardProp: e => _x(e) && e !== "disableUnderline"
})( ({theme: e}) => {
    const t = e.palette.mode === "light"
      , n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)"
      , r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)"
      , i = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)"
      , o = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
        borderTopLeftRadius: (e.vars || e).shape.borderRadius,
        borderTopRightRadius: (e.vars || e).shape.borderRadius,
        transition: e.transitions.create("background-color", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
        }),
        "&:hover": {
            backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : i,
            "@media (hover: none)": {
                backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
            }
        },
        [`&.${cu.focused}`]: {
            backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
        },
        [`&.${cu.disabled}`]: {
            backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : o
        },
        variants: [...Object.keys((e.vars ?? e).palette).filter(a => (e.vars ?? e).palette[a].main).map(a => ({
            props: {
                color: a,
                disableUnderline: !1
            },
            style: {
                "&::after": {
                    borderBottom: `2px solid ${(e.vars || e).palette[a]?.main}`
                }
            }
        })), {
            props: {
                disableUnderline: !1
            },
            style: {
                "&::after": {
                    left: 0,
                    bottom: 0,
                    content: '""',
                    position: "absolute",
                    right: 0,
                    transform: "scaleX(0)",
                    transition: e.transitions.create("transform", {
                        duration: e.transitions.duration.shorter,
                        easing: e.transitions.easing.easeOut
                    }),
                    pointerEvents: "none"
                },
                [`&.${cu.focused}:after`]: {
                    transform: "scaleX(1) translateX(0)"
                },
                [`&.${cu.error}`]: {
                    "&:before, &:after": {
                        borderBottomColor: (e.vars || e).palette.error.main
                    }
                },
                "&::before": {
                    borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : n}`,
                    left: 0,
                    bottom: 0,
                    content: '"\\00a0"',
                    position: "absolute",
                    right: 0,
                    transition: e.transitions.create("border-bottom-color", {
                        duration: e.transitions.duration.shorter
                    }),
                    pointerEvents: "none"
                },
                [`&:hover:not(.${cu.disabled}, .${cu.error}):before`]: {
                    borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
                },
                [`&.${cu.disabled}:before`]: {
                    borderBottomStyle: "dotted"
                }
            }
        }, {
            props: ({startAdornment: a}) => !!a,
            style: {
                paddingLeft: 12
            }
        }, {
            props: ({endAdornment: a}) => !!a,
            style: {
                paddingRight: 12
            }
        }]
    }
}
)
  , e4e = ue(fP, {
    name: "MuiPickersFilledInput",
    slot: "sectionsContainer",
    overridesResolver: (e, t) => t.sectionsContainer
})({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12,
    variants: [{
        props: {
            size: "small"
        },
        style: {
            paddingTop: 21,
            paddingBottom: 4
        }
    }, {
        props: ({startAdornment: e}) => !!e,
        style: {
            paddingLeft: 0
        }
    }, {
        props: ({endAdornment: e}) => !!e,
        style: {
            paddingRight: 0
        }
    }, {
        props: {
            hiddenLabel: !0
        },
        style: {
            paddingTop: 16,
            paddingBottom: 17
        }
    }, {
        props: {
            hiddenLabel: !0,
            size: "small"
        },
        style: {
            paddingTop: 8,
            paddingBottom: 9
        }
    }]
})
  , t4e = e => {
    const {classes: t, disableUnderline: n} = e
      , i = tt({
        root: ["root", !n && "underline"],
        input: ["input"]
    }, K3e, t);
    return ge({}, t, i)
}
  , yG = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersFilledInput"
    })
      , {label: i, disableUnderline: o=!1, ownerState: a} = r
      , s = Qt(r, X3e)
      , c = To()
      , u = ge({}, r, a, c, {
        color: c?.color || "primary"
    })
      , f = t4e(u);
    return g.jsx(hP, ge({
        slots: {
            root: J3e,
            input: e4e
        },
        slotProps: {
            root: {
                disableUnderline: o
            }
        }
    }, s, {
        label: i,
        classes: f,
        ref: n
    }))
});
yG.muiName = "Input";
function n4e(e) {
    return rt("MuiPickersFilledInput", e)
}
const Zp = ge({}, Mf, ot("MuiPickersInput", ["root", "input"]))
  , r4e = ["label", "autoFocus", "disableUnderline", "ownerState"]
  , i4e = ue(mS, {
    name: "MuiPickersInput",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})( ({theme: e}) => {
    let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    return e.vars && (n = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`),
    {
        "label + &": {
            marginTop: 16
        },
        variants: [...Object.keys((e.vars ?? e).palette).filter(r => (e.vars ?? e).palette[r].main).map(r => ({
            props: {
                color: r
            },
            style: {
                "&::after": {
                    borderBottom: `2px solid ${(e.vars || e).palette[r].main}`
                }
            }
        })), {
            props: {
                disableUnderline: !1
            },
            style: {
                "&::after": {
                    background: "red",
                    left: 0,
                    bottom: 0,
                    content: '""',
                    position: "absolute",
                    right: 0,
                    transform: "scaleX(0)",
                    transition: e.transitions.create("transform", {
                        duration: e.transitions.duration.shorter,
                        easing: e.transitions.easing.easeOut
                    }),
                    pointerEvents: "none"
                },
                [`&.${Zp.focused}:after`]: {
                    transform: "scaleX(1) translateX(0)"
                },
                [`&.${Zp.error}`]: {
                    "&:before, &:after": {
                        borderBottomColor: (e.vars || e).palette.error.main
                    }
                },
                "&::before": {
                    borderBottom: `1px solid ${n}`,
                    left: 0,
                    bottom: 0,
                    content: '"\\00a0"',
                    position: "absolute",
                    right: 0,
                    transition: e.transitions.create("border-bottom-color", {
                        duration: e.transitions.duration.shorter
                    }),
                    pointerEvents: "none"
                },
                [`&:hover:not(.${Zp.disabled}, .${Zp.error}):before`]: {
                    borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
                    "@media (hover: none)": {
                        borderBottom: `1px solid ${n}`
                    }
                },
                [`&.${Zp.disabled}:before`]: {
                    borderBottomStyle: "dotted"
                }
            }
        }]
    }
}
)
  , o4e = e => {
    const {classes: t, disableUnderline: n} = e
      , i = tt({
        root: ["root", !n && "underline"],
        input: ["input"]
    }, n4e, t);
    return ge({}, t, i)
}
  , bG = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersInput"
    })
      , {label: i, disableUnderline: o=!1, ownerState: a} = r
      , s = Qt(r, r4e)
      , c = To()
      , u = ge({}, r, a, c, {
        disableUnderline: o,
        color: c?.color || "primary"
    })
      , f = o4e(u);
    return g.jsx(hP, ge({
        slots: {
            root: i4e
        }
    }, s, {
        label: i,
        classes: f,
        ref: n
    }))
});
bG.muiName = "Input";
const a4e = ["onFocus", "onBlur", "className", "color", "disabled", "error", "variant", "required", "InputProps", "inputProps", "inputRef", "sectionListRef", "elements", "areAllSectionsEmpty", "onClick", "onKeyDown", "onKeyUp", "onPaste", "onInput", "endAdornment", "startAdornment", "tabIndex", "contentEditable", "focused", "value", "onChange", "fullWidth", "id", "name", "helperText", "FormHelperTextProps", "label", "InputLabelProps"]
  , s4e = {
    standard: bG,
    filled: yG,
    outlined: gG
}
  , l4e = ue(x0, {
    name: "MuiPickersTextField",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    maxWidth: "100%"
})
  , c4e = e => {
    const {focused: t, disabled: n, classes: r, required: i} = e;
    return tt({
        root: ["root", t && !n && "focused", n && "disabled", i && "required"]
    }, A3e, r)
}
  , u4e = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersTextField"
    })
      , {onFocus: i, onBlur: o, className: a, color: s="primary", disabled: c=!1, error: u=!1, variant: f="outlined", required: h=!1, InputProps: m, inputProps: y, inputRef: b, sectionListRef: v, elements: S, areAllSectionsEmpty: C, onClick: w, onKeyDown: k, onKeyUp: T, onPaste: E, onInput: P, endAdornment: D, startAdornment: $, tabIndex: z, contentEditable: O, focused: I, value: M, onChange: B, fullWidth: L, id: F, name: j, helperText: N, FormHelperTextProps: H, label: Z, InputLabelProps: q} = r
      , V = Qt(r, a4e)
      , Y = A.useRef(null)
      , W = Cn(n, Y)
      , te = Gi(F)
      , K = N && te ? `${te}-helper-text` : void 0
      , ee = Z && te ? `${te}-label` : void 0
      , re = ge({}, r, {
        color: s,
        disabled: c,
        error: u,
        focused: I,
        required: h,
        variant: f
    })
      , ie = c4e(re)
      , J = s4e[f];
    return g.jsxs(l4e, ge({
        className: Ne(ie.root, a),
        ref: W,
        focused: I,
        onFocus: i,
        onBlur: o,
        disabled: c,
        variant: f,
        error: u,
        color: s,
        fullWidth: L,
        required: h,
        ownerState: re
    }, V, {
        children: [g.jsx(S0, ge({
            htmlFor: te,
            id: ee
        }, q, {
            children: Z
        })), g.jsx(J, ge({
            elements: S,
            areAllSectionsEmpty: C,
            onClick: w,
            onKeyDown: k,
            onKeyUp: T,
            onInput: P,
            onPaste: E,
            endAdornment: D,
            startAdornment: $,
            tabIndex: z,
            contentEditable: O,
            value: M,
            onChange: B,
            id: te,
            fullWidth: L,
            inputProps: y,
            inputRef: b,
            sectionListRef: v,
            label: Z,
            name: j,
            role: "group",
            "aria-labelledby": ee,
            "aria-describedby": K,
            "aria-live": K ? "polite" : void 0
        }, m)), N && g.jsx(e3, ge({
            id: K
        }, H, {
            children: N
        }))]
    }))
})
  , d4e = ["enableAccessibleFieldDOMStructure"]
  , f4e = ["InputProps", "readOnly"]
  , h4e = ["onPaste", "onKeyDown", "inputMode", "readOnly", "InputProps", "inputProps", "inputRef"]
  , p4e = e => {
    let {enableAccessibleFieldDOMStructure: t} = e
      , n = Qt(e, d4e);
    if (t) {
        const {InputProps: h, readOnly: m} = n
          , y = Qt(n, f4e);
        return ge({}, y, {
            InputProps: ge({}, h ?? {}, {
                readOnly: m
            })
        })
    }
    const {onPaste: r, onKeyDown: i, inputMode: o, readOnly: a, InputProps: s, inputProps: c, inputRef: u} = n
      , f = Qt(n, h4e);
    return ge({}, f, {
        InputProps: ge({}, s ?? {}, {
            readOnly: a
        }),
        inputProps: ge({}, c ?? {}, {
            inputMode: o,
            onPaste: r,
            onKeyDown: i,
            ref: u
        })
    })
}
  , m4e = ["slots", "slotProps", "InputProps", "inputProps"]
  , xG = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiDateField"
    })
      , {slots: i, slotProps: o, InputProps: a, inputProps: s} = r
      , c = Qt(r, m4e)
      , u = r
      , f = i?.textField ?? (t.enableAccessibleFieldDOMStructure ? u4e : ct)
      , h = _n({
        elementType: f,
        externalSlotProps: o?.textField,
        externalForwardedProps: c,
        additionalProps: {
            ref: n
        },
        ownerState: u
    });
    h.inputProps = ge({}, s, h.inputProps),
    h.InputProps = ge({}, a, h.InputProps);
    const m = E3e(h)
      , y = p4e(m)
      , b = C3e(ge({}, y, {
        slots: i,
        slotProps: o
    }));
    return g.jsx(f, ge({}, b))
})
  , vG = ({shouldDisableDate: e, shouldDisableMonth: t, shouldDisableYear: n, minDate: r, maxDate: i, disableFuture: o, disablePast: a, timezone: s}) => {
    const c = dd();
    return A.useCallback(u => hy({
        adapter: c,
        value: u,
        timezone: s,
        props: {
            shouldDisableDate: e,
            shouldDisableMonth: t,
            shouldDisableYear: n,
            minDate: r,
            maxDate: i,
            disableFuture: o,
            disablePast: a
        }
    }) !== null, [c, e, t, n, r, i, o, a, s])
}
  , g4e = (e, t, n) => (r, i) => {
    switch (i.type) {
    case "changeMonth":
        return ge({}, r, {
            slideDirection: i.direction,
            currentMonth: i.newMonth,
            isMonthSwitchingAnimating: !e
        });
    case "changeMonthTimezone":
        {
            const o = i.newTimezone;
            if (n.getTimezone(r.currentMonth) === o)
                return r;
            let a = n.setTimezone(r.currentMonth, o);
            return n.getMonth(a) !== n.getMonth(r.currentMonth) && (a = n.setMonth(a, n.getMonth(r.currentMonth))),
            ge({}, r, {
                currentMonth: a
            })
        }
    case "finishMonthSwitchingAnimation":
        return ge({}, r, {
            isMonthSwitchingAnimating: !1
        });
    case "changeFocusedDay":
        {
            if (r.focusedDay != null && i.focusedDay != null && n.isSameDay(i.focusedDay, r.focusedDay))
                return r;
            const o = i.focusedDay != null && !t && !n.isSameMonth(r.currentMonth, i.focusedDay);
            return ge({}, r, {
                focusedDay: i.focusedDay,
                isMonthSwitchingAnimating: o && !e && !i.withoutMonthSwitchingAnimation,
                currentMonth: o ? n.startOfMonth(i.focusedDay) : r.currentMonth,
                slideDirection: i.focusedDay != null && n.isAfterDay(i.focusedDay, r.currentMonth) ? "left" : "right"
            })
        }
    default:
        throw new Error("missing support")
    }
}
  , y4e = e => {
    const {value: t, referenceDate: n, disableFuture: r, disablePast: i, disableSwitchToMonthOnDayFocus: o=!1, maxDate: a, minDate: s, onMonthChange: c, reduceAnimations: u, shouldDisableDate: f, timezone: h} = e
      , m = pr()
      , y = A.useRef(g4e(!!u, o, m)).current
      , b = A.useMemo( () => Ps.getInitialReferenceValue({
        value: t,
        utils: m,
        timezone: h,
        props: e,
        referenceDate: n,
        granularity: xs.day
    }), [n, h])
      , [v,S] = A.useReducer(y, {
        isMonthSwitchingAnimating: !1,
        focusedDay: b,
        currentMonth: m.startOfMonth(b),
        slideDirection: "left"
    });
    A.useEffect( () => {
        S({
            type: "changeMonthTimezone",
            newTimezone: m.getTimezone(b)
        })
    }
    , [b, m]);
    const C = A.useCallback(P => {
        S(ge({
            type: "changeMonth"
        }, P)),
        c && c(P.newMonth)
    }
    , [c])
      , w = A.useCallback(P => {
        const D = P;
        m.isSameMonth(D, v.currentMonth) || C({
            newMonth: m.startOfMonth(D),
            direction: m.isAfterDay(D, v.currentMonth) ? "left" : "right"
        })
    }
    , [v.currentMonth, C, m])
      , k = vG({
        shouldDisableDate: f,
        minDate: s,
        maxDate: a,
        disableFuture: r,
        disablePast: i,
        timezone: h
    })
      , T = A.useCallback( () => {
        S({
            type: "finishMonthSwitchingAnimation"
        })
    }
    , [])
      , E = ft( (P, D) => {
        k(P) || S({
            type: "changeFocusedDay",
            focusedDay: P,
            withoutMonthSwitchingAnimation: D
        })
    }
    );
    return {
        referenceDate: b,
        calendarState: v,
        changeMonth: w,
        changeFocusedDay: E,
        isDateDisabled: k,
        onMonthSwitchingAnimationEnd: T,
        handleChangeMonth: C
    }
}
  , b4e = e => rt("MuiPickersFadeTransitionGroup", e);
ot("MuiPickersFadeTransitionGroup", ["root"]);
const x4e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, b4e, t)
}
  , v4e = ue(Dg, {
    name: "MuiPickersFadeTransitionGroup",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "block",
    position: "relative"
});
function SG(e) {
    const t = hr({
        props: e,
        name: "MuiPickersFadeTransitionGroup"
    })
      , {children: n, className: r, reduceAnimations: i, transKey: o} = t
      , a = x4e(t)
      , s = ko();
    return i ? n : g.jsx(v4e, {
        className: Ne(a.root, r),
        children: g.jsx(vc, {
            appear: !1,
            mountOnEnter: !0,
            unmountOnExit: !0,
            timeout: {
                appear: s.transitions.duration.enteringScreen,
                enter: s.transitions.duration.enteringScreen,
                exit: 0
            },
            children: n
        }, o)
    })
}
const S4e = e => rt("MuiPickersSlideTransition", e)
  , da = ot("MuiPickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"])
  , C4e = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"]
  , w4e = e => {
    const {classes: t, slideDirection: n} = e
      , r = {
        root: ["root"],
        exit: ["slideExit"],
        enterActive: ["slideEnterActive"],
        enter: [`slideEnter-${n}`],
        exitActive: [`slideExitActiveLeft-${n}`]
    };
    return tt(r, S4e, t)
}
  , k4e = ue(Dg, {
    name: "MuiPickersSlideTransition",
    slot: "Root",
    overridesResolver: (e, t) => [t.root, {
        [`.${da["slideEnter-left"]}`]: t["slideEnter-left"]
    }, {
        [`.${da["slideEnter-right"]}`]: t["slideEnter-right"]
    }, {
        [`.${da.slideEnterActive}`]: t.slideEnterActive
    }, {
        [`.${da.slideExit}`]: t.slideExit
    }, {
        [`.${da["slideExitActiveLeft-left"]}`]: t["slideExitActiveLeft-left"]
    }, {
        [`.${da["slideExitActiveLeft-right"]}`]: t["slideExitActiveLeft-right"]
    }]
})( ({theme: e}) => {
    const t = e.transitions.create("transform", {
        duration: e.transitions.duration.complex,
        easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
    });
    return {
        display: "block",
        position: "relative",
        overflowX: "hidden",
        "& > *": {
            position: "absolute",
            top: 0,
            right: 0,
            left: 0
        },
        [`& .${da["slideEnter-left"]}`]: {
            willChange: "transform",
            transform: "translate(100%)",
            zIndex: 1
        },
        [`& .${da["slideEnter-right"]}`]: {
            willChange: "transform",
            transform: "translate(-100%)",
            zIndex: 1
        },
        [`& .${da.slideEnterActive}`]: {
            transform: "translate(0%)",
            transition: t
        },
        [`& .${da.slideExit}`]: {
            transform: "translate(0%)"
        },
        [`& .${da["slideExitActiveLeft-left"]}`]: {
            willChange: "transform",
            transform: "translate(-100%)",
            transition: t,
            zIndex: 0
        },
        [`& .${da["slideExitActiveLeft-right"]}`]: {
            willChange: "transform",
            transform: "translate(100%)",
            transition: t,
            zIndex: 0
        }
    }
}
);
function T4e(e) {
    const t = hr({
        props: e,
        name: "MuiPickersSlideTransition"
    })
      , {children: n, className: r, reduceAnimations: i, transKey: o} = t
      , a = Qt(t, C4e)
      , s = w4e(t)
      , c = ko();
    if (i)
        return g.jsx("div", {
            className: Ne(s.root, r),
            children: n
        });
    const u = {
        exit: s.exit,
        enterActive: s.enterActive,
        enter: s.enter,
        exitActive: s.exitActive
    };
    return g.jsx(k4e, {
        className: Ne(s.root, r),
        childFactory: f => A.cloneElement(f, {
            classNames: u
        }),
        role: "presentation",
        children: g.jsx(AE, ge({
            mountOnEnter: !0,
            unmountOnExit: !0,
            timeout: c.transitions.duration.complex,
            classNames: u
        }, a, {
            children: n
        }), o)
    })
}
const _4e = e => rt("MuiDayCalendar", e);
ot("MuiDayCalendar", ["root", "header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer", "weekNumberLabel", "weekNumber"]);
const E4e = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"]
  , A4e = ["ownerState"]
  , M4e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        header: ["header"],
        weekDayLabel: ["weekDayLabel"],
        loadingContainer: ["loadingContainer"],
        slideTransition: ["slideTransition"],
        monthContainer: ["monthContainer"],
        weekContainer: ["weekContainer"],
        weekNumberLabel: ["weekNumberLabel"],
        weekNumber: ["weekNumber"]
    }, _4e, t)
}
  , CG = (xg + fS * 2) * 6
  , P4e = ue("div", {
    name: "MuiDayCalendar",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({})
  , R4e = ue("div", {
    name: "MuiDayCalendar",
    slot: "Header",
    overridesResolver: (e, t) => t.header
})({
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
})
  , D4e = ue(Ae, {
    name: "MuiDayCalendar",
    slot: "WeekDayLabel",
    overridesResolver: (e, t) => t.weekDayLabel
})( ({theme: e}) => ({
    width: 36,
    height: 40,
    margin: "0 2px",
    textAlign: "center",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    color: (e.vars || e).palette.text.secondary
}))
  , O4e = ue(Ae, {
    name: "MuiDayCalendar",
    slot: "WeekNumberLabel",
    overridesResolver: (e, t) => t.weekNumberLabel
})( ({theme: e}) => ({
    width: 36,
    height: 40,
    margin: "0 2px",
    textAlign: "center",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    color: e.palette.text.disabled
}))
  , I4e = ue(Ae, {
    name: "MuiDayCalendar",
    slot: "WeekNumber",
    overridesResolver: (e, t) => t.weekNumber
})( ({theme: e}) => ge({}, e.typography.caption, {
    width: xg,
    height: xg,
    padding: 0,
    margin: `0 ${fS}px`,
    color: e.palette.text.disabled,
    fontSize: "0.75rem",
    alignItems: "center",
    justifyContent: "center",
    display: "inline-flex"
}))
  , $4e = ue("div", {
    name: "MuiDayCalendar",
    slot: "LoadingContainer",
    overridesResolver: (e, t) => t.loadingContainer
})({
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    minHeight: CG
})
  , L4e = ue(T4e, {
    name: "MuiDayCalendar",
    slot: "SlideTransition",
    overridesResolver: (e, t) => t.slideTransition
})({
    minHeight: CG
})
  , j4e = ue("div", {
    name: "MuiDayCalendar",
    slot: "MonthContainer",
    overridesResolver: (e, t) => t.monthContainer
})({
    overflow: "hidden"
})
  , B4e = ue("div", {
    name: "MuiDayCalendar",
    slot: "WeekContainer",
    overridesResolver: (e, t) => t.weekContainer
})({
    margin: `${fS}px 0`,
    display: "flex",
    justifyContent: "center"
});
function z4e(e) {
    let {parentProps: t, day: n, focusableDay: r, selectedDays: i, isDateDisabled: o, currentMonthNumber: a, isViewFocused: s} = e
      , c = Qt(e, E4e);
    const {disabled: u, disableHighlightToday: f, isMonthSwitchingAnimating: h, showDaysOutsideCurrentMonth: m, slots: y, slotProps: b, timezone: v} = t
      , S = pr()
      , C = dS(v)
      , w = r !== null && S.isSameDay(n, r)
      , k = i.some(M => S.isSameDay(M, n))
      , T = S.isSameDay(n, C)
      , E = y?.day ?? r3e
      , P = _n({
        elementType: E,
        externalSlotProps: b?.day,
        additionalProps: ge({
            disableHighlightToday: f,
            showDaysOutsideCurrentMonth: m,
            role: "gridcell",
            isAnimating: h,
            "data-timestamp": S.toJsDate(n).valueOf()
        }, c),
        ownerState: ge({}, t, {
            day: n,
            selected: k
        })
    })
      , D = Qt(P, A4e)
      , $ = A.useMemo( () => u || o(n), [u, o, n])
      , z = A.useMemo( () => S.getMonth(n) !== a, [S, n, a])
      , O = A.useMemo( () => {
        const M = S.startOfMonth(S.setMonth(n, a));
        return m ? S.isSameDay(n, S.startOfWeek(M)) : S.isSameDay(n, M)
    }
    , [a, n, m, S])
      , I = A.useMemo( () => {
        const M = S.endOfMonth(S.setMonth(n, a));
        return m ? S.isSameDay(n, S.endOfWeek(M)) : S.isSameDay(n, M)
    }
    , [a, n, m, S]);
    return g.jsx(E, ge({}, D, {
        day: n,
        disabled: $,
        autoFocus: s && w,
        today: T,
        outsideCurrentMonth: z,
        isFirstVisibleCell: O,
        isLastVisibleCell: I,
        selected: k,
        tabIndex: w ? 0 : -1,
        "aria-selected": k,
        "aria-current": T ? "date" : void 0
    }))
}
function F4e(e) {
    const t = hr({
        props: e,
        name: "MuiDayCalendar"
    })
      , n = pr()
      , {onFocusedDayChange: r, className: i, currentMonth: o, selectedDays: a, focusedDay: s, loading: c, onSelectedDaysChange: u, onMonthSwitchingAnimationEnd: f, readOnly: h, reduceAnimations: m, renderLoading: y= () => g.jsx("span", {
        children: "..."
    }), slideDirection: b, TransitionProps: v, disablePast: S, disableFuture: C, minDate: w, maxDate: k, shouldDisableDate: T, shouldDisableMonth: E, shouldDisableYear: P, dayOfWeekFormatter: D=Ce => n.format(Ce, "weekdayShort").charAt(0).toUpperCase(), hasFocus: $, onFocusedViewChange: z, gridLabelId: O, displayWeekNumber: I, fixedWeekNumber: M, autoFocus: B, timezone: L} = t
      , F = dS(L)
      , j = M4e(t)
      , N = Si()
      , H = vG({
        shouldDisableDate: T,
        shouldDisableMonth: E,
        shouldDisableYear: P,
        minDate: w,
        maxDate: k,
        disablePast: S,
        disableFuture: C,
        timezone: L
    })
      , Z = Rl()
      , [q,V] = go({
        name: "DayCalendar",
        state: "hasFocus",
        controlled: $,
        default: B ?? !1
    })
      , [Y,W] = A.useState( () => s || F)
      , te = ft(Ce => {
        h || u(Ce)
    }
    )
      , K = Ce => {
        H(Ce) || (r(Ce),
        W(Ce),
        z?.(!0),
        V(!0))
    }
      , ee = ft( (Ce, Ye) => {
        switch (Ce.key) {
        case "ArrowUp":
            K(n.addDays(Ye, -7)),
            Ce.preventDefault();
            break;
        case "ArrowDown":
            K(n.addDays(Ye, 7)),
            Ce.preventDefault();
            break;
        case "ArrowLeft":
            {
                const ye = n.addDays(Ye, N ? 1 : -1)
                  , Ke = n.addMonths(Ye, N ? 1 : -1)
                  , X = Lm({
                    utils: n,
                    date: ye,
                    minDate: N ? ye : n.startOfMonth(Ke),
                    maxDate: N ? n.endOfMonth(Ke) : ye,
                    isDateDisabled: H,
                    timezone: L
                });
                K(X || ye),
                Ce.preventDefault();
                break
            }
        case "ArrowRight":
            {
                const ye = n.addDays(Ye, N ? -1 : 1)
                  , Ke = n.addMonths(Ye, N ? -1 : 1)
                  , X = Lm({
                    utils: n,
                    date: ye,
                    minDate: N ? n.startOfMonth(Ke) : ye,
                    maxDate: N ? ye : n.endOfMonth(Ke),
                    isDateDisabled: H,
                    timezone: L
                });
                K(X || ye),
                Ce.preventDefault();
                break
            }
        case "Home":
            K(n.startOfWeek(Ye)),
            Ce.preventDefault();
            break;
        case "End":
            K(n.endOfWeek(Ye)),
            Ce.preventDefault();
            break;
        case "PageUp":
            K(n.addMonths(Ye, 1)),
            Ce.preventDefault();
            break;
        case "PageDown":
            K(n.addMonths(Ye, -1)),
            Ce.preventDefault();
            break
        }
    }
    )
      , re = ft( (Ce, Ye) => K(Ye))
      , ie = ft( (Ce, Ye) => {
        q && n.isSameDay(Y, Ye) && z?.(!1)
    }
    )
      , J = n.getMonth(o)
      , oe = n.getYear(o)
      , we = A.useMemo( () => a.filter(Ce => !!Ce).map(Ce => n.startOfDay(Ce)), [n, a])
      , xe = `${oe}-${J}`
      , se = A.useMemo( () => A.createRef(), [xe])
      , de = A.useMemo( () => {
        const Ce = n.startOfMonth(o)
          , Ye = n.endOfMonth(o);
        return H(Y) || n.isAfterDay(Y, Ye) || n.isBeforeDay(Y, Ce) ? Lm({
            utils: n,
            date: Y,
            minDate: Ce,
            maxDate: Ye,
            disablePast: S,
            disableFuture: C,
            isDateDisabled: H,
            timezone: L
        }) : Y
    }
    , [o, C, S, Y, H, n, L])
      , Se = A.useMemo( () => {
        const Ce = n.getWeekArray(o);
        let Ye = n.addMonths(o, 1);
        for (; M && Ce.length < M; ) {
            const ye = n.getWeekArray(Ye)
              , Ke = n.isSameDay(Ce[Ce.length - 1][0], ye[0][0]);
            ye.slice(Ke ? 1 : 0).forEach(X => {
                Ce.length < M && Ce.push(X)
            }
            ),
            Ye = n.addMonths(Ye, 1)
        }
        return Ce
    }
    , [o, M, n]);
    return g.jsxs(P4e, {
        role: "grid",
        "aria-labelledby": O,
        className: j.root,
        children: [g.jsxs(R4e, {
            role: "row",
            className: j.header,
            children: [I && g.jsx(O4e, {
                variant: "caption",
                role: "columnheader",
                "aria-label": Z.calendarWeekNumberHeaderLabel,
                className: j.weekNumberLabel,
                children: Z.calendarWeekNumberHeaderText
            }), MNe(n, F).map( (Ce, Ye) => g.jsx(D4e, {
                variant: "caption",
                role: "columnheader",
                "aria-label": n.format(Ce, "weekday"),
                className: j.weekDayLabel,
                children: D(Ce)
            }, Ye.toString()))]
        }), c ? g.jsx($4e, {
            className: j.loadingContainer,
            children: y()
        }) : g.jsx(L4e, ge({
            transKey: xe,
            onExited: f,
            reduceAnimations: m,
            slideDirection: b,
            className: Ne(i, j.slideTransition)
        }, v, {
            nodeRef: se,
            children: g.jsx(j4e, {
                ref: se,
                role: "rowgroup",
                className: j.monthContainer,
                children: Se.map( (Ce, Ye) => g.jsxs(B4e, {
                    role: "row",
                    className: j.weekContainer,
                    "aria-rowindex": Ye + 1,
                    children: [I && g.jsx(I4e, {
                        className: j.weekNumber,
                        role: "rowheader",
                        "aria-label": Z.calendarWeekNumberAriaLabelText(n.getWeekNumber(Ce[0])),
                        children: Z.calendarWeekNumberText(n.getWeekNumber(Ce[0]))
                    }), Ce.map( (ye, Ke) => g.jsx(z4e, {
                        parentProps: t,
                        day: ye,
                        selectedDays: we,
                        focusableDay: de,
                        onKeyDown: ee,
                        onFocus: re,
                        onBlur: ie,
                        onDaySelect: te,
                        isDateDisabled: H,
                        currentMonthNumber: J,
                        isViewFocused: q,
                        "aria-colindex": Ke + 1
                    }, ye.toString()))]
                }, `week-${Ce[0]}`))
            })
        }))]
    })
}
function N4e(e) {
    return rt("MuiPickersMonth", e)
}
const bx = ot("MuiPickersMonth", ["root", "monthButton", "disabled", "selected"])
  , U4e = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "aria-label", "monthsPerRow", "slots", "slotProps"]
  , V4e = e => {
    const {disabled: t, selected: n, classes: r} = e;
    return tt({
        root: ["root"],
        monthButton: ["monthButton", t && "disabled", n && "selected"]
    }, N4e, r)
}
  , H4e = ue("div", {
    name: "MuiPickersMonth",
    slot: "Root",
    overridesResolver: (e, t) => [t.root]
})({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexBasis: "33.3%",
    variants: [{
        props: {
            monthsPerRow: 4
        },
        style: {
            flexBasis: "25%"
        }
    }]
})
  , q4e = ue("button", {
    name: "MuiPickersMonth",
    slot: "MonthButton",
    overridesResolver: (e, t) => [t.monthButton, {
        [`&.${bx.disabled}`]: t.disabled
    }, {
        [`&.${bx.selected}`]: t.selected
    }]
})( ({theme: e}) => ge({
    color: "unset",
    backgroundColor: "transparent",
    border: 0,
    outline: 0
}, e.typography.subtitle1, {
    margin: "8px 0",
    height: 36,
    width: 72,
    borderRadius: 18,
    cursor: "pointer",
    "&:focus": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Ts(e.palette.action.active, e.palette.action.hoverOpacity)
    },
    "&:hover": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Ts(e.palette.action.active, e.palette.action.hoverOpacity)
    },
    "&:disabled": {
        cursor: "auto",
        pointerEvents: "none"
    },
    [`&.${bx.disabled}`]: {
        color: (e.vars || e).palette.text.secondary
    },
    [`&.${bx.selected}`]: {
        color: (e.vars || e).palette.primary.contrastText,
        backgroundColor: (e.vars || e).palette.primary.main,
        "&:focus, &:hover": {
            backgroundColor: (e.vars || e).palette.primary.dark
        }
    }
}))
  , W4e = A.memo(function(t) {
    const n = hr({
        props: t,
        name: "MuiPickersMonth"
    })
      , {autoFocus: r, className: i, children: o, disabled: a, selected: s, value: c, tabIndex: u, onClick: f, onKeyDown: h, onFocus: m, onBlur: y, "aria-current": b, "aria-label": v, slots: S, slotProps: C} = n
      , w = Qt(n, U4e)
      , k = A.useRef(null)
      , T = V4e(n);
    Cr( () => {
        r && k.current?.focus()
    }
    , [r]);
    const E = S?.monthButton ?? q4e
      , P = _n({
        elementType: E,
        externalSlotProps: C?.monthButton,
        additionalProps: {
            children: o,
            disabled: a,
            tabIndex: u,
            ref: k,
            type: "button",
            role: "radio",
            "aria-current": b,
            "aria-checked": s,
            "aria-label": v,
            onClick: D => f(D, c),
            onKeyDown: D => h(D, c),
            onFocus: D => m(D, c),
            onBlur: D => y(D, c)
        },
        ownerState: n,
        className: T.monthButton
    });
    return g.jsx(H4e, ge({
        className: Ne(T.root, i),
        ownerState: n
    }, w, {
        children: g.jsx(E, ge({}, P))
    }))
});
function G4e(e) {
    return rt("MuiMonthCalendar", e)
}
ot("MuiMonthCalendar", ["root"]);
const Y4e = ["className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow", "timezone", "gridLabelId", "slots", "slotProps"]
  , Z4e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, G4e, t)
}
;
function Q4e(e, t) {
    const n = pr()
      , r = fy()
      , i = hr({
        props: e,
        name: t
    });
    return ge({
        disableFuture: !1,
        disablePast: !1
    }, i, {
        minDate: _a(n, i.minDate, r.minDate),
        maxDate: _a(n, i.maxDate, r.maxDate)
    })
}
const K4e = ue("div", {
    name: "MuiMonthCalendar",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "flex",
    flexWrap: "wrap",
    alignContent: "stretch",
    padding: "0 4px",
    width: hS,
    boxSizing: "border-box"
})
  , X4e = A.forwardRef(function(t, n) {
    const r = Q4e(t, "MuiMonthCalendar")
      , {className: i, value: o, defaultValue: a, referenceDate: s, disabled: c, disableFuture: u, disablePast: f, maxDate: h, minDate: m, onChange: y, shouldDisableMonth: b, readOnly: v, autoFocus: S=!1, onMonthFocus: C, hasFocus: w, onFocusedViewChange: k, monthsPerRow: T=3, timezone: E, gridLabelId: P, slots: D, slotProps: $} = r
      , z = Qt(r, Y4e)
      , {value: O, handleValueChange: I, timezone: M} = cP({
        name: "MonthCalendar",
        timezone: E,
        value: o,
        defaultValue: a,
        referenceDate: s,
        onChange: y,
        valueManager: Ps
    })
      , B = dS(M)
      , L = Si()
      , F = pr()
      , j = A.useMemo( () => Ps.getInitialReferenceValue({
        value: O,
        utils: F,
        props: r,
        timezone: M,
        referenceDate: s,
        granularity: xs.month
    }), [])
      , N = r
      , H = Z4e(N)
      , Z = A.useMemo( () => F.getMonth(B), [F, B])
      , q = A.useMemo( () => O != null ? F.getMonth(O) : null, [O, F])
      , [V,Y] = A.useState( () => q || F.getMonth(j))
      , [W,te] = go({
        name: "MonthCalendar",
        state: "hasFocus",
        controlled: w,
        default: S ?? !1
    })
      , K = ft(xe => {
        te(xe),
        k && k(xe)
    }
    )
      , ee = A.useCallback(xe => {
        const se = F.startOfMonth(f && F.isAfter(B, m) ? B : m)
          , de = F.startOfMonth(u && F.isBefore(B, h) ? B : h)
          , Se = F.startOfMonth(xe);
        return F.isBefore(Se, se) || F.isAfter(Se, de) ? !0 : b ? b(Se) : !1
    }
    , [u, f, h, m, B, b, F])
      , re = ft( (xe, se) => {
        if (v)
            return;
        const de = F.setMonth(O ?? j, se);
        I(de)
    }
    )
      , ie = ft(xe => {
        ee(F.setMonth(O ?? j, xe)) || (Y(xe),
        K(!0),
        C && C(xe))
    }
    );
    A.useEffect( () => {
        Y(xe => q !== null && xe !== q ? q : xe)
    }
    , [q]);
    const J = ft( (xe, se) => {
        switch (xe.key) {
        case "ArrowUp":
            ie((12 + se - 3) % 12),
            xe.preventDefault();
            break;
        case "ArrowDown":
            ie((12 + se + 3) % 12),
            xe.preventDefault();
            break;
        case "ArrowLeft":
            ie((12 + se + (L ? 1 : -1)) % 12),
            xe.preventDefault();
            break;
        case "ArrowRight":
            ie((12 + se + (L ? -1 : 1)) % 12),
            xe.preventDefault();
            break
        }
    }
    )
      , oe = ft( (xe, se) => {
        ie(se)
    }
    )
      , we = ft( (xe, se) => {
        V === se && K(!1)
    }
    );
    return g.jsx(K4e, ge({
        ref: n,
        className: Ne(H.root, i),
        ownerState: N,
        role: "radiogroup",
        "aria-labelledby": P
    }, z, {
        children: aP(F, O ?? j).map(xe => {
            const se = F.getMonth(xe)
              , de = F.format(xe, "monthShort")
              , Se = F.format(xe, "month")
              , Ce = se === q
              , Ye = c || ee(xe);
            return g.jsx(W4e, {
                selected: Ce,
                value: se,
                onClick: re,
                onKeyDown: J,
                autoFocus: W && se === V,
                disabled: Ye,
                tabIndex: se === V && !Ye ? 0 : -1,
                onFocus: oe,
                onBlur: we,
                "aria-current": Z === se ? "date" : void 0,
                "aria-label": Se,
                monthsPerRow: T,
                slots: D,
                slotProps: $,
                children: de
            }, de)
        }
        )
    }))
});
function J4e(e) {
    return rt("MuiPickersYear", e)
}
const xx = ot("MuiPickersYear", ["root", "yearButton", "selected", "disabled"])
  , e6e = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow", "slots", "slotProps"]
  , t6e = e => {
    const {disabled: t, selected: n, classes: r} = e;
    return tt({
        root: ["root"],
        yearButton: ["yearButton", t && "disabled", n && "selected"]
    }, J4e, r)
}
  , n6e = ue("div", {
    name: "MuiPickersYear",
    slot: "Root",
    overridesResolver: (e, t) => [t.root]
})({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexBasis: "33.3%",
    variants: [{
        props: {
            yearsPerRow: 4
        },
        style: {
            flexBasis: "25%"
        }
    }]
})
  , r6e = ue("button", {
    name: "MuiPickersYear",
    slot: "YearButton",
    overridesResolver: (e, t) => [t.yearButton, {
        [`&.${xx.disabled}`]: t.disabled
    }, {
        [`&.${xx.selected}`]: t.selected
    }]
})( ({theme: e}) => ge({
    color: "unset",
    backgroundColor: "transparent",
    border: 0,
    outline: 0
}, e.typography.subtitle1, {
    margin: "6px 0",
    height: 36,
    width: 72,
    borderRadius: 18,
    cursor: "pointer",
    "&:focus": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.focusOpacity})` : Ts(e.palette.action.active, e.palette.action.focusOpacity)
    },
    "&:hover": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Ts(e.palette.action.active, e.palette.action.hoverOpacity)
    },
    "&:disabled": {
        cursor: "auto",
        pointerEvents: "none"
    },
    [`&.${xx.disabled}`]: {
        color: (e.vars || e).palette.text.secondary
    },
    [`&.${xx.selected}`]: {
        color: (e.vars || e).palette.primary.contrastText,
        backgroundColor: (e.vars || e).palette.primary.main,
        "&:focus, &:hover": {
            backgroundColor: (e.vars || e).palette.primary.dark
        }
    }
}))
  , i6e = A.memo(function(t) {
    const n = hr({
        props: t,
        name: "MuiPickersYear"
    })
      , {autoFocus: r, className: i, children: o, disabled: a, selected: s, value: c, tabIndex: u, onClick: f, onKeyDown: h, onFocus: m, onBlur: y, "aria-current": b, slots: v, slotProps: S} = n
      , C = Qt(n, e6e)
      , w = A.useRef(null)
      , k = t6e(n);
    Cr( () => {
        r && w.current?.focus()
    }
    , [r]);
    const T = v?.yearButton ?? r6e
      , E = _n({
        elementType: T,
        externalSlotProps: S?.yearButton,
        additionalProps: {
            children: o,
            disabled: a,
            tabIndex: u,
            ref: w,
            type: "button",
            role: "radio",
            "aria-current": b,
            "aria-checked": s,
            onClick: P => f(P, c),
            onKeyDown: P => h(P, c),
            onFocus: P => m(P, c),
            onBlur: P => y(P, c)
        },
        ownerState: n,
        className: k.yearButton
    });
    return g.jsx(n6e, ge({
        className: Ne(k.root, i),
        ownerState: n
    }, C, {
        children: g.jsx(T, ge({}, E))
    }))
});
function o6e(e) {
    return rt("MuiYearCalendar", e)
}
ot("MuiYearCalendar", ["root"]);
const a6e = ["autoFocus", "className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsOrder", "yearsPerRow", "timezone", "gridLabelId", "slots", "slotProps"]
  , s6e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"]
    }, o6e, t)
}
;
function l6e(e, t) {
    const n = pr()
      , r = fy()
      , i = hr({
        props: e,
        name: t
    });
    return ge({
        disablePast: !1,
        disableFuture: !1
    }, i, {
        yearsPerRow: i.yearsPerRow ?? 3,
        minDate: _a(n, i.minDate, r.minDate),
        maxDate: _a(n, i.maxDate, r.maxDate)
    })
}
const c6e = ue("div", {
    name: "MuiYearCalendar",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "flex",
    flexDirection: "row",
    flexWrap: "wrap",
    overflowY: "auto",
    height: "100%",
    padding: "0 4px",
    width: hS,
    maxHeight: kNe,
    boxSizing: "border-box",
    position: "relative"
})
  , u6e = A.forwardRef(function(t, n) {
    const r = l6e(t, "MuiYearCalendar")
      , {autoFocus: i, className: o, value: a, defaultValue: s, referenceDate: c, disabled: u, disableFuture: f, disablePast: h, maxDate: m, minDate: y, onChange: b, readOnly: v, shouldDisableYear: S, onYearFocus: C, hasFocus: w, onFocusedViewChange: k, yearsOrder: T="asc", yearsPerRow: E, timezone: P, gridLabelId: D, slots: $, slotProps: z} = r
      , O = Qt(r, a6e)
      , {value: I, handleValueChange: M, timezone: B} = cP({
        name: "YearCalendar",
        timezone: P,
        value: a,
        defaultValue: s,
        referenceDate: c,
        onChange: b,
        valueManager: Ps
    })
      , L = dS(B)
      , F = Si()
      , j = pr()
      , N = A.useMemo( () => Ps.getInitialReferenceValue({
        value: I,
        utils: j,
        props: r,
        timezone: B,
        referenceDate: c,
        granularity: xs.year
    }), [])
      , H = r
      , Z = s6e(H)
      , q = A.useMemo( () => j.getYear(L), [j, L])
      , V = A.useMemo( () => I != null ? j.getYear(I) : null, [I, j])
      , [Y,W] = A.useState( () => V || j.getYear(N))
      , [te,K] = go({
        name: "YearCalendar",
        state: "hasFocus",
        controlled: w,
        default: i ?? !1
    })
      , ee = ft(ye => {
        K(ye),
        k && k(ye)
    }
    )
      , re = A.useCallback(ye => {
        if (h && j.isBeforeYear(ye, L) || f && j.isAfterYear(ye, L) || y && j.isBeforeYear(ye, y) || m && j.isAfterYear(ye, m))
            return !0;
        if (!S)
            return !1;
        const Ke = j.startOfYear(ye);
        return S(Ke)
    }
    , [f, h, m, y, L, S, j])
      , ie = ft( (ye, Ke) => {
        if (v)
            return;
        const X = j.setYear(I ?? N, Ke);
        M(X)
    }
    )
      , J = ft(ye => {
        re(j.setYear(I ?? N, ye)) || (W(ye),
        ee(!0),
        C?.(ye))
    }
    );
    A.useEffect( () => {
        W(ye => V !== null && ye !== V ? V : ye)
    }
    , [V]);
    const oe = T !== "desc" ? E * 1 : E * -1
      , we = F && T === "asc" || !F && T === "desc" ? -1 : 1
      , xe = ft( (ye, Ke) => {
        switch (ye.key) {
        case "ArrowUp":
            J(Ke - oe),
            ye.preventDefault();
            break;
        case "ArrowDown":
            J(Ke + oe),
            ye.preventDefault();
            break;
        case "ArrowLeft":
            J(Ke - we),
            ye.preventDefault();
            break;
        case "ArrowRight":
            J(Ke + we),
            ye.preventDefault();
            break
        }
    }
    )
      , se = ft( (ye, Ke) => {
        J(Ke)
    }
    )
      , de = ft( (ye, Ke) => {
        Y === Ke && ee(!1)
    }
    )
      , Se = A.useRef(null)
      , Ce = Cn(n, Se);
    A.useEffect( () => {
        if (i || Se.current === null)
            return;
        const ye = Se.current.querySelector('[tabindex="0"]');
        if (!ye)
            return;
        const Ke = ye.offsetHeight
          , X = ye.offsetTop
          , ce = Se.current.clientHeight
          , fe = Se.current.scrollTop
          , Xe = X + Ke;
        Ke > ce || X < fe || (Se.current.scrollTop = Xe - ce / 2 - Ke / 2)
    }
    , [i]);
    const Ye = j.getYearRange([y, m]);
    return T === "desc" && Ye.reverse(),
    g.jsx(c6e, ge({
        ref: Ce,
        className: Ne(Z.root, o),
        ownerState: H,
        role: "radiogroup",
        "aria-labelledby": D
    }, O, {
        children: Ye.map(ye => {
            const Ke = j.getYear(ye)
              , X = Ke === V
              , ce = u || re(ye);
            return g.jsx(i6e, {
                selected: X,
                value: Ke,
                onClick: ie,
                onKeyDown: xe,
                autoFocus: te && Ke === Y,
                disabled: ce,
                tabIndex: Ke === Y && !ce ? 0 : -1,
                onFocus: se,
                onBlur: de,
                "aria-current": q === Ke ? "date" : void 0,
                yearsPerRow: E,
                slots: $,
                slotProps: z,
                children: j.format(ye, "year")
            }, j.format(ye, "year"))
        }
        )
    }))
})
  , d6e = e => rt("MuiPickersCalendarHeader", e)
  , f6e = ot("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"])
  , h6e = ["slots", "slotProps", "currentMonth", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onMonthChange", "onViewChange", "view", "reduceAnimations", "views", "labelId", "className", "timezone", "format"]
  , p6e = ["ownerState"]
  , m6e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        labelContainer: ["labelContainer"],
        label: ["label"],
        switchViewButton: ["switchViewButton"],
        switchViewIcon: ["switchViewIcon"]
    }, d6e, t)
}
  , g6e = ue("div", {
    name: "MuiPickersCalendarHeader",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "flex",
    alignItems: "center",
    marginTop: 12,
    marginBottom: 4,
    paddingLeft: 24,
    paddingRight: 12,
    maxHeight: 40,
    minHeight: 40
})
  , y6e = ue("div", {
    name: "MuiPickersCalendarHeader",
    slot: "LabelContainer",
    overridesResolver: (e, t) => t.labelContainer
})( ({theme: e}) => ge({
    display: "flex",
    overflow: "hidden",
    alignItems: "center",
    cursor: "pointer",
    marginRight: "auto"
}, e.typography.body1, {
    fontWeight: e.typography.fontWeightMedium
}))
  , b6e = ue("div", {
    name: "MuiPickersCalendarHeader",
    slot: "Label",
    overridesResolver: (e, t) => t.label
})({
    marginRight: 6
})
  , x6e = ue(In, {
    name: "MuiPickersCalendarHeader",
    slot: "SwitchViewButton",
    overridesResolver: (e, t) => t.switchViewButton
})({
    marginRight: "auto",
    variants: [{
        props: {
            view: "year"
        },
        style: {
            [`.${f6e.switchViewIcon}`]: {
                transform: "rotate(180deg)"
            }
        }
    }]
})
  , v6e = ue(oNe, {
    name: "MuiPickersCalendarHeader",
    slot: "SwitchViewIcon",
    overridesResolver: (e, t) => t.switchViewIcon
})( ({theme: e}) => ({
    willChange: "transform",
    transition: e.transitions.create("transform"),
    transform: "rotate(0deg)"
}))
  , S6e = A.forwardRef(function(t, n) {
    const r = Rl()
      , i = pr()
      , o = hr({
        props: t,
        name: "MuiPickersCalendarHeader"
    })
      , {slots: a, slotProps: s, currentMonth: c, disabled: u, disableFuture: f, disablePast: h, maxDate: m, minDate: y, onMonthChange: b, onViewChange: v, view: S, reduceAnimations: C, views: w, labelId: k, className: T, timezone: E, format: P=`${i.formats.month} ${i.formats.year}`} = o
      , D = Qt(o, h6e)
      , $ = o
      , z = m6e(o)
      , O = a?.switchViewButton ?? x6e
      , I = _n({
        elementType: O,
        externalSlotProps: s?.switchViewButton,
        additionalProps: {
            size: "small",
            "aria-label": r.calendarViewSwitchingButtonAriaLabel(S)
        },
        ownerState: $,
        className: z.switchViewButton
    })
      , M = a?.switchViewIcon ?? v6e
      , B = _n({
        elementType: M,
        externalSlotProps: s?.switchViewIcon,
        ownerState: $,
        className: z.switchViewIcon
    })
      , L = Qt(B, p6e)
      , F = () => b(i.addMonths(c, 1), "left")
      , j = () => b(i.addMonths(c, -1), "right")
      , N = CNe(c, {
        disableFuture: f,
        maxDate: m,
        timezone: E
    })
      , H = wNe(c, {
        disablePast: h,
        minDate: y,
        timezone: E
    })
      , Z = () => {
        if (!(w.length === 1 || !v || u))
            if (w.length === 2)
                v(w.find(V => V !== S) || w[0]);
            else {
                const V = w.indexOf(S) !== 0 ? 0 : 1;
                v(w[V])
            }
    }
    ;
    if (w.length === 1 && w[0] === "year")
        return null;
    const q = i.formatByString(c, P);
    return g.jsxs(g6e, ge({}, D, {
        ownerState: $,
        className: Ne(z.root, T),
        ref: n,
        children: [g.jsxs(y6e, {
            role: "presentation",
            onClick: Z,
            ownerState: $,
            "aria-live": "polite",
            className: z.labelContainer,
            children: [g.jsx(SG, {
                reduceAnimations: C,
                transKey: q,
                children: g.jsx(b6e, {
                    id: k,
                    ownerState: $,
                    className: z.label,
                    children: q
                })
            }), w.length > 1 && !u && g.jsx(O, ge({}, I, {
                children: g.jsx(M, ge({}, L))
            }))]
        }), g.jsx(vc, {
            in: S === "day",
            appear: !C,
            enter: !C,
            children: g.jsx(yNe, {
                slots: a,
                slotProps: s,
                onGoToPrevious: j,
                isPreviousDisabled: H,
                previousLabel: r.previousMonth,
                onGoToNext: F,
                isNextDisabled: N,
                nextLabel: r.nextMonth
            })
        })]
    }))
})
  , C6e = "@media (prefers-reduced-motion: reduce)"
  , Pf = typeof navigator < "u" && navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i)
  , H5 = Pf && Pf[1] ? parseInt(Pf[1], 10) : null
  , q5 = Pf && Pf[2] ? parseInt(Pf[2], 10) : null
  , w6e = H5 && H5 < 10 || q5 && q5 < 13 || !1
  , wG = () => n1(C6e, {
    defaultMatches: !1
}) || w6e
  , k6e = e => rt("MuiDateCalendar", e);
ot("MuiDateCalendar", ["root", "viewTransitionContainer"]);
const T6e = ["autoFocus", "onViewChange", "value", "defaultValue", "referenceDate", "disableFuture", "disablePast", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsOrder", "yearsPerRow", "monthsPerRow", "timezone"]
  , _6e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        viewTransitionContainer: ["viewTransitionContainer"]
    }, k6e, t)
}
;
function E6e(e, t) {
    const n = pr()
      , r = fy()
      , i = wG()
      , o = hr({
        props: e,
        name: t
    });
    return ge({}, o, {
        loading: o.loading ?? !1,
        disablePast: o.disablePast ?? !1,
        disableFuture: o.disableFuture ?? !1,
        openTo: o.openTo ?? "day",
        views: o.views ?? ["year", "day"],
        reduceAnimations: o.reduceAnimations ?? i,
        renderLoading: o.renderLoading ?? ( () => g.jsx("span", {
            children: "..."
        })),
        minDate: _a(n, o.minDate, r.minDate),
        maxDate: _a(n, o.maxDate, r.maxDate)
    })
}
const A6e = ue(TNe, {
    name: "MuiDateCalendar",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "flex",
    flexDirection: "column",
    height: oP
})
  , M6e = ue(SG, {
    name: "MuiDateCalendar",
    slot: "ViewTransitionContainer",
    overridesResolver: (e, t) => t.viewTransitionContainer
})({})
  , P6e = A.forwardRef(function(t, n) {
    const r = pr()
      , i = Gi()
      , o = E6e(t, "MuiDateCalendar")
      , {autoFocus: a, onViewChange: s, value: c, defaultValue: u, referenceDate: f, disableFuture: h, disablePast: m, onChange: y, onYearChange: b, onMonthChange: v, reduceAnimations: S, shouldDisableDate: C, shouldDisableMonth: w, shouldDisableYear: k, view: T, views: E, openTo: P, className: D, disabled: $, readOnly: z, minDate: O, maxDate: I, disableHighlightToday: M, focusedView: B, onFocusedViewChange: L, showDaysOutsideCurrentMonth: F, fixedWeekNumber: j, dayOfWeekFormatter: N, slots: H, slotProps: Z, loading: q, renderLoading: V, displayWeekNumber: Y, yearsOrder: W, yearsPerRow: te, monthsPerRow: K, timezone: ee} = o
      , re = Qt(o, T6e)
      , {value: ie, handleValueChange: J, timezone: oe} = cP({
        name: "DateCalendar",
        timezone: ee,
        value: c,
        defaultValue: u,
        referenceDate: f,
        onChange: y,
        valueManager: Ps
    })
      , {view: we, setView: xe, focusedView: se, setFocusedView: de, goToNextView: Se, setValueAndGoToNextView: Ce} = J7({
        view: T,
        views: E,
        openTo: P,
        onChange: J,
        onViewChange: s,
        autoFocus: a,
        focusedView: B,
        onFocusedViewChange: L
    })
      , {referenceDate: Ye, calendarState: ye, changeFocusedDay: Ke, changeMonth: X, handleChangeMonth: ce, isDateDisabled: fe, onMonthSwitchingAnimationEnd: Xe} = y4e({
        value: ie,
        referenceDate: f,
        reduceAnimations: S,
        onMonthChange: v,
        minDate: O,
        maxDate: I,
        shouldDisableDate: C,
        disablePast: m,
        disableFuture: h,
        timezone: oe
    })
      , Oe = $ && ie || O
      , Re = $ && ie || I
      , le = `${i}-grid-label`
      , ke = se !== null
      , He = H?.calendarHeader ?? S6e
      , st = _n({
        elementType: He,
        externalSlotProps: Z?.calendarHeader,
        additionalProps: {
            views: E,
            view: we,
            currentMonth: ye.currentMonth,
            onViewChange: xe,
            onMonthChange: (Xt, Mn) => ce({
                newMonth: Xt,
                direction: Mn
            }),
            minDate: Oe,
            maxDate: Re,
            disabled: $,
            disablePast: m,
            disableFuture: h,
            reduceAnimations: S,
            timezone: oe,
            labelId: le
        },
        ownerState: o
    })
      , lt = ft(Xt => {
        const Mn = r.startOfMonth(Xt)
          , Pn = r.endOfMonth(Xt)
          , wn = fe(Xt) ? Lm({
            utils: r,
            date: Xt,
            minDate: r.isBefore(O, Mn) ? Mn : O,
            maxDate: r.isAfter(I, Pn) ? Pn : I,
            disablePast: m,
            disableFuture: h,
            isDateDisabled: fe,
            timezone: oe
        }) : Xt;
        wn ? (Ce(wn, "finish"),
        v?.(Mn)) : (Se(),
        X(Mn)),
        Ke(wn, !0)
    }
    )
      , et = ft(Xt => {
        const Mn = r.startOfYear(Xt)
          , Pn = r.endOfYear(Xt)
          , wn = fe(Xt) ? Lm({
            utils: r,
            date: Xt,
            minDate: r.isBefore(O, Mn) ? Mn : O,
            maxDate: r.isAfter(I, Pn) ? Pn : I,
            disablePast: m,
            disableFuture: h,
            isDateDisabled: fe,
            timezone: oe
        }) : Xt;
        wn ? (Ce(wn, "finish"),
        b?.(wn)) : (Se(),
        X(Mn)),
        Ke(wn, !0)
    }
    )
      , Ht = ft(Xt => J(Xt && kv(r, Xt, ie ?? Ye), "finish", we));
    A.useEffect( () => {
        ie != null && r.isValid(ie) && X(ie)
    }
    , [ie]);
    const Ft = o
      , Pt = _6e(Ft)
      , nt = {
        disablePast: m,
        disableFuture: h,
        maxDate: I,
        minDate: O
    }
      , ut = {
        disableHighlightToday: M,
        readOnly: z,
        disabled: $,
        timezone: oe,
        gridLabelId: le,
        slots: H,
        slotProps: Z
    }
      , Lt = A.useRef(we);
    A.useEffect( () => {
        Lt.current !== we && (se === Lt.current && de(we, !0),
        Lt.current = we)
    }
    , [se, de, we]);
    const tn = A.useMemo( () => [ie], [ie]);
    return g.jsxs(A6e, ge({
        ref: n,
        className: Ne(Pt.root, D),
        ownerState: Ft
    }, re, {
        children: [g.jsx(He, ge({}, st, {
            slots: H,
            slotProps: Z
        })), g.jsx(M6e, {
            reduceAnimations: S,
            className: Pt.viewTransitionContainer,
            transKey: we,
            ownerState: Ft,
            children: g.jsxs("div", {
                children: [we === "year" && g.jsx(u6e, ge({}, nt, ut, {
                    value: ie,
                    onChange: et,
                    shouldDisableYear: k,
                    hasFocus: ke,
                    onFocusedViewChange: Xt => de("year", Xt),
                    yearsOrder: W,
                    yearsPerRow: te,
                    referenceDate: Ye
                })), we === "month" && g.jsx(X4e, ge({}, nt, ut, {
                    hasFocus: ke,
                    className: D,
                    value: ie,
                    onChange: lt,
                    shouldDisableMonth: w,
                    onFocusedViewChange: Xt => de("month", Xt),
                    monthsPerRow: K,
                    referenceDate: Ye
                })), we === "day" && g.jsx(F4e, ge({}, ye, nt, ut, {
                    onMonthSwitchingAnimationEnd: Xe,
                    onFocusedDayChange: Ke,
                    reduceAnimations: S,
                    selectedDays: tn,
                    onSelectedDaysChange: Ht,
                    shouldDisableDate: C,
                    shouldDisableMonth: w,
                    shouldDisableYear: k,
                    hasFocus: ke,
                    onFocusedViewChange: Xt => de("day", Xt),
                    showDaysOutsideCurrentMonth: F,
                    fixedWeekNumber: j,
                    dayOfWeekFormatter: N,
                    displayWeekNumber: Y,
                    loading: q,
                    renderLoading: V
                }))]
            })
        })]
    }))
});
function R6e(e) {
    return rt("MuiPickersToolbar", e)
}
ot("MuiPickersToolbar", ["root", "content"]);
const D6e = ["children", "className", "toolbarTitle", "hidden", "titleId", "isLandscape", "classes", "landscapeDirection"]
  , O6e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        content: ["content"]
    }, R6e, t)
}
  , I6e = ue("div", {
    name: "MuiPickersToolbar",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})( ({theme: e}) => ({
    display: "flex",
    flexDirection: "column",
    alignItems: "flex-start",
    justifyContent: "space-between",
    padding: e.spacing(2, 3),
    variants: [{
        props: {
            isLandscape: !0
        },
        style: {
            height: "auto",
            maxWidth: 160,
            padding: 16,
            justifyContent: "flex-start",
            flexWrap: "wrap"
        }
    }]
}))
  , $6e = ue("div", {
    name: "MuiPickersToolbar",
    slot: "Content",
    overridesResolver: (e, t) => t.content
})({
    display: "flex",
    flexWrap: "wrap",
    width: "100%",
    flex: 1,
    justifyContent: "space-between",
    alignItems: "center",
    flexDirection: "row",
    variants: [{
        props: {
            isLandscape: !0
        },
        style: {
            justifyContent: "flex-start",
            alignItems: "flex-start",
            flexDirection: "column"
        }
    }, {
        props: {
            isLandscape: !0,
            landscapeDirection: "row"
        },
        style: {
            flexDirection: "row"
        }
    }]
})
  , L6e = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersToolbar"
    })
      , {children: i, className: o, toolbarTitle: a, hidden: s, titleId: c} = r
      , u = Qt(r, D6e)
      , f = r
      , h = O6e(f);
    return s ? null : g.jsxs(I6e, ge({
        ref: n,
        className: Ne(h.root, o),
        ownerState: f
    }, u, {
        children: [g.jsx(Ae, {
            color: "text.secondary",
            variant: "overline",
            id: c,
            children: a
        }), g.jsx($6e, {
            className: h.content,
            ownerState: f,
            children: i
        })]
    }))
});
function j6e(e) {
    return rt("MuiDatePickerToolbar", e)
}
ot("MuiDatePickerToolbar", ["root", "title"]);
const B6e = ["value", "isLandscape", "onChange", "toolbarFormat", "toolbarPlaceholder", "views", "className", "onViewChange", "view"]
  , z6e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        title: ["title"]
    }, j6e, t)
}
  , F6e = ue(L6e, {
    name: "MuiDatePickerToolbar",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({})
  , N6e = ue(Ae, {
    name: "MuiDatePickerToolbar",
    slot: "Title",
    overridesResolver: (e, t) => t.title
})({
    variants: [{
        props: {
            isLandscape: !0
        },
        style: {
            margin: "auto 16px auto auto"
        }
    }]
})
  , U6e = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiDatePickerToolbar"
    })
      , {value: i, isLandscape: o, toolbarFormat: a, toolbarPlaceholder: s="", views: c, className: u} = r
      , f = Qt(r, B6e)
      , h = pr()
      , m = Rl()
      , y = z6e(r)
      , b = A.useMemo( () => {
        if (!i)
            return s;
        const S = sP(h, {
            format: a,
            views: c
        }, !0);
        return h.formatByString(i, S)
    }
    , [i, a, s, h, c])
      , v = r;
    return g.jsx(F6e, ge({
        ref: n,
        toolbarTitle: m.datePickerToolbarTitle,
        isLandscape: o,
        className: Ne(y.root, u)
    }, f, {
        children: g.jsx(N6e, {
            variant: "h4",
            align: o ? "left" : "center",
            ownerState: v,
            className: y.title,
            children: b
        })
    }))
});
function kG(e, t) {
    const n = pr()
      , r = fy()
      , i = hr({
        props: e,
        name: t
    })
      , o = A.useMemo( () => i.localeText?.toolbarTitle == null ? i.localeText : ge({}, i.localeText, {
        datePickerToolbarTitle: i.localeText.toolbarTitle
    }), [i.localeText]);
    return ge({}, i, {
        localeText: o
    }, bNe({
        views: i.views,
        openTo: i.openTo,
        defaultViews: ["year", "day"],
        defaultOpenTo: "day"
    }), {
        disableFuture: i.disableFuture ?? !1,
        disablePast: i.disablePast ?? !1,
        minDate: _a(n, i.minDate, r.minDate),
        maxDate: _a(n, i.maxDate, r.maxDate),
        slots: ge({
            toolbar: U6e
        }, i.slots)
    })
}
function V6e(e) {
    return rt("MuiPickersPopper", e)
}
ot("MuiPickersPopper", ["root", "paper"]);
const H6e = ["PaperComponent", "popperPlacement", "ownerState", "children", "paperSlotProps", "paperClasses", "onPaperClick", "onPaperTouchStart"]
  , q6e = e => {
    const {classes: t} = e;
    return tt({
        root: ["root"],
        paper: ["paper"]
    }, V6e, t)
}
  , W6e = ue($g, {
    name: "MuiPickersPopper",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})( ({theme: e}) => ({
    zIndex: e.zIndex.modal
}))
  , G6e = ue(yn, {
    name: "MuiPickersPopper",
    slot: "Paper",
    overridesResolver: (e, t) => t.paper
})({
    outline: 0,
    transformOrigin: "top center",
    variants: [{
        props: ({placement: e}) => ["top", "top-start", "top-end"].includes(e),
        style: {
            transformOrigin: "bottom center"
        }
    }]
});
function Y6e(e, t) {
    return t.documentElement.clientWidth < e.clientX || t.documentElement.clientHeight < e.clientY
}
function Z6e(e, t) {
    const n = A.useRef(!1)
      , r = A.useRef(!1)
      , i = A.useRef(null)
      , o = A.useRef(!1);
    A.useEffect( () => {
        if (!e)
            return;
        function c() {
            o.current = !0
        }
        return document.addEventListener("mousedown", c, !0),
        document.addEventListener("touchstart", c, !0),
        () => {
            document.removeEventListener("mousedown", c, !0),
            document.removeEventListener("touchstart", c, !0),
            o.current = !1
        }
    }
    , [e]);
    const a = ft(c => {
        if (!o.current)
            return;
        const u = r.current;
        r.current = !1;
        const f = Kr(i.current);
        if (!i.current || "clientX"in c && Y6e(c, f))
            return;
        if (n.current) {
            n.current = !1;
            return
        }
        let h;
        c.composedPath ? h = c.composedPath().indexOf(i.current) > -1 : h = !f.documentElement.contains(c.target) || i.current.contains(c.target),
        !h && !u && t(c)
    }
    )
      , s = () => {
        r.current = !0
    }
    ;
    return A.useEffect( () => {
        if (e) {
            const c = Kr(i.current)
              , u = () => {
                n.current = !0
            }
            ;
            return c.addEventListener("touchstart", a),
            c.addEventListener("touchmove", u),
            () => {
                c.removeEventListener("touchstart", a),
                c.removeEventListener("touchmove", u)
            }
        }
    }
    , [e, a]),
    A.useEffect( () => {
        if (e) {
            const c = Kr(i.current);
            return c.addEventListener("click", a),
            () => {
                c.removeEventListener("click", a),
                r.current = !1
            }
        }
    }
    , [e, a]),
    [i, s, s]
}
const Q6e = A.forwardRef( (e, t) => {
    const {PaperComponent: n, popperPlacement: r, ownerState: i, children: o, paperSlotProps: a, paperClasses: s, onPaperClick: c, onPaperTouchStart: u} = e
      , f = Qt(e, H6e)
      , h = ge({}, i, {
        placement: r
    })
      , m = _n({
        elementType: n,
        externalSlotProps: a,
        additionalProps: {
            tabIndex: -1,
            elevation: 8,
            ref: t
        },
        className: s,
        ownerState: h
    });
    return g.jsx(n, ge({}, f, m, {
        onClick: y => {
            c(y),
            m.onClick?.(y)
        }
        ,
        onTouchStart: y => {
            u(y),
            m.onTouchStart?.(y)
        }
        ,
        ownerState: h,
        children: o
    }))
}
);
function K6e(e) {
    const t = hr({
        props: e,
        name: "MuiPickersPopper"
    })
      , {anchorEl: n, children: r, containerRef: i=null, shouldRestoreFocus: o, onBlur: a, onDismiss: s, open: c, role: u, placement: f, slots: h, slotProps: m, reduceAnimations: y} = t;
    A.useEffect( () => {
        function F(j) {
            c && j.key === "Escape" && s()
        }
        return document.addEventListener("keydown", F),
        () => {
            document.removeEventListener("keydown", F)
        }
    }
    , [s, c]);
    const b = A.useRef(null);
    A.useEffect( () => {
        u === "tooltip" || o && !o() || (c ? b.current = uo(document) : b.current && b.current instanceof HTMLElement && setTimeout( () => {
            b.current instanceof HTMLElement && b.current.focus()
        }
        ))
    }
    , [c, u, o]);
    const [v,S,C] = Z6e(c, a ?? s)
      , w = A.useRef(null)
      , k = Cn(w, i)
      , T = Cn(k, v)
      , E = t
      , P = q6e(E)
      , D = wG()
      , $ = y ?? D
      , z = F => {
        F.key === "Escape" && (F.stopPropagation(),
        s())
    }
      , O = h?.desktopTransition ?? $ ? vc : Wf
      , I = h?.desktopTrapFocus ?? ZN
      , M = h?.desktopPaper ?? G6e
      , B = h?.popper ?? W6e
      , L = _n({
        elementType: B,
        externalSlotProps: m?.popper,
        additionalProps: {
            transition: !0,
            role: u,
            open: c,
            anchorEl: n,
            placement: f,
            onKeyDown: z
        },
        className: P.root,
        ownerState: t
    });
    return g.jsx(B, ge({}, L, {
        children: ({TransitionProps: F, placement: j}) => g.jsx(I, ge({
            open: c,
            disableAutoFocus: !0,
            disableRestoreFocus: !0,
            disableEnforceFocus: u === "tooltip",
            isEnabled: () => !0
        }, m?.desktopTrapFocus, {
            children: g.jsx(O, ge({}, F, m?.desktopTransition, {
                children: g.jsx(Q6e, {
                    PaperComponent: M,
                    ownerState: E,
                    popperPlacement: j,
                    ref: T,
                    onPaperClick: S,
                    onPaperTouchStart: C,
                    paperClasses: P.paper,
                    paperSlotProps: m?.desktopPaper,
                    children: r
                })
            }))
        }))
    }))
}
const X6e = ({open: e, onOpen: t, onClose: n}) => {
    const r = A.useRef(typeof e == "boolean").current
      , [i,o] = A.useState(!1);
    A.useEffect( () => {
        if (r) {
            if (typeof e != "boolean")
                throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
            o(e)
        }
    }
    , [r, e]);
    const a = A.useCallback(s => {
        r || o(s),
        s && t && t(),
        !s && n && n()
    }
    , [r, t, n]);
    return {
        isOpen: i,
        setIsOpen: a
    }
}
  , J6e = e => {
    const {action: t, hasChanged: n, dateState: r, isControlled: i} = e
      , o = !i && !r.hasBeenModifiedSinceMount;
    return t.name === "setValueFromField" ? !0 : t.name === "setValueFromAction" ? o && ["accept", "today", "clear"].includes(t.pickerAction) ? !0 : n(r.lastPublishedValue) : t.name === "setValueFromView" && t.selectionState !== "shallow" || t.name === "setValueFromShortcut" ? o ? !0 : n(r.lastPublishedValue) : !1
}
  , e9e = e => {
    const {action: t, hasChanged: n, dateState: r, isControlled: i, closeOnSelect: o} = e
      , a = !i && !r.hasBeenModifiedSinceMount;
    return t.name === "setValueFromAction" ? a && ["accept", "today", "clear"].includes(t.pickerAction) ? !0 : n(r.lastCommittedValue) : t.name === "setValueFromView" && t.selectionState === "finish" && o ? a ? !0 : n(r.lastCommittedValue) : t.name === "setValueFromShortcut" ? t.changeImportance === "accept" && n(r.lastCommittedValue) : !1
}
  , t9e = e => {
    const {action: t, closeOnSelect: n} = e;
    return t.name === "setValueFromAction" ? !0 : t.name === "setValueFromView" ? t.selectionState === "finish" && n : t.name === "setValueFromShortcut" ? t.changeImportance === "accept" : !1
}
  , n9e = ({props: e, valueManager: t, valueType: n, wrapperVariant: r, validator: i}) => {
    const {onAccept: o, onChange: a, value: s, defaultValue: c, closeOnSelect: u=r === "desktop", timezone: f, referenceDate: h} = e
      , {current: m} = A.useRef(c)
      , {current: y} = A.useRef(s !== void 0)
      , [b,v] = A.useState(f)
      , S = pr()
      , C = dd()
      , {isOpen: w, setIsOpen: k} = X6e(e)
      , {timezone: T, value: E, handleValueChange: P} = lP({
        timezone: f,
        value: s,
        defaultValue: m,
        referenceDate: h,
        onChange: a,
        valueManager: t
    })
      , [D,$] = A.useState( () => {
        let J;
        return E !== void 0 ? J = E : m !== void 0 ? J = m : J = t.emptyValue,
        {
            draft: J,
            lastPublishedValue: J,
            lastCommittedValue: J,
            lastControlledValue: s,
            hasBeenModifiedSinceMount: !1
        }
    }
    )
      , z = t.getTimezone(S, D.draft);
    b !== f && (v(f),
    f && z && f !== z && $(J => ge({}, J, {
        draft: t.setTimezone(S, f, J.draft)
    })));
    const {getValidationErrorForNewValue: O} = uG({
        props: e,
        validator: i,
        timezone: T,
        value: D.draft,
        onError: e.onError
    })
      , I = ft(J => {
        const oe = {
            action: J,
            dateState: D,
            hasChanged: Ce => !t.areValuesEqual(S, J.value, Ce),
            isControlled: y,
            closeOnSelect: u
        }
          , we = J6e(oe)
          , xe = e9e(oe)
          , se = t9e(oe);
        $(Ce => ge({}, Ce, {
            draft: J.value,
            lastPublishedValue: we ? J.value : Ce.lastPublishedValue,
            lastCommittedValue: xe ? J.value : Ce.lastCommittedValue,
            hasBeenModifiedSinceMount: !0
        }));
        let de = null;
        const Se = () => (de || (de = {
            validationError: J.name === "setValueFromField" ? J.context.validationError : O(J.value)
        },
        J.name === "setValueFromShortcut" && (de.shortcut = J.shortcut)),
        de);
        we && P(J.value, Se()),
        xe && o && o(J.value, Se()),
        se && k(!1)
    }
    );
    if (D.lastControlledValue !== s) {
        const J = t.areValuesEqual(S, D.draft, E);
        $(oe => ge({}, oe, {
            lastControlledValue: s
        }, J ? {} : {
            lastCommittedValue: E,
            lastPublishedValue: E,
            draft: E,
            hasBeenModifiedSinceMount: !0
        }))
    }
    const M = ft( () => {
        I({
            value: t.emptyValue,
            name: "setValueFromAction",
            pickerAction: "clear"
        })
    }
    )
      , B = ft( () => {
        I({
            value: D.lastPublishedValue,
            name: "setValueFromAction",
            pickerAction: "accept"
        })
    }
    )
      , L = ft( () => {
        I({
            value: D.lastPublishedValue,
            name: "setValueFromAction",
            pickerAction: "dismiss"
        })
    }
    )
      , F = ft( () => {
        I({
            value: D.lastCommittedValue,
            name: "setValueFromAction",
            pickerAction: "cancel"
        })
    }
    )
      , j = ft( () => {
        I({
            value: t.getTodayValue(S, T, n),
            name: "setValueFromAction",
            pickerAction: "today"
        })
    }
    )
      , N = ft(J => {
        J.preventDefault(),
        k(!0)
    }
    )
      , H = ft(J => {
        J?.preventDefault(),
        k(!1)
    }
    )
      , Z = ft( (J, oe="partial") => I({
        name: "setValueFromView",
        value: J,
        selectionState: oe
    }))
      , q = ft( (J, oe, we) => I({
        name: "setValueFromShortcut",
        value: J,
        changeImportance: oe,
        shortcut: we
    }))
      , V = ft( (J, oe) => I({
        name: "setValueFromField",
        value: J,
        context: oe
    }))
      , Y = {
        onClear: M,
        onAccept: B,
        onDismiss: L,
        onCancel: F,
        onSetToday: j,
        onOpen: N,
        onClose: H
    }
      , W = {
        value: D.draft,
        onChange: V
    }
      , te = A.useMemo( () => t.cleanValue(S, D.draft), [S, t, D.draft])
      , K = {
        value: te,
        onChange: Z,
        onClose: H,
        open: w
    }
      , re = ge({}, Y, {
        value: te,
        onChange: Z,
        onSelectShortcut: q,
        isValid: J => {
            const oe = i({
                adapter: C,
                value: J,
                timezone: T,
                props: e
            });
            return !t.hasError(oe)
        }
    })
      , ie = A.useMemo( () => ({
        onOpen: N,
        onClose: H,
        open: w
    }), [w, H, N]);
    return {
        open: w,
        fieldProps: W,
        viewProps: K,
        layoutProps: re,
        actions: Y,
        contextValue: ie
    }
}
  , r9e = ["className", "sx"]
  , i9e = ({props: e, propsFromPickerValue: t, additionalViewProps: n, autoFocusView: r, rendererInterceptor: i, fieldRef: o}) => {
    const {onChange: a, open: s, onClose: c} = t
      , {view: u, views: f, openTo: h, onViewChange: m, viewRenderers: y, timezone: b} = e
      , v = Qt(e, r9e)
      , {view: S, setView: C, defaultView: w, focusedView: k, setFocusedView: T, setValueAndGoToNextView: E} = J7({
        view: u,
        views: f,
        openTo: h,
        onChange: a,
        onViewChange: m,
        autoFocus: r
    })
      , {hasUIView: P, viewModeLookup: D} = A.useMemo( () => f.reduce( (L, F) => {
        let j;
        return y[F] != null ? j = "UI" : j = "field",
        L.viewModeLookup[F] = j,
        j === "UI" && (L.hasUIView = !0),
        L
    }
    , {
        hasUIView: !1,
        viewModeLookup: {}
    }), [y, f])
      , $ = A.useMemo( () => f.reduce( (L, F) => y[F] != null && vNe(F) ? L + 1 : L, 0), [y, f])
      , z = D[S]
      , O = ft( () => z === "UI")
      , [I,M] = A.useState(z === "UI" ? S : null);
    return I !== S && D[S] === "UI" && M(S),
    Cr( () => {
        z === "field" && s && (c(),
        setTimeout( () => {
            o?.current?.setSelectedSections(S),
            o?.current?.focusField(S)
        }
        ))
    }
    , [S]),
    Cr( () => {
        if (!s)
            return;
        let L = S;
        z === "field" && I != null && (L = I),
        L !== w && D[L] === "UI" && D[w] === "UI" && (L = w),
        L !== S && C(L),
        T(L, !0)
    }
    , [s]),
    {
        hasUIView: P,
        shouldRestoreFocus: O,
        layoutProps: {
            views: f,
            view: I,
            onViewChange: C
        },
        renderCurrentView: () => {
            if (I == null)
                return null;
            const L = y[I];
            if (L == null)
                return null;
            const F = ge({}, v, n, t, {
                views: f,
                timezone: b,
                onChange: E,
                view: I,
                onViewChange: C,
                focusedView: k,
                onFocusedViewChange: T,
                showViewSwitcher: $ > 1,
                timeViewsCount: $
            });
            return i ? i(y, I, F) : L(F)
        }
    }
}
;
function W5() {
    return typeof window > "u" ? "portrait" : window.screen && window.screen.orientation && window.screen.orientation.angle ? Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait" : window.orientation && Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait"
}
const o9e = (e, t) => {
    const [n,r] = A.useState(W5);
    return Cr( () => {
        const o = () => {
            r(W5())
        }
        ;
        return window.addEventListener("orientationchange", o),
        () => {
            window.removeEventListener("orientationchange", o)
        }
    }
    , []),
    YNe(e, ["hours", "minutes", "seconds"]) ? !1 : (t || n) === "landscape"
}
  , a9e = ({props: e, propsFromPickerValue: t, propsFromPickerViews: n, wrapperVariant: r}) => {
    const {orientation: i} = e
      , o = o9e(n.views, i)
      , a = Si();
    return {
        layoutProps: ge({}, n, t, {
            isLandscape: o,
            isRtl: a,
            wrapperVariant: r,
            disabled: e.disabled,
            readOnly: e.readOnly
        })
    }
}
;
function s9e(e) {
    const {props: t, pickerValueResponse: n} = e;
    return A.useMemo( () => ({
        value: n.viewProps.value,
        open: n.open,
        disabled: t.disabled ?? !1,
        readOnly: t.readOnly ?? !1
    }), [n.viewProps.value, n.open, t.disabled, t.readOnly])
}
const TG = ({props: e, valueManager: t, valueType: n, wrapperVariant: r, additionalViewProps: i, validator: o, autoFocusView: a, rendererInterceptor: s, fieldRef: c}) => {
    const u = n9e({
        props: e,
        valueManager: t,
        valueType: n,
        wrapperVariant: r,
        validator: o
    })
      , f = i9e({
        props: e,
        additionalViewProps: i,
        autoFocusView: a,
        fieldRef: c,
        propsFromPickerValue: u.viewProps,
        rendererInterceptor: s
    })
      , h = a9e({
        props: e,
        wrapperVariant: r,
        propsFromPickerValue: u.layoutProps,
        propsFromPickerViews: f.layoutProps
    })
      , m = s9e({
        props: e,
        pickerValueResponse: u
    });
    return {
        open: u.open,
        actions: u.actions,
        fieldProps: u.fieldProps,
        renderCurrentView: f.renderCurrentView,
        hasUIView: f.hasUIView,
        shouldRestoreFocus: f.shouldRestoreFocus,
        layoutProps: h.layoutProps,
        contextValue: u.contextValue,
        ownerState: m
    }
}
;
function _G(e) {
    return rt("MuiPickersLayout", e)
}
const uu = ot("MuiPickersLayout", ["root", "landscape", "contentWrapper", "toolbar", "actionBar", "tabs", "shortcuts"])
  , l9e = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
function c9e(e) {
    const {onAccept: t, onClear: n, onCancel: r, onSetToday: i, actions: o} = e
      , a = Qt(e, l9e)
      , s = Rl();
    if (o == null || o.length === 0)
        return null;
    const c = o?.map(u => {
        switch (u) {
        case "clear":
            return g.jsx(Mt, {
                onClick: n,
                children: s.clearButtonLabel
            }, u);
        case "cancel":
            return g.jsx(Mt, {
                onClick: r,
                children: s.cancelButtonLabel
            }, u);
        case "accept":
            return g.jsx(Mt, {
                onClick: t,
                children: s.okButtonLabel
            }, u);
        case "today":
            return g.jsx(Mt, {
                onClick: i,
                children: s.todayButtonLabel
            }, u);
        default:
            return null
        }
    }
    );
    return g.jsx(lc, ge({}, a, {
        children: c
    }))
}
const u9e = ["items", "changeImportance", "isLandscape", "onChange", "isValid"]
  , d9e = ["getValue"];
function f9e(e) {
    const {items: t, changeImportance: n="accept", onChange: r, isValid: i} = e
      , o = Qt(e, u9e);
    if (t == null || t.length === 0)
        return null;
    const a = t.map(s => {
        let {getValue: c} = s
          , u = Qt(s, d9e);
        const f = c({
            isValid: i
        });
        return ge({}, u, {
            label: u.label,
            onClick: () => {
                r(f, n, u)
            }
            ,
            disabled: !i(f)
        })
    }
    );
    return g.jsx(Fu, ge({
        dense: !0,
        sx: [{
            maxHeight: oP,
            maxWidth: 200,
            overflow: "auto"
        }, ...Array.isArray(o.sx) ? o.sx : [o.sx]]
    }, o, {
        children: a.map(s => g.jsx(HE, {
            children: g.jsx(zE, ge({}, s))
        }, s.id ?? s.label))
    }))
}
function h9e(e) {
    return e.view !== null
}
const p9e = e => {
    const {classes: t, isLandscape: n} = e;
    return tt({
        root: ["root", n && "landscape"],
        contentWrapper: ["contentWrapper"],
        toolbar: ["toolbar"],
        actionBar: ["actionBar"],
        tabs: ["tabs"],
        landscape: ["landscape"],
        shortcuts: ["shortcuts"]
    }, _G, t)
}
  , m9e = e => {
    const {wrapperVariant: t, onAccept: n, onClear: r, onCancel: i, onSetToday: o, view: a, views: s, onViewChange: c, value: u, onChange: f, onSelectShortcut: h, isValid: m, isLandscape: y, disabled: b, readOnly: v, children: S, slots: C, slotProps: w} = e
      , k = p9e(e)
      , T = C?.actionBar ?? c9e
      , E = _n({
        elementType: T,
        externalSlotProps: w?.actionBar,
        additionalProps: {
            onAccept: n,
            onClear: r,
            onCancel: i,
            onSetToday: o,
            actions: t === "desktop" ? [] : ["cancel", "accept"]
        },
        className: k.actionBar,
        ownerState: ge({}, e, {
            wrapperVariant: t
        })
    })
      , P = g.jsx(T, ge({}, E))
      , D = C?.toolbar
      , $ = _n({
        elementType: D,
        externalSlotProps: w?.toolbar,
        additionalProps: {
            isLandscape: y,
            onChange: f,
            value: u,
            view: a,
            onViewChange: c,
            views: s,
            disabled: b,
            readOnly: v
        },
        className: k.toolbar,
        ownerState: ge({}, e, {
            wrapperVariant: t
        })
    })
      , z = h9e($) && D ? g.jsx(D, ge({}, $)) : null
      , O = S
      , I = C?.tabs
      , M = a && I ? g.jsx(I, ge({
        view: a,
        onViewChange: c,
        className: k.tabs
    }, w?.tabs)) : null
      , B = C?.shortcuts ?? f9e
      , L = _n({
        elementType: B,
        externalSlotProps: w?.shortcuts,
        additionalProps: {
            isValid: m,
            isLandscape: y,
            onChange: h
        },
        className: k.shortcuts,
        ownerState: {
            isValid: m,
            isLandscape: y,
            onChange: h,
            wrapperVariant: t
        }
    })
      , F = a && B ? g.jsx(B, ge({}, L)) : null;
    return {
        toolbar: z,
        content: O,
        tabs: M,
        actionBar: P,
        shortcuts: F
    }
}
  , g9e = e => {
    const {isLandscape: t, classes: n} = e;
    return tt({
        root: ["root", t && "landscape"],
        contentWrapper: ["contentWrapper"]
    }, _G, n)
}
  , y9e = ue("div", {
    name: "MuiPickersLayout",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "grid",
    gridAutoColumns: "max-content auto max-content",
    gridAutoRows: "max-content auto max-content",
    [`& .${uu.actionBar}`]: {
        gridColumn: "1 / 4",
        gridRow: 3
    },
    variants: [{
        props: {
            isLandscape: !0
        },
        style: {
            [`& .${uu.toolbar}`]: {
                gridColumn: 1,
                gridRow: "2 / 3"
            },
            [`.${uu.shortcuts}`]: {
                gridColumn: "2 / 4",
                gridRow: 1
            }
        }
    }, {
        props: {
            isLandscape: !0,
            isRtl: !0
        },
        style: {
            [`& .${uu.toolbar}`]: {
                gridColumn: 3
            }
        }
    }, {
        props: {
            isLandscape: !1
        },
        style: {
            [`& .${uu.toolbar}`]: {
                gridColumn: "2 / 4",
                gridRow: 1
            },
            [`& .${uu.shortcuts}`]: {
                gridColumn: 1,
                gridRow: "2 / 3"
            }
        }
    }, {
        props: {
            isLandscape: !1,
            isRtl: !0
        },
        style: {
            [`& .${uu.shortcuts}`]: {
                gridColumn: 3
            }
        }
    }]
})
  , b9e = ue("div", {
    name: "MuiPickersLayout",
    slot: "ContentWrapper",
    overridesResolver: (e, t) => t.contentWrapper
})({
    gridColumn: 2,
    gridRow: 2,
    display: "flex",
    flexDirection: "column"
})
  , EG = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiPickersLayout"
    })
      , {toolbar: i, content: o, tabs: a, actionBar: s, shortcuts: c} = m9e(r)
      , {sx: u, className: f, isLandscape: h, wrapperVariant: m} = r
      , y = g9e(r);
    return g.jsxs(y9e, {
        ref: n,
        sx: u,
        className: Ne(y.root, f),
        ownerState: r,
        children: [h ? c : i, h ? i : c, g.jsx(b9e, {
            className: y.contentWrapper,
            children: m === "desktop" ? g.jsxs(A.Fragment, {
                children: [o, a]
            }) : g.jsxs(A.Fragment, {
                children: [a, o]
            })
        }), s]
    })
})
  , x9e = ["props", "getOpenDialogAriaText"]
  , v9e = ["ownerState"]
  , S9e = ["ownerState"]
  , C9e = e => {
    let {props: t, getOpenDialogAriaText: n} = e
      , r = Qt(e, x9e);
    const {slots: i, slotProps: o, className: a, sx: s, format: c, formatDensity: u, enableAccessibleFieldDOMStructure: f, selectedSections: h, onSelectedSectionsChange: m, timezone: y, name: b, label: v, inputRef: S, readOnly: C, disabled: w, autoFocus: k, localeText: T, reduceAnimations: E} = t
      , P = A.useRef(null)
      , D = A.useRef(null)
      , $ = Gi()
      , z = o?.toolbar?.hidden ?? !1
      , {open: O, actions: I, hasUIView: M, layoutProps: B, renderCurrentView: L, shouldRestoreFocus: F, fieldProps: j, contextValue: N, ownerState: H} = TG(ge({}, r, {
        props: t,
        fieldRef: D,
        autoFocusView: !0,
        additionalViewProps: {},
        wrapperVariant: "desktop"
    }))
      , Z = i.inputAdornment ?? v0
      , q = _n({
        elementType: Z,
        externalSlotProps: o?.inputAdornment,
        additionalProps: {
            position: "end"
        },
        ownerState: t
    })
      , V = Qt(q, v9e)
      , Y = i.openPickerButton ?? In
      , W = _n({
        elementType: Y,
        externalSlotProps: o?.openPickerButton,
        additionalProps: {
            disabled: w || C,
            onClick: O ? I.onClose : I.onOpen,
            "aria-label": n(j.value),
            edge: V.position
        },
        ownerState: t
    })
      , te = Qt(W, S9e)
      , K = i.openPickerIcon
      , ee = _n({
        elementType: K,
        externalSlotProps: o?.openPickerIcon,
        ownerState: H
    })
      , re = i.field
      , ie = _n({
        elementType: re,
        externalSlotProps: o?.field,
        additionalProps: ge({}, j, z && {
            id: $
        }, {
            readOnly: C,
            disabled: w,
            className: a,
            sx: s,
            format: c,
            formatDensity: u,
            enableAccessibleFieldDOMStructure: f,
            selectedSections: h,
            onSelectedSectionsChange: m,
            timezone: y,
            label: v,
            name: b,
            autoFocus: k && !t.open,
            focused: O ? !0 : void 0
        }, S ? {
            inputRef: S
        } : {}),
        ownerState: t
    });
    M && (ie.InputProps = ge({}, ie.InputProps, {
        ref: P
    }, !t.disableOpenPicker && {
        [`${V.position}Adornment`]: g.jsx(Z, ge({}, V, {
            children: g.jsx(Y, ge({}, te, {
                children: g.jsx(K, ge({}, ee))
            }))
        }))
    }));
    const J = ge({
        textField: i.textField,
        clearIcon: i.clearIcon,
        clearButton: i.clearButton
    }, ie.slots)
      , oe = i.layout ?? EG;
    let we = $;
    z && (v ? we = `${$}-label` : we = void 0);
    const xe = ge({}, o, {
        toolbar: ge({}, o?.toolbar, {
            titleId: $
        }),
        popper: ge({
            "aria-labelledby": we
        }, o?.popper)
    })
      , se = Cn(D, ie.unstableFieldRef);
    return {
        renderPicker: () => g.jsxs(dG, {
            contextValue: N,
            localeText: T,
            children: [g.jsx(re, ge({}, ie, {
                slots: J,
                slotProps: xe,
                unstableFieldRef: se
            })), g.jsx(K6e, ge({
                role: "dialog",
                placement: "bottom-start",
                anchorEl: P.current
            }, I, {
                open: O,
                slots: i,
                slotProps: xe,
                shouldRestoreFocus: F,
                reduceAnimations: E,
                children: g.jsx(oe, ge({}, B, xe?.layout, {
                    slots: i,
                    slotProps: xe,
                    children: L()
                }))
            }))]
        })
    }
}
  , Rf = ({view: e, onViewChange: t, views: n, focusedView: r, onFocusedViewChange: i, value: o, defaultValue: a, referenceDate: s, onChange: c, className: u, classes: f, disableFuture: h, disablePast: m, minDate: y, maxDate: b, shouldDisableDate: v, shouldDisableMonth: S, shouldDisableYear: C, reduceAnimations: w, onMonthChange: k, monthsPerRow: T, onYearChange: E, yearsOrder: P, yearsPerRow: D, slots: $, slotProps: z, loading: O, renderLoading: I, disableHighlightToday: M, readOnly: B, disabled: L, showDaysOutsideCurrentMonth: F, dayOfWeekFormatter: j, sx: N, autoFocus: H, fixedWeekNumber: Z, displayWeekNumber: q, timezone: V}) => g.jsx(P6e, {
    view: e,
    onViewChange: t,
    views: n.filter(L5),
    focusedView: r && L5(r) ? r : null,
    onFocusedViewChange: i,
    value: o,
    defaultValue: a,
    referenceDate: s,
    onChange: c,
    className: u,
    classes: f,
    disableFuture: h,
    disablePast: m,
    minDate: y,
    maxDate: b,
    shouldDisableDate: v,
    shouldDisableMonth: S,
    shouldDisableYear: C,
    reduceAnimations: w,
    onMonthChange: k,
    monthsPerRow: T,
    onYearChange: E,
    yearsOrder: P,
    yearsPerRow: D,
    slots: $,
    slotProps: z,
    loading: O,
    renderLoading: I,
    disableHighlightToday: M,
    readOnly: B,
    disabled: L,
    showDaysOutsideCurrentMonth: F,
    dayOfWeekFormatter: j,
    sx: N,
    autoFocus: H,
    fixedWeekNumber: Z,
    displayWeekNumber: q,
    timezone: V
})
  , AG = A.forwardRef(function(t, n) {
    const r = Rl()
      , i = pr()
      , o = kG(t, "MuiDesktopDatePicker")
      , a = ge({
        day: Rf,
        month: Rf,
        year: Rf
    }, o.viewRenderers)
      , s = ge({}, o, {
        viewRenderers: a,
        format: sP(i, o, !1),
        yearsPerRow: o.yearsPerRow ?? 4,
        slots: ge({
            openPickerIcon: lNe,
            field: xG
        }, o.slots),
        slotProps: ge({}, o.slotProps, {
            field: u => ge({}, Yv(o.slotProps?.field, u), cG(o), {
                ref: n
            }),
            toolbar: ge({
                hidden: !0
            }, o.slotProps?.toolbar)
        })
    })
      , {renderPicker: c} = C9e({
        props: s,
        valueManager: Ps,
        valueType: "date",
        getOpenDialogAriaText: K7({
            utils: i,
            formatKey: "fullDate",
            contextTranslation: r.openDatePickerDialogue,
            propsTranslation: s.localeText?.openDatePickerDialogue
        }),
        validator: hy
    });
    return c()
});
AG.propTypes = {
    autoFocus: ze.bool,
    className: ze.string,
    closeOnSelect: ze.bool,
    dayOfWeekFormatter: ze.func,
    defaultValue: ze.object,
    disabled: ze.bool,
    disableFuture: ze.bool,
    disableHighlightToday: ze.bool,
    disableOpenPicker: ze.bool,
    disablePast: ze.bool,
    displayWeekNumber: ze.bool,
    enableAccessibleFieldDOMStructure: ze.any,
    fixedWeekNumber: ze.number,
    format: ze.string,
    formatDensity: ze.oneOf(["dense", "spacious"]),
    inputRef: AN,
    label: ze.node,
    loading: ze.bool,
    localeText: ze.object,
    maxDate: ze.object,
    minDate: ze.object,
    monthsPerRow: ze.oneOf([3, 4]),
    name: ze.string,
    onAccept: ze.func,
    onChange: ze.func,
    onClose: ze.func,
    onError: ze.func,
    onMonthChange: ze.func,
    onOpen: ze.func,
    onSelectedSectionsChange: ze.func,
    onViewChange: ze.func,
    onYearChange: ze.func,
    open: ze.bool,
    openTo: ze.oneOf(["day", "month", "year"]),
    orientation: ze.oneOf(["landscape", "portrait"]),
    readOnly: ze.bool,
    reduceAnimations: ze.bool,
    referenceDate: ze.object,
    renderLoading: ze.func,
    selectedSections: ze.oneOfType([ze.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), ze.number]),
    shouldDisableDate: ze.func,
    shouldDisableMonth: ze.func,
    shouldDisableYear: ze.func,
    showDaysOutsideCurrentMonth: ze.bool,
    slotProps: ze.object,
    slots: ze.object,
    sx: ze.oneOfType([ze.arrayOf(ze.oneOfType([ze.func, ze.object, ze.bool])), ze.func, ze.object]),
    timezone: ze.string,
    value: ze.object,
    view: ze.oneOf(["day", "month", "year"]),
    viewRenderers: ze.shape({
        day: ze.func,
        month: ze.func,
        year: ze.func
    }),
    views: ze.arrayOf(ze.oneOf(["day", "month", "year"]).isRequired),
    yearsOrder: ze.oneOf(["asc", "desc"]),
    yearsPerRow: ze.oneOf([3, 4])
};
const w9e = ue(sc)({
    [`& .${gm.container}`]: {
        outline: 0
    },
    [`& .${gm.paper}`]: {
        outline: 0,
        minWidth: hS
    }
})
  , k9e = ue(cc)({
    "&:first-of-type": {
        padding: 0
    }
});
function T9e(e) {
    const {children: t, onDismiss: n, open: r, slots: i, slotProps: o} = e
      , a = i?.dialog ?? w9e
      , s = i?.mobileTransition ?? vc;
    return g.jsx(a, ge({
        open: r,
        onClose: n
    }, o?.dialog, {
        TransitionComponent: s,
        TransitionProps: o?.mobileTransition,
        PaperComponent: i?.mobilePaper,
        PaperProps: o?.mobilePaper,
        children: g.jsx(k9e, {
            children: t
        })
    }))
}
const _9e = ["props", "getOpenDialogAriaText"]
  , E9e = e => {
    let {props: t, getOpenDialogAriaText: n} = e
      , r = Qt(e, _9e);
    const {slots: i, slotProps: o, className: a, sx: s, format: c, formatDensity: u, enableAccessibleFieldDOMStructure: f, selectedSections: h, onSelectedSectionsChange: m, timezone: y, name: b, label: v, inputRef: S, readOnly: C, disabled: w, localeText: k} = t
      , T = A.useRef(null)
      , E = Gi()
      , P = o?.toolbar?.hidden ?? !1
      , {open: D, actions: $, layoutProps: z, renderCurrentView: O, fieldProps: I, contextValue: M} = TG(ge({}, r, {
        props: t,
        fieldRef: T,
        autoFocusView: !0,
        additionalViewProps: {},
        wrapperVariant: "mobile"
    }))
      , B = i.field
      , L = _n({
        elementType: B,
        externalSlotProps: o?.field,
        additionalProps: ge({}, I, P && {
            id: E
        }, !(w || C) && {
            onClick: $.onOpen,
            onKeyDown: ZNe($.onOpen)
        }, {
            readOnly: C ?? !0,
            disabled: w,
            className: a,
            sx: s,
            format: c,
            formatDensity: u,
            enableAccessibleFieldDOMStructure: f,
            selectedSections: h,
            onSelectedSectionsChange: m,
            timezone: y,
            label: v,
            name: b
        }, S ? {
            inputRef: S
        } : {}),
        ownerState: t
    });
    L.inputProps = ge({}, L.inputProps, {
        "aria-label": n(I.value)
    });
    const F = ge({
        textField: i.textField
    }, L.slots)
      , j = i.layout ?? EG;
    let N = E;
    P && (v ? N = `${E}-label` : N = void 0);
    const H = ge({}, o, {
        toolbar: ge({}, o?.toolbar, {
            titleId: E
        }),
        mobilePaper: ge({
            "aria-labelledby": N
        }, o?.mobilePaper)
    })
      , Z = Cn(T, L.unstableFieldRef);
    return {
        renderPicker: () => g.jsxs(dG, {
            contextValue: M,
            localeText: k,
            children: [g.jsx(B, ge({}, L, {
                slots: F,
                slotProps: H,
                unstableFieldRef: Z
            })), g.jsx(T9e, ge({}, $, {
                open: D,
                slots: i,
                slotProps: H,
                children: g.jsx(j, ge({}, z, H?.layout, {
                    slots: i,
                    slotProps: H,
                    children: O()
                }))
            }))]
        })
    }
}
  , MG = A.forwardRef(function(t, n) {
    const r = Rl()
      , i = pr()
      , o = kG(t, "MuiMobileDatePicker")
      , a = ge({
        day: Rf,
        month: Rf,
        year: Rf
    }, o.viewRenderers)
      , s = ge({}, o, {
        viewRenderers: a,
        format: sP(i, o, !1),
        slots: ge({
            field: xG
        }, o.slots),
        slotProps: ge({}, o.slotProps, {
            field: u => ge({}, Yv(o.slotProps?.field, u), cG(o), {
                ref: n
            }),
            toolbar: ge({
                hidden: !1
            }, o.slotProps?.toolbar)
        })
    })
      , {renderPicker: c} = E9e({
        props: s,
        valueManager: Ps,
        valueType: "date",
        getOpenDialogAriaText: K7({
            utils: i,
            formatKey: "fullDate",
            contextTranslation: r.openDatePickerDialogue,
            propsTranslation: s.localeText?.openDatePickerDialogue
        }),
        validator: hy
    });
    return c()
});
MG.propTypes = {
    autoFocus: ze.bool,
    className: ze.string,
    closeOnSelect: ze.bool,
    dayOfWeekFormatter: ze.func,
    defaultValue: ze.object,
    disabled: ze.bool,
    disableFuture: ze.bool,
    disableHighlightToday: ze.bool,
    disableOpenPicker: ze.bool,
    disablePast: ze.bool,
    displayWeekNumber: ze.bool,
    enableAccessibleFieldDOMStructure: ze.any,
    fixedWeekNumber: ze.number,
    format: ze.string,
    formatDensity: ze.oneOf(["dense", "spacious"]),
    inputRef: AN,
    label: ze.node,
    loading: ze.bool,
    localeText: ze.object,
    maxDate: ze.object,
    minDate: ze.object,
    monthsPerRow: ze.oneOf([3, 4]),
    name: ze.string,
    onAccept: ze.func,
    onChange: ze.func,
    onClose: ze.func,
    onError: ze.func,
    onMonthChange: ze.func,
    onOpen: ze.func,
    onSelectedSectionsChange: ze.func,
    onViewChange: ze.func,
    onYearChange: ze.func,
    open: ze.bool,
    openTo: ze.oneOf(["day", "month", "year"]),
    orientation: ze.oneOf(["landscape", "portrait"]),
    readOnly: ze.bool,
    reduceAnimations: ze.bool,
    referenceDate: ze.object,
    renderLoading: ze.func,
    selectedSections: ze.oneOfType([ze.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), ze.number]),
    shouldDisableDate: ze.func,
    shouldDisableMonth: ze.func,
    shouldDisableYear: ze.func,
    showDaysOutsideCurrentMonth: ze.bool,
    slotProps: ze.object,
    slots: ze.object,
    sx: ze.oneOfType([ze.arrayOf(ze.oneOfType([ze.func, ze.object, ze.bool])), ze.func, ze.object]),
    timezone: ze.string,
    value: ze.object,
    view: ze.oneOf(["day", "month", "year"]),
    viewRenderers: ze.shape({
        day: ze.func,
        month: ze.func,
        year: ze.func
    }),
    views: ze.arrayOf(ze.oneOf(["day", "month", "year"]).isRequired),
    yearsOrder: ze.oneOf(["asc", "desc"]),
    yearsPerRow: ze.oneOf([3, 4])
};
const A9e = ["desktopModeMediaQuery"]
  , M9e = A.forwardRef(function(t, n) {
    const r = hr({
        props: t,
        name: "MuiDatePicker"
    })
      , {desktopModeMediaQuery: i=QNe} = r
      , o = Qt(r, A9e);
    return n1(i, {
        defaultMatches: !0
    }) ? g.jsx(AG, ge({
        ref: n
    }, o)) : g.jsx(MG, ge({
        ref: n
    }, o))
});
var e0 = {
    exports: {}
}, P9e = e0.exports, G5;
function R9e() {
    return G5 || (G5 = 1,
    (function(e, t) {
        (function(n, r) {
            e.exports = r()
        }
        )(P9e, (function() {
            var n = "week"
              , r = "year";
            return function(i, o, a) {
                var s = o.prototype;
                s.week = function(c) {
                    if (c === void 0 && (c = null),
                    c !== null)
                        return this.add(7 * (c - this.week()), "day");
                    var u = this.$locale().yearStart || 1;
                    if (this.month() === 11 && this.date() > 25) {
                        var f = a(this).startOf(r).add(1, r).date(u)
                          , h = a(this).endOf(n);
                        if (f.isBefore(h))
                            return 1
                    }
                    var m = a(this).startOf(r).date(u).startOf(n).subtract(1, "millisecond")
                      , y = this.diff(m, n, !0);
                    return y < 0 ? a(this).startOf("week").week() : Math.ceil(y)
                }
                ,
                s.weeks = function(c) {
                    return c === void 0 && (c = null),
                    this.week(c)
                }
            }
        }
        ))
    }
    )(e0)),
    e0.exports
}
var D9e = R9e();
const O9e = es(D9e);
var t0 = {
    exports: {}
}, I9e = t0.exports, Y5;
function $9e() {
    return Y5 || (Y5 = 1,
    (function(e, t) {
        (function(n, r) {
            e.exports = r()
        }
        )(I9e, (function() {
            var n = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            }
              , r = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g
              , i = /\d/
              , o = /\d\d/
              , a = /\d\d?/
              , s = /\d*[^-_:/,()\s\d]+/
              , c = {}
              , u = function(S) {
                return (S = +S) + (S > 68 ? 1900 : 2e3)
            }
              , f = function(S) {
                return function(C) {
                    this[S] = +C
                }
            }
              , h = [/[+-]\d\d:?(\d\d)?|Z/, function(S) {
                (this.zone || (this.zone = {})).offset = (function(C) {
                    if (!C || C === "Z")
                        return 0;
                    var w = C.match(/([+-]|\d\d)/g)
                      , k = 60 * w[1] + (+w[2] || 0);
                    return k === 0 ? 0 : w[0] === "+" ? -k : k
                }
                )(S)
            }
            ]
              , m = function(S) {
                var C = c[S];
                return C && (C.indexOf ? C : C.s.concat(C.f))
            }
              , y = function(S, C) {
                var w, k = c.meridiem;
                if (k) {
                    for (var T = 1; T <= 24; T += 1)
                        if (S.indexOf(k(T, 0, C)) > -1) {
                            w = T > 12;
                            break
                        }
                } else
                    w = S === (C ? "pm" : "PM");
                return w
            }
              , b = {
                A: [s, function(S) {
                    this.afternoon = y(S, !1)
                }
                ],
                a: [s, function(S) {
                    this.afternoon = y(S, !0)
                }
                ],
                Q: [i, function(S) {
                    this.month = 3 * (S - 1) + 1
                }
                ],
                S: [i, function(S) {
                    this.milliseconds = 100 * +S
                }
                ],
                SS: [o, function(S) {
                    this.milliseconds = 10 * +S
                }
                ],
                SSS: [/\d{3}/, function(S) {
                    this.milliseconds = +S
                }
                ],
                s: [a, f("seconds")],
                ss: [a, f("seconds")],
                m: [a, f("minutes")],
                mm: [a, f("minutes")],
                H: [a, f("hours")],
                h: [a, f("hours")],
                HH: [a, f("hours")],
                hh: [a, f("hours")],
                D: [a, f("day")],
                DD: [o, f("day")],
                Do: [s, function(S) {
                    var C = c.ordinal
                      , w = S.match(/\d+/);
                    if (this.day = w[0],
                    C)
                        for (var k = 1; k <= 31; k += 1)
                            C(k).replace(/\[|\]/g, "") === S && (this.day = k)
                }
                ],
                w: [a, f("week")],
                ww: [o, f("week")],
                M: [a, f("month")],
                MM: [o, f("month")],
                MMM: [s, function(S) {
                    var C = m("months")
                      , w = (m("monthsShort") || C.map((function(k) {
                        return k.slice(0, 3)
                    }
                    ))).indexOf(S) + 1;
                    if (w < 1)
                        throw new Error;
                    this.month = w % 12 || w
                }
                ],
                MMMM: [s, function(S) {
                    var C = m("months").indexOf(S) + 1;
                    if (C < 1)
                        throw new Error;
                    this.month = C % 12 || C
                }
                ],
                Y: [/[+-]?\d+/, f("year")],
                YY: [o, function(S) {
                    this.year = u(S)
                }
                ],
                YYYY: [/\d{4}/, f("year")],
                Z: h,
                ZZ: h
            };
            function v(S) {
                var C, w;
                C = S,
                w = c && c.formats;
                for (var k = (S = C.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(O, I, M) {
                    var B = M && M.toUpperCase();
                    return I || w[M] || n[M] || w[B].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(L, F, j) {
                        return F || j.slice(1)
                    }
                    ))
                }
                ))).match(r), T = k.length, E = 0; E < T; E += 1) {
                    var P = k[E]
                      , D = b[P]
                      , $ = D && D[0]
                      , z = D && D[1];
                    k[E] = z ? {
                        regex: $,
                        parser: z
                    } : P.replace(/^\[|\]$/g, "")
                }
                return function(O) {
                    for (var I = {}, M = 0, B = 0; M < T; M += 1) {
                        var L = k[M];
                        if (typeof L == "string")
                            B += L.length;
                        else {
                            var F = L.regex
                              , j = L.parser
                              , N = O.slice(B)
                              , H = F.exec(N)[0];
                            j.call(I, H),
                            O = O.replace(H, "")
                        }
                    }
                    return (function(Z) {
                        var q = Z.afternoon;
                        if (q !== void 0) {
                            var V = Z.hours;
                            q ? V < 12 && (Z.hours += 12) : V === 12 && (Z.hours = 0),
                            delete Z.afternoon
                        }
                    }
                    )(I),
                    I
                }
            }
            return function(S, C, w) {
                w.p.customParseFormat = !0,
                S && S.parseTwoDigitYear && (u = S.parseTwoDigitYear);
                var k = C.prototype
                  , T = k.parse;
                k.parse = function(E) {
                    var P = E.date
                      , D = E.utc
                      , $ = E.args;
                    this.$u = D;
                    var z = $[1];
                    if (typeof z == "string") {
                        var O = $[2] === !0
                          , I = $[3] === !0
                          , M = O || I
                          , B = $[2];
                        I && (B = $[2]),
                        c = this.$locale(),
                        !O && B && (c = w.Ls[B]),
                        this.$d = (function(N, H, Z, q) {
                            try {
                                if (["x", "X"].indexOf(H) > -1)
                                    return new Date((H === "X" ? 1e3 : 1) * N);
                                var V = v(H)(N)
                                  , Y = V.year
                                  , W = V.month
                                  , te = V.day
                                  , K = V.hours
                                  , ee = V.minutes
                                  , re = V.seconds
                                  , ie = V.milliseconds
                                  , J = V.zone
                                  , oe = V.week
                                  , we = new Date
                                  , xe = te || (Y || W ? 1 : we.getDate())
                                  , se = Y || we.getFullYear()
                                  , de = 0;
                                Y && !W || (de = W > 0 ? W - 1 : we.getMonth());
                                var Se, Ce = K || 0, Ye = ee || 0, ye = re || 0, Ke = ie || 0;
                                return J ? new Date(Date.UTC(se, de, xe, Ce, Ye, ye, Ke + 60 * J.offset * 1e3)) : Z ? new Date(Date.UTC(se, de, xe, Ce, Ye, ye, Ke)) : (Se = new Date(se,de,xe,Ce,Ye,ye,Ke),
                                oe && (Se = q(Se).week(oe).toDate()),
                                Se)
                            } catch {
                                return new Date("")
                            }
                        }
                        )(P, z, D, w),
                        this.init(),
                        B && B !== !0 && (this.$L = this.locale(B).$L),
                        M && P != this.format(z) && (this.$d = new Date("")),
                        c = {}
                    } else if (z instanceof Array)
                        for (var L = z.length, F = 1; F <= L; F += 1) {
                            $[1] = z[F - 1];
                            var j = w.apply(this, $);
                            if (j.isValid()) {
                                this.$d = j.$d,
                                this.$L = j.$L,
                                this.init();
                                break
                            }
                            F === L && (this.$d = new Date(""))
                        }
                    else
                        T.call(this, E)
                }
            }
        }
        ))
    }
    )(t0)),
    t0.exports
}
var L9e = $9e();
const j9e = es(L9e);
var n0 = {
    exports: {}
}, B9e = n0.exports, Z5;
function z9e() {
    return Z5 || (Z5 = 1,
    (function(e, t) {
        (function(n, r) {
            e.exports = r()
        }
        )(B9e, (function() {
            var n = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            };
            return function(r, i, o) {
                var a = i.prototype
                  , s = a.format;
                o.en.formats = n,
                a.format = function(c) {
                    c === void 0 && (c = "YYYY-MM-DDTHH:mm:ssZ");
                    var u = this.$locale().formats
                      , f = (function(h, m) {
                        return h.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(y, b, v) {
                            var S = v && v.toUpperCase();
                            return b || m[v] || n[v] || m[S].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(C, w, k) {
                                return w || k.slice(1)
                            }
                            ))
                        }
                        ))
                    }
                    )(c, u === void 0 ? {} : u);
                    return s.call(this, f)
                }
            }
        }
        ))
    }
    )(n0)),
    n0.exports
}
var F9e = z9e();
const N9e = es(F9e);
var r0 = {
    exports: {}
}, U9e = r0.exports, Q5;
function V9e() {
    return Q5 || (Q5 = 1,
    (function(e, t) {
        (function(n, r) {
            e.exports = r()
        }
        )(U9e, (function() {
            return function(n, r, i) {
                r.prototype.isBetween = function(o, a, s, c) {
                    var u = i(o)
                      , f = i(a)
                      , h = (c = c || "()")[0] === "("
                      , m = c[1] === ")";
                    return (h ? this.isAfter(u, s) : !this.isBefore(u, s)) && (m ? this.isBefore(f, s) : !this.isAfter(f, s)) || (h ? this.isBefore(u, s) : !this.isAfter(u, s)) && (m ? this.isAfter(f, s) : !this.isBefore(f, s))
                }
            }
        }
        ))
    }
    )(r0)),
    r0.exports
}
var H9e = V9e();
const q9e = es(H9e);
var i0 = {
    exports: {}
}, W9e = i0.exports, K5;
function G9e() {
    return K5 || (K5 = 1,
    (function(e, t) {
        (function(n, r) {
            e.exports = r()
        }
        )(W9e, (function() {
            return function(n, r) {
                var i = r.prototype
                  , o = i.format;
                i.format = function(a) {
                    var s = this
                      , c = this.$locale();
                    if (!this.isValid())
                        return o.bind(this)(a);
                    var u = this.$utils()
                      , f = (a || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(h) {
                        switch (h) {
                        case "Q":
                            return Math.ceil((s.$M + 1) / 3);
                        case "Do":
                            return c.ordinal(s.$D);
                        case "gggg":
                            return s.weekYear();
                        case "GGGG":
                            return s.isoWeekYear();
                        case "wo":
                            return c.ordinal(s.week(), "W");
                        case "w":
                        case "ww":
                            return u.s(s.week(), h === "w" ? 1 : 2, "0");
                        case "W":
                        case "WW":
                            return u.s(s.isoWeek(), h === "W" ? 1 : 2, "0");
                        case "k":
                        case "kk":
                            return u.s(String(s.$H === 0 ? 24 : s.$H), h === "k" ? 1 : 2, "0");
                        case "X":
                            return Math.floor(s.$d.getTime() / 1e3);
                        case "x":
                            return s.$d.getTime();
                        case "z":
                            return "[" + s.offsetName() + "]";
                        case "zzz":
                            return "[" + s.offsetName("long") + "]";
                        default:
                            return h
                        }
                    }
                    ));
                    return o.bind(this)(f)
                }
            }
        }
        ))
    }
    )(i0)),
    i0.exports
}
var Y9e = G9e();
const Z9e = es(Y9e);
Gr.extend(N9e);
Gr.extend(O9e);
Gr.extend(q9e);
Gr.extend(Z9e);
const Q9e = {
    YY: "year",
    YYYY: {
        sectionType: "year",
        contentType: "digit",
        maxLength: 4
    },
    M: {
        sectionType: "month",
        contentType: "digit",
        maxLength: 2
    },
    MM: "month",
    MMM: {
        sectionType: "month",
        contentType: "letter"
    },
    MMMM: {
        sectionType: "month",
        contentType: "letter"
    },
    D: {
        sectionType: "day",
        contentType: "digit",
        maxLength: 2
    },
    DD: "day",
    Do: {
        sectionType: "day",
        contentType: "digit-with-letter"
    },
    d: {
        sectionType: "weekDay",
        contentType: "digit",
        maxLength: 2
    },
    dd: {
        sectionType: "weekDay",
        contentType: "letter"
    },
    ddd: {
        sectionType: "weekDay",
        contentType: "letter"
    },
    dddd: {
        sectionType: "weekDay",
        contentType: "letter"
    },
    A: "meridiem",
    a: "meridiem",
    H: {
        sectionType: "hours",
        contentType: "digit",
        maxLength: 2
    },
    HH: "hours",
    h: {
        sectionType: "hours",
        contentType: "digit",
        maxLength: 2
    },
    hh: "hours",
    m: {
        sectionType: "minutes",
        contentType: "digit",
        maxLength: 2
    },
    mm: "minutes",
    s: {
        sectionType: "seconds",
        contentType: "digit",
        maxLength: 2
    },
    ss: "seconds"
}
  , K9e = {
    year: "YYYY",
    month: "MMMM",
    monthShort: "MMM",
    dayOfMonth: "D",
    dayOfMonthFull: "Do",
    weekday: "dddd",
    weekdayShort: "dd",
    hours24h: "HH",
    hours12h: "hh",
    meridiem: "A",
    minutes: "mm",
    seconds: "ss",
    fullDate: "ll",
    keyboardDate: "L",
    shortDate: "MMM D",
    normalDate: "D MMMM",
    normalDateWithWeekday: "ddd, MMM D",
    fullTime: "LT",
    fullTime12h: "hh:mm A",
    fullTime24h: "HH:mm",
    keyboardDateTime: "L LT",
    keyboardDateTime12h: "L hh:mm A",
    keyboardDateTime24h: "L HH:mm"
}
  , S2 = ["Missing UTC plugin", "To be able to use UTC or timezones, you have to enable the `utc` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join(`
`)
  , X5 = ["Missing timezone plugin", "To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join(`
`)
  , X9e = (e, t) => t ? (...n) => e(...n).locale(t) : e;
class J9e {
    constructor({locale: t, formats: n}={}) {
        this.isMUIAdapter = !0,
        this.isTimezoneCompatible = !0,
        this.lib = "dayjs",
        this.dayjs = void 0,
        this.locale = void 0,
        this.formats = void 0,
        this.escapedCharacters = {
            start: "[",
            end: "]"
        },
        this.formatTokenMap = Q9e,
        this.setLocaleToValue = r => {
            const i = this.getCurrentLocaleCode();
            return i === r.locale() ? r : r.locale(i)
        }
        ,
        this.hasUTCPlugin = () => typeof Gr.utc < "u",
        this.hasTimezonePlugin = () => typeof Gr.tz < "u",
        this.isSame = (r, i, o) => {
            const a = this.setTimezone(i, this.getTimezone(r));
            return r.format(o) === a.format(o)
        }
        ,
        this.cleanTimezone = r => {
            switch (r) {
            case "default":
                return;
            case "system":
                return Gr.tz.guess();
            default:
                return r
            }
        }
        ,
        this.createSystemDate = r => {
            if (this.hasUTCPlugin() && this.hasTimezonePlugin()) {
                const i = Gr.tz.guess();
                return i !== "UTC" ? Gr.tz(r, i) : Gr(r)
            }
            return Gr(r)
        }
        ,
        this.createUTCDate = r => {
            if (!this.hasUTCPlugin())
                throw new Error(S2);
            return Gr.utc(r)
        }
        ,
        this.createTZDate = (r, i) => {
            if (!this.hasUTCPlugin())
                throw new Error(S2);
            if (!this.hasTimezonePlugin())
                throw new Error(X5);
            const o = r !== void 0 && !r.endsWith("Z");
            return Gr(r).tz(this.cleanTimezone(i), o)
        }
        ,
        this.getLocaleFormats = () => {
            const r = Gr.Ls
              , i = this.locale || "en";
            let o = r[i];
            return o === void 0 && (o = r.en),
            o.formats
        }
        ,
        this.adjustOffset = r => {
            if (!this.hasTimezonePlugin())
                return r;
            const i = this.getTimezone(r);
            if (i !== "UTC") {
                const o = r.tz(this.cleanTimezone(i), !0);
                if (o.$offset === (r.$offset ?? 0))
                    return r;
                r.$offset = o.$offset
            }
            return r
        }
        ,
        this.date = (r, i="default") => {
            if (r === null)
                return null;
            let o;
            return i === "UTC" ? o = this.createUTCDate(r) : i === "system" || i === "default" && !this.hasTimezonePlugin() ? o = this.createSystemDate(r) : o = this.createTZDate(r, i),
            this.locale === void 0 ? o : o.locale(this.locale)
        }
        ,
        this.getInvalidDate = () => Gr(new Date("Invalid date")),
        this.getTimezone = r => {
            if (this.hasTimezonePlugin()) {
                const i = r.$x?.$timezone;
                if (i)
                    return i
            }
            return this.hasUTCPlugin() && r.isUTC() ? "UTC" : "system"
        }
        ,
        this.setTimezone = (r, i) => {
            if (this.getTimezone(r) === i)
                return r;
            if (i === "UTC") {
                if (!this.hasUTCPlugin())
                    throw new Error(S2);
                return r.utc()
            }
            if (i === "system")
                return r.local();
            if (!this.hasTimezonePlugin()) {
                if (i === "default")
                    return r;
                throw new Error(X5)
            }
            return Gr.tz(r, this.cleanTimezone(i))
        }
        ,
        this.toJsDate = r => r.toDate(),
        this.parse = (r, i) => r === "" ? null : this.dayjs(r, i, this.locale, !0),
        this.getCurrentLocaleCode = () => this.locale || "en",
        this.is12HourCycleInCurrentLocale = () => /A|a/.test(this.getLocaleFormats().LT || ""),
        this.expandFormat = r => {
            const i = this.getLocaleFormats()
              , o = a => a.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (s, c, u) => c || u.slice(1));
            return r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (a, s, c) => {
                const u = c && c.toUpperCase();
                return s || i[c] || o(i[u])
            }
            )
        }
        ,
        this.isValid = r => r == null ? !1 : r.isValid(),
        this.format = (r, i) => this.formatByString(r, this.formats[i]),
        this.formatByString = (r, i) => this.dayjs(r).format(i),
        this.formatNumber = r => r,
        this.isEqual = (r, i) => r === null && i === null ? !0 : r === null || i === null ? !1 : r.toDate().getTime() === i.toDate().getTime(),
        this.isSameYear = (r, i) => this.isSame(r, i, "YYYY"),
        this.isSameMonth = (r, i) => this.isSame(r, i, "YYYY-MM"),
        this.isSameDay = (r, i) => this.isSame(r, i, "YYYY-MM-DD"),
        this.isSameHour = (r, i) => r.isSame(i, "hour"),
        this.isAfter = (r, i) => r > i,
        this.isAfterYear = (r, i) => this.hasUTCPlugin() ? !this.isSameYear(r, i) && r.utc() > i.utc() : r.isAfter(i, "year"),
        this.isAfterDay = (r, i) => this.hasUTCPlugin() ? !this.isSameDay(r, i) && r.utc() > i.utc() : r.isAfter(i, "day"),
        this.isBefore = (r, i) => r < i,
        this.isBeforeYear = (r, i) => this.hasUTCPlugin() ? !this.isSameYear(r, i) && r.utc() < i.utc() : r.isBefore(i, "year"),
        this.isBeforeDay = (r, i) => this.hasUTCPlugin() ? !this.isSameDay(r, i) && r.utc() < i.utc() : r.isBefore(i, "day"),
        this.isWithinRange = (r, [i,o]) => r >= i && r <= o,
        this.startOfYear = r => this.adjustOffset(r.startOf("year")),
        this.startOfMonth = r => this.adjustOffset(r.startOf("month")),
        this.startOfWeek = r => this.adjustOffset(this.setLocaleToValue(r).startOf("week")),
        this.startOfDay = r => this.adjustOffset(r.startOf("day")),
        this.endOfYear = r => this.adjustOffset(r.endOf("year")),
        this.endOfMonth = r => this.adjustOffset(r.endOf("month")),
        this.endOfWeek = r => this.adjustOffset(this.setLocaleToValue(r).endOf("week")),
        this.endOfDay = r => this.adjustOffset(r.endOf("day")),
        this.addYears = (r, i) => this.adjustOffset(i < 0 ? r.subtract(Math.abs(i), "year") : r.add(i, "year")),
        this.addMonths = (r, i) => this.adjustOffset(i < 0 ? r.subtract(Math.abs(i), "month") : r.add(i, "month")),
        this.addWeeks = (r, i) => this.adjustOffset(i < 0 ? r.subtract(Math.abs(i), "week") : r.add(i, "week")),
        this.addDays = (r, i) => this.adjustOffset(i < 0 ? r.subtract(Math.abs(i), "day") : r.add(i, "day")),
        this.addHours = (r, i) => this.adjustOffset(i < 0 ? r.subtract(Math.abs(i), "hour") : r.add(i, "hour")),
        this.addMinutes = (r, i) => this.adjustOffset(i < 0 ? r.subtract(Math.abs(i), "minute") : r.add(i, "minute")),
        this.addSeconds = (r, i) => this.adjustOffset(i < 0 ? r.subtract(Math.abs(i), "second") : r.add(i, "second")),
        this.getYear = r => r.year(),
        this.getMonth = r => r.month(),
        this.getDate = r => r.date(),
        this.getHours = r => r.hour(),
        this.getMinutes = r => r.minute(),
        this.getSeconds = r => r.second(),
        this.getMilliseconds = r => r.millisecond(),
        this.setYear = (r, i) => this.adjustOffset(r.set("year", i)),
        this.setMonth = (r, i) => this.adjustOffset(r.set("month", i)),
        this.setDate = (r, i) => this.adjustOffset(r.set("date", i)),
        this.setHours = (r, i) => this.adjustOffset(r.set("hour", i)),
        this.setMinutes = (r, i) => this.adjustOffset(r.set("minute", i)),
        this.setSeconds = (r, i) => this.adjustOffset(r.set("second", i)),
        this.setMilliseconds = (r, i) => this.adjustOffset(r.set("millisecond", i)),
        this.getDaysInMonth = r => r.daysInMonth(),
        this.getWeekArray = r => {
            const i = this.startOfWeek(this.startOfMonth(r))
              , o = this.endOfWeek(this.endOfMonth(r));
            let a = 0
              , s = i;
            const c = [];
            for (; s < o; ) {
                const u = Math.floor(a / 7);
                c[u] = c[u] || [],
                c[u].push(s),
                s = this.addDays(s, 1),
                a += 1
            }
            return c
        }
        ,
        this.getWeekNumber = r => r.week(),
        this.getYearRange = ([r,i]) => {
            const o = this.startOfYear(r)
              , a = this.endOfYear(i)
              , s = [];
            let c = o;
            for (; this.isBefore(c, a); )
                s.push(c),
                c = this.addYears(c, 1);
            return s
        }
        ,
        this.dayjs = X9e(Gr, t),
        this.locale = t,
        this.formats = ge({}, K9e, n),
        Gr.extend(j9e)
    }
    getDayOfWeek(t) {
        return t.day() + 1
    }
}
const vx = ({attributes: e, maxFields: t=5, onChange: n}) => {
    const [r,i] = A.useState(e)
      , [o,a] = A.useState({
        open: !1,
        fieldId: null
    });
    A.useEffect( () => {
        i(e)
    }
    , [e]);
    const s = b => {
        i(b),
        n?.(b)
    }
      , c = b => {
        if (r.length < t) {
            const v = r[0].name.replace(/\s*\d+$/, "") || "Attribute"
              , S = r[0].label.replace(/\s*\d+$/, "") || "Attribute"
              , C = {
                id: Date.now(),
                name: `${v} ${r.length + 1}`,
                label: `${S} ${r.length + 1}`,
                type: r[0].type,
                value: r[0].type === "date" ? null : "",
                options: r[0].options || []
            }
              , k = [...r.slice(0, b + 1), C, ...r.slice(b + 1)].map( (T, E) => ({
                ...T,
                name: `${v} ${E + 1}`,
                label: `${S} ${E + 1}`
            }));
            s(k)
        }
    }
      , u = b => {
        a({
            open: !0,
            fieldId: b
        })
    }
      , f = () => {
        if (o.fieldId !== null) {
            const b = r[0].name.replace(/\s*\d+$/, "") || "Attribute"
              , v = r[0].label.replace(/\s*\d+$/, "") || "Attribute"
              , C = r.filter(w => w.id !== o.fieldId).map( (w, k) => ({
                ...w,
                name: `${b} ${k + 1}`,
                label: `${v} ${k + 1}`
            }));
            s(C)
        }
        a({
            open: !1,
            fieldId: null
        })
    }
      , h = () => {
        a({
            open: !1,
            fieldId: null
        })
    }
      , m = (b, v) => {
        const S = r.map(C => C.id === b ? {
            ...C,
            value: v
        } : C);
        s(S)
    }
      , y = b => {
        switch (b.type) {
        case "text":
            return g.jsx(ct, {
                label: b.label,
                value: b.value ?? "",
                onChange: v => m(b.id, v.target.value),
                size: "small",
                fullWidth: !0
            });
        case "number":
            return g.jsx(ct, {
                label: b.label,
                type: "number",
                value: b.value !== null ? b.value : "",
                onChange: v => m(b.id, v.target.value),
                size: "small",
                fullWidth: !0
            });
        case "dropdown":
            return g.jsx(co, {
                options: b.options || [],
                value: b.value ? String(b.value) : "",
                onChange: (v, S) => m(b.id, S || ""),
                renderInput: v => g.jsx(ct, {
                    ...v,
                    label: b.label,
                    size: "small",
                    fullWidth: !0
                }),
                fullWidth: !0,
                disableClearable: !0
            });
        case "date":
            return g.jsx(Q7, {
                dateAdapter: J9e,
                children: g.jsx(M9e, {
                    label: b.label,
                    value: b.value,
                    onChange: v => m(b.id, v),
                    slotProps: {
                        textField: {
                            fullWidth: !0,
                            size: "small"
                        }
                    }
                })
            });
        default:
            return null
        }
    }
    ;
    return g.jsxs(g.Fragment, {
        children: [g.jsx(Gf, {
            spacing: 2,
            children: r.map( (b, v) => g.jsxs(Gf, {
                direction: "row",
                spacing: 1,
                alignItems: "center",
                children: [y(b), g.jsx(In, {
                    color: "primary",
                    onClick: () => c(v),
                    disabled: r.length >= t,
                    children: g.jsx(Go, {})
                }), g.jsx(In, {
                    color: "error",
                    onClick: () => u(b.id),
                    disabled: r.length === 1,
                    children: g.jsx(D1, {})
                })]
            }, b.id))
        }), g.jsx(tNe, {
            open: o.open,
            title: "Delete confirmation",
            message: "Are you sure you want to delete this field?",
            onConfirm: f,
            onCancel: h
        })]
    })
}
  , e8e = ({initialRows: e=[{
    id: Date.now(),
    uom: null,
    quantity: "",
    primaryQty: "",
    length: null,
    width: null,
    height: null,
    netWeight: null,
    grossWeight: null,
    volume: null,
    lengthUom: "",
    weightUom: "",
    volumeUom: ""
}], maxRows: t=5, onChange: n, uomOptions: r}) => {
    const [i,o] = A.useState(e);
    A.useEffect( () => {
        n?.(i)
    }
    , [i, n]);
    const a = (u, f, h) => {
        const m = i.map(y => y.id === u ? {
            ...y,
            [f]: h
        } : y);
        o(m)
    }
      , s = u => {
        if (i.length < t) {
            const f = {
                id: Date.now(),
                uom: null,
                quantity: "",
                primaryQty: "",
                length: null,
                width: null,
                height: null,
                lengthUom: "",
                netWeight: null,
                grossWeight: null,
                weightUom: "",
                volume: null,
                volumeUom: ""
            }
              , h = [...i.slice(0, u + 1), f, ...i.slice(u + 1)];
            o(h)
        }
    }
      , c = u => {
        if (i.length === 1)
            return;
        const f = i.filter(h => h.id !== u);
        o(f)
    }
    ;
    return g.jsx(Gf, {
        spacing: 2,
        children: i.map( (u, f) => g.jsxs(Gf, {
            spacing: 2,
            children: [g.jsxs(je, {
                container: !0,
                spacing: 2,
                children: [g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(co, {
                        fullWidth: !0,
                        disablePortal: !0,
                        options: r,
                        value: r.find(h => h.uomId === u.uom) ?? null,
                        getOptionLabel: h => `${h.uomDesc} (${h.uomCode})` || "",
                        isOptionEqualToValue: (h, m) => h.uomId === m.uomId,
                        onChange: (h, m) => a(u.id, "uom", m?.uomId?.toString() || ""),
                        size: "small",
                        renderInput: h => g.jsx(ct, {
                            ...h,
                            label: "UOM",
                            size: "small"
                        })
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Qty",
                        value: u.quantity,
                        onChange: h => a(u.id, "quantity", h.target.value)
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Primary Qty",
                        value: u.primaryQty,
                        onChange: h => a(u.id, "primaryQty", h.target.value)
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Length",
                        value: u.length,
                        onChange: h => a(u.id, "length", h.target.value)
                    })
                })]
            }), g.jsxs(je, {
                container: !0,
                spacing: 2,
                children: [g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Width",
                        value: u.width,
                        onChange: h => a(u.id, "width", h.target.value)
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Height",
                        value: u.height,
                        onChange: h => a(u.id, "height", h.target.value)
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Length UOM",
                        value: u.lengthUom,
                        onChange: h => a(u.id, "lengthUom", h.target.value)
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Net Weight",
                        value: u.netWeight,
                        onChange: h => a(u.id, "netWeight", h.target.value)
                    })
                })]
            }), g.jsxs(je, {
                container: !0,
                spacing: 2,
                children: [g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Gross Weight",
                        value: u.grossWeight,
                        onChange: h => a(u.id, "grossWeight", h.target.value)
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Weight UOM",
                        value: u.weightUom,
                        onChange: h => a(u.id, "weightUom", h.target.value)
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Volume",
                        value: u.volume,
                        onChange: h => a(u.id, "volume", h.target.value)
                    })
                }), g.jsxs(je, {
                    size: {
                        xs: 12,
                        sm: 6,
                        md: 3,
                        lg: 3
                    },
                    children: [g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Volume UOM",
                        value: u.volumeUom,
                        onChange: h => a(u.id, "volumeUom", h.target.value)
                    }), g.jsx(In, {
                        color: "primary",
                        onClick: () => s(f),
                        disabled: i.length >= t,
                        children: g.jsx(Go, {})
                    }), g.jsx(In, {
                        color: "error",
                        onClick: () => c(u.id),
                        disabled: i.length === 1,
                        children: g.jsx(D1, {})
                    })]
                })]
            })]
        }, u.id))
    })
}
  , t8e = ({onCancel: e, initialData: t=null, mode: n="add", productMasterId: r=0}) => {
    const i = [{
        id: Date.now(),
        uom: null,
        quantity: "",
        primaryQty: "",
        length: null,
        width: null,
        height: null,
        netWeight: null,
        grossWeight: null,
        volume: null,
        lengthUom: "",
        weightUom: "",
        volumeUom: ""
    }]
      , o = {
        productId: "",
        productTypeId: null,
        productGroupId: null,
        productCategoryId: null,
        salesStatusId: null,
        languageId: null,
        shortDescription: "",
        longDescription: "",
        attribute1: "",
        attribute2: "",
        attribute3: "",
        attribute4: "",
        attribute5: "",
        date1: null,
        date2: null,
        date3: null,
        date4: null,
        date5: null,
        number1: null,
        number2: null,
        number3: null,
        number4: null,
        number5: null,
        dropDown1: "",
        dropDown2: "",
        dropDown3: "",
        dropDown4: "",
        dropDown5: "",
        productMasterUomDto: i,
        unitOfMeasurement: null,
        manufacturerId: null,
        manufacturerPartNumber: "",
        notes: ""
    }
      , [a,s] = A.useState(t?.productMasterUomDto && t.productMasterUomDto.length > 0 ? t.productMasterUomDto : i)
      , [c,u] = A.useState(t || o)
      , f = [{
        id: 1,
        name: "Number1",
        label: "Number 1",
        type: "number",
        value: null
    }]
      , h = [{
        id: 1,
        name: "DropDown1",
        label: "DropDown 1",
        type: "dropdown",
        value: "",
        options: ["Option 1", "Option 2", "Option 3"]
    }]
      , m = [{
        id: 1,
        name: "Date1",
        label: "Date 1",
        type: "date",
        value: null
    }]
      , y = [{
        id: 1,
        name: "attribute1",
        label: "Attribute 1",
        type: "text",
        value: ""
    }];
    n === "edit" && t && (["attribute1", "attribute2", "attribute3", "attribute4", "attribute5"].forEach( (se, de) => {
        const Se = t[se];
        Se && Se.trim() !== "" && (de === 0 ? y[0].value = Se : y.push({
            id: de + 1,
            name: se,
            label: `Attribute ${de + 1}`,
            type: "text",
            value: Se
        }))
    }
    ),
    ["number1", "number2", "number3", "number4", "number5"].forEach( (se, de) => {
        const Se = t[se];
        Se != null && (de === 0 ? f[0].value = Se : f.push({
            id: de + 1,
            name: se,
            label: `Number ${de + 1}`,
            type: "number",
            value: Se
        }))
    }
    ),
    ["dropDown1", "dropDown2", "dropDown3", "dropDown4", "dropDown5"].forEach( (se, de) => {
        const Se = t[se];
        Se && Se.trim() !== "" && (de === 0 ? h[0].value = Se : h.push({
            id: de + 1,
            name: se,
            label: `DropDown ${de + 1}`,
            type: "dropdown",
            value: Se,
            options: ["Option 1", "Option 2", "Option 3"]
        }))
    }
    ),
    ["date1", "date2", "date3", "date4", "date5"].forEach( (se, de) => {
        const Se = t[se];
        if (Se) {
            const Ce = Gr(Se);
            de === 0 ? m[0].value = Ce : m.push({
                id: de + 1,
                name: se,
                label: `Date ${de + 1}`,
                type: "date",
                value: Ce
            })
        }
    }
    ));
    const b = uh()
      , [v,S] = A.useState(y)
      , [C,w] = A.useState(f)
      , [k,T] = A.useState(h)
      , [E,P] = A.useState(m)
      , [D,$] = A.useState(!1)
      , [z,O] = A.useState(!1)
      , [I,M] = A.useState("")
      , [B,L] = A.useState("success")
      , [F,j] = A.useState(!1);
    A.useEffect( () => {
        u(J => ({
            ...J,
            productMasterUomDto: a
        }))
    }
    , [a]);
    const {mutate: N} = $ye()
      , {mutate: H} = Lye()
      , Z = J => {
        const {name: oe, value: we} = J.target;
        u(xe => ({
            ...xe,
            [oe]: we
        }))
    }
      , {data: q=[]} = L6()
      , {data: V=[]} = Oye()
      , {data: Y=[]} = Iye()
      , {data: W=[]} = $6()
      , {data: te=[]} = I6()
      , {data: K=[]} = Rye()
      , {data: ee=[]} = Dye(c.unitOfMeasurement)
      , re = () => {
        u({
            productId: "",
            productTypeId: null,
            productGroupId: null,
            productCategoryId: null,
            salesStatusId: null,
            languageId: null,
            shortDescription: "",
            longDescription: "",
            attribute1: "",
            attribute2: "",
            attribute3: "",
            attribute4: "",
            attribute5: "",
            date1: null,
            date2: null,
            date3: null,
            date4: null,
            date5: null,
            number1: null,
            number2: null,
            number3: null,
            number4: null,
            number5: null,
            dropDown1: "",
            dropDown2: "",
            dropDown3: "",
            dropDown4: "",
            dropDown5: "",
            productMasterUomDto: [],
            unitOfMeasurement: null,
            manufacturerId: null,
            manufacturerPartNumber: "",
            notes: ""
        }),
        S(y),
        w(f),
        P(m),
        T(h),
        s([{
            id: Date.now(),
            uom: null,
            quantity: "",
            primaryQty: "",
            length: null,
            width: null,
            height: null,
            netWeight: null,
            grossWeight: null,
            volume: null,
            lengthUom: "",
            weightUom: "",
            volumeUom: ""
        }])
    }
      , ie = J => {
        J.preventDefault(),
        $(!0),
        j(!0);
        const oe = Object.fromEntries(v.map( (Se, Ce) => [`attribute${Ce + 1}`, Se.value]))
          , we = Object.fromEntries(C.map( (Se, Ce) => [`number${Ce + 1}`, Se.value]))
          , xe = Object.fromEntries(k.map( (Se, Ce) => [`dropDown${Ce + 1}`, Se.value]))
          , se = Object.fromEntries(E.map( (Se, Ce) => [`date${Ce + 1}`, Se.value]))
          , de = {
            ...c,
            ...oe,
            ...we,
            ...xe,
            ...se,
            productMasterUomDto: a
        };
        n === "edit" && r ? ($(!0),
        j(!0),
        H({
            id: r,
            data: de
        }, {
            onSuccess: () => {
                b.invalidateQueries({
                    queryKey: ["readProductMasterForm"]
                }),
                M("Product Master Form updated successfully!"),
                L("success"),
                O(!0),
                re(),
                e()
            }
            ,
            onError: Se => {
                M(`Failed to update: ${Se.message}`),
                L("error"),
                O(!0)
            }
            ,
            onSettled: () => {
                setTimeout( () => {
                    $(!1),
                    j(!1)
                }
                , 5e3)
            }
        })) : N(de, {
            onSuccess: () => {
                b.invalidateQueries({
                    queryKey: ["readProductMasterForm"]
                }),
                M("Product Master Form submitted successfully!"),
                L("success"),
                O(!0),
                re(),
                e()
            }
            ,
            onError: Se => {
                M(`Failed to submit: ${Se.message}`),
                L("error"),
                O(!0)
            }
            ,
            onSettled: () => {
                setTimeout( () => {
                    $(!1),
                    j(!1)
                }
                , 5e3)
            }
        })
    }
    ;
    return g.jsxs(Be, {
        sx: {
            maxWidth: "100%",
            width: "100%"
        },
        children: [g.jsxs(Be, {
            sx: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                mb: 2
            },
            children: [g.jsx(Ae, {
                variant: "h5",
                children: n === "add" ? "Add Product Master" : "Edit Product Master"
            }), g.jsx(Mt, {
                variant: "outlined",
                color: "primary",
                onClick: e,
                size: "small",
                sx: {
                    borderRadius: "8px",
                    minWidth: "100px"
                },
                children: "Back"
            })]
        }), g.jsxs("form", {
            onSubmit: ie,
            style: {
                width: "100%"
            },
            children: [g.jsxs(je, {
                container: !0,
                spacing: 2,
                children: [g.jsx(je, {
                    size: {
                        xs: 12
                    },
                    children: g.jsx(Be, {
                        component: "section",
                        children: g.jsx(Ae, {
                            variant: "body1",
                            gutterBottom: !0,
                            children: "General Data"
                        })
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        label: "Product Id",
                        name: "productId",
                        value: c.productId,
                        onChange: Z,
                        required: !0
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(co, {
                        disablePortal: !0,
                        options: q,
                        value: q.find(J => J.productTypeId === c.productTypeId) ?? null,
                        getOptionLabel: J => `${J.productTypeDesc} (${J.productTypeCode})` || "",
                        isOptionEqualToValue: (J, oe) => J.productTypeId === oe.productTypeId,
                        onChange: (J, oe) => {
                            u(we => ({
                                ...we,
                                productTypeId: oe?.productTypeId || null
                            }))
                        }
                        ,
                        fullWidth: !0,
                        renderInput: J => g.jsx(ct, {
                            ...J,
                            label: "Product Type",
                            size: "small",
                            fullWidth: !0,
                            required: !0
                        })
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(co, {
                        disablePortal: !0,
                        options: V,
                        value: V.find(J => J.productGroupId === c.productGroupId) || null,
                        getOptionLabel: J => `${J.productGroupDesc} (${J.productGroupCode})` || "",
                        isOptionEqualToValue: (J, oe) => J.productGroupId === oe.productGroupId,
                        onChange: (J, oe) => {
                            u(we => ({
                                ...we,
                                productGroupId: oe?.productGroupId
                            }))
                        }
                        ,
                        fullWidth: !0,
                        renderInput: J => g.jsx(ct, {
                            ...J,
                            label: "Product Group",
                            size: "small",
                            fullWidth: !0,
                            required: !0
                        })
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(co, {
                        disablePortal: !0,
                        options: Y,
                        value: Y.find(J => J.productCategoryId === c.productCategoryId) || null,
                        getOptionLabel: J => `${J.productCategoryDesc} (${J.productCategoryCode})` || "",
                        isOptionEqualToValue: (J, oe) => J.productCategoryId === oe.productCategoryId,
                        onChange: (J, oe) => {
                            u(we => ({
                                ...we,
                                productCategoryId: oe?.productCategoryId
                            }))
                        }
                        ,
                        fullWidth: !0,
                        renderInput: J => g.jsx(ct, {
                            ...J,
                            label: "Product Category",
                            size: "small",
                            fullWidth: !0,
                            required: !0
                        })
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(co, {
                        disablePortal: !0,
                        options: te,
                        value: te.find(J => J.languageId === c.languageId) || null,
                        getOptionLabel: J => `${J.languageDesc} (${J.languageCode})` || "",
                        isOptionEqualToValue: (J, oe) => J.languageId === oe.languageId,
                        onChange: (J, oe) => {
                            u(we => ({
                                ...we,
                                languageId: oe?.languageId
                            }))
                        }
                        ,
                        fullWidth: !0,
                        renderInput: J => g.jsx(ct, {
                            ...J,
                            label: "Language",
                            size: "small",
                            fullWidth: !0,
                            required: !0
                        })
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(co, {
                        disablePortal: !0,
                        options: W,
                        value: W.find(J => J.salesStatusId === c.salesStatusId) || null,
                        getOptionLabel: J => `${J.salesStatusDesc} (${J.salesStatusCode})` || "",
                        isOptionEqualToValue: (J, oe) => J.salesStatusId === oe.salesStatusId,
                        onChange: (J, oe) => {
                            u(we => ({
                                ...we,
                                salesStatusId: oe?.salesStatusId
                            }))
                        }
                        ,
                        fullWidth: !0,
                        renderInput: J => g.jsx(ct, {
                            ...J,
                            label: "Status",
                            size: "small",
                            fullWidth: !0,
                            required: !0
                        })
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(co, {
                        disablePortal: !0,
                        options: K,
                        value: K.find(J => J.uomDimId === c.unitOfMeasurement) || null,
                        getOptionLabel: J => `${J.uomDimDesc} (${J.uomDimCode})` || "",
                        isOptionEqualToValue: (J, oe) => J.uomDimId === oe.uomDimId,
                        onChange: (J, oe) => {
                            u(we => ({
                                ...we,
                                unitOfMeasurement: oe?.uomDimId
                            }))
                        }
                        ,
                        fullWidth: !0,
                        renderInput: J => g.jsx(ct, {
                            ...J,
                            label: "Unit of Measurement",
                            size: "small",
                            fullWidth: !0,
                            required: !0
                        })
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        multiline: !0,
                        rows: 2,
                        label: "Short Description",
                        name: "shortDescription",
                        value: c.shortDescription,
                        onChange: Z,
                        required: !0
                    })
                }), g.jsx(je, {
                    size: {
                        xs: 12,
                        sm: 12,
                        md: 6,
                        lg: 4
                    },
                    children: g.jsx(ct, {
                        fullWidth: !0,
                        size: "small",
                        multiline: !0,
                        rows: 2,
                        label: "Long Description",
                        name: "longDescription",
                        value: c.longDescription,
                        onChange: Z,
                        required: !0
                    })
                }), g.jsx(je, {}), g.jsxs(je, {
                    container: !0,
                    spacing: 2,
                    children: [g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 6,
                            md: 6
                        },
                        children: g.jsx(vx, {
                            attributes: v,
                            maxFields: 5,
                            onChange: J => S(J)
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 6,
                            md: 6
                        },
                        children: g.jsx(vx, {
                            attributes: E,
                            maxFields: 5,
                            onChange: J => P(J)
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 6,
                            md: 6
                        },
                        children: g.jsx(vx, {
                            attributes: C,
                            maxFields: 5,
                            onChange: J => w(J)
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 6,
                            md: 6
                        },
                        children: g.jsx(vx, {
                            attributes: k,
                            maxFields: 5,
                            onChange: J => T(J)
                        })
                    }), g.jsx(je, {}), g.jsx(je, {
                        size: 12,
                        children: g.jsx(e8e, {
                            initialRows: a,
                            maxRows: 5,
                            onChange: J => {
                                s(J)
                            }
                            ,
                            uomOptions: ee
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(co, {
                            disablePortal: !0,
                            options: W,
                            value: W.find(J => J.salesStatusId === c.manufacturerId) || null,
                            getOptionLabel: J => `${J.salesStatusDesc} (${J.salesStatusCode})` || "",
                            isOptionEqualToValue: (J, oe) => J.salesStatusId === oe.salesStatusId,
                            onChange: (J, oe) => {
                                u(we => ({
                                    ...we,
                                    manufacturerId: oe?.salesStatusId
                                }))
                            }
                            ,
                            fullWidth: !0,
                            renderInput: J => g.jsx(ct, {
                                ...J,
                                label: "Manuafcturer",
                                size: "small",
                                fullWidth: !0,
                                required: !0
                            })
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 6,
                            md: 4
                        },
                        children: g.jsx(ct, {
                            fullWidth: !0,
                            size: "small",
                            label: "Manufacturer Part Number",
                            name: "manufacturerPartNumber",
                            value: c.manufacturerPartNumber,
                            onChange: Z,
                            required: !0
                        })
                    }), g.jsx(je, {
                        size: {
                            xs: 12,
                            sm: 12,
                            md: 6,
                            lg: 4
                        },
                        children: g.jsx(ct, {
                            fullWidth: !0,
                            size: "small",
                            label: "Notes",
                            name: "notes",
                            value: c.notes,
                            onChange: Z,
                            required: !0
                        })
                    }), g.jsxs(je, {
                        size: 12,
                        children: [g.jsx(Mt, {
                            variant: "contained",
                            color: "primary",
                            type: "submit",
                            disabled: D,
                            size: "small",
                            sx: {
                                marginLeft: "10px",
                                borderRadius: "8px",
                                minWidth: "100px"
                            },
                            children: D ? g.jsx(Jr, {
                                size: 20,
                                color: "inherit"
                            }) : n === "add" ? "Submit" : "Update"
                        }), g.jsx(Mt, {
                            variant: "outlined",
                            color: "secondary",
                            onClick: re,
                            disabled: D,
                            size: "small",
                            sx: {
                                marginLeft: "10px",
                                borderRadius: "8px",
                                minWidth: "100px"
                            },
                            children: "Reset"
                        })]
                    })]
                })]
            }), g.jsx(jg, {
                open: F,
                sx: {
                    color: "#fff",
                    zIndex: J => J.zIndex.drawer + 1
                },
                children: g.jsx(Jr, {
                    color: "inherit"
                })
            }), g.jsx(hh, {
                open: z,
                autoHideDuration: 3e3,
                onClose: () => O(!1),
                anchorOrigin: {
                    vertical: "bottom",
                    horizontal: "center"
                },
                children: g.jsx(Mc, {
                    variant: "filled",
                    onClose: () => O(!1),
                    severity: B,
                    sx: {
                        width: "100%"
                    },
                    children: I
                })
            })]
        })]
    })
}
  , n8e = ({onEdit: e}) => {
    const {data: t=[], isLoading: n} = zye()
      , [r,i] = A.useState([])
      , [o,a] = A.useState("asc")
      , [s,c] = A.useState("productId");
    A.useEffect( () => {
        Array.isArray(t) ? i(t) : (console.warn("Unexpected data:", t),
        i([]))
    }
    , [t]);
    const u = N => {
        a(s === N && o === "asc" ? "desc" : "asc"),
        c(N)
    }
    ;
    function f(N, H) {
        return N === "desc" ? (Z, q) => h(Z, q, H) : (Z, q) => -h(Z, q, H)
    }
    function h(N, H, Z) {
        let q = N[Z]
          , V = H[Z];
        return Z === "productType" && (q = N.productType.productTypeDesc),
        Z === "productGroup" && (q = N.productGroup.productGroupDesc),
        Z === "productCategory" && (q = N.productCategory.productCategoryDesc),
        Z === "productType" && (V = H.productType.productTypeDesc),
        Z === "productGroup" && (V = H.productGroup.productGroupDesc),
        Z === "productCategory" && (V = H.productCategory.productCategoryDesc),
        V < q ? -1 : V > q ? 1 : 0
    }
    const [m,y] = A.useState("")
      , [b,v] = A.useState(!1)
      , [S,C] = A.useState("add")
      , [w,k] = A.useState(null)
      , [T,E] = A.useState(!1)
      , [P,D] = A.useState(0)
      , [$,z] = A.useState(10)
      , O = (N, H=null) => {
        C(N),
        k(H),
        v(!0)
    }
      , I = (N, H) => {
        D(H)
    }
      , M = N => {
        z(parseInt(N.target.value, 10)),
        D(0)
    }
      , B = Array.isArray(r) ? r.filter(N => {
        const H = m.toLowerCase();
        return N.productId.toLowerCase().includes(H) || N.productType.productTypeDesc.toLowerCase().includes(H) || N.productType.productTypeCode.toLowerCase().includes(H) || N.productGroup.productGroupDesc.toLowerCase().includes(H) || N.productGroup.productGroupCode.toLowerCase().includes(H) || N.productCategory.productCategoryDesc.toLowerCase().includes(H) || N.productCategory.productCategoryCode.toLowerCase().includes(H) || (N.shortDescription || "").toLowerCase().includes(H) || (N.longDescription || "").toLowerCase().includes(H)
    }
    ) : []
      , F = [...B].sort(f(o, s)).slice(P * $, P * $ + $)
      , j = () => Array($).fill(0).map( (N, H) => g.jsxs(gn, {
        children: [g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "70%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "80%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "75%",
                height: 24,
                animation: "wave"
            })
        }), g.jsx(Me, {
            sx: {
                py: 1
            },
            children: g.jsx(Fn, {
                variant: "text",
                width: "85%",
                height: 24,
                animation: "wave"
            })
        })]
    }, `skeleton-${H}`));
    return g.jsxs(Be, {
        children: [!b && !w && g.jsxs(g.Fragment, {
            children: [g.jsxs(Be, {
                display: "flex",
                justifyContent: "space-between",
                sx: {
                    p: 2,
                    mt: 0
                },
                children: [g.jsx(ct, {
                    label: "Search",
                    placeholder: "search",
                    variant: "outlined",
                    size: "small",
                    value: m,
                    onChange: N => y(N.target.value),
                    sx: {
                        width: 250
                    },
                    disabled: n,
                    InputProps: {
                        endAdornment: n && g.jsx(Jr, {
                            color: "inherit",
                            size: 20
                        })
                    }
                }), g.jsx(Mt, {
                    variant: "contained",
                    startIcon: n ? g.jsx(Jr, {
                        size: 20,
                        color: "inherit"
                    }) : g.jsx(Go, {}),
                    size: "small",
                    sx: {
                        borderRadius: "10px",
                        minWidth: "100px",
                        textTransform: "none"
                    },
                    onClick: () => O("add"),
                    disabled: n,
                    children: "Add New"
                })]
            }), g.jsxs(Ha, {
                component: yn,
                children: [g.jsxs(Ua, {
                    size: "small",
                    children: [g.jsx(qa, {
                        children: g.jsxs(gn, {
                            children: [g.jsx(Me, {
                                sx: {
                                    py: 1,
                                    fontWeight: "bold"
                                },
                                children: n ? g.jsx(Fn, {
                                    variant: "text",
                                    width: "70%",
                                    height: 24,
                                    animation: "wave"
                                }) : g.jsx(Fi, {
                                    active: s === "productId",
                                    direction: s === "productId" ? o : "asc",
                                    onClick: () => u("productId"),
                                    disabled: n,
                                    children: "Product Id"
                                })
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1,
                                    fontWeight: "bold"
                                },
                                children: n ? g.jsx(Fn, {
                                    variant: "text",
                                    width: "70%",
                                    height: 24,
                                    animation: "wave"
                                }) : g.jsx(Fi, {
                                    active: s === "productType",
                                    direction: s === "productType" ? o : "asc",
                                    onClick: () => u("productType"),
                                    disabled: n,
                                    children: "Product Type"
                                })
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1,
                                    fontWeight: "bold"
                                },
                                children: n ? g.jsx(Fn, {
                                    variant: "text",
                                    width: "70%",
                                    height: 24,
                                    animation: "wave"
                                }) : g.jsx(Fi, {
                                    active: s === "productGroup",
                                    direction: s === "productGroup" ? o : "asc",
                                    onClick: () => u("productGroup"),
                                    disabled: n,
                                    children: "Product Group"
                                })
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1,
                                    fontWeight: "bold"
                                },
                                children: n ? g.jsx(Fn, {
                                    variant: "text",
                                    width: "70%",
                                    height: 24,
                                    animation: "wave"
                                }) : g.jsx(Fi, {
                                    active: s === "productCategory",
                                    direction: s === "productCategory" ? o : "asc",
                                    onClick: () => u("productCategory"),
                                    disabled: n,
                                    children: "Product Category"
                                })
                            })]
                        })
                    }), g.jsxs(Va, {
                        children: [n ? j() : F.map(N => g.jsxs(gn, {
                            onClick: () => k(N),
                            sx: {
                                "&:hover": {
                                    backgroundColor: "#f1f1fa",
                                    cursor: "pointer"
                                }
                            },
                            children: [g.jsx(Me, {
                                sx: {
                                    py: 1
                                },
                                children: N.productId
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1
                                },
                                children: N.productType.productTypeDesc
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1
                                },
                                children: N.productGroup.productGroupDesc
                            }), g.jsx(Me, {
                                sx: {
                                    py: 1
                                },
                                children: N.productCategory.productCategoryDesc
                            })]
                        }, N.productMasterId)), !n && F.length === 0 && g.jsx(gn, {
                            children: g.jsx(Me, {
                                colSpan: 5,
                                align: "center",
                                sx: {
                                    py: 2
                                },
                                children: "No data found."
                            })
                        })]
                    })]
                }), g.jsx(Bg, {
                    component: "div",
                    count: n ? 0 : B.length,
                    page: P,
                    onPageChange: I,
                    rowsPerPage: $,
                    onRowsPerPageChange: M,
                    disabled: n
                })]
            })]
        }), w && !b && g.jsx(Be, {
            children: g.jsx(eNe, {
                product: w,
                onBack: () => k(null),
                onEdit: N => e ? e(N) : O("edit", N)
            })
        }), b && g.jsx(Be, {
            sx: {
                backgroundColor: "white",
                p: 2,
                borderRadius: 1
            },
            children: g.jsx(t8e, {
                onCancel: () => v(!1),
                initialData: S === "edit" && w ? w : null,
                mode: S === "edit" ? "edit" : "add",
                productMasterId: w ? w.productMasterId : 0
            })
        }), T && g.jsxs(Be, {
            sx: {
                position: "fixed",
                top: "64px",
                right: 0,
                bottom: 0,
                width: "100%",
                backgroundColor: "white",
                boxShadow: 1,
                overflowY: "auto",
                p: 2,
                zIndex: 1200
            },
            children: [g.jsx(T7, {}), g.jsx(Mt, {
                variant: "outlined",
                onClick: () => E(!1),
                sx: {
                    position: "absolute",
                    top: 16,
                    right: 16
                },
                children: "Close"
            })]
        })]
    })
}
  , r8e = () => g.jsxs(zQ, {
    children: [g.jsx(wi, {
        path: "/login",
        element: g.jsx(Mze, {})
    }), g.jsxs(wi, {
        element: g.jsx(Y1e, {}),
        children: [g.jsx(wi, {
            path: "/home",
            element: g.jsx(mze, {})
        }), g.jsx(wi, {
            path: "/profile",
            element: g.jsx(aze, {})
        }), g.jsx(wi, {
            path: "/profile/update",
            element: g.jsx(lze, {})
        }), g.jsx(wi, {
            path: "/notifications",
            element: g.jsx(oze, {})
        }), g.jsx(wi, {
            path: "/form",
            element: g.jsx(n8e, {})
        }), g.jsx(wi, {
            path: "/chat",
            element: g.jsx(XFe, {})
        }), g.jsx(wi, {
            path: "/vendorform",
            element: g.jsx(_7, {})
        }), g.jsx(wi, {
            path: "/dashboard/analytics",
            element: g.jsx(ize, {})
        }), g.jsx(wi, {
            path: "/vendor",
            element: g.jsx(kze, {})
        }), g.jsx(wi, {
            path: "/products",
            element: g.jsx(Uye, {})
        }), g.jsx(wi, {
            path: "/products/add",
            element: g.jsx(T1e, {})
        }), g.jsx(wi, {
            path: "/productGroup",
            element: g.jsx(pze, {})
        }), g.jsx(wi, {
            path: "/workflow",
            element: g.jsx(JFe, {})
        })]
    })]
})
  , i8e = () => g.jsx(nge, {
    children: g.jsx(r8e, {})
});
WZ.createRoot(document.getElementById("root")).render(g.jsx(c6, {
    children: g.jsx(i8e, {})
}));
export {E8 as $, Pm as A, p2e as B, $Te as C, jM as D, Mi as E, b8 as F, fOe as G, pMe as H, zB as I, vPe as J, Q2e as K, eh as L, HUe as M, eS as N, mTe as O, nM as P, KB as Q, oMe as R, Wx as S, dOe as T, ry as U, wTe as V, ny as W, St as X, Ot as Y, rOe as Z, U as _, MTe as a, iH as a$, tMe as a0, yz as a1, gz as a2, tVe as a3, QUe as a4, JUe as a5, XUe as a6, YUe as a7, ef as a8, mM as a9, JDe as aA, qRe as aB, WDe as aC, AM as aD, m5 as aE, _Ie as aF, nMe as aG, VUe as aH, es as aI, uy as aJ, kIe as aK, wIe as aL, dM as aM, oc as aN, uz as aO, $Ee as aP, sg as aQ, ad as aR, eOe as aS, gH as aT, Z1 as aU, J1 as aV, dv as aW, bH as aX, mH as aY, PDe as aZ, kt as a_, eVe as aa, ZUe as ab, rVe as ac, nVe as ad, KUe as ae, KIe as af, _W as ag, hVe as ah, CPe as ai, oi as aj, Lc as ak, EM as al, XH as am, cd as an, kH as ao, Yt as ap, As as aq, U$e as ar, fVe as as, pVe as at, uVe as au, Tt as av, dVe as aw, k$e as ax, x$e as ay, b$e as az, ATe as b, mo as b0, AEe as b1, uM as b2, N8 as b3, oy as b4, H8 as b5, GUe as b6, Gr as b7, j9e as b8, Z9e as b9, RM as bA, dH as bB, V_ as bC, tOe as bD, X1 as bE, qn as bF, XDe as ba, qDe as bb, DRe as bc, MM as bd, _De as be, nOe as bf, ly as bg, Ch as bh, lv as bi, jDe as bj, dLe as bk, sy as bl, uv as bm, RDe as bn, cH as bo, $Re as bp, LRe as bq, gu as br, jz as bs, jRe as bt, PM as bu, IRe as bv, FRe as bw, wh as bx, $c as by, Dz as bz, Vn as c, En as d, _8 as e, ri as f, RTe as g, _l as h, ka as i, APe as j, vh as k, Qe as l, _H as m, qUe as n, gVe as o, DTe as p, OTe as q, mVe as r, PTe as s, SPe as t, Na as u, m$e as v, mOe as w, iVe as x, ETe as y, WUe as z};
